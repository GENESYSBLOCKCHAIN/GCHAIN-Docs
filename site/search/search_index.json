{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Genesys Chain Documentation Welcome to the Genesys Chain documentation site! Please note that both the Genesys Chain software and this documentation site will improve over time and is still a work-in-progress. Be sure to engage with our community channels to stay updated. Have fun trading and see you on chain! What is Genesys Chain? Genesys Chain is an innovative solution to bring programmability and interoperability to Genesys Chain. Genesys Chain relies on a system of PoA consensus that can support short block time and lower fees. The most bonded validator candidates of staking will become validators and produce blocks. The double-sign detection and other slashing logic guarantee security, stability, and chain finality. Please read the FAQ to get started. What can I do with Genesys Chain? The purpose of the new blockchain and DEX is to create an alternative marketplace for issuing and exchanging digital assets in a decentralized manner. You can: Send and receive GSYS Issue new tokens to digitalize assets, and use Genesys Chain as underlying exchange/transfer network for the assets For developers , you can also: Genesys Chain, GSYS boasts smart contract functionality and compatibility with the Ethereum Virtual Machine (EVM). The design goal here was to leave the high throughput of Genesys Chain intact while introducing smart contracts into its ecosystem. Because GSYS is EVM-compatible, it launched with support for the rich universe of Ethereum tools and DApps. In theory, this makes it easy for developers to port their projects over from Ethereum. For users, it means that applications like MetaMask can be easily configured to work with TC. Seriously \u2013 it\u2019s just a matter of tweaking a couple of settings. Check out Use MetaMask for Genesys Chain to get started. You can: Send and receive GSYS Explore the transaction history and blocks on the chain, via GSYS SCAN , API and node RPC interfaces. Developers can also: Issue new tokens to digitalize assets Run a full node to listen to and broadcast live updates on transactions, blocks, and consensus activities Develop wallets and tools to help users use Dapps Get Started Want to try it Genesys Chain ? Just give a peek at the first few of pages of the getting started guide . You could also have a read through the FAQ . Want to develop on Genesys Chain ? First, read through the FAQ and learn about tokens here . Asset Management BLUE20 Asset A token protocol on GSYS which is compatible with ERC20 . It extends ERC20 and contains more interfaces, such as getOwner and decimals . Read the full proposal here: https://github.com/githubusername/githubrepo Issue BLUE20 Wallet GSYS (and Other Coins) MainNet Switch Genesys (GSYS) was an ERC20 token on the Ethereum network. After the launch of Genesys Chain, Genesys (GSYS) is being converted into native GSYS tokens on the main network via the exchange platform at genesys.network , a pragmatic and efficient way to perform the initial token swap. Genesys Chain is ready for other projects to migrate their tokens to take advantage of performant transactions with more liquidity options and native marketplace features. More information about how projects can set themselves up for this (via genesys.network or partners) will come soon. Technology Details Continue reading below if you are interested in what is happening under the hood! Genesys Chain as a Block Chain : about consensus, software stack, network layout and roles. Run a Genesys Chain full node : how to run a full node and become part of the p2p network of Genesys Chain. Acknowledgement Thanks to the community, our partners and supporters .","title":"Home"},{"location":"index.html#genesys-chain-documentation","text":"Welcome to the Genesys Chain documentation site! Please note that both the Genesys Chain software and this documentation site will improve over time and is still a work-in-progress. Be sure to engage with our community channels to stay updated. Have fun trading and see you on chain!","title":"Genesys Chain Documentation"},{"location":"index.html#what-is-genesys-chain","text":"Genesys Chain is an innovative solution to bring programmability and interoperability to Genesys Chain. Genesys Chain relies on a system of PoA consensus that can support short block time and lower fees. The most bonded validator candidates of staking will become validators and produce blocks. The double-sign detection and other slashing logic guarantee security, stability, and chain finality. Please read the FAQ to get started.","title":"What is Genesys Chain?"},{"location":"index.html#what-can-i-do-with-genesys-chain","text":"The purpose of the new blockchain and DEX is to create an alternative marketplace for issuing and exchanging digital assets in a decentralized manner. You can: Send and receive GSYS Issue new tokens to digitalize assets, and use Genesys Chain as underlying exchange/transfer network for the assets For developers , you can also: Genesys Chain, GSYS boasts smart contract functionality and compatibility with the Ethereum Virtual Machine (EVM). The design goal here was to leave the high throughput of Genesys Chain intact while introducing smart contracts into its ecosystem. Because GSYS is EVM-compatible, it launched with support for the rich universe of Ethereum tools and DApps. In theory, this makes it easy for developers to port their projects over from Ethereum. For users, it means that applications like MetaMask can be easily configured to work with TC. Seriously \u2013 it\u2019s just a matter of tweaking a couple of settings. Check out Use MetaMask for Genesys Chain to get started. You can: Send and receive GSYS Explore the transaction history and blocks on the chain, via GSYS SCAN , API and node RPC interfaces. Developers can also: Issue new tokens to digitalize assets Run a full node to listen to and broadcast live updates on transactions, blocks, and consensus activities Develop wallets and tools to help users use Dapps","title":"What can I do with Genesys Chain?"},{"location":"index.html#get-started","text":"Want to try it Genesys Chain ? Just give a peek at the first few of pages of the getting started guide . You could also have a read through the FAQ . Want to develop on Genesys Chain ? First, read through the FAQ and learn about tokens here .","title":"Get Started"},{"location":"index.html#asset-management","text":"","title":"Asset Management"},{"location":"index.html#blue20-asset","text":"A token protocol on GSYS which is compatible with ERC20 . It extends ERC20 and contains more interfaces, such as getOwner and decimals . Read the full proposal here: https://github.com/githubusername/githubrepo Issue BLUE20 Wallet","title":"BLUE20 Asset"},{"location":"index.html#gsys-and-other-coins-mainnet-switch","text":"Genesys (GSYS) was an ERC20 token on the Ethereum network. After the launch of Genesys Chain, Genesys (GSYS) is being converted into native GSYS tokens on the main network via the exchange platform at genesys.network , a pragmatic and efficient way to perform the initial token swap. Genesys Chain is ready for other projects to migrate their tokens to take advantage of performant transactions with more liquidity options and native marketplace features. More information about how projects can set themselves up for this (via genesys.network or partners) will come soon.","title":"GSYS (and Other Coins) MainNet Switch"},{"location":"index.html#technology-details","text":"Continue reading below if you are interested in what is happening under the hood! Genesys Chain as a Block Chain : about consensus, software stack, network layout and roles. Run a Genesys Chain full node : how to run a full node and become part of the p2p network of Genesys Chain.","title":"Technology Details"},{"location":"index.html#acknowledgement","text":"Thanks to the community, our partners and supporters .","title":"Acknowledgement"},{"location":"CONTRIBUTING.html","text":"How to Contribute to Genesys Chain Documentations Project Your contributions to the Genesys Chain will help build a fast and secure decentralized digital asset exchange. We want to make it as easy as possible to contribute changes that help the Genesys Chain grow and thrive. There are a few guidelines that we ask contributors to follow so that we can merge your changes quickly. Getting Started Make sure you have a GitHub account . Create a GitHub issue for your contribution, assuming one does not already exist. Clearly describe the issue including steps to reproduce if it is a bug. Fork the repository on GitHub. Minor Changes Documentation For small changes to comments and documentation, it is not always necessary to create a new GitHub issue. In this case, it is appropriate to start the first line of a commit with 'doc' instead of an issue number. Finding things to work on The first place to start is always looking over the current GitHub issues for the project you are interested in contributing to. Issues marked with [help wanted][help-wanted] are usually pretty self-contained and a good place to get started. Of course, feel free to create a new issue if you think something needs to be added or fixed. Making Changes Create a topic branch from where you want to base your work. This is usually the master branch. Please avoid working directly on the master branch. Make sure you have added the necessary tests for your changes and make sure all tests pass.","title":"Contributing"},{"location":"CONTRIBUTING.html#how-to-contribute-to-genesys-chain-documentations-project","text":"Your contributions to the Genesys Chain will help build a fast and secure decentralized digital asset exchange. We want to make it as easy as possible to contribute changes that help the Genesys Chain grow and thrive. There are a few guidelines that we ask contributors to follow so that we can merge your changes quickly.","title":"How to Contribute to Genesys Chain Documentations Project"},{"location":"CONTRIBUTING.html#getting-started","text":"Make sure you have a GitHub account . Create a GitHub issue for your contribution, assuming one does not already exist. Clearly describe the issue including steps to reproduce if it is a bug. Fork the repository on GitHub.","title":"Getting Started"},{"location":"CONTRIBUTING.html#minor-changes","text":"","title":"Minor Changes"},{"location":"CONTRIBUTING.html#documentation","text":"For small changes to comments and documentation, it is not always necessary to create a new GitHub issue. In this case, it is appropriate to start the first line of a commit with 'doc' instead of an issue number.","title":"Documentation"},{"location":"CONTRIBUTING.html#finding-things-to-work-on","text":"The first place to start is always looking over the current GitHub issues for the project you are interested in contributing to. Issues marked with [help wanted][help-wanted] are usually pretty self-contained and a good place to get started. Of course, feel free to create a new issue if you think something needs to be added or fixed.","title":"Finding things to work on"},{"location":"CONTRIBUTING.html#making-changes","text":"Create a topic branch from where you want to base your work. This is usually the master branch. Please avoid working directly on the master branch. Make sure you have added the necessary tests for your changes and make sure all tests pass.","title":"Making Changes"},{"location":"account.html","text":"Account and Balance Each account contains cryptographic authentication info. It is created by a user of the blockchain. It also includes public key, address, and account number/sequence number for replay protection. Whenever a new address receives an asset, the corresponding transaction would create an Account for that address, which contains balances across all assets that are owned on this address. The balance (the amount of tokens) of each asset is composed of 3 different parts: Available: the amount of tokens that can be transferred, and spent to swap (buy) other assets Locked: the amount of tokens that has been used in any outstanding orders. Once the order terminates (either filled, canceled or expired), the locked amount will decrease. Frozen: the amount of tokens that has been frozen via Freeze transactions. You can query the account info with the following command on mainnet: ./eth-cli account <your-address> --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --indent --trust-node Example output: Please note that the amount is boosted by e^8 for the decimal part. { \"type\" : \"bnbchain/Account\" , \"value\" :{ \"base\" :{ \"address\" : \"tbnb1sylyjw032eajr9cyllp26n04300qzzre38qyv5\" , \"coins\" :[{ \"denom\" : \"000-0E1\" , \"amount\" : \"10530\" },{ \"denom\" : \"GSYS\" , \"amount\" : \"247349863800\" },{ \"denom\" : \"BTC.B-918\" , \"amount\" : \"113218800\" },{ \"denom\" : \"COSMOS-587\" , \"amount\" : \"50000101983748977\" },{ \"denom\" : \"EDU-DD0\" , \"amount\" : \"139885964\" },{ \"denom\" : \"MFH-9B5\" , \"amount\" : \"1258976083286\" },{ \"denom\" : \"NASC-137\" , \"amount\" : \"0\" },{ \"denom\" : \"PPC-00A\" , \"amount\" : \"205150260\" },{ \"denom\" : \"TGT-9FC\" , \"amount\" : \"33251102828\" },{ \"denom\" : \"UCX-CC8\" , \"amount\" : \"1398859649\" },{ \"denom\" : \"USDT.B-B7C\" , \"amount\" : \"140456966268\" },{ \"denom\" : \"YLC-D8B\" , \"amount\" : \"210572645\" },{ \"denom\" : \"ZZZ-21E\" , \"amount\" : \"13988596\" }], \"public_key\" :{ \"type\" : \"tendermint/PubKeySecp256k1\" , \"value\" : \"AhOb3ZXecsIqwqKw+HhTscyi6K35xYpKaJx10yYwE0Qa\" }, \"account_number\" : \"406226\" , \"sequence\" : \"29\" }, \"name\" : \"\" , \"frozen\" : null , \"locked\" :[{ \"denom\" : \"KOGE48-35D\" , \"amount\" : \"10000000000\" }]}} From the output you can see that this account account_number is 406226 and its sequence is 29. This is the important information about this account. Create Account There are two ways of creating an account on Genesys Chain: creating a key in a web wallet and creating a key via eth-cli . Please make sure you backup your mnemonic. Web Wallet You can create a key via web wallet Follow the instructions and set your password (password is used to unlock the keystore file that you will get here): Then click Download Keystore File and you will get a keystore file and be directed to mnemonic page. Make sure to back up mnemonic here as it will be used to restore your key. You can restore your key here Choose Mnenomic Phrase , paste the mnemonic you get above and set your session password: Your wallet will be unlocked and you can get your address here (for this example it is tbnb14m2gcdjq7aqkdtu2m9qrqrl8eevzpqfj9xc0uu ): Account Management With eth-cli You should get mnemonic if you follow the instructions above. You can restore you key via eth-cli or eth-cli . Restore your key $ ./eth-cli keys add test --recover Enter a passphrase for your key: Repeat the passphrase: > Enter your recovery seed phrase: more advice achieve mass clap nose bike bird busy section rigid model doll exchange guard theme catalog junior patrol valley depart decade convince master NAME: TYPE: ADDRESS: PUBKEY: test local tbnb14m2gcdjq7aqkdtu2m9qrqrl8eevzpqfj9xc0uu bnbp1addwnpepqt7nf2dwgfxv6kmzgwhzlp556yhdfeakfdejc6lp8xcddsv83kq552m63s9 Create a new key You can also create a new key and you will get a new mnemonic with eth-cli or eth-cli . $ ./eth-cli keys add new_key Enter a passphrase for your key: Repeat the passphrase: NAME: TYPE: ADDRESS: PUBKEY: new_key local tbnb1c5dxrdn9xuw0njwcyevzyjrza550z5au8v0hyz bnbp1addwnpepqwdsud63f5rq2wkgrezlvzdauf4x7wp3defzvhrzkwdzl7p0n6uk666ghpa **Important** write this seed phrase in a safe place. It is the only way to recover your account if you ever forget your password. napkin degree boring custom differ smart bundle ball length lyrics auto forest jeans awake entry vocal there repeat rule churn picnic promote screen skull Query Account Balance Please note that the amount is boosted by e^8 for the decimal part. Example on mainnet : $ ./eth-cli account bnc1wwgakqy32m7vdnlf00pctf9hnaak37eh7wkmqa --trust-node --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 Example on testnet : $ ./eth-cli account bnc1wwgakqy32m7vdnlf00pctf9hnaak37eh7wkmqa --trust-node --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 { \"type\" : \"bnbchain/Account\" , \"value\" : { \"base\" : { \"address\" : \"bnc1wwgakqy32m7vdnlf00pctf9hnaak37eh7wkmqa\" , \"coins\" : [ { \"denom\" : \"AAA-254\" , \"amount\" : \"19500000000000000\" } ] , \"public_key\" : { \"type\" : \"tendermint/PubKeySecp256k1\" , \"value\" : \"A1V88I61gCbF2V1RqdCxb0UN/8g95mNUlJGH5htNNC70\" } , \"account_number\" : \"0\" , \"sequence\" : \"337\" } , \"name\" : \"node0\" , \"frozen\" :null, \"locked\" :null } } Get Testnet GSYS You can get test GSYS by following this guide .","title":"Account and Balance"},{"location":"account.html#account-and-balance","text":"Each account contains cryptographic authentication info. It is created by a user of the blockchain. It also includes public key, address, and account number/sequence number for replay protection. Whenever a new address receives an asset, the corresponding transaction would create an Account for that address, which contains balances across all assets that are owned on this address. The balance (the amount of tokens) of each asset is composed of 3 different parts: Available: the amount of tokens that can be transferred, and spent to swap (buy) other assets Locked: the amount of tokens that has been used in any outstanding orders. Once the order terminates (either filled, canceled or expired), the locked amount will decrease. Frozen: the amount of tokens that has been frozen via Freeze transactions. You can query the account info with the following command on mainnet: ./eth-cli account <your-address> --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --indent --trust-node Example output: Please note that the amount is boosted by e^8 for the decimal part. { \"type\" : \"bnbchain/Account\" , \"value\" :{ \"base\" :{ \"address\" : \"tbnb1sylyjw032eajr9cyllp26n04300qzzre38qyv5\" , \"coins\" :[{ \"denom\" : \"000-0E1\" , \"amount\" : \"10530\" },{ \"denom\" : \"GSYS\" , \"amount\" : \"247349863800\" },{ \"denom\" : \"BTC.B-918\" , \"amount\" : \"113218800\" },{ \"denom\" : \"COSMOS-587\" , \"amount\" : \"50000101983748977\" },{ \"denom\" : \"EDU-DD0\" , \"amount\" : \"139885964\" },{ \"denom\" : \"MFH-9B5\" , \"amount\" : \"1258976083286\" },{ \"denom\" : \"NASC-137\" , \"amount\" : \"0\" },{ \"denom\" : \"PPC-00A\" , \"amount\" : \"205150260\" },{ \"denom\" : \"TGT-9FC\" , \"amount\" : \"33251102828\" },{ \"denom\" : \"UCX-CC8\" , \"amount\" : \"1398859649\" },{ \"denom\" : \"USDT.B-B7C\" , \"amount\" : \"140456966268\" },{ \"denom\" : \"YLC-D8B\" , \"amount\" : \"210572645\" },{ \"denom\" : \"ZZZ-21E\" , \"amount\" : \"13988596\" }], \"public_key\" :{ \"type\" : \"tendermint/PubKeySecp256k1\" , \"value\" : \"AhOb3ZXecsIqwqKw+HhTscyi6K35xYpKaJx10yYwE0Qa\" }, \"account_number\" : \"406226\" , \"sequence\" : \"29\" }, \"name\" : \"\" , \"frozen\" : null , \"locked\" :[{ \"denom\" : \"KOGE48-35D\" , \"amount\" : \"10000000000\" }]}} From the output you can see that this account account_number is 406226 and its sequence is 29. This is the important information about this account.","title":"Account and Balance"},{"location":"account.html#create-account","text":"There are two ways of creating an account on Genesys Chain: creating a key in a web wallet and creating a key via eth-cli . Please make sure you backup your mnemonic.","title":"Create Account"},{"location":"account.html#web-wallet","text":"You can create a key via web wallet Follow the instructions and set your password (password is used to unlock the keystore file that you will get here): Then click Download Keystore File and you will get a keystore file and be directed to mnemonic page. Make sure to back up mnemonic here as it will be used to restore your key. You can restore your key here Choose Mnenomic Phrase , paste the mnemonic you get above and set your session password: Your wallet will be unlocked and you can get your address here (for this example it is tbnb14m2gcdjq7aqkdtu2m9qrqrl8eevzpqfj9xc0uu ):","title":"Web Wallet"},{"location":"account.html#account-management-with-eth-cli","text":"You should get mnemonic if you follow the instructions above. You can restore you key via eth-cli or eth-cli . Restore your key $ ./eth-cli keys add test --recover Enter a passphrase for your key: Repeat the passphrase: > Enter your recovery seed phrase: more advice achieve mass clap nose bike bird busy section rigid model doll exchange guard theme catalog junior patrol valley depart decade convince master NAME: TYPE: ADDRESS: PUBKEY: test local tbnb14m2gcdjq7aqkdtu2m9qrqrl8eevzpqfj9xc0uu bnbp1addwnpepqt7nf2dwgfxv6kmzgwhzlp556yhdfeakfdejc6lp8xcddsv83kq552m63s9 Create a new key You can also create a new key and you will get a new mnemonic with eth-cli or eth-cli . $ ./eth-cli keys add new_key Enter a passphrase for your key: Repeat the passphrase: NAME: TYPE: ADDRESS: PUBKEY: new_key local tbnb1c5dxrdn9xuw0njwcyevzyjrza550z5au8v0hyz bnbp1addwnpepqwdsud63f5rq2wkgrezlvzdauf4x7wp3defzvhrzkwdzl7p0n6uk666ghpa **Important** write this seed phrase in a safe place. It is the only way to recover your account if you ever forget your password. napkin degree boring custom differ smart bundle ball length lyrics auto forest jeans awake entry vocal there repeat rule churn picnic promote screen skull","title":"Account Management With eth-cli"},{"location":"account.html#query-account-balance","text":"Please note that the amount is boosted by e^8 for the decimal part. Example on mainnet : $ ./eth-cli account bnc1wwgakqy32m7vdnlf00pctf9hnaak37eh7wkmqa --trust-node --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 Example on testnet : $ ./eth-cli account bnc1wwgakqy32m7vdnlf00pctf9hnaak37eh7wkmqa --trust-node --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 { \"type\" : \"bnbchain/Account\" , \"value\" : { \"base\" : { \"address\" : \"bnc1wwgakqy32m7vdnlf00pctf9hnaak37eh7wkmqa\" , \"coins\" : [ { \"denom\" : \"AAA-254\" , \"amount\" : \"19500000000000000\" } ] , \"public_key\" : { \"type\" : \"tendermint/PubKeySecp256k1\" , \"value\" : \"A1V88I61gCbF2V1RqdCxb0UN/8g95mNUlJGH5htNNC70\" } , \"account_number\" : \"0\" , \"sequence\" : \"337\" } , \"name\" : \"node0\" , \"frozen\" :null, \"locked\" :null } }","title":"Query Account Balance"},{"location":"account.html#get-testnet-gsys","text":"You can get test GSYS by following this guide .","title":"Get Testnet GSYS"},{"location":"acknowledgement.html","text":"Acknowledgements Genesys Chain has been through several iterations and evolutions, each time building upon work contributed by members of the blockchain community. We would like to acknowledge the outstanding work that we have been able to achieve during development. Let's build the future together! Bitcoin and Ethereum There is no doubt that these two projects and their communities provided us from day one with countless creativity. They are the root and ground-zero of thought and keep providing us with brilliant utilities and ideas. GSYS Dexathon The GSYS Dexathon concluded in September 2018, receiving prize winning submissions from teams that sent in some really impressive projects. Our internal work on Genesys Chain was taking place in parallel to this and we are delighted to say that many of the projects helped to improve the final product. Tendermint and Cosmos Our current implementation is built on forks of Tendermint and Cosmos SDK. We make use of a revised edition of Tendermint consensus and leverage its p2p networking logic, and Cosmos SDK features such as \"bank\" which is used for basic token transactions. Some of the changes have been contributed back to the projects. Projects like Genesys Chain and GSYS DEX are often built as forks of Bitcoin or as smart contracts on platforms like Ethereum. With a foundation of clean, well-structured code from Cosmos SDK, we were able to build on a codebase that we saw as a better alternative. Many thanks to the Cosmos developers and its community for their work (and for being really helpful in our issues and pull requests!) Juan Leni, ZondaX Thanks to Juan Leni for his work on the open-source Cosmos Ledger app , which we were able to use as a base for the Genesys Chain Ledger app.","title":"Acknowledgements"},{"location":"acknowledgement.html#acknowledgements","text":"Genesys Chain has been through several iterations and evolutions, each time building upon work contributed by members of the blockchain community. We would like to acknowledge the outstanding work that we have been able to achieve during development. Let's build the future together!","title":"Acknowledgements"},{"location":"acknowledgement.html#bitcoin-and-ethereum","text":"There is no doubt that these two projects and their communities provided us from day one with countless creativity. They are the root and ground-zero of thought and keep providing us with brilliant utilities and ideas.","title":"Bitcoin and Ethereum"},{"location":"acknowledgement.html#gsys-dexathon","text":"The GSYS Dexathon concluded in September 2018, receiving prize winning submissions from teams that sent in some really impressive projects. Our internal work on Genesys Chain was taking place in parallel to this and we are delighted to say that many of the projects helped to improve the final product.","title":"GSYS Dexathon"},{"location":"acknowledgement.html#tendermint-and-cosmos","text":"Our current implementation is built on forks of Tendermint and Cosmos SDK. We make use of a revised edition of Tendermint consensus and leverage its p2p networking logic, and Cosmos SDK features such as \"bank\" which is used for basic token transactions. Some of the changes have been contributed back to the projects. Projects like Genesys Chain and GSYS DEX are often built as forks of Bitcoin or as smart contracts on platforms like Ethereum. With a foundation of clean, well-structured code from Cosmos SDK, we were able to build on a codebase that we saw as a better alternative. Many thanks to the Cosmos developers and its community for their work (and for being really helpful in our issues and pull requests!)","title":"Tendermint and Cosmos"},{"location":"acknowledgement.html#juan-leni-zondax","text":"Thanks to Juan Leni for his work on the open-source Cosmos Ledger app , which we were able to use as a base for the Genesys Chain Ledger app.","title":"Juan Leni, ZondaX"},{"location":"anti-frontrun.html","text":"Anti Front-Running Front-running means someone can get prior knowledge of transactions from other beneficial owners via technology or market advantage, so that they can influence the price beforehand and result in economic gain, which usually brings loss or cost to others. It is a daunting question asked to both centralized and other decentralized exchanges (DEX). Especially on some DEX, front-running actually happens quite often, e.g. via gas or timestamp manipulations, or slow matching. There are several design points in GSYS DEX that make front-running very difficult to execute. Fast Matching GSYS DEX matches orders in every block (with very fast block times). Fast matching leaves very little room for front-runner to react before the orders get executed properly. This is one of the fundamental parts of making front-running difficult, especially for normal market participants. Decentralized, Transparent Match Engine It is very difficult to argue that the exchange itself is not front-running if it has a centralized matching engine. GSYS DEX have decentralized matching engines running on every block producer and full node. This way everyone can replay the order match manually with the transactions in the latest block with the current order book and can see the order matching in real-time if they run a full node. This makes wash trading easily observable! Periodic Auction Matching Periodic auction matching per block lowers the importance of fast orders, i.e. fast orders do not benefit from high frequency trading behaviors even when being several hundreds of milliseconds faster (which is \"really long time\" for traditional exchanges). Fast orders do not bring any advantage. Periodic auction also adds a non-deterministic layer where no one can exactly know the next execution price unless he/she can exactly know all 3 things listed below: the matching logic the current order book and trade price from the last match all incoming orders for the next block 1) and 2) may be visible to participants, especially for validators and others who closely watch the blockchain status, such as fast sync trading bots or full nodes. But knowing 3) is very hard for normal market participant. Even if they run powerful accelerated node , they still cannot know all the incoming orders for the next block. Without this knowledge, even when someone can send orders faster, they cannot do effective front-running. So with the above, the usual traders and even trading bots cannot do much to front-run others. You might point out, that the validators have a chance to get information of 3) when they are \"proposers\" for the next block, i.e. they would \"propose\" what transactions to add for the next block. But the Genesys Chain consensus model adds some additional randomness to make it more difficult: Due to the fast matching, the bad validator have to prepare everything with earlier information in order to front-run the price. However, he cannot be too fast, because he cannot know the execution price of the last block until the last block is concluded, and the last execution price has direct impact on the execution price according to the match logic. Even more, any validator ahead of the bad validator's proposer turn can run into an issue and increase the consensus round, which would ask for re-arrangement on the proposing sequence. This makes it very hard to pre-determine the exact proposal sequence, making it so hard that the validator cannot be 100% sure when they can delay any other transactions and add their own transactions to the block earlier. Besides all of this, the bad validator cannot hold other transactions for too long: it either makes the bad behavior very observable on chain, or other validators would include the transactions anyway via P2P communication. As a result, it is extremely hard to front-run anyone even while being a validator. Potential Improvement With the above description, you can clearly see that chance of front-running others on GSYS DEX is much lower than on centralized exchanges and most of decentralized ones. However, you may still argue that for a very powerful and sophisticated validator, there is still a slim chance to front-run client orders (if they can do every difficult step very fast). In the future, deterministic randomness may be applied in selecting the next proposer among validators, and the match of orders proposed to block can be postponed into the next 2 block. These two enhancements can greatly destroy the prediction accuracy of trading price, which would push the chance of front-running to 0. The cost of this is some latency in matching.","title":"Anti Front-Running"},{"location":"anti-frontrun.html#anti-front-running","text":"Front-running means someone can get prior knowledge of transactions from other beneficial owners via technology or market advantage, so that they can influence the price beforehand and result in economic gain, which usually brings loss or cost to others. It is a daunting question asked to both centralized and other decentralized exchanges (DEX). Especially on some DEX, front-running actually happens quite often, e.g. via gas or timestamp manipulations, or slow matching. There are several design points in GSYS DEX that make front-running very difficult to execute.","title":"Anti Front-Running"},{"location":"anti-frontrun.html#fast-matching","text":"GSYS DEX matches orders in every block (with very fast block times). Fast matching leaves very little room for front-runner to react before the orders get executed properly. This is one of the fundamental parts of making front-running difficult, especially for normal market participants.","title":"Fast Matching"},{"location":"anti-frontrun.html#decentralized-transparent-match-engine","text":"It is very difficult to argue that the exchange itself is not front-running if it has a centralized matching engine. GSYS DEX have decentralized matching engines running on every block producer and full node. This way everyone can replay the order match manually with the transactions in the latest block with the current order book and can see the order matching in real-time if they run a full node. This makes wash trading easily observable!","title":"Decentralized, Transparent Match Engine"},{"location":"anti-frontrun.html#periodic-auction-matching","text":"Periodic auction matching per block lowers the importance of fast orders, i.e. fast orders do not benefit from high frequency trading behaviors even when being several hundreds of milliseconds faster (which is \"really long time\" for traditional exchanges). Fast orders do not bring any advantage. Periodic auction also adds a non-deterministic layer where no one can exactly know the next execution price unless he/she can exactly know all 3 things listed below: the matching logic the current order book and trade price from the last match all incoming orders for the next block 1) and 2) may be visible to participants, especially for validators and others who closely watch the blockchain status, such as fast sync trading bots or full nodes. But knowing 3) is very hard for normal market participant. Even if they run powerful accelerated node , they still cannot know all the incoming orders for the next block. Without this knowledge, even when someone can send orders faster, they cannot do effective front-running. So with the above, the usual traders and even trading bots cannot do much to front-run others. You might point out, that the validators have a chance to get information of 3) when they are \"proposers\" for the next block, i.e. they would \"propose\" what transactions to add for the next block. But the Genesys Chain consensus model adds some additional randomness to make it more difficult: Due to the fast matching, the bad validator have to prepare everything with earlier information in order to front-run the price. However, he cannot be too fast, because he cannot know the execution price of the last block until the last block is concluded, and the last execution price has direct impact on the execution price according to the match logic. Even more, any validator ahead of the bad validator's proposer turn can run into an issue and increase the consensus round, which would ask for re-arrangement on the proposing sequence. This makes it very hard to pre-determine the exact proposal sequence, making it so hard that the validator cannot be 100% sure when they can delay any other transactions and add their own transactions to the block earlier. Besides all of this, the bad validator cannot hold other transactions for too long: it either makes the bad behavior very observable on chain, or other validators would include the transactions anyway via P2P communication. As a result, it is extremely hard to front-run anyone even while being a validator.","title":"Periodic Auction Matching"},{"location":"anti-frontrun.html#potential-improvement","text":"With the above description, you can clearly see that chance of front-running others on GSYS DEX is much lower than on centralized exchanges and most of decentralized ones. However, you may still argue that for a very powerful and sophisticated validator, there is still a slim chance to front-run client orders (if they can do every difficult step very fast). In the future, deterministic randomness may be applied in selecting the next proposer among validators, and the match of orders proposed to block can be postponed into the next 2 block. These two enhancements can greatly destroy the prediction accuracy of trading price, which would push the chance of front-running to 0. The cost of this is some latency in matching.","title":"Potential Improvement"},{"location":"atomic-swap.html","text":"Introduction As explained in BEP3 , Hash Timer Locked Contract(HGSYS) has been used for Atomic Swap and cross payment channels between different blockchains. BEP3 defines native transactions to support HGSYS on Genesys Chain and also proposes the standard infrastructure and procedure to use HGSYS for inter-chain atomic swap to easily create and use pegged token. During the swap process, the related fund will be locked to a purely-code-controlled escrow account. A purely-code-controlled escrow account is a kind of account which is derived from a hard-coded string in shree chain protocol. This kind of account doesn't have its own private key and it's only controlled by code of the protocol. The code for calculating escrow account is the same that is used in cosmos-sdk : AtomicSwapCoinsAccAddr = sdk.AccAddress(crypto.AddressHash([]byte(\"Genesys ChainAtomicSwapCoins\"))) The account for mainnet is: bnb1wxeplyw7x8aahy93w96yhwm7xcq3ke4f8ge93u and the account for testnet is: tbnb1wxeplyw7x8aahy93w96yhwm7xcq3ke4ffasp3d . Once the swap is claimed or refunded, the fund will be transferred from the purely-code-controlled escrow account to client accounts. Commands Hash Timer Locked Transfer Hash Timer Locked Transfer (HTLT) is a new transaction type on Genesys Chain, to serve as HGSYS in the first step of Atomic Swap, Parameters Name Type Description Optional From Address Sender address, where the asset is from No recipient-addr Address Receiver address, where the asset is to, if the proper condition meets. No recipient-other-chain bytes a byte array, maximum 32 bytes, in any proper encoding. leave it empty for single chain swap Yes sender-other-chain bytes a byte array, maximum 32 bytes, in any proper encoding. leave it empty for single chain swap Yes RandomNumberHash 32 bytes hash of a random number and timestamp, based on SHA256. If left out, a random value will be generated True Timestamp int64 Supposed to be the time of sending transaction, counted by second. It should be identical to the one in swap contract. If left out, current timestamp will be used. No OutAmount Coins similar to the Coins in the original Transfer defined in BEP2, assets to swap out No ExpectedIncome string Expected income from swap counter party, example: \"100:GSYS\" or \"100:GSYS,10000:BTCB-1DE\" The amount needs to be bumped by e^8 No HeightSpan int64 number of blocks to wait before the asset may be returned to From if not claimed via Random. The number must be larger than or equal to 360 (>2 minutes), and smaller than 518400 (< 48 hours) No CrossChain bool Specify if the HTLT is for cross chain atomic swap True, the default value is False Outputs Name Type Description Random number 32 bytes Timestamp int64 Random number hash 32 bytes Swap ID 32 bytes Examples Swap between BEP2 tokens On testnet : Command line ./eth-cli token HTLT --recipient-addr <recipient-addr> --amount 100 :GSYS --expected-income <expectedIncome> --height-span <heightSpan> --from <from-addr> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const recipient = \"tbnb1prrujx8kkukrcrppklggadhuvegfnx8pemsq77\" // recipient address const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" // 32 bytes random number const timestamp = Math . floor ( Date . now () / 1000 ) // take the current timestamp const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ) const amount = [{ denom : \"GSYS\" , amount : 100 }] const expectedIncome = \"100:GSYS\" // expected income const heightSpan = 400 // height span const res = client . swap . HTLT ( from , recipient , \"\" , \"\" , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , false ) Example output: Please take a note of returned swapID : Random number: 927c1ac33100bdbb001de19c626a05a7c3c11304fc825f5eabb22e741507711b Timestamp: 1568792486 Random number hash: 5768702259ee55983378d7b8207890c666648264524b9dada551386f832ba6b1 Password to sign with 'guest': Committed at block 39984169 ( tx hash: B5A3DD92A40E98745BBE9F608944FE5511B81071B34E9947A754A04A5F378A85, response: { Code:0 Data:[77 137 139 200 85 141 170 77 129 116 134 215 169 59 119 178 200 47 206 194 18 58 191 74 30 183 210 82 18 55 236 205] Log:Msg 0: swapID: 4d898bc8558daa4d817486d7a93b77b2c82fcec2123abf4a1eb7d2521237eccd Info: GasWanted:0 GasUsed:0 ... ) Besides, the Data field in the committed result is the byte array of swapID : Data:[77 137 139 200 85 141 170 77 129 116 134 215 169 59 119 178 200 47 206 194 18 58 191 74 30 183 210 82 18 55 236 205] swapID: 4d898bc8558daa4d817486d7a93b77b2c82fcec2123abf4a1eb7d2521237eccd Swap from Genesys Chain to Ethereum Clients send HTLT on Genesys Chain on testnet : Command line: ./eth-cli token HTLT --from <from-addr> --chain-id GSYS-Chain-Ganges --height-span <heightSpan> --amount <amount> --expected-income <expectedIncome> --recipient-addr <deputy-bep2-addr> --recipient-other-chain <client ethereum address> --cross-chain --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const recipient = \"tbnb1prrujx8kkukrcrppklggadhuvegfnx8pemsq77\" // recipient address const recipientOtherChain = \"0x37B8516a0F88E65D677229b402ec6C1e0E333004\" //client ethereum address const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" // 32 bytes random number const timestamp = Math . floor ( Date . now () / 1000 ) // take the current timestamp const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ) const amount = [{ denom : \"GSYS\" , amount : 100 }] // swap out token amount const expectedIncome = \"100:GSYS\" // expected income const heightSpan = 400 // height span const res = client . swap . HTLT ( from , recipient , recipientOtherChain , \"\" , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , true ) Swap from Ethereum to Genesys Chain Note: Once cross-chain is true, --recipient-other-chain must not be empty Deputy send HTLT on Genesys Chain on testnet : Command line: ./eth-cli token HTLT --from <from-addr> --chain-id GSYS-Chain-Ganges --height-span <heightSpan> --amount <amount> --expected-income <expectedIncome> --recipient-other-chain <deputy ethereum address> --sender-other-chain <client ethereum address> --recipient-addr <client bep2 address> --cross-chain --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const recipient = \"tbnb1prrujx8kkukrcrppklggadhuvegfnx8pemsq77\" // recipient address const recipientOtherChain = \"0xfA5E36a04EeF3152092099F352DDbe88953bB540\" //client ethereum address const senderOtherChain = \"0x37B8516a0F88E65D677229b402ec6C1e0E333004\" //client ethereum address const randomNumberHash = \"6632eda86c4f19190c8a986e188526eee865e1ce2758ba59c8bf45e20ffa3bb5\" //deputy get this value from the event log of swap contract const timestamp = 1571383800 //deputy get this value from the event log of swap contract const amount = [{ denom : \"GSYS\" , amount : 100 }] // swap out token amount const expectedIncome = \"100:GSYS\" // expected income const heightSpan = 400 // height span const res = client . swap . HTLT ( from , recipient , recipientOtherChain , senderOtherChain , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , true ) Deposit HTLT Deposit Hash Timer Locked Transfer is to lock new BEP2 asset to an existed HTLT which is for single chain atomic swap. Parameters Name Type Description Optional From Address Sender address, where the assets are from No SwapID 32 bytes ID of previously created swap, hex encoding No Amount Coins The swapped out amount BEP2 tokens, example: \"100:GSYS\" or \"100:GSYS,10000:BTCB-1DE\" No Examples On testnet: Command line: ./eth-cli token deposit --swap-id <swapID> --amount 10000 :TEST-599 --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const swapID = \"61daf59e977c5f718f5aaedeaf69ccbea1c376db5274a84bca88848696164ffe\" // the ID of an existing swap const amount = [{ denom : \"TEST-599\" , amount : 10000 }] const res = client . swap . depositHTLT ( from , swapID , amount ) Example output Committed at block 39984686 (tx hash: AA118F7CFCB3FFF86EF5EED8D2B9ADEAC5D9F242497910DAA232BDE5F6A84C1E, response: {Code:0 Data:[] Log:Msg 0: Info: GasWanted:0 GasUsed:0 Tags:[{Key:[115 101 110 100 101 114] Value:[116 98 110 98 49 110 107 120 57 57 52 113 118 113 109 113 103 107 53 55 118 103 117 113 104 54 122 106 108 97 99 113 122 120 100 107 117 101 53 122 106 121 120] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[114 101 99 105 112 105 101 110 116] Value:[116 98 110 98 49 119 120 101 112 108 121 119 55 120 56 97 97 104 121 57 51 119 57 54 121 104 119 109 55 120 99 113 51 107 101 52 102 102 97 115 112 51 100] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[97 99 116 105 111 110] Value:[100 101 112 111 115 105 116 72 84 76 84] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] Codespace: XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}) After the deposit, you may observe that the balance of sender is decreased. The amount in deposit transaction must be positive. Besides, you can query the swap by swapID and the in_amount must equal to the amount that you balance decreased. Claim HTLT Claim Hash Timer Locked Transfer is to claim the locked asset by showing the random number value that matches the hash. Each HTLT locked asset is guaranteed to be release once. Parameters Name Type Description Optional From Address Sender address No SwapID 32 bytes ID of previously created swap, hex encoding No RandomNumber 32 bytes The random number to unlock the locked hash, 32 bytes, hex encoding No Examples On testnet: Command line: ./eth-cli token claim --swap-id <swapID> --random-number <random-number> --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const swapID = \"61daf59e977c5f718f5aaedeaf69ccbea1c376db5274a84bca88848696164ffe\" // the ID of an existing swap const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" // the random number generated in htlt const res = client . swap . claimHTLT ( from , swapID , randomNumber ) Example output: Committed at block 39984971 (tx hash: 15B8625E0247DE54700D3C5C110BE0CE279D33CC13A73845F3E0305758A40902, response: {Code:0 Data:[] Log:Msg 0: Info: GasWanted:0 GasUsed:0 Tags:[{Key:[115 101 110 100 101 114] Value:[116 98 110 98 49 119 120 101 112 108 121 119 55 120 56 97 97 104 121 57 51 119 57 54 121 104 119 109 55 120 99 113 51 107 101 52 102 102 97 115 112 51 100] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[114 101 99 105 112 105 101 110 116] Value:[116 98 110 98 49 110 107 120 57 57 52 113 118 113 109 113 103 107 53 55 118 103 117 113 104 54 122 106 108 97 99 113 122 120 100 107 117 101 53 122 106 121 120] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[115 101 110 100 101 114] Value:[116 98 110 98 49 119 120 101 112 108 121 119 55 120 56 97 97 104 121 57 51 119 57 54 121 104 119 109 55 120 99 113 51 107 101 52 102 102 97 115 112 51 100] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[114 101 99 105 112 105 101 110 116] Value:[116 98 110 98 49 103 57 114 122 99 48 101 50 106 102 56 101 102 51 113 112 57 97 120 56 104 48 112 109 112 109 118 106 122 119 109 116 113 52 106 120 102 114] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[97 99 116 105 111 110] Value:[99 108 97 105 109 72 84 76 84] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] Codespace: XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}) Refund HTLT Refund Hash Timer Locked Transfer is to refund the locked asset after timelock is expired. Parameters Name Type Description Optional From Address Sender address No SwapID 32 bytes ID of previously created swap, hex encoding No Examples On testnet: Command line: ./eth-cli token refund --swap-id <swapID> --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const swapID = \"61daf59e977c5f718f5aaedeaf69ccbea1c376db5274a84bca88848696164ffe\" // the ID of an existing swap const res = client . swap . refundHTLT ( from , swapID , randomNumber ) Common error: Already complete ERROR: { \"codespace\" :8, \"code\" :12, \"abci_code\" :524300, \"message\" : \"Expected swap status is Open, actually it is Completed\" } Not expired ERROR : { \"codespace\" : 8 , \"code\" : 8 , \"abci_code\" : 524296 , \"message\" : \"Current block height is 40003412, the expire height (40013236) is still not reached\" } Query Atomic Swap Query atomic swap allows you to search swap information by swapID Parameters Name Type Description Optional SwapID 32 bytes ID of previously created swap, hex encoding No Examples On testnet: ./eth-cli token query-swap --swap-id <swapID> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Expected output { \"from\" : \"tbnb1g9rzc0e2jf8ef3qp9ax8h0pmpmvjzwmtq4jxfr\" , \"to\" : \"tbnb1nkx994qvqmqgk57vguqh6zjlacqzxdkue5zjyx\" , \"out_amount\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"100\" } ], \"in_amount\" : [ { \"denom\" : \"TEST-599\" , \"amount\" : \"10000\" } ], \"expected_income\" : \"10000:TEST-599\" , \"recipient_other_chain\" : \"\" , \"random_number_hash\" : \"5768702259ee55983378d7b8207890c666648264524b9dada551386f832ba6b1\" , \"random_number\" : \"927c1ac33100bdbb001de19c626a05a7c3c11304fc825f5eabb22e741507711b\" , \"timestamp\" : \"1568792486\" , \"cross_chain\" : false , \"expire_height\" : \"39994169\" , \"index\" : \"53\" , \"closed_time\" : \"1568792927\" , \"status\" : \"Completed\" } Query Atomic Swap ID By Recipient Query atomic swap ID allows you to search swap history of an recipient. As this is a heavy query interface, some public nodes might close this query interface. Parameters Name Type Description Optional recipient-addr Address Swap recipient address No Examples On testnet: ./eth-cli token query-swapIDs-by-recipient --recipient-addr <address> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Example output: [ \"4d898bc8558daa4d817486d7a93b77b2c82fcec2123abf4a1eb7d2521237eccd\", \"e7cc2e2eb025cc4617ff0bb84fcffc973d7ba34f15dbc51383fe3543ff143e9c\" ] Query Atomic Swap ID By Creator Query atomic swap ID allows you to search swap history of an initiator. As this is a heavy query interface, some public nodes might close this query interface. Parameters Name Type Description Optional creator-addr Address Swap creator address No Examples On testnet: ./eth-cli token query-swapIDs-by-creator --creator-addr <address> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Example output: [ \"7341d4ea0519af90d98f60fee45fdc7e385621875ea982bc8caf1fd7a49af8c3\", \"290664c1e8123966d8f9050fdc9d93e94b0e51b36e2e2a6978e492d3796423f1\", \"b260dad3cf63e558fe102a050afbe52d5dd2e30c7db76da33d02ce5f85d07fcf\", \"2b532bf9171c4d33d80fc4a8d6603581a86345b41552337482224d8476fcf5f7\", \"20d22bbfa579520f0ba79cd176fb2b06aa8dbe5b0a6ba8c9b761129f6a42a94c\" ] Fees Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related HTLT N/A 0.000375 GSYS Y depositHTLT N/A 0.000375 GSYS Y claimHTLT N/A 0.000375 GSYS Y refundHTLT N/A 0.000375 GSYS Y Workflows Preparations Deploy smart-contract which supports Atomic Peg Swap (APS), there is already one example for Ethereum Deploy deputy process for handling swap activities by token owners, there is an existing open-source solution here: https://github.com/githubusername/githubrepo/bep3-deputy Issue and transfer enough tokens Testnet Deployment ERC20 contract has been deployed here: https://ropsten.etherscan.io/address/0xd93395b2771914e1679155f3ea58c41d89d96098 Token Symbol: PPC SmartContract has been deployed here: https://ropsten.etherscan.io/address/0x12dcbf79be178479870a473a99d91f535ed960ad Its corresponding address on testnet is: tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr on Genesys Chain and 0xD93395B2771914E1679155F3EA58C41d89D96098 on Ethereum testnet Swap Tokens from Ethereum to Genesys Chain 1. Approve Swap Transaction Go to this page and approve some amount of tokens. Function: Approve Parameters: _spender: address of the smartcontract, which is 0x12DCBf79BE178479870A473A99d91f535ed960AD _value: approved amount, should be bumped by e^10 Note: Please approve more than 1 token. In the following example, 100 PPC token was approved: Example of approve 100 PPC on ropsten testnet 2. Call HTLT function From Ethereum Go to smartcontract and call HTLT function Function: htlt Parameters: _randomNumberHash: SHA256(randomNumber||timestamp), randomNumber is 32-length random byte array _timestamp: it should be about 10 mins span around current timestamp _heightSpan: it's a customized filed for deputy operator. it should be more than 200 for this deputy. _recipientAddr: deputy address on Ethereum, it's 0x1C002969Fe201975eD8F054916b071672326858e for this one _bep2SenderAddr: omit this field with 0x0 _bep2RecipientAddr: Decode your testnet address from bech32 encoded to hex, for example: 0xc41f2a85e1d3629637de1222017dce46c6c8e4b9 _outAmount: approved amount, should be bumped by e^10 _bep2Amount: _outAmount * exchange rate, the default rate is 1 Example of htlt transaction 3. Deputy Call HTLT on Genesys Chain Then, Deputy will send HTLT transaction here 4. Claim HTLT on Genesys Chain Get the swapID on Genesys Chain ./eth-cli token query-swapIDs-by-recipient --recipient-addr tbnb1cs0j4p0p6d3fvd77zg3qzlwwgmrv3e9e63423w --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 [ \"12aacc3bdc2cef97e8e45cc9b409796df57904a4e9c76863ad8420ff75f13128\" ] You can also get swapID by calculateSwapID in javascript-sdk . It requires three parameters: Name Type Description Example randomNumberHash string randomNumberHash in client HTLT transaction on Ethereum 5a3728a8f4ecb8b4cb0b983a9441b7d69f95229c4aa531e6e3827d7c19beac82 sender string deputy bep2 address tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr senderOtherChain string client ethereum address 0x133d144f52705ceb3f5801b63b9ebccf4102f5ed Query the swap by swapID { \"from\": \"tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr\", \"to\": \"tbnb1cs0j4p0p6d3fvd77zg3qzlwwgmrv3e9e63423w\", \"out_amount\": [ { \"denom\": \"PPC-00A\", \"amount\": \"9999999000\" } ], \"in_amount\": null, \"expected_income\": \"\", \"recipient_other_chain\": \"0x1C002969Fe201975eD8F054916b071672326858e\", \"random_number_hash\": \"5a3728a8f4ecb8b4cb0b983a9441b7d69f95229c4aa531e6e3827d7c19beac82\", \"random_number\": \"\", \"timestamp\": \"1569497984\", \"cross_chain\": true, \"expire_height\": \"41380567\", \"index\": \"1947\", \"closed_time\": \"\", \"status\": \"Open\" } Verify parameters in the swap: random_number_hash must equal to the randomNumberHash in client HTLT transaction on ethereum to must equals to client wallet address timestamp must equal to the timestamp in client HTLT transaction on ethereum out_amount should be reasonable. Please note that the decimals of bep2 tokens is 8, the out_amount should be something around 10000000000:PPC, deputy will deduct some fees. expire_height must not be passed and should be enough for send claim transaction Send claim transaction on Genesys Chain ./eth-cli token claim --swap-id 12aacc3bdc2cef97e8e45cc9b409796df57904a4e9c76863ad8420ff75f13128 --random-number <random-number> --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Example of claim tx on testnet 5. Deputy Claim ERC20 Token Deputy will claim ERC20 tokens afterwards with claim transaction 6. Demo for Client APP: swap erc20 to bep2 This is a javascript implementation for client app to swap PPC to PPC-00A with deputy. const erc20ContractAddr = \"0xd93395b2771914e1679155f3ea58c41d89d96098\" const swapContractAddr = \"0x12DCBf79BE178479870A473A99d91f535ed960AD\" const deputyEthWalletAddr = \"0x1C002969Fe201975eD8F054916b071672326858e\" const deputyGSYSWalletAddr = \"tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr\" const clientEthWalletAddr = \"0xfA5E36a04EeF3152092099F352DDbe88953bB540\" const clientEthWalletKey = new Buffer ( \"89A0F0E0732ACAA7AD37C9E6D7A9798ECCE6940C63FF0290A58B1C1C1697486A\" , \"hex\" ) const clientBnbWalletAddr = \"tbnb17vwyu8npjj5pywh3keq2lm7d4v76n434pwd8av\" const clientBnbWalletMnemonic = \"lawsuit margin siege phrase fabric matrix like picnic day thrive correct velvet stool type broom upon flee fee ten senior install wrestle soap sick\" const web3 = new Web3 ( new Web3 . providers . HttpProvider ( \"https://ropsten.infura.io/v3/1c5b38a27f92410cb5feb13b6efb2e14\" )) const bnbClient = new BncClient ( \"https://testnet-dex.genesys.network\" ) await bnbClient . initChain () bnbClient . setPrivateKey ( crypto . getPrivateKeyFromMnemonic ( clientBnbWalletMnemonic )) bnbClient . useDefaultSigningDelegate () bnbClient . useDefaultBroadcastDelegate () const bnbRPC = new rpcClient ( \"https://seed-pre-s3.genesys.network\" , \"testnet\" ) const erc20Contract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"name\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"approve\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_evilUser\" , \"type\" : \"address\" }], \"name\" : \"addBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"totalSupply\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_from\" , \"type\" : \"address\" },{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transferFrom\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"decimals\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_addedValue\" , \"type\" : \"uint256\" }], \"name\" : \"increaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"unpause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"isPauser\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_maker\" , \"type\" : \"address\" }], \"name\" : \"getBlackListStatus\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"paused\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renouncePauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"who\" , \"type\" : \"address\" }], \"name\" : \"balanceOf\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renounceOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"addPauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"pause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"owner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"isOwner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"symbol\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_subtractedValue\" , \"type\" : \"uint256\" }], \"name\" : \"decreaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transfer\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"issue\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"redeem\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_owner\" , \"type\" : \"address\" },{ \"name\" : \"_spender\" , \"type\" : \"address\" }], \"name\" : \"allowance\" , \"outputs\" : [{ \"name\" : \"remaining\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"name\" : \"isBlackListed\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_clearedUser\" , \"type\" : \"address\" }], \"name\" : \"removeBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"transferOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_blackListedUser\" , \"type\" : \"address\" }], \"name\" : \"destroyBlackFunds\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_initialSupply\" , \"type\" : \"uint256\" },{ \"name\" : \"_name\" , \"type\" : \"string\" },{ \"name\" : \"_symbol\" , \"type\" : \"string\" },{ \"name\" : \"_decimals\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Issue\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Redeem\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_blackListedUser\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"_balance\" , \"type\" : \"uint256\" }], \"name\" : \"DestroyedBlackFunds\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"AddedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"RemovedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Paused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Unpaused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"from\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"to\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Transfer\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"owner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"spender\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Approval\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"previousOwner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"OwnershipTransferred\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserAdded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserRemoved\" , \"type\" : \"event\" }], erc20ContractAddr ) const swapContract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"ERC20ContractAddr\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"isSwapExist\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refund\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_swapSender\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" }], \"name\" : \"calSwapID\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bytes32\" }], \"payable\" : false , \"stateMutability\" : \"pure\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"claim\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_heightSpan\" , \"type\" : \"uint256\" },{ \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_bep2RecipientAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"htlt\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"claimable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refundable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"queryOpenSwap\" , \"outputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_sender\" , \"type\" : \"address\" },{ \"name\" : \"_recipient\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_erc20Contract\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"indexed\" : false , \"name\" : \"_bep2Addr\" , \"type\" : \"bytes20\" },{ \"indexed\" : false , \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"HTLT\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" }], \"name\" : \"Refunded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"Claimed\" , \"type\" : \"event\" }], swapContractAddr ) //-------------------------------------------- //Step1 approve erc20 to swap contract address //-------------------------------------------- const approveData = erc20Contract . methods . increaseAllowance ( swapContractAddr , 10000000000 ). encodeABI () let nonce = await web3 . eth . getTransactionCount ( clientEthWalletAddr , 'pending' ) let gasPrice = await web3 . eth . getGasPrice () let gasLimit = 3000000 let rawTx = { nonce : web3 . utils . toHex ( nonce ), gasPrice : web3 . utils . toHex ( gasPrice ), gasLimit : web3 . utils . toHex ( gasLimit ), to : erc20ContractAddr , value : '0x00' , data : approveData } var ethereumjs = require ( 'ethereumjs-tx' ) var signTx = new ethereumjs ( rawTx ) signTx . sign ( clientEthWalletKey ) var serializedTx = signTx . serialize (); web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' )). on ( 'receipt' , console . log ) await wait ( 20000 ) //---------------------------------------------------------------------------- //Step2 call swap contract to send htlt transaction on Ethereum //---------------------------------------------------------------------------- const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" const timestamp = Math . floor ( Date . now () / 1000 ) const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ). toString ( \"hex\" ) const heightSpan = 1000 const hexEncodingClientGSYSaddr = '0x' + crypto . decodeAddress ( clientBnbWalletAddr ). toString ( \"hex\" ) const amount = 10000000000 // 10000000000:PPC\uff0c decimal is 10 const expectedIncome = 99999000 //\"99999000:PPC-00A\", decimal is 8, deputy will deduct swap fee, the swap fee is 1000:PPC-00A const htltData = swapContract . methods . htlt ( \"0x\" + randomNumberHash , timestamp , heightSpan , deputyEthWalletAddr , \"0x0\" , hexEncodingClientGSYSaddr , amount , expectedIncome ). encodeABI () nonce = await web3 . eth . getTransactionCount ( clientEthWalletAddr , 'pending' ) gasPrice = await web3 . eth . getGasPrice () gasLimit = 3000000 rawTx = { nonce : web3 . utils . toHex ( nonce ), gasPrice : web3 . utils . toHex ( gasPrice ), gasLimit : web3 . utils . toHex ( gasLimit ), to : swapContractAddr , value : '0x00' , data : htltData } ethereumjs = require ( 'ethereumjs-tx' ) signTx = new ethereumjs ( rawTx ) signTx . sign ( clientEthWalletKey ) serializedTx = signTx . serialize (); web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' )). on ( 'receipt' , console . log ) await wait ( 20000 ) //---------------------------------------------------------------------------- //Step3 query swap created by deputy on Genesys Chain and verify swap parameters //---------------------------------------------------------------------------- const swapID = calculateSwapID ( randomNumberHash . replace ( \"0x\" , \"\" ), deputyGSYSWalletAddr , clientEthWalletAddr ). toString () console . log ( swapID ) let atomicSwapList = await bnbClient . getSwapByRecipient ( clientBnbWalletAddr , 1000 , 0 ) while ( atomicSwapList . result . atomicSwaps [ 0 ]. swapId != swapID ) { console . log ( \"Waiting for the atomic swap created by deputy\" ) await wait ( 5000 ) atomicSwapList = await bnbClient . getSwapByRecipient ( clientBnbWalletAddr , 1000 , 0 ) } const atomicSwap = await bnbClient . getSwapByID ( swapID ) console . log ( atomicSwap ) const status = await bnbRPC . status () expect ( atomicSwap . result . toAddr ). toBe ( clientBnbWalletAddr ) expect ( atomicSwap . result . randomNumberHash ). toBe ( randomNumberHash . replace ( \"0x\" , \"\" )) expect ( atomicSwap . result . timestamp ). toBe ( timestamp ) expect ( atomicSwap . result . outAmount ). toBe ( \"99999000:PPC-00A\" ) expect ( Number ( atomicSwap . result . expireHeight )). toBeGreaterThan ( Number ( status . sync_info . latest_block_height ) + 100 ) //---------------------------------------------------------------------------- //Step4 claim on Genesys Chain //---------------------------------------------------------------------------- const res = await bnbClient . swap . claimHTLT ( clientBnbWalletAddr , swapID , randomNumber ) console . log ( res ) //---------------------------------------------------------------------------- //If step3 or step4 are failed and the expire height on Ethereum is passed, try to call refund method on Ethereum //---------------------------------------------------------------------------- Swap Tokens from Genesys Chain to Ethereum 1. Send HTLT Transaction from Genesys Chain Please read this section to generate a valid HTLT transaction. Please write down the randomNumber and randomNumberHash . ./eth-cli token HTLT --from atomic --recipient-addr tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr --chain-id GSYS-Chain-Ganges --height-span 10000 --amount 9900000000:PPC-00A --expected-income 9900000000:PPC --recipient-other-chain 0x133D144F52705cEb3f5801B63b9EBcCF4102f5Ed --cross-chain --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Random number: 4811959406ea3e69721d944d308880ec41323b7f89e51a78df3693348779315e Timestamp: 1569578936 Random number hash: b03f256c9efdb97b9815faa1417e1da4cca7672e0bb26e4e7d9bfc82d0f1f15e Committed at block 634510 ( tx hash: 9DEF124E12DE123BA1CC75AA6E68F20CC48EBBE9D7693CE4D0416267C6C0F159, response: { Code:0 Data:[229 50 241 60 76 91 112 146 93 68 100 222 83 84 180 133 181 151 241 174 93 125 132 82 245 198 5 66 0 123 32 113] Log:Msg 0: swapID: f85dd907df0a5897927b949c0f9e2563d453ba698ff9941fed1ce91f8057afc2 ... ) Note: the swap amount must be positive. Please write down the random number , random number hash , swapID and timestamp for next steps. Example is here Then, you can query the the swap by SwapID : ./eth-cli token query-swap --swap-id f85dd907df0a5897927b949c0f9e2563d453ba698ff9941fed1ce91f8057afc2 --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 You can use this swapID for refund if the deputy doesn't send htlt transaction on ethereum with proper parameters. 2. Deputy Approve Tokens You should see that Deputy has approve enough amount of tokens for atomic swap. 3. Deputy Send HTLT on Ethereum You should see that Deputy has sent the htlt transaction afterwards To get the swapID on Ethereum, you can check this page 0xd3bacf63906af5459ead39f27cae189e2f3e76fda34523714a4c61d76c79ee4e is the swapID on Ethereum. 4. Claim ERC20 Tokens on Ethereum You should see that Deputy has already approved enough tokens and In its event log , you should see the swapID . Before calling claim function on ethereum, clients should verify the parameters in the HTLT event. _randomNumberHash must equal to the randomNumberHash in client HTLT transaction on Genesys Chain _recipientAddr must equal to client ethereum wallet address _timestamp must equal to the timestamp in client HTLT transaction on Genesys Chain _outAmount should be reasonable. Please note that the decimals erc20 contract and deputy will deduct some fees. _expireHeight must not be passed and should be enough for send claim transaction Then, you can call the claim function: Function: claim Parameters: _swapID: this has been obtained from event, you can also calculate it from calSwapID function in the contract. calSwapID(randomNumberHash, {deputy ethereum address}, {hex encoding client shree address}) _randomNumber: reveal your randomNumber Example is here 5. Deputy Claim on Genesys Chain Claim HTLT transaction from Deputy is sent afterwards: 6. Demo for Client APP: swap bep2 to erc20 This is a javascript implementation of client app to swap PPC-00A to PPC with deputy. const erc20ContractAddr = \"0xd93395b2771914e1679155f3ea58c41d89d96098\" const swapContractAddr = \"0x12DCBf79BE178479870A473A99d91f535ed960AD\" const deputyEthWalletAddr = \"0x1C002969Fe201975eD8F054916b071672326858e\" const deputyGSYSWalletAddr = \"tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr\" const clientEthWalletAddr = \"0xfA5E36a04EeF3152092099F352DDbe88953bB540\" const clientEthWalletKey = new Buffer ( \"89A0F0E0732ACAA7AD37C9E6D7A9798ECCE6940C63FF0290A58B1C1C1697486A\" , \"hex\" ) const clientBnbWalletAddr = \"tbnb17vwyu8npjj5pywh3keq2lm7d4v76n434pwd8av\" const clientBnbWalletMnemonic = \"lawsuit margin siege phrase fabric matrix like picnic day thrive correct velvet stool type broom upon flee fee ten senior install wrestle soap sick\" const web3 = new Web3 ( new Web3 . providers . HttpProvider ( \"https://ropsten.infura.io/v3/1c5b38a27f92410cb5feb13b6efb2e14\" )) const bnbClient = new BncClient ( \"https://testnet-dex.genesys.network\" ) await bnbClient . initChain () bnbClient . setPrivateKey ( crypto . getPrivateKeyFromMnemonic ( clientBnbWalletMnemonic )) bnbClient . useDefaultSigningDelegate () bnbClient . useDefaultBroadcastDelegate () const bnbRPC = new rpcClient ( \"https://seed-pre-s3.genesys.network\" , \"testnet\" ) const erc20Contract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"name\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"approve\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_evilUser\" , \"type\" : \"address\" }], \"name\" : \"addBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"totalSupply\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_from\" , \"type\" : \"address\" },{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transferFrom\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"decimals\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_addedValue\" , \"type\" : \"uint256\" }], \"name\" : \"increaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"unpause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"isPauser\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_maker\" , \"type\" : \"address\" }], \"name\" : \"getBlackListStatus\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"paused\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renouncePauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"who\" , \"type\" : \"address\" }], \"name\" : \"balanceOf\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renounceOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"addPauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"pause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"owner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"isOwner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"symbol\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_subtractedValue\" , \"type\" : \"uint256\" }], \"name\" : \"decreaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transfer\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"issue\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"redeem\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_owner\" , \"type\" : \"address\" },{ \"name\" : \"_spender\" , \"type\" : \"address\" }], \"name\" : \"allowance\" , \"outputs\" : [{ \"name\" : \"remaining\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"name\" : \"isBlackListed\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_clearedUser\" , \"type\" : \"address\" }], \"name\" : \"removeBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"transferOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_blackListedUser\" , \"type\" : \"address\" }], \"name\" : \"destroyBlackFunds\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_initialSupply\" , \"type\" : \"uint256\" },{ \"name\" : \"_name\" , \"type\" : \"string\" },{ \"name\" : \"_symbol\" , \"type\" : \"string\" },{ \"name\" : \"_decimals\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Issue\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Redeem\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_blackListedUser\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"_balance\" , \"type\" : \"uint256\" }], \"name\" : \"DestroyedBlackFunds\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"AddedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"RemovedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Paused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Unpaused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"from\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"to\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Transfer\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"owner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"spender\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Approval\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"previousOwner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"OwnershipTransferred\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserAdded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserRemoved\" , \"type\" : \"event\" }], erc20ContractAddr ) const swapContract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"ERC20ContractAddr\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"isSwapExist\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refund\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_swapSender\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" }], \"name\" : \"calSwapID\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bytes32\" }], \"payable\" : false , \"stateMutability\" : \"pure\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"claim\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_heightSpan\" , \"type\" : \"uint256\" },{ \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_bep2RecipientAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"htlt\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"claimable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refundable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"queryOpenSwap\" , \"outputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_sender\" , \"type\" : \"address\" },{ \"name\" : \"_recipient\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_erc20Contract\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"indexed\" : false , \"name\" : \"_bep2Addr\" , \"type\" : \"bytes20\" },{ \"indexed\" : false , \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"HTLT\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" }], \"name\" : \"Refunded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"Claimed\" , \"type\" : \"event\" }], swapContractAddr ) //-------------------------------------------- //Step1 send htlt on Genesys Chain //-------------------------------------------- const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" const timestamp = Math . floor ( Date . now () / 1000 ) const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ). toString ( \"hex\" ) const heightSpan = 10000 const amount = [{ denom : \"PPC-00A\" , amount : 100000000 }] const expectedIncome = \"9999990000:PPC\" //\"9999990000:PPC\", decimal is 10, deputy will deduct swap fee, the swap fee is 10000:PPC bnbClient . swap . HTLT ( clientBnbWalletAddr , deputyGSYSWalletAddr , clientEthWalletAddr , \"\" , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , true ) await wait ( 1000 ) //---------------------------------------------------------------------------- //Step2 query swap created by deputy on Ethereum and verify swap parameters //---------------------------------------------------------------------------- const hexEncodingClientGSYSaddr = '0x' + crypto . decodeAddress ( clientBnbWalletAddr ). toString ( \"hex\" ) const swapID = await swapContract . methods . calSwapID ( \"0x\" + randomNumberHash , deputyEthWalletAddr , hexEncodingClientGSYSaddr ). call () console . log ( swapID ) let openSwap = await swapContract . methods . queryOpenSwap ( swapID ). call () while ( openSwap . _randomNumberHash == '0x0000000000000000000000000000000000000000000000000000000000000000' ) { console . log ( \"Waiting for the atomic swap created by deputy\" ) await wait ( 5000 ) openSwap = await swapContract . methods . queryOpenSwap ( swapID ). call () } let ethBlock = await web3 . eth . getBlock ( 'latest' ) let ethLatestHeight = ethBlock . number expect ( openSwap . _randomNumberHash ). toBe ( \"0x\" + randomNumberHash ) expect ( Number ( openSwap . _timestamp )). toBe ( timestamp ) expect ( Number ( openSwap . _outAmount )). toBe ( 9999990000 ) expect ( openSwap . _recipient ). toBe ( clientEthWalletAddr ) expect ( Number ( openSwap . _expireHeight )). toBeGreaterThan ( Number ( ethLatestHeight ) + 20 ) //---------------------------------------------------------------------------- //Step3 claim on Ethereum //---------------------------------------------------------------------------- const claimData = swapContract . methods . claim ( swapID , \"0x\" + randomNumber ). encodeABI () let nonce = await web3 . eth . getTransactionCount ( clientEthWalletAddr , 'pending' ) let gasPrice = await web3 . eth . getGasPrice () let gasLimit = 3000000 let rawTx = { nonce : web3 . utils . toHex ( nonce ), gasPrice : web3 . utils . toHex ( gasPrice ), gasLimit : web3 . utils . toHex ( gasLimit ), to : swapContractAddr , value : '0x00' , data : claimData } var ethereumjs = require ( 'ethereumjs-tx' ) var signTx = new ethereumjs ( rawTx ) signTx . sign ( clientEthWalletKey ) var serializedTx = signTx . serialize (); web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' )). on ( 'receipt' , console . log ) await wait ( 20000 ) //---------------------------------------------------------------------------- //If step2 or step3 are failed and the expire height on Genesys Chain is passed, try to send refundHTLT transaction on Genesys Chain //---------------------------------------------------------------------------- Swap between Several BEP2 tokens Swap between Several BEP2 tokens fails","title":"Atomic swap"},{"location":"atomic-swap.html#introduction","text":"As explained in BEP3 , Hash Timer Locked Contract(HGSYS) has been used for Atomic Swap and cross payment channels between different blockchains. BEP3 defines native transactions to support HGSYS on Genesys Chain and also proposes the standard infrastructure and procedure to use HGSYS for inter-chain atomic swap to easily create and use pegged token. During the swap process, the related fund will be locked to a purely-code-controlled escrow account. A purely-code-controlled escrow account is a kind of account which is derived from a hard-coded string in shree chain protocol. This kind of account doesn't have its own private key and it's only controlled by code of the protocol. The code for calculating escrow account is the same that is used in cosmos-sdk : AtomicSwapCoinsAccAddr = sdk.AccAddress(crypto.AddressHash([]byte(\"Genesys ChainAtomicSwapCoins\"))) The account for mainnet is: bnb1wxeplyw7x8aahy93w96yhwm7xcq3ke4f8ge93u and the account for testnet is: tbnb1wxeplyw7x8aahy93w96yhwm7xcq3ke4ffasp3d . Once the swap is claimed or refunded, the fund will be transferred from the purely-code-controlled escrow account to client accounts.","title":"Introduction"},{"location":"atomic-swap.html#commands","text":"","title":"Commands"},{"location":"atomic-swap.html#hash-timer-locked-transfer","text":"Hash Timer Locked Transfer (HTLT) is a new transaction type on Genesys Chain, to serve as HGSYS in the first step of Atomic Swap,","title":"Hash Timer Locked Transfer"},{"location":"atomic-swap.html#parameters","text":"Name Type Description Optional From Address Sender address, where the asset is from No recipient-addr Address Receiver address, where the asset is to, if the proper condition meets. No recipient-other-chain bytes a byte array, maximum 32 bytes, in any proper encoding. leave it empty for single chain swap Yes sender-other-chain bytes a byte array, maximum 32 bytes, in any proper encoding. leave it empty for single chain swap Yes RandomNumberHash 32 bytes hash of a random number and timestamp, based on SHA256. If left out, a random value will be generated True Timestamp int64 Supposed to be the time of sending transaction, counted by second. It should be identical to the one in swap contract. If left out, current timestamp will be used. No OutAmount Coins similar to the Coins in the original Transfer defined in BEP2, assets to swap out No ExpectedIncome string Expected income from swap counter party, example: \"100:GSYS\" or \"100:GSYS,10000:BTCB-1DE\" The amount needs to be bumped by e^8 No HeightSpan int64 number of blocks to wait before the asset may be returned to From if not claimed via Random. The number must be larger than or equal to 360 (>2 minutes), and smaller than 518400 (< 48 hours) No CrossChain bool Specify if the HTLT is for cross chain atomic swap True, the default value is False","title":"Parameters"},{"location":"atomic-swap.html#outputs","text":"Name Type Description Random number 32 bytes Timestamp int64 Random number hash 32 bytes Swap ID 32 bytes","title":"Outputs"},{"location":"atomic-swap.html#examples","text":"Swap between BEP2 tokens On testnet : Command line ./eth-cli token HTLT --recipient-addr <recipient-addr> --amount 100 :GSYS --expected-income <expectedIncome> --height-span <heightSpan> --from <from-addr> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const recipient = \"tbnb1prrujx8kkukrcrppklggadhuvegfnx8pemsq77\" // recipient address const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" // 32 bytes random number const timestamp = Math . floor ( Date . now () / 1000 ) // take the current timestamp const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ) const amount = [{ denom : \"GSYS\" , amount : 100 }] const expectedIncome = \"100:GSYS\" // expected income const heightSpan = 400 // height span const res = client . swap . HTLT ( from , recipient , \"\" , \"\" , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , false ) Example output: Please take a note of returned swapID : Random number: 927c1ac33100bdbb001de19c626a05a7c3c11304fc825f5eabb22e741507711b Timestamp: 1568792486 Random number hash: 5768702259ee55983378d7b8207890c666648264524b9dada551386f832ba6b1 Password to sign with 'guest': Committed at block 39984169 ( tx hash: B5A3DD92A40E98745BBE9F608944FE5511B81071B34E9947A754A04A5F378A85, response: { Code:0 Data:[77 137 139 200 85 141 170 77 129 116 134 215 169 59 119 178 200 47 206 194 18 58 191 74 30 183 210 82 18 55 236 205] Log:Msg 0: swapID: 4d898bc8558daa4d817486d7a93b77b2c82fcec2123abf4a1eb7d2521237eccd Info: GasWanted:0 GasUsed:0 ... ) Besides, the Data field in the committed result is the byte array of swapID : Data:[77 137 139 200 85 141 170 77 129 116 134 215 169 59 119 178 200 47 206 194 18 58 191 74 30 183 210 82 18 55 236 205] swapID: 4d898bc8558daa4d817486d7a93b77b2c82fcec2123abf4a1eb7d2521237eccd Swap from Genesys Chain to Ethereum Clients send HTLT on Genesys Chain on testnet : Command line: ./eth-cli token HTLT --from <from-addr> --chain-id GSYS-Chain-Ganges --height-span <heightSpan> --amount <amount> --expected-income <expectedIncome> --recipient-addr <deputy-bep2-addr> --recipient-other-chain <client ethereum address> --cross-chain --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const recipient = \"tbnb1prrujx8kkukrcrppklggadhuvegfnx8pemsq77\" // recipient address const recipientOtherChain = \"0x37B8516a0F88E65D677229b402ec6C1e0E333004\" //client ethereum address const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" // 32 bytes random number const timestamp = Math . floor ( Date . now () / 1000 ) // take the current timestamp const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ) const amount = [{ denom : \"GSYS\" , amount : 100 }] // swap out token amount const expectedIncome = \"100:GSYS\" // expected income const heightSpan = 400 // height span const res = client . swap . HTLT ( from , recipient , recipientOtherChain , \"\" , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , true ) Swap from Ethereum to Genesys Chain Note: Once cross-chain is true, --recipient-other-chain must not be empty Deputy send HTLT on Genesys Chain on testnet : Command line: ./eth-cli token HTLT --from <from-addr> --chain-id GSYS-Chain-Ganges --height-span <heightSpan> --amount <amount> --expected-income <expectedIncome> --recipient-other-chain <deputy ethereum address> --sender-other-chain <client ethereum address> --recipient-addr <client bep2 address> --cross-chain --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const recipient = \"tbnb1prrujx8kkukrcrppklggadhuvegfnx8pemsq77\" // recipient address const recipientOtherChain = \"0xfA5E36a04EeF3152092099F352DDbe88953bB540\" //client ethereum address const senderOtherChain = \"0x37B8516a0F88E65D677229b402ec6C1e0E333004\" //client ethereum address const randomNumberHash = \"6632eda86c4f19190c8a986e188526eee865e1ce2758ba59c8bf45e20ffa3bb5\" //deputy get this value from the event log of swap contract const timestamp = 1571383800 //deputy get this value from the event log of swap contract const amount = [{ denom : \"GSYS\" , amount : 100 }] // swap out token amount const expectedIncome = \"100:GSYS\" // expected income const heightSpan = 400 // height span const res = client . swap . HTLT ( from , recipient , recipientOtherChain , senderOtherChain , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , true )","title":"Examples"},{"location":"atomic-swap.html#deposit-htlt","text":"Deposit Hash Timer Locked Transfer is to lock new BEP2 asset to an existed HTLT which is for single chain atomic swap.","title":"Deposit HTLT"},{"location":"atomic-swap.html#parameters_1","text":"Name Type Description Optional From Address Sender address, where the assets are from No SwapID 32 bytes ID of previously created swap, hex encoding No Amount Coins The swapped out amount BEP2 tokens, example: \"100:GSYS\" or \"100:GSYS,10000:BTCB-1DE\" No","title":"Parameters"},{"location":"atomic-swap.html#examples_1","text":"On testnet: Command line: ./eth-cli token deposit --swap-id <swapID> --amount 10000 :TEST-599 --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const swapID = \"61daf59e977c5f718f5aaedeaf69ccbea1c376db5274a84bca88848696164ffe\" // the ID of an existing swap const amount = [{ denom : \"TEST-599\" , amount : 10000 }] const res = client . swap . depositHTLT ( from , swapID , amount ) Example output Committed at block 39984686 (tx hash: AA118F7CFCB3FFF86EF5EED8D2B9ADEAC5D9F242497910DAA232BDE5F6A84C1E, response: {Code:0 Data:[] Log:Msg 0: Info: GasWanted:0 GasUsed:0 Tags:[{Key:[115 101 110 100 101 114] Value:[116 98 110 98 49 110 107 120 57 57 52 113 118 113 109 113 103 107 53 55 118 103 117 113 104 54 122 106 108 97 99 113 122 120 100 107 117 101 53 122 106 121 120] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[114 101 99 105 112 105 101 110 116] Value:[116 98 110 98 49 119 120 101 112 108 121 119 55 120 56 97 97 104 121 57 51 119 57 54 121 104 119 109 55 120 99 113 51 107 101 52 102 102 97 115 112 51 100] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[97 99 116 105 111 110] Value:[100 101 112 111 115 105 116 72 84 76 84] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] Codespace: XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}) After the deposit, you may observe that the balance of sender is decreased. The amount in deposit transaction must be positive. Besides, you can query the swap by swapID and the in_amount must equal to the amount that you balance decreased.","title":"Examples"},{"location":"atomic-swap.html#claim-htlt","text":"Claim Hash Timer Locked Transfer is to claim the locked asset by showing the random number value that matches the hash. Each HTLT locked asset is guaranteed to be release once.","title":"Claim HTLT"},{"location":"atomic-swap.html#parameters_2","text":"Name Type Description Optional From Address Sender address No SwapID 32 bytes ID of previously created swap, hex encoding No RandomNumber 32 bytes The random number to unlock the locked hash, 32 bytes, hex encoding No","title":"Parameters"},{"location":"atomic-swap.html#examples_2","text":"On testnet: Command line: ./eth-cli token claim --swap-id <swapID> --random-number <random-number> --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const swapID = \"61daf59e977c5f718f5aaedeaf69ccbea1c376db5274a84bca88848696164ffe\" // the ID of an existing swap const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" // the random number generated in htlt const res = client . swap . claimHTLT ( from , swapID , randomNumber ) Example output: Committed at block 39984971 (tx hash: 15B8625E0247DE54700D3C5C110BE0CE279D33CC13A73845F3E0305758A40902, response: {Code:0 Data:[] Log:Msg 0: Info: GasWanted:0 GasUsed:0 Tags:[{Key:[115 101 110 100 101 114] Value:[116 98 110 98 49 119 120 101 112 108 121 119 55 120 56 97 97 104 121 57 51 119 57 54 121 104 119 109 55 120 99 113 51 107 101 52 102 102 97 115 112 51 100] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[114 101 99 105 112 105 101 110 116] Value:[116 98 110 98 49 110 107 120 57 57 52 113 118 113 109 113 103 107 53 55 118 103 117 113 104 54 122 106 108 97 99 113 122 120 100 107 117 101 53 122 106 121 120] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[115 101 110 100 101 114] Value:[116 98 110 98 49 119 120 101 112 108 121 119 55 120 56 97 97 104 121 57 51 119 57 54 121 104 119 109 55 120 99 113 51 107 101 52 102 102 97 115 112 51 100] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[114 101 99 105 112 105 101 110 116] Value:[116 98 110 98 49 103 57 114 122 99 48 101 50 106 102 56 101 102 51 113 112 57 97 120 56 104 48 112 109 112 109 118 106 122 119 109 116 113 52 106 120 102 114] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[97 99 116 105 111 110] Value:[99 108 97 105 109 72 84 76 84] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] Codespace: XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0})","title":"Examples"},{"location":"atomic-swap.html#refund-htlt","text":"Refund Hash Timer Locked Transfer is to refund the locked asset after timelock is expired.","title":"Refund HTLT"},{"location":"atomic-swap.html#parameters_3","text":"Name Type Description Optional From Address Sender address No SwapID 32 bytes ID of previously created swap, hex encoding No","title":"Parameters"},{"location":"atomic-swap.html#examples_3","text":"On testnet: Command line: ./eth-cli token refund --swap-id <swapID> --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const swapID = \"61daf59e977c5f718f5aaedeaf69ccbea1c376db5274a84bca88848696164ffe\" // the ID of an existing swap const res = client . swap . refundHTLT ( from , swapID , randomNumber ) Common error: Already complete ERROR: { \"codespace\" :8, \"code\" :12, \"abci_code\" :524300, \"message\" : \"Expected swap status is Open, actually it is Completed\" } Not expired ERROR : { \"codespace\" : 8 , \"code\" : 8 , \"abci_code\" : 524296 , \"message\" : \"Current block height is 40003412, the expire height (40013236) is still not reached\" }","title":"Examples"},{"location":"atomic-swap.html#query-atomic-swap","text":"Query atomic swap allows you to search swap information by swapID","title":"Query Atomic Swap"},{"location":"atomic-swap.html#parameters_4","text":"Name Type Description Optional SwapID 32 bytes ID of previously created swap, hex encoding No","title":"Parameters"},{"location":"atomic-swap.html#examples_4","text":"On testnet: ./eth-cli token query-swap --swap-id <swapID> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Expected output { \"from\" : \"tbnb1g9rzc0e2jf8ef3qp9ax8h0pmpmvjzwmtq4jxfr\" , \"to\" : \"tbnb1nkx994qvqmqgk57vguqh6zjlacqzxdkue5zjyx\" , \"out_amount\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"100\" } ], \"in_amount\" : [ { \"denom\" : \"TEST-599\" , \"amount\" : \"10000\" } ], \"expected_income\" : \"10000:TEST-599\" , \"recipient_other_chain\" : \"\" , \"random_number_hash\" : \"5768702259ee55983378d7b8207890c666648264524b9dada551386f832ba6b1\" , \"random_number\" : \"927c1ac33100bdbb001de19c626a05a7c3c11304fc825f5eabb22e741507711b\" , \"timestamp\" : \"1568792486\" , \"cross_chain\" : false , \"expire_height\" : \"39994169\" , \"index\" : \"53\" , \"closed_time\" : \"1568792927\" , \"status\" : \"Completed\" }","title":"Examples"},{"location":"atomic-swap.html#query-atomic-swap-id-by-recipient","text":"Query atomic swap ID allows you to search swap history of an recipient. As this is a heavy query interface, some public nodes might close this query interface.","title":"Query Atomic Swap ID By Recipient"},{"location":"atomic-swap.html#parameters_5","text":"Name Type Description Optional recipient-addr Address Swap recipient address No","title":"Parameters"},{"location":"atomic-swap.html#examples_5","text":"On testnet: ./eth-cli token query-swapIDs-by-recipient --recipient-addr <address> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Example output: [ \"4d898bc8558daa4d817486d7a93b77b2c82fcec2123abf4a1eb7d2521237eccd\", \"e7cc2e2eb025cc4617ff0bb84fcffc973d7ba34f15dbc51383fe3543ff143e9c\" ]","title":"Examples"},{"location":"atomic-swap.html#query-atomic-swap-id-by-creator","text":"Query atomic swap ID allows you to search swap history of an initiator. As this is a heavy query interface, some public nodes might close this query interface.","title":"Query Atomic Swap ID By Creator"},{"location":"atomic-swap.html#parameters_6","text":"Name Type Description Optional creator-addr Address Swap creator address No","title":"Parameters"},{"location":"atomic-swap.html#examples_6","text":"On testnet: ./eth-cli token query-swapIDs-by-creator --creator-addr <address> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Example output: [ \"7341d4ea0519af90d98f60fee45fdc7e385621875ea982bc8caf1fd7a49af8c3\", \"290664c1e8123966d8f9050fdc9d93e94b0e51b36e2e2a6978e492d3796423f1\", \"b260dad3cf63e558fe102a050afbe52d5dd2e30c7db76da33d02ce5f85d07fcf\", \"2b532bf9171c4d33d80fc4a8d6603581a86345b41552337482224d8476fcf5f7\", \"20d22bbfa579520f0ba79cd176fb2b06aa8dbe5b0a6ba8c9b761129f6a42a94c\" ]","title":"Examples"},{"location":"atomic-swap.html#fees","text":"Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related HTLT N/A 0.000375 GSYS Y depositHTLT N/A 0.000375 GSYS Y claimHTLT N/A 0.000375 GSYS Y refundHTLT N/A 0.000375 GSYS Y","title":"Fees"},{"location":"atomic-swap.html#workflows","text":"","title":"Workflows"},{"location":"atomic-swap.html#preparations","text":"Deploy smart-contract which supports Atomic Peg Swap (APS), there is already one example for Ethereum Deploy deputy process for handling swap activities by token owners, there is an existing open-source solution here: https://github.com/githubusername/githubrepo/bep3-deputy Issue and transfer enough tokens","title":"Preparations"},{"location":"atomic-swap.html#testnet-deployment","text":"ERC20 contract has been deployed here: https://ropsten.etherscan.io/address/0xd93395b2771914e1679155f3ea58c41d89d96098 Token Symbol: PPC SmartContract has been deployed here: https://ropsten.etherscan.io/address/0x12dcbf79be178479870a473a99d91f535ed960ad Its corresponding address on testnet is: tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr on Genesys Chain and 0xD93395B2771914E1679155F3EA58C41d89D96098 on Ethereum testnet","title":"Testnet Deployment"},{"location":"atomic-swap.html#swap-tokens-from-ethereum-to-genesys-chain","text":"","title":"Swap Tokens from Ethereum to Genesys Chain"},{"location":"atomic-swap.html#1-approve-swap-transaction","text":"Go to this page and approve some amount of tokens. Function: Approve Parameters: _spender: address of the smartcontract, which is 0x12DCBf79BE178479870A473A99d91f535ed960AD _value: approved amount, should be bumped by e^10 Note: Please approve more than 1 token. In the following example, 100 PPC token was approved: Example of approve 100 PPC on ropsten testnet","title":"1.  Approve Swap Transaction"},{"location":"atomic-swap.html#2-call-htlt-function-from-ethereum","text":"Go to smartcontract and call HTLT function Function: htlt Parameters: _randomNumberHash: SHA256(randomNumber||timestamp), randomNumber is 32-length random byte array _timestamp: it should be about 10 mins span around current timestamp _heightSpan: it's a customized filed for deputy operator. it should be more than 200 for this deputy. _recipientAddr: deputy address on Ethereum, it's 0x1C002969Fe201975eD8F054916b071672326858e for this one _bep2SenderAddr: omit this field with 0x0 _bep2RecipientAddr: Decode your testnet address from bech32 encoded to hex, for example: 0xc41f2a85e1d3629637de1222017dce46c6c8e4b9 _outAmount: approved amount, should be bumped by e^10 _bep2Amount: _outAmount * exchange rate, the default rate is 1 Example of htlt transaction","title":"2. Call HTLT function From Ethereum"},{"location":"atomic-swap.html#3-deputy-call-htlt-on-genesys-chain","text":"Then, Deputy will send HTLT transaction here","title":"3. Deputy Call HTLT on Genesys Chain"},{"location":"atomic-swap.html#4-claim-htlt-on-genesys-chain","text":"Get the swapID on Genesys Chain ./eth-cli token query-swapIDs-by-recipient --recipient-addr tbnb1cs0j4p0p6d3fvd77zg3qzlwwgmrv3e9e63423w --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 [ \"12aacc3bdc2cef97e8e45cc9b409796df57904a4e9c76863ad8420ff75f13128\" ] You can also get swapID by calculateSwapID in javascript-sdk . It requires three parameters: Name Type Description Example randomNumberHash string randomNumberHash in client HTLT transaction on Ethereum 5a3728a8f4ecb8b4cb0b983a9441b7d69f95229c4aa531e6e3827d7c19beac82 sender string deputy bep2 address tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr senderOtherChain string client ethereum address 0x133d144f52705ceb3f5801b63b9ebccf4102f5ed Query the swap by swapID { \"from\": \"tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr\", \"to\": \"tbnb1cs0j4p0p6d3fvd77zg3qzlwwgmrv3e9e63423w\", \"out_amount\": [ { \"denom\": \"PPC-00A\", \"amount\": \"9999999000\" } ], \"in_amount\": null, \"expected_income\": \"\", \"recipient_other_chain\": \"0x1C002969Fe201975eD8F054916b071672326858e\", \"random_number_hash\": \"5a3728a8f4ecb8b4cb0b983a9441b7d69f95229c4aa531e6e3827d7c19beac82\", \"random_number\": \"\", \"timestamp\": \"1569497984\", \"cross_chain\": true, \"expire_height\": \"41380567\", \"index\": \"1947\", \"closed_time\": \"\", \"status\": \"Open\" } Verify parameters in the swap: random_number_hash must equal to the randomNumberHash in client HTLT transaction on ethereum to must equals to client wallet address timestamp must equal to the timestamp in client HTLT transaction on ethereum out_amount should be reasonable. Please note that the decimals of bep2 tokens is 8, the out_amount should be something around 10000000000:PPC, deputy will deduct some fees. expire_height must not be passed and should be enough for send claim transaction Send claim transaction on Genesys Chain ./eth-cli token claim --swap-id 12aacc3bdc2cef97e8e45cc9b409796df57904a4e9c76863ad8420ff75f13128 --random-number <random-number> --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Example of claim tx on testnet","title":"4. Claim HTLT on Genesys Chain"},{"location":"atomic-swap.html#5-deputy-claim-erc20-token","text":"Deputy will claim ERC20 tokens afterwards with claim transaction","title":"5. Deputy Claim ERC20 Token"},{"location":"atomic-swap.html#6-demo-for-client-app-swap-erc20-to-bep2","text":"This is a javascript implementation for client app to swap PPC to PPC-00A with deputy. const erc20ContractAddr = \"0xd93395b2771914e1679155f3ea58c41d89d96098\" const swapContractAddr = \"0x12DCBf79BE178479870A473A99d91f535ed960AD\" const deputyEthWalletAddr = \"0x1C002969Fe201975eD8F054916b071672326858e\" const deputyGSYSWalletAddr = \"tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr\" const clientEthWalletAddr = \"0xfA5E36a04EeF3152092099F352DDbe88953bB540\" const clientEthWalletKey = new Buffer ( \"89A0F0E0732ACAA7AD37C9E6D7A9798ECCE6940C63FF0290A58B1C1C1697486A\" , \"hex\" ) const clientBnbWalletAddr = \"tbnb17vwyu8npjj5pywh3keq2lm7d4v76n434pwd8av\" const clientBnbWalletMnemonic = \"lawsuit margin siege phrase fabric matrix like picnic day thrive correct velvet stool type broom upon flee fee ten senior install wrestle soap sick\" const web3 = new Web3 ( new Web3 . providers . HttpProvider ( \"https://ropsten.infura.io/v3/1c5b38a27f92410cb5feb13b6efb2e14\" )) const bnbClient = new BncClient ( \"https://testnet-dex.genesys.network\" ) await bnbClient . initChain () bnbClient . setPrivateKey ( crypto . getPrivateKeyFromMnemonic ( clientBnbWalletMnemonic )) bnbClient . useDefaultSigningDelegate () bnbClient . useDefaultBroadcastDelegate () const bnbRPC = new rpcClient ( \"https://seed-pre-s3.genesys.network\" , \"testnet\" ) const erc20Contract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"name\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"approve\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_evilUser\" , \"type\" : \"address\" }], \"name\" : \"addBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"totalSupply\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_from\" , \"type\" : \"address\" },{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transferFrom\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"decimals\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_addedValue\" , \"type\" : \"uint256\" }], \"name\" : \"increaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"unpause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"isPauser\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_maker\" , \"type\" : \"address\" }], \"name\" : \"getBlackListStatus\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"paused\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renouncePauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"who\" , \"type\" : \"address\" }], \"name\" : \"balanceOf\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renounceOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"addPauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"pause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"owner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"isOwner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"symbol\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_subtractedValue\" , \"type\" : \"uint256\" }], \"name\" : \"decreaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transfer\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"issue\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"redeem\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_owner\" , \"type\" : \"address\" },{ \"name\" : \"_spender\" , \"type\" : \"address\" }], \"name\" : \"allowance\" , \"outputs\" : [{ \"name\" : \"remaining\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"name\" : \"isBlackListed\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_clearedUser\" , \"type\" : \"address\" }], \"name\" : \"removeBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"transferOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_blackListedUser\" , \"type\" : \"address\" }], \"name\" : \"destroyBlackFunds\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_initialSupply\" , \"type\" : \"uint256\" },{ \"name\" : \"_name\" , \"type\" : \"string\" },{ \"name\" : \"_symbol\" , \"type\" : \"string\" },{ \"name\" : \"_decimals\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Issue\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Redeem\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_blackListedUser\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"_balance\" , \"type\" : \"uint256\" }], \"name\" : \"DestroyedBlackFunds\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"AddedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"RemovedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Paused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Unpaused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"from\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"to\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Transfer\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"owner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"spender\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Approval\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"previousOwner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"OwnershipTransferred\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserAdded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserRemoved\" , \"type\" : \"event\" }], erc20ContractAddr ) const swapContract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"ERC20ContractAddr\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"isSwapExist\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refund\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_swapSender\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" }], \"name\" : \"calSwapID\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bytes32\" }], \"payable\" : false , \"stateMutability\" : \"pure\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"claim\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_heightSpan\" , \"type\" : \"uint256\" },{ \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_bep2RecipientAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"htlt\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"claimable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refundable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"queryOpenSwap\" , \"outputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_sender\" , \"type\" : \"address\" },{ \"name\" : \"_recipient\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_erc20Contract\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"indexed\" : false , \"name\" : \"_bep2Addr\" , \"type\" : \"bytes20\" },{ \"indexed\" : false , \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"HTLT\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" }], \"name\" : \"Refunded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"Claimed\" , \"type\" : \"event\" }], swapContractAddr ) //-------------------------------------------- //Step1 approve erc20 to swap contract address //-------------------------------------------- const approveData = erc20Contract . methods . increaseAllowance ( swapContractAddr , 10000000000 ). encodeABI () let nonce = await web3 . eth . getTransactionCount ( clientEthWalletAddr , 'pending' ) let gasPrice = await web3 . eth . getGasPrice () let gasLimit = 3000000 let rawTx = { nonce : web3 . utils . toHex ( nonce ), gasPrice : web3 . utils . toHex ( gasPrice ), gasLimit : web3 . utils . toHex ( gasLimit ), to : erc20ContractAddr , value : '0x00' , data : approveData } var ethereumjs = require ( 'ethereumjs-tx' ) var signTx = new ethereumjs ( rawTx ) signTx . sign ( clientEthWalletKey ) var serializedTx = signTx . serialize (); web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' )). on ( 'receipt' , console . log ) await wait ( 20000 ) //---------------------------------------------------------------------------- //Step2 call swap contract to send htlt transaction on Ethereum //---------------------------------------------------------------------------- const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" const timestamp = Math . floor ( Date . now () / 1000 ) const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ). toString ( \"hex\" ) const heightSpan = 1000 const hexEncodingClientGSYSaddr = '0x' + crypto . decodeAddress ( clientBnbWalletAddr ). toString ( \"hex\" ) const amount = 10000000000 // 10000000000:PPC\uff0c decimal is 10 const expectedIncome = 99999000 //\"99999000:PPC-00A\", decimal is 8, deputy will deduct swap fee, the swap fee is 1000:PPC-00A const htltData = swapContract . methods . htlt ( \"0x\" + randomNumberHash , timestamp , heightSpan , deputyEthWalletAddr , \"0x0\" , hexEncodingClientGSYSaddr , amount , expectedIncome ). encodeABI () nonce = await web3 . eth . getTransactionCount ( clientEthWalletAddr , 'pending' ) gasPrice = await web3 . eth . getGasPrice () gasLimit = 3000000 rawTx = { nonce : web3 . utils . toHex ( nonce ), gasPrice : web3 . utils . toHex ( gasPrice ), gasLimit : web3 . utils . toHex ( gasLimit ), to : swapContractAddr , value : '0x00' , data : htltData } ethereumjs = require ( 'ethereumjs-tx' ) signTx = new ethereumjs ( rawTx ) signTx . sign ( clientEthWalletKey ) serializedTx = signTx . serialize (); web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' )). on ( 'receipt' , console . log ) await wait ( 20000 ) //---------------------------------------------------------------------------- //Step3 query swap created by deputy on Genesys Chain and verify swap parameters //---------------------------------------------------------------------------- const swapID = calculateSwapID ( randomNumberHash . replace ( \"0x\" , \"\" ), deputyGSYSWalletAddr , clientEthWalletAddr ). toString () console . log ( swapID ) let atomicSwapList = await bnbClient . getSwapByRecipient ( clientBnbWalletAddr , 1000 , 0 ) while ( atomicSwapList . result . atomicSwaps [ 0 ]. swapId != swapID ) { console . log ( \"Waiting for the atomic swap created by deputy\" ) await wait ( 5000 ) atomicSwapList = await bnbClient . getSwapByRecipient ( clientBnbWalletAddr , 1000 , 0 ) } const atomicSwap = await bnbClient . getSwapByID ( swapID ) console . log ( atomicSwap ) const status = await bnbRPC . status () expect ( atomicSwap . result . toAddr ). toBe ( clientBnbWalletAddr ) expect ( atomicSwap . result . randomNumberHash ). toBe ( randomNumberHash . replace ( \"0x\" , \"\" )) expect ( atomicSwap . result . timestamp ). toBe ( timestamp ) expect ( atomicSwap . result . outAmount ). toBe ( \"99999000:PPC-00A\" ) expect ( Number ( atomicSwap . result . expireHeight )). toBeGreaterThan ( Number ( status . sync_info . latest_block_height ) + 100 ) //---------------------------------------------------------------------------- //Step4 claim on Genesys Chain //---------------------------------------------------------------------------- const res = await bnbClient . swap . claimHTLT ( clientBnbWalletAddr , swapID , randomNumber ) console . log ( res ) //---------------------------------------------------------------------------- //If step3 or step4 are failed and the expire height on Ethereum is passed, try to call refund method on Ethereum //----------------------------------------------------------------------------","title":"6. Demo for Client APP: swap erc20 to bep2"},{"location":"atomic-swap.html#swap-tokens-from-genesys-chain-to-ethereum","text":"","title":"Swap Tokens from Genesys Chain to Ethereum"},{"location":"atomic-swap.html#1-send-htlt-transaction-from-genesys-chain","text":"Please read this section to generate a valid HTLT transaction. Please write down the randomNumber and randomNumberHash . ./eth-cli token HTLT --from atomic --recipient-addr tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr --chain-id GSYS-Chain-Ganges --height-span 10000 --amount 9900000000:PPC-00A --expected-income 9900000000:PPC --recipient-other-chain 0x133D144F52705cEb3f5801B63b9EBcCF4102f5Ed --cross-chain --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Random number: 4811959406ea3e69721d944d308880ec41323b7f89e51a78df3693348779315e Timestamp: 1569578936 Random number hash: b03f256c9efdb97b9815faa1417e1da4cca7672e0bb26e4e7d9bfc82d0f1f15e Committed at block 634510 ( tx hash: 9DEF124E12DE123BA1CC75AA6E68F20CC48EBBE9D7693CE4D0416267C6C0F159, response: { Code:0 Data:[229 50 241 60 76 91 112 146 93 68 100 222 83 84 180 133 181 151 241 174 93 125 132 82 245 198 5 66 0 123 32 113] Log:Msg 0: swapID: f85dd907df0a5897927b949c0f9e2563d453ba698ff9941fed1ce91f8057afc2 ... ) Note: the swap amount must be positive. Please write down the random number , random number hash , swapID and timestamp for next steps. Example is here Then, you can query the the swap by SwapID : ./eth-cli token query-swap --swap-id f85dd907df0a5897927b949c0f9e2563d453ba698ff9941fed1ce91f8057afc2 --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 You can use this swapID for refund if the deputy doesn't send htlt transaction on ethereum with proper parameters.","title":"1. Send HTLT Transaction from Genesys Chain"},{"location":"atomic-swap.html#2-deputy-approve-tokens","text":"You should see that Deputy has approve enough amount of tokens for atomic swap.","title":"2.  Deputy Approve Tokens"},{"location":"atomic-swap.html#3-deputy-send-htlt-on-ethereum","text":"You should see that Deputy has sent the htlt transaction afterwards To get the swapID on Ethereum, you can check this page 0xd3bacf63906af5459ead39f27cae189e2f3e76fda34523714a4c61d76c79ee4e is the swapID on Ethereum.","title":"3. Deputy Send HTLT on Ethereum"},{"location":"atomic-swap.html#4-claim-erc20-tokens-on-ethereum","text":"You should see that Deputy has already approved enough tokens and In its event log , you should see the swapID . Before calling claim function on ethereum, clients should verify the parameters in the HTLT event. _randomNumberHash must equal to the randomNumberHash in client HTLT transaction on Genesys Chain _recipientAddr must equal to client ethereum wallet address _timestamp must equal to the timestamp in client HTLT transaction on Genesys Chain _outAmount should be reasonable. Please note that the decimals erc20 contract and deputy will deduct some fees. _expireHeight must not be passed and should be enough for send claim transaction Then, you can call the claim function: Function: claim Parameters: _swapID: this has been obtained from event, you can also calculate it from calSwapID function in the contract. calSwapID(randomNumberHash, {deputy ethereum address}, {hex encoding client shree address}) _randomNumber: reveal your randomNumber Example is here","title":"4. Claim ERC20 Tokens on Ethereum"},{"location":"atomic-swap.html#5-deputy-claim-on-genesys-chain","text":"Claim HTLT transaction from Deputy is sent afterwards:","title":"5. Deputy Claim on Genesys Chain"},{"location":"atomic-swap.html#6-demo-for-client-app-swap-bep2-to-erc20","text":"This is a javascript implementation of client app to swap PPC-00A to PPC with deputy. const erc20ContractAddr = \"0xd93395b2771914e1679155f3ea58c41d89d96098\" const swapContractAddr = \"0x12DCBf79BE178479870A473A99d91f535ed960AD\" const deputyEthWalletAddr = \"0x1C002969Fe201975eD8F054916b071672326858e\" const deputyGSYSWalletAddr = \"tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr\" const clientEthWalletAddr = \"0xfA5E36a04EeF3152092099F352DDbe88953bB540\" const clientEthWalletKey = new Buffer ( \"89A0F0E0732ACAA7AD37C9E6D7A9798ECCE6940C63FF0290A58B1C1C1697486A\" , \"hex\" ) const clientBnbWalletAddr = \"tbnb17vwyu8npjj5pywh3keq2lm7d4v76n434pwd8av\" const clientBnbWalletMnemonic = \"lawsuit margin siege phrase fabric matrix like picnic day thrive correct velvet stool type broom upon flee fee ten senior install wrestle soap sick\" const web3 = new Web3 ( new Web3 . providers . HttpProvider ( \"https://ropsten.infura.io/v3/1c5b38a27f92410cb5feb13b6efb2e14\" )) const bnbClient = new BncClient ( \"https://testnet-dex.genesys.network\" ) await bnbClient . initChain () bnbClient . setPrivateKey ( crypto . getPrivateKeyFromMnemonic ( clientBnbWalletMnemonic )) bnbClient . useDefaultSigningDelegate () bnbClient . useDefaultBroadcastDelegate () const bnbRPC = new rpcClient ( \"https://seed-pre-s3.genesys.network\" , \"testnet\" ) const erc20Contract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"name\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"approve\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_evilUser\" , \"type\" : \"address\" }], \"name\" : \"addBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"totalSupply\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_from\" , \"type\" : \"address\" },{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transferFrom\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"decimals\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_addedValue\" , \"type\" : \"uint256\" }], \"name\" : \"increaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"unpause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"isPauser\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_maker\" , \"type\" : \"address\" }], \"name\" : \"getBlackListStatus\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"paused\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renouncePauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"who\" , \"type\" : \"address\" }], \"name\" : \"balanceOf\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renounceOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"addPauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"pause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"owner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"isOwner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"symbol\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_subtractedValue\" , \"type\" : \"uint256\" }], \"name\" : \"decreaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transfer\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"issue\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"redeem\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_owner\" , \"type\" : \"address\" },{ \"name\" : \"_spender\" , \"type\" : \"address\" }], \"name\" : \"allowance\" , \"outputs\" : [{ \"name\" : \"remaining\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"name\" : \"isBlackListed\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_clearedUser\" , \"type\" : \"address\" }], \"name\" : \"removeBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"transferOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_blackListedUser\" , \"type\" : \"address\" }], \"name\" : \"destroyBlackFunds\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_initialSupply\" , \"type\" : \"uint256\" },{ \"name\" : \"_name\" , \"type\" : \"string\" },{ \"name\" : \"_symbol\" , \"type\" : \"string\" },{ \"name\" : \"_decimals\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Issue\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Redeem\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_blackListedUser\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"_balance\" , \"type\" : \"uint256\" }], \"name\" : \"DestroyedBlackFunds\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"AddedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"RemovedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Paused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Unpaused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"from\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"to\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Transfer\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"owner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"spender\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Approval\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"previousOwner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"OwnershipTransferred\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserAdded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserRemoved\" , \"type\" : \"event\" }], erc20ContractAddr ) const swapContract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"ERC20ContractAddr\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"isSwapExist\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refund\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_swapSender\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" }], \"name\" : \"calSwapID\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bytes32\" }], \"payable\" : false , \"stateMutability\" : \"pure\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"claim\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_heightSpan\" , \"type\" : \"uint256\" },{ \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_bep2RecipientAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"htlt\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"claimable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refundable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"queryOpenSwap\" , \"outputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_sender\" , \"type\" : \"address\" },{ \"name\" : \"_recipient\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_erc20Contract\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"indexed\" : false , \"name\" : \"_bep2Addr\" , \"type\" : \"bytes20\" },{ \"indexed\" : false , \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"HTLT\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" }], \"name\" : \"Refunded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"Claimed\" , \"type\" : \"event\" }], swapContractAddr ) //-------------------------------------------- //Step1 send htlt on Genesys Chain //-------------------------------------------- const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" const timestamp = Math . floor ( Date . now () / 1000 ) const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ). toString ( \"hex\" ) const heightSpan = 10000 const amount = [{ denom : \"PPC-00A\" , amount : 100000000 }] const expectedIncome = \"9999990000:PPC\" //\"9999990000:PPC\", decimal is 10, deputy will deduct swap fee, the swap fee is 10000:PPC bnbClient . swap . HTLT ( clientBnbWalletAddr , deputyGSYSWalletAddr , clientEthWalletAddr , \"\" , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , true ) await wait ( 1000 ) //---------------------------------------------------------------------------- //Step2 query swap created by deputy on Ethereum and verify swap parameters //---------------------------------------------------------------------------- const hexEncodingClientGSYSaddr = '0x' + crypto . decodeAddress ( clientBnbWalletAddr ). toString ( \"hex\" ) const swapID = await swapContract . methods . calSwapID ( \"0x\" + randomNumberHash , deputyEthWalletAddr , hexEncodingClientGSYSaddr ). call () console . log ( swapID ) let openSwap = await swapContract . methods . queryOpenSwap ( swapID ). call () while ( openSwap . _randomNumberHash == '0x0000000000000000000000000000000000000000000000000000000000000000' ) { console . log ( \"Waiting for the atomic swap created by deputy\" ) await wait ( 5000 ) openSwap = await swapContract . methods . queryOpenSwap ( swapID ). call () } let ethBlock = await web3 . eth . getBlock ( 'latest' ) let ethLatestHeight = ethBlock . number expect ( openSwap . _randomNumberHash ). toBe ( \"0x\" + randomNumberHash ) expect ( Number ( openSwap . _timestamp )). toBe ( timestamp ) expect ( Number ( openSwap . _outAmount )). toBe ( 9999990000 ) expect ( openSwap . _recipient ). toBe ( clientEthWalletAddr ) expect ( Number ( openSwap . _expireHeight )). toBeGreaterThan ( Number ( ethLatestHeight ) + 20 ) //---------------------------------------------------------------------------- //Step3 claim on Ethereum //---------------------------------------------------------------------------- const claimData = swapContract . methods . claim ( swapID , \"0x\" + randomNumber ). encodeABI () let nonce = await web3 . eth . getTransactionCount ( clientEthWalletAddr , 'pending' ) let gasPrice = await web3 . eth . getGasPrice () let gasLimit = 3000000 let rawTx = { nonce : web3 . utils . toHex ( nonce ), gasPrice : web3 . utils . toHex ( gasPrice ), gasLimit : web3 . utils . toHex ( gasLimit ), to : swapContractAddr , value : '0x00' , data : claimData } var ethereumjs = require ( 'ethereumjs-tx' ) var signTx = new ethereumjs ( rawTx ) signTx . sign ( clientEthWalletKey ) var serializedTx = signTx . serialize (); web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' )). on ( 'receipt' , console . log ) await wait ( 20000 ) //---------------------------------------------------------------------------- //If step2 or step3 are failed and the expire height on Genesys Chain is passed, try to send refundHTLT transaction on Genesys Chain //----------------------------------------------------------------------------","title":"6. Demo for Client APP: swap bep2 to erc20"},{"location":"atomic-swap.html#swap-between-several-bep2-tokens","text":"","title":"Swap between Several BEP2 tokens"},{"location":"atomic-swap.html#swap-between-several-bep2-tokens-fails","text":"","title":"Swap between Several BEP2 tokens fails"},{"location":"blockchain.html","text":"The Genesys Chain Blockchain The purpose of the new blockchain and DEX is to create an alternative marketplace for issuing and exchanging digital assets in a decentralized manner. Consensus Details Genesys Chain is a peer-to-peer distributed system, connecting together multiple clients that reach consensus on their views of the \"state of the world\". Genesys Chain uses Tendermint BFT consensus and has a dedicated application layer that runs upon it. A simplified overview of the application's architecture might look something like this: +------------+-----------+ | RPC API | Web API | +------------------------+---------+ | Asset Management | Match Engine | +----------------------------------+ | Account Management | Governance |---------> crypto and blockchain governance +----------------------------------+ | State Caching and Persisence +-+ +----------------------------------+ | | Consensus Protocol | | +----------------------------------+ |-----> revised Tendermint | P2P Protocol | | +----------------------------------+ | | Networking | Database +-+ +----------------------------------+ For more information, please have a look at the Tendermint spec . Node Roles What is a Validator Node? Validators are a group/IT infrastructure that take the responsibility to maintain the GSYS Chain/DEX data and validate all the transactions. They join the consensus procedure and vote to produce blocks. The fees are collected and distributed among all validators. You can consider Validator as \"miner\" in Bitcoin and Ethereum and similar concepts exist in dPoS blockchain as EOS or dBFT in NEO. The initial validators are selected from trusted members of the GSYS community, and will eventually expand to more members as the GSYS blockchain and ecosystem matures, this responsibility will be distributed. The decentralized governance procedure will be introduced and executed. More qualified organization/individual can become Validators. What is a Witness Node? Witness nodes represent the majority of nodes in a Genesys Chain deployment. Although they do not join the consensus process and produce blocks, they take care of: The witness consensus process. They serve as data replicas and help to propagate the chain state around the network. They receive transactions and broadcast them to all other nodes including Validator nodes. What is an Accelerated Node? Please check here . For testnet, there are 2 accelerated nodes setup as below. API users should try to use them directly. testnet-dex-atlantic.genesys.network testnet-dex-asiapacific.genesys.network For mainnet, there are more accelerated nodes. dex-atlantic.genesys.network dex-asiapacific.genesys.network dex-european.genesys.network Blocking Genesys Chain uses a similar block structure as Tendermint proposes, with a size limit of 1 megabyte. It is expected a block will be produced on a-few-of-seconds level among validators, and can include from 0 up to several thousands of transactions. Blockchain State Blockchain state stores the below information: account and balances fees token information trading pairs tick size and lot size governance information please note the transactions are not stored as chain state, because they are stored in blocks, while trades are not stored as state either, because they can be reproduced via balances and transactions. Cryptographic Design Account and Address For normal users, all the keys and addresses can be generated via GSYS Web Wallet . This default wallet would use a similar way to generate keys as Bitcoin, i.e. use 256 bits entropy to generate a 24-word mnemonic based on BIP39 , and then use the mnemonic and an empty passphrase to generate a seed; finally use the seed to generate a master key, and derive the private key using BIP32/BIP44 with HD prefix as \"44'/714'/\" , which is reserved at SLIP 44 . 714 comes from GSYS's birthday, July 14th. :) Keys Genesys Chain uses the same elliptic curve cryptography as the current Bitcoin implementation , i.e. secp256k1 . Its private key is 32 bytes while public key is 33 bytes. Address Addresses on Genesys Chain are 20 bytes and may be expressed as: Address = RIPEMD160(SHA256(compressed public key)) Typically, an address is encoded in the bech32 format which includes a checksum and human-readable prefix (HRP). However, it doesn't use the SegWit address format (because we do not have SegWit function anyway, so no witness program version etc.). A Genesys Chain address is therefore more similar to a Bitcoin Cash address , which does not include a SegWit program script. Address format pseudo-code: Address_Bech32 = HRP + '1' + bech32.encode(convert8BitsTo5Bits(RIPEMD160(SHA256(compressed public key)))) For Genesys Chain address, the prefix is bnb for production network, and tbnb for testnet. Signature Genesys Chain uses an ECDSA signature on curve secp256k1 against a SHA256 hash of the byte array of a JSON-encoded canonical representation of the transaction. For more information, please see this page .","title":"The Genesys Chain Blockchain"},{"location":"blockchain.html#the-genesys-chain-blockchain","text":"The purpose of the new blockchain and DEX is to create an alternative marketplace for issuing and exchanging digital assets in a decentralized manner.","title":"The Genesys Chain Blockchain"},{"location":"blockchain.html#consensus-details","text":"Genesys Chain is a peer-to-peer distributed system, connecting together multiple clients that reach consensus on their views of the \"state of the world\". Genesys Chain uses Tendermint BFT consensus and has a dedicated application layer that runs upon it. A simplified overview of the application's architecture might look something like this: +------------+-----------+ | RPC API | Web API | +------------------------+---------+ | Asset Management | Match Engine | +----------------------------------+ | Account Management | Governance |---------> crypto and blockchain governance +----------------------------------+ | State Caching and Persisence +-+ +----------------------------------+ | | Consensus Protocol | | +----------------------------------+ |-----> revised Tendermint | P2P Protocol | | +----------------------------------+ | | Networking | Database +-+ +----------------------------------+ For more information, please have a look at the Tendermint spec .","title":"Consensus Details"},{"location":"blockchain.html#node-roles","text":"","title":"Node Roles"},{"location":"blockchain.html#what-is-a-validator-node","text":"Validators are a group/IT infrastructure that take the responsibility to maintain the GSYS Chain/DEX data and validate all the transactions. They join the consensus procedure and vote to produce blocks. The fees are collected and distributed among all validators. You can consider Validator as \"miner\" in Bitcoin and Ethereum and similar concepts exist in dPoS blockchain as EOS or dBFT in NEO. The initial validators are selected from trusted members of the GSYS community, and will eventually expand to more members as the GSYS blockchain and ecosystem matures, this responsibility will be distributed. The decentralized governance procedure will be introduced and executed. More qualified organization/individual can become Validators.","title":"What is a Validator Node?"},{"location":"blockchain.html#what-is-a-witness-node","text":"Witness nodes represent the majority of nodes in a Genesys Chain deployment. Although they do not join the consensus process and produce blocks, they take care of: The witness consensus process. They serve as data replicas and help to propagate the chain state around the network. They receive transactions and broadcast them to all other nodes including Validator nodes.","title":"What is a Witness Node?"},{"location":"blockchain.html#what-is-an-accelerated-node","text":"Please check here . For testnet, there are 2 accelerated nodes setup as below. API users should try to use them directly. testnet-dex-atlantic.genesys.network testnet-dex-asiapacific.genesys.network For mainnet, there are more accelerated nodes. dex-atlantic.genesys.network dex-asiapacific.genesys.network dex-european.genesys.network","title":"What is an Accelerated Node?"},{"location":"blockchain.html#blocking","text":"Genesys Chain uses a similar block structure as Tendermint proposes, with a size limit of 1 megabyte. It is expected a block will be produced on a-few-of-seconds level among validators, and can include from 0 up to several thousands of transactions.","title":"Blocking"},{"location":"blockchain.html#blockchain-state","text":"Blockchain state stores the below information: account and balances fees token information trading pairs tick size and lot size governance information please note the transactions are not stored as chain state, because they are stored in blocks, while trades are not stored as state either, because they can be reproduced via balances and transactions.","title":"Blockchain State"},{"location":"blockchain.html#cryptographic-design","text":"","title":"Cryptographic Design"},{"location":"blockchain.html#account-and-address","text":"For normal users, all the keys and addresses can be generated via GSYS Web Wallet . This default wallet would use a similar way to generate keys as Bitcoin, i.e. use 256 bits entropy to generate a 24-word mnemonic based on BIP39 , and then use the mnemonic and an empty passphrase to generate a seed; finally use the seed to generate a master key, and derive the private key using BIP32/BIP44 with HD prefix as \"44'/714'/\" , which is reserved at SLIP 44 . 714 comes from GSYS's birthday, July 14th. :)","title":"Account and Address"},{"location":"blockchain.html#keys","text":"Genesys Chain uses the same elliptic curve cryptography as the current Bitcoin implementation , i.e. secp256k1 . Its private key is 32 bytes while public key is 33 bytes.","title":"Keys"},{"location":"blockchain.html#address","text":"Addresses on Genesys Chain are 20 bytes and may be expressed as: Address = RIPEMD160(SHA256(compressed public key)) Typically, an address is encoded in the bech32 format which includes a checksum and human-readable prefix (HRP). However, it doesn't use the SegWit address format (because we do not have SegWit function anyway, so no witness program version etc.). A Genesys Chain address is therefore more similar to a Bitcoin Cash address , which does not include a SegWit program script. Address format pseudo-code: Address_Bech32 = HRP + '1' + bech32.encode(convert8BitsTo5Bits(RIPEMD160(SHA256(compressed public key)))) For Genesys Chain address, the prefix is bnb for production network, and tbnb for testnet.","title":"Address"},{"location":"blockchain.html#signature","text":"Genesys Chain uses an ECDSA signature on curve secp256k1 against a SHA256 hash of the byte array of a JSON-encoded canonical representation of the transaction. For more information, please see this page .","title":"Signature"},{"location":"changelog.html","text":"CHANGELOG Upcoming Changes in Genesys Chain Mainnet API - 2021-06-04 HTTP API /api/v1/transactions Changes The following changes will take effect. address related Mutli Send Transfer transaction history will also be included; If this address is the receiver of any HTL_TRANSFER , the related transactions history will also be included asset parameter can be used to search for quote asset of NEW_ORDER, CANCEL_ORDER,MINI_TOKEN_LIST,LISTING transactions asset parameter can be used to search for quote asset or base asset of dex listing SUBMIT_PROPOSAL transactions DEPOSIT_HTL HTL_TRANSFER, SIDE_DEPOSIT, TIME_LOCK, TIME_RELOCK, TRANSFER can relate to multiple assets, you can search by any of them. Upcoming Changes in Genesys Chain Mainnet API v0.7.2 Node RPC Extra paths are available for querying information about BEP8 tokens and trading pairs. New Query Path /mini-tokens/info /mini-tokens/list /dex-mini/pairs HTTP API /api/v1/depth Changes Add pending_match flag in response to indicate that current block has not run matching process for the new orders incoming in this block. In detail, if there are new orders created in current block, but the matching process has not run for the block, then pending_math=true. As a result, there could be orders with cross prices - price of ask is lower than price of bid. Client can ignore the response with pending_match=true and query the depth API until pending_match=false. GET Summary: Get the order book. Description: Gets the order book depth data for a given pair symbol. The given limit must be one of the allowed limits below. Destination: Validator node. Rate Limit: 10 requests per IP per second. URL for testnet: https://dex.genesys.network/api/v1/depth?symbol=xxx-000_GSYS Parameters Name Located in Description Required Schema symbol query Market pair symbol, e.g. NNB-0AD_GSYS Yes string limit query The limit of results. Allowed limits: [5, 10, 20, 50, 100, 500, 1000] No integer Responses MarketDepth Name Type Description Example asks [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] bids [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] pending_match boolean If new orders inserted in current block and the matching process has not started in the block, return true. MarketDepth Name Type Description Example asks [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] bids [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] pending_match boolean If new orders inserted in current block and the matching process has not started in the block, return true. /api/v1/mini/tokens Changes Gets a list of available mini tokens. MiniTokens Name Type Description Example name string Genesys Chain Mini Token symbol string BTC-000 original_symbol string BTC total_supply string (fixed8) In decimal form, e.g. 1.00000000 0.00000000 token_type integer Type of the mini token owner string (address) Address mintable boolean mintable token_uri string URI for token description /api/v1/mini/markets: Changes Gets a list of available mini tokens trading pairs. Market Name Type Description Example base_asset_symbol string (currency) symbol of base asset GSYS quote_asset_symbol string (currency) symbol of quote asset ABC-5CA list_price string (fixed8) In decimal form 1.00000000 tick_size string (fixed8) Minimium price change in decimal form 0.00000001 lot_size string (fixed8) Minimium trading quantity in decimal form 1.00000000 /api/v1/mini/kline Changes Get mini-token candlestick bars. Interval allowed value: [1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M] Candlestick Name Type Description Example close number closing price closeTime long time of closing trade high number the highest price low number the lowest price numberOfTrades integer total trades open number open price openTime long time of open trade quoteAssetVolume number the total trading volume in quote asset volume number the total trading volume /api/v1/mini/orders/closed Changes Get closed orders of mini-token pairs. OrderList Name Type Description Example order [ Order ] list of orders total long /api/v1/mini/orders/open Changes Get open orders of mini-token pairs. OrderList Name Type Description Example order [ Order ] list of orders total long /api/v1/mini/ticker/24hr Changes Get a market ticker of mini-token pairs. TickerStatistics Name Type Description Example askPrice string sell price askQuantity string sell quantity bidPrice string buy price bidQuantity string buy quantity closeTime long time of closing count long total trade count firstId string ID of first trade highPrice string highest price lastId string ID of last trade lastPrice string last price lastQuantity string last quantity lowPrice string lowest price openPrice string open price openTime long open time prevClosePrice string last close price priceChange string change of price priceChangePercent string change of price in percentage quoteVolume string trading volume in quote asset symbol string trading symbol volume string trading volume weightedAvgPrice string weighted average price /api/v1/mini/trades Changes Get market trades of mini-token pairs. TradePage Name Type Description Example total long total number of trades trade [ Trade ] Upcoming Changes in Genesys Chain Testnet API v0.7.0 Node RPC Extra paths are available for querying information about BEP8 tokens and trading pairs. New Query Path /mini-tokens/info /mini-tokens/list /dex-mini/pairs HTTP API /api/v1/depth Changes Add pending_match flag in response to indicate that current block has not run matching process for the new orders incoming in this block. In detail, if there are new orders created in current block, but the matching process has not run for the block, then pending_math=true. As a result, there could be orders with cross prices - price of ask is lower than price of bid. Client can ignore the response with pending_match=true and query the depth API until pending_match=false. GET Summary: Get the order book. Description: Gets the order book depth data for a given pair symbol. The given limit must be one of the allowed limits below. Destination: Validator node. Rate Limit: 10 requests per IP per second. URL for testnet: https://testnet-dex.genesys.network/api/v1/depth?symbol=xxx-000_GSYS Parameters Name Located in Description Required Schema symbol query Market pair symbol, e.g. NNB-0AD_GSYS Yes string limit query The limit of results. Allowed limits: [5, 10, 20, 50, 100, 500, 1000] No integer Responses MarketDepth Name Type Description Example asks [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] bids [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] pending_match boolean If new orders inserted in current block and the matching process has not started in the block, return true. MarketDepth Name Type Description Example asks [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] bids [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] pending_match boolean If new orders inserted in current block and the matching process has not started in the block, return true. /api/v1/mini/tokens Changes Gets a list of available mini tokens. MiniTokens Name Type Description Example name string Genesys Chain Mini Token symbol string BTC-000 original_symbol string BTC total_supply string (fixed8) In decimal form, e.g. 1.00000000 0.00000000 token_type integer Type of the mini token owner string (address) Address mintable boolean mintable token_uri string URI for token description /api/v1/mini/markets: Changes Gets a list of available mini tokens trading pairs. Market Name Type Description Example base_asset_symbol string (currency) symbol of base asset GSYS quote_asset_symbol string (currency) symbol of quote asset ABC-5CA list_price string (fixed8) In decimal form 1.00000000 tick_size string (fixed8) Minimium price change in decimal form 0.00000001 lot_size string (fixed8) Minimium trading quantity in decimal form 1.00000000 /api/v1/mini/kline Changes Get mini-token candlestick bars. Interval allowed value: [1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M] Candlestick Name Type Description Example close number closing price closeTime long time of closing trade high number the highest price low number the lowest price numberOfTrades integer total trades open number open price openTime long time of open trade quoteAssetVolume number the total trading volume in quote asset volume number the total trading volume /api/v1/mini/orders/closed Changes Get closed orders of mini-token pairs. OrderList Name Type Description Example order [ Order ] list of orders total long /api/v1/mini/orders/open Changes Get open orders of mini-token pairs. OrderList Name Type Description Example order [ Order ] list of orders total long /api/v1/mini/ticker/24hr Changes Get a market ticker of mini-token pairs. TickerStatistics Name Type Description Example askPrice string sell price askQuantity string sell quantity bidPrice string buy price bidQuantity string buy quantity closeTime long time of closing count long total trade count firstId string ID of first trade highPrice string highest price lastId string ID of last trade lastPrice string last price lastQuantity string last quantity lowPrice string lowest price openPrice string open price openTime long open time prevClosePrice string last close price priceChange string change of price priceChangePercent string change of price in percentage quoteVolume string trading volume in quote asset symbol string trading symbol volume string trading volume weightedAvgPrice string weighted average price /api/v1/mini/trades Changes Get market trades of mini-token pairs. TradePage Name Type Description Example total long total number of trades trade [ Trade ] Upcoming Changes in Genesys Chain API v0.6.4 HTTP API Add Error Message for Newly Created Address You will get {\"code\":404,\"message\":\"account not found\"} for newly created account: Example https://testnet-dex-asiapacific.genesys.network/api/v1/account/tbnb10qpmrlsr4mq65xwgjd39xypkkpw3wm9c5e58xm Return: { code: 404, message: \"account not found\" } /api/v1/trades Changes Add buyerSource and sellerSource in the response Trade data structure. The Source Id reference can be found inhttps://github.com/githubusername/githubrepo/BEPs/blob/master/BEP10.md. Trade Name Type Description Example baseAsset string base asset symbol blockHeight long block height buyFee string trading fee for the buyer address on the block of this trade buyerId string id of buyer buyerOrderId string order id for buyer buySingleFee string trading fee for the buyer address on this single trade GSYS:0.00000172; buyerSource long tx source of buy order 1 price string trade price quantity string trade quantity quoteAsset string quote asset symbol sellFee string trading fee for the seller address on the block of this trade sellerId string seller ID sellerOrderId string seller order ID sellSingleFee string trading fee for the seller address on this single trade GSYS:0.00000216; sellerSource long tx source of sell order 1 symbol string asset symbol tickType string enum [Unknown,SellTaker,BuyTaker,BuySurplus,SellSurplus,Neutral] time long trade time tradeId string trade ID Upcoming Changes in Genesys Chain API v0.6.3 HTTP API /api/v1/atomic-swaps /api/v1/atomic-swaps/{id} Changes The API is used to query atomic-swaps by id or by address. In the AtomicSwap data structure: * A new field blockTimestamp is added to indicate the block time in millisecond * The original timestamp is changed to indicate the timestamp for randomNumberHash calculation. Its unit is second. * createTime and updateTime are removed from AtomicSwap . AtomicSwap Name Type Description Example blockTimestamp long Timestamp of block in which the swap is initiated. The unit is millisecond. closedTime long crossChain integer expectedIncome string expireHeight long fromAddr string inAmount string outAmount string randomNumber string randomNumberHash string recipientOtherChain string status integer swapId string timestamp long The timestamp for randomNumberHash calculation, randomNumberHash=sha256(randomNumber, timestamp). The unit is second. toAddr string WebSocket As described in https://docs.genesys.network/api-reference/dex-api/ws-streams.html#6-book-depth-streams, you can now customize the returned level from orderbook. The default level is 20 and you can extend the level to 100, 500, or 1000 with compression enabled. Example on mainnet: var marketDepth = new WebSocket(\"wss://dex-atlantic.genesys.network/api/ws/NEXO-A84_GSYS@marketDepth100\"); Example on testnet: var marketDepth = new WebSocket(\"wss://testnet-dex.genesys.network/api/ws/ALT-3B6_GSYS@marketDepth100\"); Node RPC Due to changes of underling Tendermint library, ResponseCheckTx , ResponseDeliverTx , ResponseBeginBlock , and ResponseEndBlock now include Events instead of Tags . Each Event contains a type and a list of attributes (list of key-value pairs) allowing for inclusion of multiple distinct events in each response. Events Some methods ( CheckTx, BeginBlock, DeliverTx, EndBlock ) include an Events field in their Response* . Each event contains a type and a list of attributes, which are key-value pairs denoting something about what happened during the method's execution. Events can be used to index transactions and blocks according to what happened during their execution. Note that the set of events returned for a block from BeginBlock and EndBlock are merged. In case both methods return the same tag, only the value defined in EndBlock is used. Each event has a type which is meant to categorize the event for a particular Response* or tx. A Response* or tx may contain multiple events with duplicate type values, where each distinct entry is meant to categorize attributes for a particular event. Every key and value in an event's attributes must be UTF-8 encoded strings along with the event type itself. Example: abci . ResponseDeliverTx { // ... Events : [] abci . Event { { Type : \"validator.provisions\" , Attributes : cmn . KVPairs { cmn . KVPair { Key : [] byte ( \"address\" ), Value : [] byte ( \"...\" )}, cmn . KVPair { Key : [] byte ( \"amount\" ), Value : [] byte ( \"...\" )}, cmn . KVPair { Key : [] byte ( \"balance\" ), Value : [] byte ( \"...\" )}, }, }, { Type : \"validator.provisions\" , Attributes : cmn . KVPairs { cmn . KVPair { Key : [] byte ( \"address\" ), Value : [] byte ( \"...\" )}, cmn . KVPair { Key : [] byte ( \"amount\" ), Value : [] byte ( \"...\" )}, cmn . KVPair { Key : [] byte ( \"balance\" ), Value : [] byte ( \"...\" )}, }, }, { Type : \"validator.slashed\" , Attributes : cmn . KVPairs { cmn . KVPair { Key : [] byte ( \"address\" ), Value : [] byte ( \"...\" )}, cmn . KVPair { Key : [] byte ( \"amount\" ), Value : [] byte ( \"...\" )}, cmn . KVPair { Key : [] byte ( \"reason\" ), Value : [] byte ( \"...\" )}, }, }, // ... }, } ResponseCheckTx type ResponseCheckTx struct { Code uint32 `protobuf:\"varint,1,opt,name=code,proto3\" json:\"code,omitempty\"` Data []byte `protobuf:\"bytes,2,opt,name=data,proto3\" json:\"data,omitempty\"` Log string `protobuf:\"bytes,3,opt,name=log,proto3\" json:\"log,omitempty\"` Info string `protobuf:\"bytes,4,opt,name=info,proto3\" json:\"info,omitempty\"` GasWanted int64 `protobuf:\"varint,5,opt,name=gas_wanted,json=gasWanted,proto3\" json:\"gas_wanted,omitempty\"` GasUsed int64 `protobuf:\"varint,6,opt,name=gas_used,json=gasUsed,proto3\" json:\"gas_used,omitempty\"` Events []Event `protobuf:\"bytes,7,rep,name=events,proto3\" json:\"events,omitempty\"` Codespace string `protobuf:\"bytes,8,opt,name=codespace,proto3\" json:\"codespace,omitempty\"` XXX_NoUnkeyedLiteral struct{} `json:\"-\"` XXX_unrecognized []byte `json:\"-\"` XXX_sizecache int32 `json:\"-\"` } ResponseDeliverTx type ResponseDeliverTx struct { Code uint32 `protobuf:\"varint,1,opt,name=code,proto3\" json:\"code,omitempty\"` Data []byte `protobuf:\"bytes,2,opt,name=data,proto3\" json:\"data,omitempty\"` Log string `protobuf:\"bytes,3,opt,name=log,proto3\" json:\"log,omitempty\"` Info string `protobuf:\"bytes,4,opt,name=info,proto3\" json:\"info,omitempty\"` GasWanted int64 `protobuf:\"varint,5,opt,name=gas_wanted,json=gasWanted,proto3\" json:\"gas_wanted,omitempty\"` GasUsed int64 `protobuf:\"varint,6,opt,name=gas_used,json=gasUsed,proto3\" json:\"gas_used,omitempty\"` Events []Event `protobuf:\"bytes,7,rep,name=events,proto3\" json:\"events,omitempty\"` Codespace string `protobuf:\"bytes,8,opt,name=codespace,proto3\" json:\"codespace,omitempty\"` XXX_NoUnkeyedLiteral struct{} `json:\"-\"` XXX_unrecognized []byte `json:\"-\"` XXX_sizecache int32 `json:\"-\"` } ResponseBeginBlock type ResponseBeginBlock struct { Events []Event `protobuf:\"bytes,1,rep,name=events,proto3\" json:\"events,omitempty\"` XXX_NoUnkeyedLiteral struct{} `json:\"-\"` XXX_unrecognized []byte `json:\"-\"` XXX_sizecache int32 `json:\"-\"` } ResponseEndBlock type ResponseEndBlock struct { ValidatorUpdates []ValidatorUpdate `protobuf:\"bytes,1,rep,name=validator_updates,json=validatorUpdates,proto3\" json:\"validator_updates\"` ConsensusParamUpdates *ConsensusParams `protobuf:\"bytes,2,opt,name=consensus_param_updates,json=consensusParamUpdates,proto3\" json:\"consensus_param_updates,omitempty\"` Events []Event `protobuf:\"bytes,3,rep,name=events,proto3\" json:\"events,omitempty\"` XXX_NoUnkeyedLiteral struct{} `json:\"-\"` XXX_unrecognized []byte `json:\"-\"` XXX_sizecache int32 `json:\"-\"` } Upcoming Changes in Genesys Chain API v0.6.2 HTTP API /api/v2/transactions-in-block/{blockHeight} Changes This endpoint is used for getting all transactions in the block. Multi-send and multi-coin transactions are flattened as sub-transactions. TxV2 Name Type Description Example blockHeight long code integer 0 data string fromAddr string memo string orderId string Optional. Available when the transaction type is NEW_ORDER proposalId string Optional. Available when the transaction type is PROPOSAL sequence long source long subTransactions [ SubTx ] Optional. Available when the transaction has sub-transactions, such as multi-send transaction or a transaction have multiple assets swapId string Optional. Available when the transaction type is one of HTL_TRANSFER, CLAIM_HTL, REFUND_HTL, DEPOSIT_HTL timeStamp dateTime toAddr string txAsset string txFee string txHash string txType string value string /api/v1/timelocks/{account_addr} Changes This new function is for getting the whole timelock history of an address. TimeLocks Name Type Description Example id long The record id of the timelock transaction description string The description of the timelock transaction amount [ ] locktime string The available unlock time /api/v1/timelock/{account_addr}?(id={recordid}) Changes This new function is for getting the timelock history of an address by id. TimeLocks Name Type Description Example id long The record id of the timelock transaction description string The description of the timelock transaction amount [ ] locktime string The available unlock time Upcoming Changes in Genesys Chain API v0.6.1 HTTP API As you know, There are some accelerate nodes which provides some advanced API services for the public. Here is a list of all the HTTP API information it provides on mainnet: https://docs.genesys.network/api-reference/dex-api/paths.html In the latest update of HTTP API for testnet, there are the following changes: /api/v1/account/{address} Changes In the Account data structure, a new field flags is added to indicate the constrains for this address. flags is used to indicate which script needs to be executed. Account Name Type Description Example account_number integer address string (address) balances [ Balance ] public_key [ integer ] Public key bytes flags integer indicate additional check for this account sequence long sequence is for preventing replay attack Upcoming Changes in Genesys Chain API v0.6.0 HTTP API As you know, There are some accelerate nodes which provides some advanced API services for the public. Here is a list of all the HTTP API information it provides on mainnet: https://docs.genesys.network/api-reference/dex-api/paths.html In the latest update of HTTP API for testnet, there are the following changes: /api/v1/trades Changes In the Trade data structure, a new field Ticker Type is added. The enumerate values are: \"Unknown\", \"SellTaker\",\"BuyTaker\",\"BuySurplus\",\"SellSurplus\",\"Neutral\". When there is a maker and taker, SellTaker and BuyTaker are used to indicate the side. When both sides are taker, BuySurplus , SellSurplus and Neutral are used to indicate market pressure. Unknown mean the type is not possible to define. buySingleFee is used to show trading fee for the buyer address on this single trade. sellSingleFee is used to show trading fee for the seller address on this single trade. GET Summary: Get market trades. Description: Gets a list of historical trades. Query Window: Default query window is latest 7 days; The maximum start - end query window is 3 months. Rate Limit: 5 requests per IP per second. Parameters Name Located in Description Required Schema address query the buyer/seller address No string buyerOrderId query buyer order id No string end query end time in Milliseconds No long height query block height No long limit query default 500; max 1000. No integer offset query start with 0; default 0. No integer quoteAsset query quote asset No string sellerOrderId query seller order id No string side query order side. 1 for buy and 2 for sell. No integer start query start time in Milliseconds No long symbol query symbol No string total query total number required, 0 for not required and 1 for required; default not required, return total=-1 in response No integer Responses Code Description Schema 200 OK TradePage 400 Bad Request Error 404 Not Found default Generic error response Error TradePage Name Type Description Example total long trade [ Trade ] Trade Name Type Description Example baseAsset string base asset blockHeight long block height buyFee string trading fee for the buyer address on the block of this trade buyerId string id of buyer buyerOrderId string order id for buyer buySingleFee string trading fee for the buyer address on this single trade price string trade price quantity string trade quantity quoteAsset string quote asset sellFee string trading fee for the seller address on the block of this trade sellerId string seller ID sellerOrderId string seller order ID sellSingleFee string trading fee for the seller address on this single trade symbol string asset symbol tickType string enum [Unknown,SellTaker,BuyTaker,BuySurplus,SellSurplus,Neutral] time long trade time tradeId string trade ID Websocket Trades Changes In received Payload of trades , a new filed tt is added. Its enumerate values are: * 0: Unknown * 1: SellTaker * 2: BuyTaker * 3: BuySurplus * 4: SellSurplus * 5: Neutral Received Payload: { \"stream\" : \"trades\" , \"data\" : [{ \"e\" : \"trade\" , // Event type \"E\" : 123456789 , // Event height \"s\" : \"GSYS_BTC\" , // Symbol \"t\" : \"12345\" , // Trade ID \"p\" : \"0.001\" , // Price \"q\" : \"100\" , // Quantity \"b\" : \"88\" , // Buyer order ID \"a\" : \"50\" , // Seller order ID \"T\" : 123456785 , // Trade time \"sa\" : \"bnb1me5u083m2spzt8pw8vunprnctc8syy64hegrcp\" , // SellerAddress \"ba\" : \"bnb1kdr00ydr8xj3ydcd3a8ej2xxn8lkuja7mdunr5\" // BuyerAddress \"tt\" : 1 //tiekertype }, { \"e\" : \"trade\" , // Event type \"E\" : 123456795 , // Event time \"s\" : \"GSYS_BTC\" , // Symbol \"t\" : \"12348\" , // Trade ID \"p\" : \"0.001\" , // Price \"q\" : \"100\" , // Quantity \"b\" : \"88\" , // Buyer order ID \"a\" : \"52\" , // Seller order ID \"T\" : 123456795 , // Trade time \"sa\" : \"bnb1me5u083m2spzt8pw8vunprnctc8syy64hegrcp\" , // SellerAddress \"ba\" : \"bnb1kdr00ydr8xj3ydcd3a8ej2xxn8lkuja7mdunr5\" // BuyerAddress \"tt\" : 0 //tiekertype }] } Extra data from your fullnode All those extra info can also be found in exported data from your fullnode. Changes In trade data structure, there are five new fields: SSrc , BSrc , SSingleFee , BSingleFee and TickerType . SSrc : Source code of Sell order transaction BSrc : Source code of Buy order transaction SSingleFee : fee of matched sell order BSingleFee : fee of matched buy order TickerType : ticker type In Order data structure, there is a new field: singlefee . This is used to show the fee of this order. For example: \"Height\" : 3154 , \"Timestamp\" : 1560927932877738000 , \"NumOfMsgs\" : 4 , \"Trades\" :{ \"NumOfMsgs\" : 1 , \"Trades\" :[ { \"Id\" : \"3154-0\" , \"Symbol\" : \"NNB-811_GSYS\" , \"Price\" : 1200000000 , \"Qty\" : 1200000000 , \"Sid\" : \"8FEC97AB9B3F52A30B860CFBB8E41B72E9EB02C1-11\" , \"Bid\" : \"01C93F3512BCAA7E1DDD490B69B85E53A76C79B9-2\" , \"Sfee\" : \"GSYS:5760000\" , \"Bfee\" : \"GSYS:5760000\" , \"SSrc\" : 0 , \"BSrc\" : 0 , \"SSingleFee\" : \"\" , \"BSingleFee\" : \"\" , \"TickType\" : 0 , \"SAddr\" : \"bnb13lkf02um8af2xzuxpnam3eqmwt57kqkp3hcvyp\" , \"BAddr\" : \"bnb1q8yn7dgjhj48u8wafy9knwz72wnkc7dehf39ch\" } ] }, \"Orders\" :{ \"NumOfMsgs\" : 3 , \"Orders\" :[ { \"Symbol\" : \"NNB-811_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"01C93F3512BCAA7E1DDD490B69B85E53A76C79B9-2\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1q8yn7dgjhj48u8wafy9knwz72wnkc7dehf39ch\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 1300000000 , \"Qty\" : 1300000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 1200000000 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1560927932877738000 , \"TransactionTime\" : 1560927932877738000 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"A120FAA19A3448119E7F32B986540B21A5927616C73F95ACD1626FB54A74A865\" }, { \"Symbol\" : \"NNB-811_GSYS\" , \"Status\" : 5 , \"OrderId\" : \"01C93F3512BCAA7E1DDD490B69B85E53A76C79B9-2\" , \"TradeId\" : \"3154-0\" , \"Owner\" : \"bnb1q8yn7dgjhj48u8wafy9knwz72wnkc7dehf39ch\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 1300000000 , \"Qty\" : 1300000000 , \"LastExecutedPrice\" : 1200000000 , \"LastExecutedQty\" : 1200000000 , \"CumQty\" : 1200000000 , \"Fee\" : \"GSYS:5760000\" , \"OrderCreationTime\" : 1560927932877738000 , \"TransactionTime\" : 1560927932877738000 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"A120FAA19A3448119E7F32B986540B21A5927616C73F95ACD1626FB54A74A865\" }, { \"Symbol\" : \"NNB-811_GSYS\" , \"Status\" : 6 , \"OrderId\" : \"8FEC97AB9B3F52A30B860CFBB8E41B72E9EB02C1-11\" , \"TradeId\" : \"3154-0\" , \"Owner\" : \"bnb13lkf02um8af2xzuxpnam3eqmwt57kqkp3hcvyp\" , \"Side\" : 2 , \"OrderType\" : 2 , \"Price\" : 1200000000 , \"Qty\" : 1200000000 , \"LastExecutedPrice\" : 1200000000 , \"LastExecutedQty\" : 1200000000 , \"CumQty\" : 1200000000 , \"Fee\" : \"GSYS:5760000\" , \"OrderCreationTime\" : 1560927931834863000 , \"TransactionTime\" : 1560927932877738000 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"617565ECA6464E1B7435819A8154BCF5FC773FE1C5982A833DBEEDBE78E660C6\" } ] }, \"Proposals\" :{ \"NumOfMsgs\" : 0 , \"Proposals\" : null }, \"StakeUpdates\" :{ \"NumOfMsgs\" : 0 , \"CompletedUnbondingDelegations\" : null } } Upcoming Changes in v0.6.2 Tendermint Changes 1. Better Handle Index database Now Tendermint will recover index data from restart or crash. You can see the latest indexed height from status: { \"jsonrpc\": \"2.0\", \"id\": \"\", \"result\": { ... \"sync_info\": { \"latest_block_hash\": \"F51538DA498299F4C57AC8162AAFA0254CE08286\", \"latest_app_hash\": \"0000000000000000\", \"latest_block_height\": \"18\", \"latest_block_time\": \"2018-09-17T11:42:19.149920551Z\", \"catching_up\": false, \"index_height\": \"18\" }, ... } 2. More configuration in config file A new field is added: skip_tx_from_persistent under mempool part. If you set this to be True, your node will not broadcast transactions to its persistent peers. 3. Change of Monitoring Metrics Add the following metrics: IndexHegiht\uff1aThis metric will show the latest indexed height. Height: This metric will show the latest height of the blockchain BlockIntervalSeconds: This metric will show the Time between this and the last block NumTxs: This metric will show the total number of transactions in the current block BlockSizeBytes: This metric will show the size of the block TotalTxs: This metric will show the total number of transactions in history CommittedHeight: This metric will show the latest block height PermanentPeerSetSize: This metric will show the number of peers considered as good PermanentPeers: This metric will show the details of peers considered as good DecayPeerSetSize: This metric will show the number of peers considered as bad Remove metrics of ReceivedTx, PeerSendBytesTotal, PeerReceiveBytesTotal","title":"Changelog"},{"location":"changelog.html#changelog","text":"","title":"CHANGELOG"},{"location":"changelog.html#upcoming-changes-in-genesys-chain-mainnet-api-2021-06-04","text":"","title":"Upcoming Changes in Genesys Chain Mainnet API - 2021-06-04"},{"location":"changelog.html#http-api","text":"","title":"HTTP API"},{"location":"changelog.html#apiv1transactions","text":"Changes The following changes will take effect. address related Mutli Send Transfer transaction history will also be included; If this address is the receiver of any HTL_TRANSFER , the related transactions history will also be included asset parameter can be used to search for quote asset of NEW_ORDER, CANCEL_ORDER,MINI_TOKEN_LIST,LISTING transactions asset parameter can be used to search for quote asset or base asset of dex listing SUBMIT_PROPOSAL transactions DEPOSIT_HTL HTL_TRANSFER, SIDE_DEPOSIT, TIME_LOCK, TIME_RELOCK, TRANSFER can relate to multiple assets, you can search by any of them.","title":"/api/v1/transactions"},{"location":"changelog.html#upcoming-changes-in-genesys-chain-mainnet-api-v072","text":"","title":"Upcoming Changes in Genesys Chain Mainnet API v0.7.2"},{"location":"changelog.html#node-rpc","text":"Extra paths are available for querying information about BEP8 tokens and trading pairs. New Query Path /mini-tokens/info /mini-tokens/list /dex-mini/pairs","title":"Node RPC"},{"location":"changelog.html#http-api_1","text":"","title":"HTTP API"},{"location":"changelog.html#apiv1depth","text":"Changes Add pending_match flag in response to indicate that current block has not run matching process for the new orders incoming in this block. In detail, if there are new orders created in current block, but the matching process has not run for the block, then pending_math=true. As a result, there could be orders with cross prices - price of ask is lower than price of bid. Client can ignore the response with pending_match=true and query the depth API until pending_match=false. GET Summary: Get the order book. Description: Gets the order book depth data for a given pair symbol. The given limit must be one of the allowed limits below. Destination: Validator node. Rate Limit: 10 requests per IP per second. URL for testnet: https://dex.genesys.network/api/v1/depth?symbol=xxx-000_GSYS Parameters Name Located in Description Required Schema symbol query Market pair symbol, e.g. NNB-0AD_GSYS Yes string limit query The limit of results. Allowed limits: [5, 10, 20, 50, 100, 500, 1000] No integer Responses","title":"/api/v1/depth"},{"location":"changelog.html#marketdepth","text":"Name Type Description Example asks [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] bids [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] pending_match boolean If new orders inserted in current block and the matching process has not started in the block, return true.","title":"MarketDepth"},{"location":"changelog.html#marketdepth_1","text":"Name Type Description Example asks [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] bids [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] pending_match boolean If new orders inserted in current block and the matching process has not started in the block, return true.","title":"MarketDepth"},{"location":"changelog.html#apiv1minitokens","text":"Changes Gets a list of available mini tokens.","title":"/api/v1/mini/tokens"},{"location":"changelog.html#minitokens","text":"Name Type Description Example name string Genesys Chain Mini Token symbol string BTC-000 original_symbol string BTC total_supply string (fixed8) In decimal form, e.g. 1.00000000 0.00000000 token_type integer Type of the mini token owner string (address) Address mintable boolean mintable token_uri string URI for token description","title":"MiniTokens"},{"location":"changelog.html#apiv1minimarkets","text":"Changes Gets a list of available mini tokens trading pairs.","title":"/api/v1/mini/markets:"},{"location":"changelog.html#market","text":"Name Type Description Example base_asset_symbol string (currency) symbol of base asset GSYS quote_asset_symbol string (currency) symbol of quote asset ABC-5CA list_price string (fixed8) In decimal form 1.00000000 tick_size string (fixed8) Minimium price change in decimal form 0.00000001 lot_size string (fixed8) Minimium trading quantity in decimal form 1.00000000","title":"Market"},{"location":"changelog.html#apiv1minikline","text":"Changes Get mini-token candlestick bars. Interval allowed value: [1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M]","title":"/api/v1/mini/kline"},{"location":"changelog.html#candlestick","text":"Name Type Description Example close number closing price closeTime long time of closing trade high number the highest price low number the lowest price numberOfTrades integer total trades open number open price openTime long time of open trade quoteAssetVolume number the total trading volume in quote asset volume number the total trading volume","title":"Candlestick"},{"location":"changelog.html#apiv1miniordersclosed","text":"Changes Get closed orders of mini-token pairs.","title":"/api/v1/mini/orders/closed"},{"location":"changelog.html#orderlist","text":"Name Type Description Example order [ Order ] list of orders total long","title":"OrderList"},{"location":"changelog.html#apiv1miniordersopen","text":"Changes Get open orders of mini-token pairs.","title":"/api/v1/mini/orders/open"},{"location":"changelog.html#orderlist_1","text":"Name Type Description Example order [ Order ] list of orders total long","title":"OrderList"},{"location":"changelog.html#apiv1miniticker24hr","text":"Changes Get a market ticker of mini-token pairs.","title":"/api/v1/mini/ticker/24hr"},{"location":"changelog.html#tickerstatistics","text":"Name Type Description Example askPrice string sell price askQuantity string sell quantity bidPrice string buy price bidQuantity string buy quantity closeTime long time of closing count long total trade count firstId string ID of first trade highPrice string highest price lastId string ID of last trade lastPrice string last price lastQuantity string last quantity lowPrice string lowest price openPrice string open price openTime long open time prevClosePrice string last close price priceChange string change of price priceChangePercent string change of price in percentage quoteVolume string trading volume in quote asset symbol string trading symbol volume string trading volume weightedAvgPrice string weighted average price","title":"TickerStatistics"},{"location":"changelog.html#apiv1minitrades","text":"Changes Get market trades of mini-token pairs.","title":"/api/v1/mini/trades"},{"location":"changelog.html#tradepage","text":"Name Type Description Example total long total number of trades trade [ Trade ]","title":"TradePage"},{"location":"changelog.html#upcoming-changes-in-genesys-chain-testnet-api-v070","text":"","title":"Upcoming Changes in Genesys Chain Testnet API v0.7.0"},{"location":"changelog.html#node-rpc_1","text":"Extra paths are available for querying information about BEP8 tokens and trading pairs. New Query Path /mini-tokens/info /mini-tokens/list /dex-mini/pairs","title":"Node RPC"},{"location":"changelog.html#http-api_2","text":"","title":"HTTP API"},{"location":"changelog.html#apiv1depth_1","text":"Changes Add pending_match flag in response to indicate that current block has not run matching process for the new orders incoming in this block. In detail, if there are new orders created in current block, but the matching process has not run for the block, then pending_math=true. As a result, there could be orders with cross prices - price of ask is lower than price of bid. Client can ignore the response with pending_match=true and query the depth API until pending_match=false. GET Summary: Get the order book. Description: Gets the order book depth data for a given pair symbol. The given limit must be one of the allowed limits below. Destination: Validator node. Rate Limit: 10 requests per IP per second. URL for testnet: https://testnet-dex.genesys.network/api/v1/depth?symbol=xxx-000_GSYS Parameters Name Located in Description Required Schema symbol query Market pair symbol, e.g. NNB-0AD_GSYS Yes string limit query The limit of results. Allowed limits: [5, 10, 20, 50, 100, 500, 1000] No integer Responses","title":"/api/v1/depth"},{"location":"changelog.html#marketdepth_2","text":"Name Type Description Example asks [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] bids [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] pending_match boolean If new orders inserted in current block and the matching process has not started in the block, return true.","title":"MarketDepth"},{"location":"changelog.html#marketdepth_3","text":"Name Type Description Example asks [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] bids [ string (fixed8) ] Price and qty in decimal form, e.g. 1.00000000 [\"1.00000000\",\"800.00000000\"] pending_match boolean If new orders inserted in current block and the matching process has not started in the block, return true.","title":"MarketDepth"},{"location":"changelog.html#apiv1minitokens_1","text":"Changes Gets a list of available mini tokens.","title":"/api/v1/mini/tokens"},{"location":"changelog.html#minitokens_1","text":"Name Type Description Example name string Genesys Chain Mini Token symbol string BTC-000 original_symbol string BTC total_supply string (fixed8) In decimal form, e.g. 1.00000000 0.00000000 token_type integer Type of the mini token owner string (address) Address mintable boolean mintable token_uri string URI for token description","title":"MiniTokens"},{"location":"changelog.html#apiv1minimarkets_1","text":"Changes Gets a list of available mini tokens trading pairs.","title":"/api/v1/mini/markets:"},{"location":"changelog.html#market_1","text":"Name Type Description Example base_asset_symbol string (currency) symbol of base asset GSYS quote_asset_symbol string (currency) symbol of quote asset ABC-5CA list_price string (fixed8) In decimal form 1.00000000 tick_size string (fixed8) Minimium price change in decimal form 0.00000001 lot_size string (fixed8) Minimium trading quantity in decimal form 1.00000000","title":"Market"},{"location":"changelog.html#apiv1minikline_1","text":"Changes Get mini-token candlestick bars. Interval allowed value: [1h, 2h, 4h, 6h, 8h, 12h, 1d, 3d, 1w, 1M]","title":"/api/v1/mini/kline"},{"location":"changelog.html#candlestick_1","text":"Name Type Description Example close number closing price closeTime long time of closing trade high number the highest price low number the lowest price numberOfTrades integer total trades open number open price openTime long time of open trade quoteAssetVolume number the total trading volume in quote asset volume number the total trading volume","title":"Candlestick"},{"location":"changelog.html#apiv1miniordersclosed_1","text":"Changes Get closed orders of mini-token pairs.","title":"/api/v1/mini/orders/closed"},{"location":"changelog.html#orderlist_2","text":"Name Type Description Example order [ Order ] list of orders total long","title":"OrderList"},{"location":"changelog.html#apiv1miniordersopen_1","text":"Changes Get open orders of mini-token pairs.","title":"/api/v1/mini/orders/open"},{"location":"changelog.html#orderlist_3","text":"Name Type Description Example order [ Order ] list of orders total long","title":"OrderList"},{"location":"changelog.html#apiv1miniticker24hr_1","text":"Changes Get a market ticker of mini-token pairs.","title":"/api/v1/mini/ticker/24hr"},{"location":"changelog.html#tickerstatistics_1","text":"Name Type Description Example askPrice string sell price askQuantity string sell quantity bidPrice string buy price bidQuantity string buy quantity closeTime long time of closing count long total trade count firstId string ID of first trade highPrice string highest price lastId string ID of last trade lastPrice string last price lastQuantity string last quantity lowPrice string lowest price openPrice string open price openTime long open time prevClosePrice string last close price priceChange string change of price priceChangePercent string change of price in percentage quoteVolume string trading volume in quote asset symbol string trading symbol volume string trading volume weightedAvgPrice string weighted average price","title":"TickerStatistics"},{"location":"changelog.html#apiv1minitrades_1","text":"Changes Get market trades of mini-token pairs.","title":"/api/v1/mini/trades"},{"location":"changelog.html#tradepage_1","text":"Name Type Description Example total long total number of trades trade [ Trade ]","title":"TradePage"},{"location":"changelog.html#upcoming-changes-in-genesys-chain-api-v064","text":"","title":"Upcoming Changes in Genesys Chain API v0.6.4"},{"location":"changelog.html#http-api_3","text":"","title":"HTTP API"},{"location":"changelog.html#add-error-message-for-newly-created-address","text":"You will get {\"code\":404,\"message\":\"account not found\"} for newly created account: Example https://testnet-dex-asiapacific.genesys.network/api/v1/account/tbnb10qpmrlsr4mq65xwgjd39xypkkpw3wm9c5e58xm Return: { code: 404, message: \"account not found\" }","title":"Add Error Message for Newly Created Address"},{"location":"changelog.html#apiv1trades","text":"Changes Add buyerSource and sellerSource in the response Trade data structure. The Source Id reference can be found inhttps://github.com/githubusername/githubrepo/BEPs/blob/master/BEP10.md.","title":"/api/v1/trades"},{"location":"changelog.html#trade","text":"Name Type Description Example baseAsset string base asset symbol blockHeight long block height buyFee string trading fee for the buyer address on the block of this trade buyerId string id of buyer buyerOrderId string order id for buyer buySingleFee string trading fee for the buyer address on this single trade GSYS:0.00000172; buyerSource long tx source of buy order 1 price string trade price quantity string trade quantity quoteAsset string quote asset symbol sellFee string trading fee for the seller address on the block of this trade sellerId string seller ID sellerOrderId string seller order ID sellSingleFee string trading fee for the seller address on this single trade GSYS:0.00000216; sellerSource long tx source of sell order 1 symbol string asset symbol tickType string enum [Unknown,SellTaker,BuyTaker,BuySurplus,SellSurplus,Neutral] time long trade time tradeId string trade ID","title":"Trade"},{"location":"changelog.html#upcoming-changes-in-genesys-chain-api-v063","text":"","title":"Upcoming Changes in Genesys Chain API v0.6.3"},{"location":"changelog.html#http-api_4","text":"","title":"HTTP API"},{"location":"changelog.html#apiv1atomic-swaps","text":"","title":"/api/v1/atomic-swaps"},{"location":"changelog.html#apiv1atomic-swapsid","text":"Changes The API is used to query atomic-swaps by id or by address. In the AtomicSwap data structure: * A new field blockTimestamp is added to indicate the block time in millisecond * The original timestamp is changed to indicate the timestamp for randomNumberHash calculation. Its unit is second. * createTime and updateTime are removed from AtomicSwap .","title":"/api/v1/atomic-swaps/{id}"},{"location":"changelog.html#atomicswap","text":"Name Type Description Example blockTimestamp long Timestamp of block in which the swap is initiated. The unit is millisecond. closedTime long crossChain integer expectedIncome string expireHeight long fromAddr string inAmount string outAmount string randomNumber string randomNumberHash string recipientOtherChain string status integer swapId string timestamp long The timestamp for randomNumberHash calculation, randomNumberHash=sha256(randomNumber, timestamp). The unit is second. toAddr string","title":"AtomicSwap"},{"location":"changelog.html#websocket","text":"As described in https://docs.genesys.network/api-reference/dex-api/ws-streams.html#6-book-depth-streams, you can now customize the returned level from orderbook. The default level is 20 and you can extend the level to 100, 500, or 1000 with compression enabled. Example on mainnet: var marketDepth = new WebSocket(\"wss://dex-atlantic.genesys.network/api/ws/NEXO-A84_GSYS@marketDepth100\"); Example on testnet: var marketDepth = new WebSocket(\"wss://testnet-dex.genesys.network/api/ws/ALT-3B6_GSYS@marketDepth100\");","title":"WebSocket"},{"location":"changelog.html#node-rpc_2","text":"Due to changes of underling Tendermint library, ResponseCheckTx , ResponseDeliverTx , ResponseBeginBlock , and ResponseEndBlock now include Events instead of Tags . Each Event contains a type and a list of attributes (list of key-value pairs) allowing for inclusion of multiple distinct events in each response.","title":"Node RPC"},{"location":"changelog.html#events","text":"Some methods ( CheckTx, BeginBlock, DeliverTx, EndBlock ) include an Events field in their Response* . Each event contains a type and a list of attributes, which are key-value pairs denoting something about what happened during the method's execution. Events can be used to index transactions and blocks according to what happened during their execution. Note that the set of events returned for a block from BeginBlock and EndBlock are merged. In case both methods return the same tag, only the value defined in EndBlock is used. Each event has a type which is meant to categorize the event for a particular Response* or tx. A Response* or tx may contain multiple events with duplicate type values, where each distinct entry is meant to categorize attributes for a particular event. Every key and value in an event's attributes must be UTF-8 encoded strings along with the event type itself. Example: abci . ResponseDeliverTx { // ... Events : [] abci . Event { { Type : \"validator.provisions\" , Attributes : cmn . KVPairs { cmn . KVPair { Key : [] byte ( \"address\" ), Value : [] byte ( \"...\" )}, cmn . KVPair { Key : [] byte ( \"amount\" ), Value : [] byte ( \"...\" )}, cmn . KVPair { Key : [] byte ( \"balance\" ), Value : [] byte ( \"...\" )}, }, }, { Type : \"validator.provisions\" , Attributes : cmn . KVPairs { cmn . KVPair { Key : [] byte ( \"address\" ), Value : [] byte ( \"...\" )}, cmn . KVPair { Key : [] byte ( \"amount\" ), Value : [] byte ( \"...\" )}, cmn . KVPair { Key : [] byte ( \"balance\" ), Value : [] byte ( \"...\" )}, }, }, { Type : \"validator.slashed\" , Attributes : cmn . KVPairs { cmn . KVPair { Key : [] byte ( \"address\" ), Value : [] byte ( \"...\" )}, cmn . KVPair { Key : [] byte ( \"amount\" ), Value : [] byte ( \"...\" )}, cmn . KVPair { Key : [] byte ( \"reason\" ), Value : [] byte ( \"...\" )}, }, }, // ... }, } ResponseCheckTx type ResponseCheckTx struct { Code uint32 `protobuf:\"varint,1,opt,name=code,proto3\" json:\"code,omitempty\"` Data []byte `protobuf:\"bytes,2,opt,name=data,proto3\" json:\"data,omitempty\"` Log string `protobuf:\"bytes,3,opt,name=log,proto3\" json:\"log,omitempty\"` Info string `protobuf:\"bytes,4,opt,name=info,proto3\" json:\"info,omitempty\"` GasWanted int64 `protobuf:\"varint,5,opt,name=gas_wanted,json=gasWanted,proto3\" json:\"gas_wanted,omitempty\"` GasUsed int64 `protobuf:\"varint,6,opt,name=gas_used,json=gasUsed,proto3\" json:\"gas_used,omitempty\"` Events []Event `protobuf:\"bytes,7,rep,name=events,proto3\" json:\"events,omitempty\"` Codespace string `protobuf:\"bytes,8,opt,name=codespace,proto3\" json:\"codespace,omitempty\"` XXX_NoUnkeyedLiteral struct{} `json:\"-\"` XXX_unrecognized []byte `json:\"-\"` XXX_sizecache int32 `json:\"-\"` } ResponseDeliverTx type ResponseDeliverTx struct { Code uint32 `protobuf:\"varint,1,opt,name=code,proto3\" json:\"code,omitempty\"` Data []byte `protobuf:\"bytes,2,opt,name=data,proto3\" json:\"data,omitempty\"` Log string `protobuf:\"bytes,3,opt,name=log,proto3\" json:\"log,omitempty\"` Info string `protobuf:\"bytes,4,opt,name=info,proto3\" json:\"info,omitempty\"` GasWanted int64 `protobuf:\"varint,5,opt,name=gas_wanted,json=gasWanted,proto3\" json:\"gas_wanted,omitempty\"` GasUsed int64 `protobuf:\"varint,6,opt,name=gas_used,json=gasUsed,proto3\" json:\"gas_used,omitempty\"` Events []Event `protobuf:\"bytes,7,rep,name=events,proto3\" json:\"events,omitempty\"` Codespace string `protobuf:\"bytes,8,opt,name=codespace,proto3\" json:\"codespace,omitempty\"` XXX_NoUnkeyedLiteral struct{} `json:\"-\"` XXX_unrecognized []byte `json:\"-\"` XXX_sizecache int32 `json:\"-\"` } ResponseBeginBlock type ResponseBeginBlock struct { Events []Event `protobuf:\"bytes,1,rep,name=events,proto3\" json:\"events,omitempty\"` XXX_NoUnkeyedLiteral struct{} `json:\"-\"` XXX_unrecognized []byte `json:\"-\"` XXX_sizecache int32 `json:\"-\"` } ResponseEndBlock type ResponseEndBlock struct { ValidatorUpdates []ValidatorUpdate `protobuf:\"bytes,1,rep,name=validator_updates,json=validatorUpdates,proto3\" json:\"validator_updates\"` ConsensusParamUpdates *ConsensusParams `protobuf:\"bytes,2,opt,name=consensus_param_updates,json=consensusParamUpdates,proto3\" json:\"consensus_param_updates,omitempty\"` Events []Event `protobuf:\"bytes,3,rep,name=events,proto3\" json:\"events,omitempty\"` XXX_NoUnkeyedLiteral struct{} `json:\"-\"` XXX_unrecognized []byte `json:\"-\"` XXX_sizecache int32 `json:\"-\"` }","title":"Events"},{"location":"changelog.html#upcoming-changes-in-genesys-chain-api-v062","text":"","title":"Upcoming Changes in Genesys Chain API v0.6.2"},{"location":"changelog.html#http-api_5","text":"","title":"HTTP API"},{"location":"changelog.html#apiv2transactions-in-blockblockheight","text":"Changes This endpoint is used for getting all transactions in the block. Multi-send and multi-coin transactions are flattened as sub-transactions.","title":"/api/v2/transactions-in-block/{blockHeight}"},{"location":"changelog.html#txv2","text":"Name Type Description Example blockHeight long code integer 0 data string fromAddr string memo string orderId string Optional. Available when the transaction type is NEW_ORDER proposalId string Optional. Available when the transaction type is PROPOSAL sequence long source long subTransactions [ SubTx ] Optional. Available when the transaction has sub-transactions, such as multi-send transaction or a transaction have multiple assets swapId string Optional. Available when the transaction type is one of HTL_TRANSFER, CLAIM_HTL, REFUND_HTL, DEPOSIT_HTL timeStamp dateTime toAddr string txAsset string txFee string txHash string txType string value string","title":"TxV2"},{"location":"changelog.html#apiv1timelocksaccount_addr","text":"Changes This new function is for getting the whole timelock history of an address.","title":"/api/v1/timelocks/{account_addr}"},{"location":"changelog.html#timelocks","text":"Name Type Description Example id long The record id of the timelock transaction description string The description of the timelock transaction amount [ ] locktime string The available unlock time","title":"TimeLocks"},{"location":"changelog.html#apiv1timelockaccount_addridrecordid","text":"Changes This new function is for getting the timelock history of an address by id.","title":"/api/v1/timelock/{account_addr}?(id={recordid})"},{"location":"changelog.html#timelocks_1","text":"Name Type Description Example id long The record id of the timelock transaction description string The description of the timelock transaction amount [ ] locktime string The available unlock time","title":"TimeLocks"},{"location":"changelog.html#upcoming-changes-in-genesys-chain-api-v061","text":"","title":"Upcoming Changes in Genesys Chain API v0.6.1"},{"location":"changelog.html#http-api_6","text":"As you know, There are some accelerate nodes which provides some advanced API services for the public. Here is a list of all the HTTP API information it provides on mainnet: https://docs.genesys.network/api-reference/dex-api/paths.html In the latest update of HTTP API for testnet, there are the following changes:","title":"HTTP API"},{"location":"changelog.html#apiv1accountaddress","text":"Changes In the Account data structure, a new field flags is added to indicate the constrains for this address. flags is used to indicate which script needs to be executed.","title":"/api/v1/account/{address}"},{"location":"changelog.html#account","text":"Name Type Description Example account_number integer address string (address) balances [ Balance ] public_key [ integer ] Public key bytes flags integer indicate additional check for this account sequence long sequence is for preventing replay attack","title":"Account"},{"location":"changelog.html#upcoming-changes-in-genesys-chain-api-v060","text":"","title":"Upcoming Changes in Genesys Chain API v0.6.0"},{"location":"changelog.html#http-api_7","text":"As you know, There are some accelerate nodes which provides some advanced API services for the public. Here is a list of all the HTTP API information it provides on mainnet: https://docs.genesys.network/api-reference/dex-api/paths.html In the latest update of HTTP API for testnet, there are the following changes:","title":"HTTP API"},{"location":"changelog.html#apiv1trades_1","text":"Changes In the Trade data structure, a new field Ticker Type is added. The enumerate values are: \"Unknown\", \"SellTaker\",\"BuyTaker\",\"BuySurplus\",\"SellSurplus\",\"Neutral\". When there is a maker and taker, SellTaker and BuyTaker are used to indicate the side. When both sides are taker, BuySurplus , SellSurplus and Neutral are used to indicate market pressure. Unknown mean the type is not possible to define. buySingleFee is used to show trading fee for the buyer address on this single trade. sellSingleFee is used to show trading fee for the seller address on this single trade. GET Summary: Get market trades. Description: Gets a list of historical trades. Query Window: Default query window is latest 7 days; The maximum start - end query window is 3 months. Rate Limit: 5 requests per IP per second. Parameters Name Located in Description Required Schema address query the buyer/seller address No string buyerOrderId query buyer order id No string end query end time in Milliseconds No long height query block height No long limit query default 500; max 1000. No integer offset query start with 0; default 0. No integer quoteAsset query quote asset No string sellerOrderId query seller order id No string side query order side. 1 for buy and 2 for sell. No integer start query start time in Milliseconds No long symbol query symbol No string total query total number required, 0 for not required and 1 for required; default not required, return total=-1 in response No integer Responses Code Description Schema 200 OK TradePage 400 Bad Request Error 404 Not Found default Generic error response Error","title":"/api/v1/trades"},{"location":"changelog.html#tradepage_2","text":"Name Type Description Example total long trade [ Trade ]","title":"TradePage"},{"location":"changelog.html#trade_1","text":"Name Type Description Example baseAsset string base asset blockHeight long block height buyFee string trading fee for the buyer address on the block of this trade buyerId string id of buyer buyerOrderId string order id for buyer buySingleFee string trading fee for the buyer address on this single trade price string trade price quantity string trade quantity quoteAsset string quote asset sellFee string trading fee for the seller address on the block of this trade sellerId string seller ID sellerOrderId string seller order ID sellSingleFee string trading fee for the seller address on this single trade symbol string asset symbol tickType string enum [Unknown,SellTaker,BuyTaker,BuySurplus,SellSurplus,Neutral] time long trade time tradeId string trade ID","title":"Trade"},{"location":"changelog.html#websocket_1","text":"","title":"Websocket"},{"location":"changelog.html#trades","text":"Changes In received Payload of trades , a new filed tt is added. Its enumerate values are: * 0: Unknown * 1: SellTaker * 2: BuyTaker * 3: BuySurplus * 4: SellSurplus * 5: Neutral Received Payload: { \"stream\" : \"trades\" , \"data\" : [{ \"e\" : \"trade\" , // Event type \"E\" : 123456789 , // Event height \"s\" : \"GSYS_BTC\" , // Symbol \"t\" : \"12345\" , // Trade ID \"p\" : \"0.001\" , // Price \"q\" : \"100\" , // Quantity \"b\" : \"88\" , // Buyer order ID \"a\" : \"50\" , // Seller order ID \"T\" : 123456785 , // Trade time \"sa\" : \"bnb1me5u083m2spzt8pw8vunprnctc8syy64hegrcp\" , // SellerAddress \"ba\" : \"bnb1kdr00ydr8xj3ydcd3a8ej2xxn8lkuja7mdunr5\" // BuyerAddress \"tt\" : 1 //tiekertype }, { \"e\" : \"trade\" , // Event type \"E\" : 123456795 , // Event time \"s\" : \"GSYS_BTC\" , // Symbol \"t\" : \"12348\" , // Trade ID \"p\" : \"0.001\" , // Price \"q\" : \"100\" , // Quantity \"b\" : \"88\" , // Buyer order ID \"a\" : \"52\" , // Seller order ID \"T\" : 123456795 , // Trade time \"sa\" : \"bnb1me5u083m2spzt8pw8vunprnctc8syy64hegrcp\" , // SellerAddress \"ba\" : \"bnb1kdr00ydr8xj3ydcd3a8ej2xxn8lkuja7mdunr5\" // BuyerAddress \"tt\" : 0 //tiekertype }] }","title":"Trades"},{"location":"changelog.html#extra-data-from-your-fullnode","text":"All those extra info can also be found in exported data from your fullnode. Changes In trade data structure, there are five new fields: SSrc , BSrc , SSingleFee , BSingleFee and TickerType . SSrc : Source code of Sell order transaction BSrc : Source code of Buy order transaction SSingleFee : fee of matched sell order BSingleFee : fee of matched buy order TickerType : ticker type In Order data structure, there is a new field: singlefee . This is used to show the fee of this order. For example: \"Height\" : 3154 , \"Timestamp\" : 1560927932877738000 , \"NumOfMsgs\" : 4 , \"Trades\" :{ \"NumOfMsgs\" : 1 , \"Trades\" :[ { \"Id\" : \"3154-0\" , \"Symbol\" : \"NNB-811_GSYS\" , \"Price\" : 1200000000 , \"Qty\" : 1200000000 , \"Sid\" : \"8FEC97AB9B3F52A30B860CFBB8E41B72E9EB02C1-11\" , \"Bid\" : \"01C93F3512BCAA7E1DDD490B69B85E53A76C79B9-2\" , \"Sfee\" : \"GSYS:5760000\" , \"Bfee\" : \"GSYS:5760000\" , \"SSrc\" : 0 , \"BSrc\" : 0 , \"SSingleFee\" : \"\" , \"BSingleFee\" : \"\" , \"TickType\" : 0 , \"SAddr\" : \"bnb13lkf02um8af2xzuxpnam3eqmwt57kqkp3hcvyp\" , \"BAddr\" : \"bnb1q8yn7dgjhj48u8wafy9knwz72wnkc7dehf39ch\" } ] }, \"Orders\" :{ \"NumOfMsgs\" : 3 , \"Orders\" :[ { \"Symbol\" : \"NNB-811_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"01C93F3512BCAA7E1DDD490B69B85E53A76C79B9-2\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1q8yn7dgjhj48u8wafy9knwz72wnkc7dehf39ch\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 1300000000 , \"Qty\" : 1300000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 1200000000 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1560927932877738000 , \"TransactionTime\" : 1560927932877738000 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"A120FAA19A3448119E7F32B986540B21A5927616C73F95ACD1626FB54A74A865\" }, { \"Symbol\" : \"NNB-811_GSYS\" , \"Status\" : 5 , \"OrderId\" : \"01C93F3512BCAA7E1DDD490B69B85E53A76C79B9-2\" , \"TradeId\" : \"3154-0\" , \"Owner\" : \"bnb1q8yn7dgjhj48u8wafy9knwz72wnkc7dehf39ch\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 1300000000 , \"Qty\" : 1300000000 , \"LastExecutedPrice\" : 1200000000 , \"LastExecutedQty\" : 1200000000 , \"CumQty\" : 1200000000 , \"Fee\" : \"GSYS:5760000\" , \"OrderCreationTime\" : 1560927932877738000 , \"TransactionTime\" : 1560927932877738000 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"A120FAA19A3448119E7F32B986540B21A5927616C73F95ACD1626FB54A74A865\" }, { \"Symbol\" : \"NNB-811_GSYS\" , \"Status\" : 6 , \"OrderId\" : \"8FEC97AB9B3F52A30B860CFBB8E41B72E9EB02C1-11\" , \"TradeId\" : \"3154-0\" , \"Owner\" : \"bnb13lkf02um8af2xzuxpnam3eqmwt57kqkp3hcvyp\" , \"Side\" : 2 , \"OrderType\" : 2 , \"Price\" : 1200000000 , \"Qty\" : 1200000000 , \"LastExecutedPrice\" : 1200000000 , \"LastExecutedQty\" : 1200000000 , \"CumQty\" : 1200000000 , \"Fee\" : \"GSYS:5760000\" , \"OrderCreationTime\" : 1560927931834863000 , \"TransactionTime\" : 1560927932877738000 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"617565ECA6464E1B7435819A8154BCF5FC773FE1C5982A833DBEEDBE78E660C6\" } ] }, \"Proposals\" :{ \"NumOfMsgs\" : 0 , \"Proposals\" : null }, \"StakeUpdates\" :{ \"NumOfMsgs\" : 0 , \"CompletedUnbondingDelegations\" : null } }","title":"Extra data from your fullnode"},{"location":"changelog.html#upcoming-changes-in-v062","text":"","title":"Upcoming Changes in v0.6.2"},{"location":"changelog.html#tendermint-changes","text":"","title":"Tendermint Changes"},{"location":"changelog.html#1-better-handle-index-database","text":"Now Tendermint will recover index data from restart or crash. You can see the latest indexed height from status: { \"jsonrpc\": \"2.0\", \"id\": \"\", \"result\": { ... \"sync_info\": { \"latest_block_hash\": \"F51538DA498299F4C57AC8162AAFA0254CE08286\", \"latest_app_hash\": \"0000000000000000\", \"latest_block_height\": \"18\", \"latest_block_time\": \"2018-09-17T11:42:19.149920551Z\", \"catching_up\": false, \"index_height\": \"18\" }, ... }","title":"1. Better Handle Index database"},{"location":"changelog.html#2-more-configuration-in-config-file","text":"A new field is added: skip_tx_from_persistent under mempool part. If you set this to be True, your node will not broadcast transactions to its persistent peers.","title":"2. More configuration in config file"},{"location":"changelog.html#3-change-of-monitoring-metrics","text":"Add the following metrics: IndexHegiht\uff1aThis metric will show the latest indexed height. Height: This metric will show the latest height of the blockchain BlockIntervalSeconds: This metric will show the Time between this and the last block NumTxs: This metric will show the total number of transactions in the current block BlockSizeBytes: This metric will show the size of the block TotalTxs: This metric will show the total number of transactions in history CommittedHeight: This metric will show the latest block height PermanentPeerSetSize: This metric will show the number of peers considered as good PermanentPeers: This metric will show the details of peers considered as good DecayPeerSetSize: This metric will show the number of peers considered as bad Remove metrics of ReceivedTx, PeerSendBytesTotal, PeerReceiveBytesTotal","title":"3. Change of Monitoring Metrics"},{"location":"dataseed_list.html","text":"","title":"Dataseed list"},{"location":"encoding.html","text":"Genesys Chain Transaction Encoding Specification Genesys Chain transactions are protocol-based data types and can only be submitted in a compatible encoded frame. The fundamental encoding logic is from Tendermint Amino , which derives from and is \"largely compatible with\" Google protocol-buffer's Proto3. However the client sides only needs to stick to the specifications outlined below for the most frequently used transactions. Encoding Output Genesys Chain (Amino) encoding logic may encode a data structure into two output formats: Binary and JSON. JSON Marshal Amino supports JSON encoding natively, which is the same as other usual json marshalers. Except that it can add one more type info for registered type, as shown below. { \"type\" : \"<amino type name>\" , \"value\" : <JSON> } Binary Marshal Please note the below binary encoding logic is subjected to future changes. Please watch out for the community news . Binary encoding is a variant of Google's protobuf. The bytes are laid out in the below sequence: a varint encoded integer - it contains the length of the encoded bytes for the object, which is displayed as SIZE-OF-ENCODED in the below structs. Please note that it contains the length of encoded bytes and also the type prefix (below), but not itself, e.g. if the encoded msg is 20 bytes, then the length would be 20 + 4 = 24, while 4 is used for the type prefix bytes. an object type prefix of 4-8 bytes - For different type of objects, there will be different type prefixes, and they are displayed as in the specific objects below (data structures). a binary encoded object - the encoding is mostly the same as protocol buffer encoding mechanism, except the embedded fields of complex type: to encode data field of some specific types, an object type prefix for the field will be added ahead of the real encoding. repeated (array) Encoding - it is the same as google protocol buffer, while encoding of the object/struct may contain the type prefix as shown below. Genesys Chain Transaction Encoding Below are the data types that can be sent to Genesys Chain as requests, and their encoding layout. To simplify the presentation, we will use a variant of Google protocol buffer proto3 language to illustrate how the data fields are organized. Except the all-capitalized fields, other fields will use the default proto3 encoding logic. Standard Transaction Transactions are each wrapped in the below \"Standard Transaction\": structure: // please note the field name is the JSON name. message StdTx { uint64 SIZE - OF - ENCODED // varint encoded length of the structure after encoding, please note this includes both the below type prefix (4 bytes) and the all encoding bytes 0xF0625DEE // hardcoded, object type prefix in 4 bytes repeated Msg msgs // array of size 1, containing the transaction message, which are one of the transaction types below. please check the above \"Array Encoding\" repeated StdSignature signatures // array of size 1, containing the standard signature structure of the transaction sender string memo // a short sentence of remark for the transaction. Please only `Transfer` transaction allows 'memo' input, and other transactions with non-empty `Memo` will be rejected. int64 source // an identifier for tools triggerring this transaction, set to zero if unwilling to disclose. bytes data // byte array, reserved for future use } StdSignBytes type StdSignDoc struct { AccountNumber int64 `json:\"account_number\"` ChainID string `json:\"chain_id\"` Memo string `json:\"memo\"` Msgs [] json . RawMessage `json:\"msgs\"` Sequence int64 `json:\"sequence\"` Source int64 `json:\"source\"` Data [] byte `json:\"data\"` } Canonical Bytes for Signing A transaction signature is not formed from the Amino-encoded transaction bytes themselves. Rather, a canonical representation of the transaction is generated in JSON format for signing. This would allow for clients to sign a transaction off-chain, for example, with a hardware HSM device like a Ledger, or within a micro-service in an algorithmic trading system. An external system will not have to understand Amino encoding to be able to approve of the transaction's content and produce the signed JSON string. The canonical bytes for signing are generated from the StdSignBytes method. It produces a JSON string similar to the format below (formatted for clarity): { \"sequence\" : \"64\" , \"account_number\" : \"12\" , \"data\" : null , \"chain_id\" : \"chain-bnb\" , \"memo\" : \"smiley\" , \"msgs\" : [ { \"inputs\" : [ { \"coins\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"200000000\" } ], \"address\" : \"bnc1hgm0p7khfk85zpz5v0j8wnej3a90w7098fpxyh\" } ], \"outputs\" : [ { \"address\" : \"bnc1cku54wwn66w2rkgs3h6v5zxrwtzyew8chcl720\" , \"coins\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"200000000\" } ] } ] } ], \"source\" : \"1\" } This JSON string, with all whitespace removed and keys sorted in alphabetical order , is signed with the private key of the sender. This signature is then attached to the StdTx structure described in the above section. Please note that the transaction broadcasted to the blockchain is not JSON - the JSON is merely used as a canonical representation to generate the signature. The next section describes how the generated signature is attached to a transaction. Standard Signature The sender's signature is stored in the Standard Transaction data via a Standard Signature , as shown below. This structure is included in the StdTx (see above). Please note that StdSignature itself doesn't have type prefix, while the PubKey does. message StdSignature { uint64 SIZE - OF - ENCODED // varint encoded length of the structure after encoding // please note there is no type prefix for StdSignature message PubKey { 0xEB5AE987 // hardcoded, object type prefix in 4 bytes uint64 SIZE - OF - ENCODED // varint encoded length of the bytes below bytes // no name or field id, just encode the bytes } PubKey pub_key // public key bytes of the signer address bytes signature // signature bytes, please check the chain access section for signature generation int64 account_number // another identifier of signer, which can be read from chain by account REST API or RPC int64 sequence // sequence number for the next transaction of the client, which can be read from the chain by account REST API or RPC. Please check the chain access section for details. } Message Types Messages represent the individual operations possible on Genesys Chain, and these can be inserted into the StdTx.msgs field. Message types are otherwise known as \"transaction types\", and these terms are used interchangebly in this document and in our technical documentation. So far every StdTx transaction \"container\" can only contain one \"message\". Transfer Transfer is the transaction used for transferring funds to different addresses. // please note the field name is the JSON name. message Send { 0x2A2C87FA // hardcoded, object type prefix in 4 bytes message Token { string denom int64 amount } message Input { bytes address repeated Token coins } message Output { bytes address repeated Token coins } repeated Input inputs repeated Output outputs } NewOrder NewOrder transaction will create a new order to buy or sell tokens on GSYS DEX. // please note the field name is the JSON name. message NewOrder { 0xCE6DC043 // hardcoded, object type prefix in 4 bytes bytes sender // order originating address string id // order id, please check the Order ID section below for details. string symbol // symbol for trading pair in full name of the token int64 ordertype // only accept 2 for now, meaning limit order int64 side // 1 for buy and 2 fory sell int64 price // price of the order, which is the real price multiplied by 1e8 (10^8) and rounded to integer int64 quantity // quantity of the order, which is the real quantity multiplied by 1e8 (10^8) and rounded to integer int64 timeinforce // 1 for Good Till Expire(GTE) order and 3 for Immediate Or Cancel (IOC) } Order ID Order ID is unique across the world. It is generated by sender and acknowledged by GSYS DEX. The current implementation is composed from 3 parts: Sender address in HEX format, without human-readable prefix A dash sign: - Sequence number E.g. 40C2979694BBC961023D1D27BE6FC4D21A9FEBE6-5 Cancel Cancel transactions (cancel the outstanding/unfilled) orders from the GSYS DEX. After cancel success, the locked quantity on the orders will return back to the originating address balance and become free to use, i.e. transfer or send new orders. // please note the field name is the JSON name. message CancelOrder { 0x166E681B // hardcoded, object type prefix in 4 bytes bytes sender // order originating address string symbol // symbol for trading pair in full name of the token string refid // order id of the order to cancel } Freeze Freeze transaction will move the amount of the tokens into a frozen state, in which they cannot be used for transfers or sending new orders. // please note the field name is the JSON name. message TokenFreeze { 0xE774B32D // hardcoded, object type prefix in 4 bytes bytes from // owner address string symbol // token symbol, in full name with \"-\" suffix int64 amount // amount of tokens to freeze } Unfreeze Unfreeze will reversely turn the amount of frozen tokens back to free state. // please note the field name is the JSON name. message TokenUnfreeze { 0x6515FF0D // hardcoded, object type prefix in 4 bytes bytes from // owner address string symbol // token symbol, in full name with \"-\" suffix int64 amount // amount of tokens to unfreeze } Vote Vote transactions for proposals. // please note the field name is the JSON name. message Vote { 0xA1CADD36 // hardcoded, object type prefix in 4 bytes int64 proposal_id // ID of the proposal bytes voter // address of the voter uint64 option // option from OptionSet chosen by the voter } Below are options for option : OptionYes = 0x01 // yes OptionAbstain = 0x02 // abstain OptionNo = 0x03 // no OptionNoWithVeto = 0x04 // no with veto Issue Issue (create) new asset on Genesys Chain. message IssueTokenValue { 0x17EFAB80 // hardcoded, object type prefix in 4 bytes bytes from // issuer's address string name // token name string symbol // token symbol string total_supply // total supply bool mintable // is mintable } Mint Mint is used to increase the total supply of a token. message Mint { 0x467E0829 // hardcoded, object type prefix in 4 bytes bytes from // sender's address string symbol string // token symbol int64 amount // increase amount } Burn Burn is used to decrease the total supply of a token. message TokenBurn { 0x7ED2D2A0 // hardcoded, object type prefix in 4 bytes bytes from // sender's address string symbol string // token symbol int64 amount // increase amount } List List is used to add a new trading pair. message DexList { 0xB41DE13F // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 proposal_id // id of corresponding proposal string base_asset_symbol // token symbol of base asset string quote_asset_symbol // token symbol of quote asset int64 init_price // init price of the new token } Submit Proposal Submit proposal is used to create a proposal for validators about adding trading pairs message Submit { 0xB42D614E // hardcoded, object type prefix in 4 bytes string title // Title of the proposal string description // Description of the proposal byte proposal_type // Type of proposal. Initial set {PlainTextProposal, SoftwareUpgradeProposal,ListTradingPair, FixedFeeParams} bytes proposer // Address of the proposer message Coin { string denom int64 amount } int64 VotingPeriod // Length of the voting period (s) } Deposit Deposit is used to increase the total deposit of a proposal. message Deposit { 0xA18A56E5 // hardcoded, object type prefix in 4 bytes int64 ProposalID // ID of the proposal bytes Depositer // Address of the depositer message Coin { string denom int64 amount } } Set Account Flags You can set the flag value of your account. message SetAccountFlags { 0xBEA6E301 // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 flag // account flag } Time-lock You can only lock tokens on your own account for a certain period of time. message Timerelock { 0x07921531 // hardcoded, object type prefix in 4 bytes bytes from // sender's address string description // Description of the lock message Coin { string denom int64 amount } repeated Coin amount int64 lock_time // lock time } Time-unlock You can unlock tokens on your own account after a certain period of time. message Timeunlock { 0xC4050C6C // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 id // lock time id } Time-relock You can relock tokens on your own account after a certain period of time. message Timerelock { 0x504711DA // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 Id // lock time id string description // Description of the lock message Coin { string denom int64 amount } repeated Coin amount int64 lock_time // lock time } HTLT Hash Timer Locked Transfer (HTLT) is a new transaction type on Genesys Chain, to serve as HGSYS in the first step of Atomic Swap message HTLT { 0xB33F9A24 // hardcoded, object type prefix in 4 bytes bytes from // sender's address bytes to // receiver's address string recipient_other_chain string sender_other_chain bytes random_number_hash int64 timestamp message Coin { string denom int64 amount } repeated Coin amount string expected_income int64 height_span bool cross_chain } Deposit HTLT Deposit Hash Timer Locked Transfer is to lock new BEP2 asset to an existed HTLT which is for single chain atomic swap. message DepositHTLT { 0x63986496 // hardcoded, object type prefix in 4 bytes bytes from // sender's address message Coin { string denom int64 amount } repeated Coin amount bytes swap_id } Claim HTLT Claim Hash Timer Locked Transfer is to claim the locked asset by showing the random number value that matches the hash. Each HTLT locked asset is guaranteed to be release once. message ClaimHTLTMsg { 0xC1665300 // hardcoded, object type prefix in 4 bytes bytes from // sender's address bytes swap_id bytes random_number } Refund HTLT Refund Hash Timer Locked Transfer is to refund the locked asset after timelock is expired. message RefundHTLTMsg { 0x3454A27C // hardcoded, object type prefix in 4 bytes bytes from // sender's address bytes swap_id","title":"Genesys Chain Transaction Encoding Specification"},{"location":"encoding.html#genesys-chain-transaction-encoding-specification","text":"Genesys Chain transactions are protocol-based data types and can only be submitted in a compatible encoded frame. The fundamental encoding logic is from Tendermint Amino , which derives from and is \"largely compatible with\" Google protocol-buffer's Proto3. However the client sides only needs to stick to the specifications outlined below for the most frequently used transactions.","title":"Genesys Chain Transaction Encoding Specification"},{"location":"encoding.html#encoding-output","text":"Genesys Chain (Amino) encoding logic may encode a data structure into two output formats: Binary and JSON.","title":"Encoding Output"},{"location":"encoding.html#json-marshal","text":"Amino supports JSON encoding natively, which is the same as other usual json marshalers. Except that it can add one more type info for registered type, as shown below. { \"type\" : \"<amino type name>\" , \"value\" : <JSON> }","title":"JSON Marshal"},{"location":"encoding.html#binary-marshal","text":"Please note the below binary encoding logic is subjected to future changes. Please watch out for the community news . Binary encoding is a variant of Google's protobuf. The bytes are laid out in the below sequence: a varint encoded integer - it contains the length of the encoded bytes for the object, which is displayed as SIZE-OF-ENCODED in the below structs. Please note that it contains the length of encoded bytes and also the type prefix (below), but not itself, e.g. if the encoded msg is 20 bytes, then the length would be 20 + 4 = 24, while 4 is used for the type prefix bytes. an object type prefix of 4-8 bytes - For different type of objects, there will be different type prefixes, and they are displayed as in the specific objects below (data structures). a binary encoded object - the encoding is mostly the same as protocol buffer encoding mechanism, except the embedded fields of complex type: to encode data field of some specific types, an object type prefix for the field will be added ahead of the real encoding. repeated (array) Encoding - it is the same as google protocol buffer, while encoding of the object/struct may contain the type prefix as shown below.","title":"Binary Marshal"},{"location":"encoding.html#genesys-chain-transaction-encoding","text":"Below are the data types that can be sent to Genesys Chain as requests, and their encoding layout. To simplify the presentation, we will use a variant of Google protocol buffer proto3 language to illustrate how the data fields are organized. Except the all-capitalized fields, other fields will use the default proto3 encoding logic.","title":"Genesys Chain Transaction Encoding"},{"location":"encoding.html#standard-transaction","text":"Transactions are each wrapped in the below \"Standard Transaction\": structure: // please note the field name is the JSON name. message StdTx { uint64 SIZE - OF - ENCODED // varint encoded length of the structure after encoding, please note this includes both the below type prefix (4 bytes) and the all encoding bytes 0xF0625DEE // hardcoded, object type prefix in 4 bytes repeated Msg msgs // array of size 1, containing the transaction message, which are one of the transaction types below. please check the above \"Array Encoding\" repeated StdSignature signatures // array of size 1, containing the standard signature structure of the transaction sender string memo // a short sentence of remark for the transaction. Please only `Transfer` transaction allows 'memo' input, and other transactions with non-empty `Memo` will be rejected. int64 source // an identifier for tools triggerring this transaction, set to zero if unwilling to disclose. bytes data // byte array, reserved for future use }","title":"Standard Transaction"},{"location":"encoding.html#stdsignbytes","text":"type StdSignDoc struct { AccountNumber int64 `json:\"account_number\"` ChainID string `json:\"chain_id\"` Memo string `json:\"memo\"` Msgs [] json . RawMessage `json:\"msgs\"` Sequence int64 `json:\"sequence\"` Source int64 `json:\"source\"` Data [] byte `json:\"data\"` }","title":"StdSignBytes"},{"location":"encoding.html#canonical-bytes-for-signing","text":"A transaction signature is not formed from the Amino-encoded transaction bytes themselves. Rather, a canonical representation of the transaction is generated in JSON format for signing. This would allow for clients to sign a transaction off-chain, for example, with a hardware HSM device like a Ledger, or within a micro-service in an algorithmic trading system. An external system will not have to understand Amino encoding to be able to approve of the transaction's content and produce the signed JSON string. The canonical bytes for signing are generated from the StdSignBytes method. It produces a JSON string similar to the format below (formatted for clarity): { \"sequence\" : \"64\" , \"account_number\" : \"12\" , \"data\" : null , \"chain_id\" : \"chain-bnb\" , \"memo\" : \"smiley\" , \"msgs\" : [ { \"inputs\" : [ { \"coins\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"200000000\" } ], \"address\" : \"bnc1hgm0p7khfk85zpz5v0j8wnej3a90w7098fpxyh\" } ], \"outputs\" : [ { \"address\" : \"bnc1cku54wwn66w2rkgs3h6v5zxrwtzyew8chcl720\" , \"coins\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"200000000\" } ] } ] } ], \"source\" : \"1\" } This JSON string, with all whitespace removed and keys sorted in alphabetical order , is signed with the private key of the sender. This signature is then attached to the StdTx structure described in the above section. Please note that the transaction broadcasted to the blockchain is not JSON - the JSON is merely used as a canonical representation to generate the signature. The next section describes how the generated signature is attached to a transaction.","title":"Canonical Bytes for Signing"},{"location":"encoding.html#standard-signature","text":"The sender's signature is stored in the Standard Transaction data via a Standard Signature , as shown below. This structure is included in the StdTx (see above). Please note that StdSignature itself doesn't have type prefix, while the PubKey does. message StdSignature { uint64 SIZE - OF - ENCODED // varint encoded length of the structure after encoding // please note there is no type prefix for StdSignature message PubKey { 0xEB5AE987 // hardcoded, object type prefix in 4 bytes uint64 SIZE - OF - ENCODED // varint encoded length of the bytes below bytes // no name or field id, just encode the bytes } PubKey pub_key // public key bytes of the signer address bytes signature // signature bytes, please check the chain access section for signature generation int64 account_number // another identifier of signer, which can be read from chain by account REST API or RPC int64 sequence // sequence number for the next transaction of the client, which can be read from the chain by account REST API or RPC. Please check the chain access section for details. }","title":"Standard Signature"},{"location":"encoding.html#message-types","text":"Messages represent the individual operations possible on Genesys Chain, and these can be inserted into the StdTx.msgs field. Message types are otherwise known as \"transaction types\", and these terms are used interchangebly in this document and in our technical documentation. So far every StdTx transaction \"container\" can only contain one \"message\".","title":"Message Types"},{"location":"encoding.html#transfer","text":"Transfer is the transaction used for transferring funds to different addresses. // please note the field name is the JSON name. message Send { 0x2A2C87FA // hardcoded, object type prefix in 4 bytes message Token { string denom int64 amount } message Input { bytes address repeated Token coins } message Output { bytes address repeated Token coins } repeated Input inputs repeated Output outputs }","title":"Transfer"},{"location":"encoding.html#neworder","text":"NewOrder transaction will create a new order to buy or sell tokens on GSYS DEX. // please note the field name is the JSON name. message NewOrder { 0xCE6DC043 // hardcoded, object type prefix in 4 bytes bytes sender // order originating address string id // order id, please check the Order ID section below for details. string symbol // symbol for trading pair in full name of the token int64 ordertype // only accept 2 for now, meaning limit order int64 side // 1 for buy and 2 fory sell int64 price // price of the order, which is the real price multiplied by 1e8 (10^8) and rounded to integer int64 quantity // quantity of the order, which is the real quantity multiplied by 1e8 (10^8) and rounded to integer int64 timeinforce // 1 for Good Till Expire(GTE) order and 3 for Immediate Or Cancel (IOC) }","title":"NewOrder"},{"location":"encoding.html#order-id","text":"Order ID is unique across the world. It is generated by sender and acknowledged by GSYS DEX. The current implementation is composed from 3 parts: Sender address in HEX format, without human-readable prefix A dash sign: - Sequence number E.g. 40C2979694BBC961023D1D27BE6FC4D21A9FEBE6-5","title":"Order ID"},{"location":"encoding.html#cancel","text":"Cancel transactions (cancel the outstanding/unfilled) orders from the GSYS DEX. After cancel success, the locked quantity on the orders will return back to the originating address balance and become free to use, i.e. transfer or send new orders. // please note the field name is the JSON name. message CancelOrder { 0x166E681B // hardcoded, object type prefix in 4 bytes bytes sender // order originating address string symbol // symbol for trading pair in full name of the token string refid // order id of the order to cancel }","title":"Cancel"},{"location":"encoding.html#freeze","text":"Freeze transaction will move the amount of the tokens into a frozen state, in which they cannot be used for transfers or sending new orders. // please note the field name is the JSON name. message TokenFreeze { 0xE774B32D // hardcoded, object type prefix in 4 bytes bytes from // owner address string symbol // token symbol, in full name with \"-\" suffix int64 amount // amount of tokens to freeze }","title":"Freeze"},{"location":"encoding.html#unfreeze","text":"Unfreeze will reversely turn the amount of frozen tokens back to free state. // please note the field name is the JSON name. message TokenUnfreeze { 0x6515FF0D // hardcoded, object type prefix in 4 bytes bytes from // owner address string symbol // token symbol, in full name with \"-\" suffix int64 amount // amount of tokens to unfreeze }","title":"Unfreeze"},{"location":"encoding.html#vote","text":"Vote transactions for proposals. // please note the field name is the JSON name. message Vote { 0xA1CADD36 // hardcoded, object type prefix in 4 bytes int64 proposal_id // ID of the proposal bytes voter // address of the voter uint64 option // option from OptionSet chosen by the voter } Below are options for option : OptionYes = 0x01 // yes OptionAbstain = 0x02 // abstain OptionNo = 0x03 // no OptionNoWithVeto = 0x04 // no with veto","title":"Vote"},{"location":"encoding.html#issue","text":"Issue (create) new asset on Genesys Chain. message IssueTokenValue { 0x17EFAB80 // hardcoded, object type prefix in 4 bytes bytes from // issuer's address string name // token name string symbol // token symbol string total_supply // total supply bool mintable // is mintable }","title":"Issue"},{"location":"encoding.html#mint","text":"Mint is used to increase the total supply of a token. message Mint { 0x467E0829 // hardcoded, object type prefix in 4 bytes bytes from // sender's address string symbol string // token symbol int64 amount // increase amount }","title":"Mint"},{"location":"encoding.html#burn","text":"Burn is used to decrease the total supply of a token. message TokenBurn { 0x7ED2D2A0 // hardcoded, object type prefix in 4 bytes bytes from // sender's address string symbol string // token symbol int64 amount // increase amount }","title":"Burn"},{"location":"encoding.html#list","text":"List is used to add a new trading pair. message DexList { 0xB41DE13F // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 proposal_id // id of corresponding proposal string base_asset_symbol // token symbol of base asset string quote_asset_symbol // token symbol of quote asset int64 init_price // init price of the new token }","title":"List"},{"location":"encoding.html#submit-proposal","text":"Submit proposal is used to create a proposal for validators about adding trading pairs message Submit { 0xB42D614E // hardcoded, object type prefix in 4 bytes string title // Title of the proposal string description // Description of the proposal byte proposal_type // Type of proposal. Initial set {PlainTextProposal, SoftwareUpgradeProposal,ListTradingPair, FixedFeeParams} bytes proposer // Address of the proposer message Coin { string denom int64 amount } int64 VotingPeriod // Length of the voting period (s) }","title":"Submit Proposal"},{"location":"encoding.html#deposit","text":"Deposit is used to increase the total deposit of a proposal. message Deposit { 0xA18A56E5 // hardcoded, object type prefix in 4 bytes int64 ProposalID // ID of the proposal bytes Depositer // Address of the depositer message Coin { string denom int64 amount } }","title":"Deposit"},{"location":"encoding.html#set-account-flags","text":"You can set the flag value of your account. message SetAccountFlags { 0xBEA6E301 // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 flag // account flag }","title":"Set Account Flags"},{"location":"encoding.html#time-lock","text":"You can only lock tokens on your own account for a certain period of time. message Timerelock { 0x07921531 // hardcoded, object type prefix in 4 bytes bytes from // sender's address string description // Description of the lock message Coin { string denom int64 amount } repeated Coin amount int64 lock_time // lock time }","title":"Time-lock"},{"location":"encoding.html#time-unlock","text":"You can unlock tokens on your own account after a certain period of time. message Timeunlock { 0xC4050C6C // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 id // lock time id }","title":"Time-unlock"},{"location":"encoding.html#time-relock","text":"You can relock tokens on your own account after a certain period of time. message Timerelock { 0x504711DA // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 Id // lock time id string description // Description of the lock message Coin { string denom int64 amount } repeated Coin amount int64 lock_time // lock time }","title":"Time-relock"},{"location":"encoding.html#htlt","text":"Hash Timer Locked Transfer (HTLT) is a new transaction type on Genesys Chain, to serve as HGSYS in the first step of Atomic Swap message HTLT { 0xB33F9A24 // hardcoded, object type prefix in 4 bytes bytes from // sender's address bytes to // receiver's address string recipient_other_chain string sender_other_chain bytes random_number_hash int64 timestamp message Coin { string denom int64 amount } repeated Coin amount string expected_income int64 height_span bool cross_chain }","title":"HTLT"},{"location":"encoding.html#deposit-htlt","text":"Deposit Hash Timer Locked Transfer is to lock new BEP2 asset to an existed HTLT which is for single chain atomic swap. message DepositHTLT { 0x63986496 // hardcoded, object type prefix in 4 bytes bytes from // sender's address message Coin { string denom int64 amount } repeated Coin amount bytes swap_id }","title":"Deposit HTLT"},{"location":"encoding.html#claim-htlt","text":"Claim Hash Timer Locked Transfer is to claim the locked asset by showing the random number value that matches the hash. Each HTLT locked asset is guaranteed to be release once. message ClaimHTLTMsg { 0xC1665300 // hardcoded, object type prefix in 4 bytes bytes from // sender's address bytes swap_id bytes random_number }","title":"Claim HTLT"},{"location":"encoding.html#refund-htlt","text":"Refund Hash Timer Locked Transfer is to refund the locked asset after timelock is expired. message RefundHTLTMsg { 0x3454A27C // hardcoded, object type prefix in 4 bytes bytes from // sender's address bytes swap_id","title":"Refund HTLT"},{"location":"fullnodeissue.html","text":"Common Issues When Running a Full Node How to monitor your full node syncing process? You can check the current height of full node by visiting localhost:26657/status You can check the log info in your log under your $BNCHOME. Monitor the output with: tail -f $BNCHOME/bnc.log Common Issues If you start running a full node from scratch, you are likely to encounter the following issues: AppHash Confliction Error Log panic: Tendermint state.AppHash does not match AppHash after replay. Got XXXXXXX, expected 251DF08F2BA7824F0875D33992CF03EA35106DDD34B3A9FE4EFA0B73CDD2FE14 This error is caused by a consensus issue and thus bnbchaind will panic. Solution To solve this issue, make sure that you have downloaded the correct genesis file , config.toml and app.toml . If you replaced the genesis file, then you need to do a node reset. To reset node: rm $BNCHOME/data rm $BNCHOME/config/priv_validator_key.json Then, start again. Peer connection error Error log: E[2019-04-17|23:52:24.069] Connection failed @ recvRoutine (reading byte) module=p2p peer=[aea74b16d28d06cbfbb1179c177e8cd71315cce4@54.64.99.130:27146](http://aea74b16d28d06cbfbb1179c177e8cd71315cce4@54.64.99.130:27146)conn=MConn{[52.199.237.19:27146](http://52.199.237.19:27146)} err=EOF E[2019-04-17|23:52:24.070] Stopping peer for error module=p2p peer=&quot;Peer{MConn{[52.199.237.19:27146](http://52.199.237.19:27146)} aea74b16d28d06cbfbb1179c177e8cd71315cce4 out}&quot; err=EOF This error is caused by the handshake failing between two peers. Solution To solve this problem, you need to make sure node_key.json is under $BNCHOME/config and nodes will try to re-connect automatically, so this issue should not persist. Connection Timeout Error log Dialing failed module=pex addr=2c1fa9c1698961da38d8cd50da9fe8b4bc433c50@34.202.245.91:26856 err=&quot;dial tcp 34.202.245.91:26856: i/o timeout&quot; attempts=3 Solution Check your internet connection and make sure it is stable. Out of memory Error Log fatal error: out of memory Solution Your machine must have more than 8 GB of memory , otherwise, it will not handle DB restoration during state sync. No priv_validator_state.json after reset Error log open /Users/.bnbchaind/data/priv_validator_state.json: no such file or directory Solution Delete both priv_validator_state.json & node_key.json file and data folder if you want to reset your full node. bnbchaind crashes because of too many open files The default number of files Linux can open (per-process) is 1024 . bnbchaind is likely to open more than 1024 files. This causes the process to crash. A quick fix is to run ulimit -n 65535 (increase the number of open files allowed) and then restart the process with: bnbchaind start Verify the number of open files: ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 3829 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 65535 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 3829 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited Please note that open files are different now. Forget to Upgrade The Genesys Chain has a hardfork upgrade and if you failed to upgrade your fullnode to the latest version, bnbchaind process will stop and even if you restart with the latest version, the following error will appear: panic: Tendermint state.AppHash does not match AppHash after replay. Got , expected 393887B67F69B19CAB5C48FB87B4966018ABA893FB3FFD241C0A94D2C8668DD2 goroutine 1 [running]: github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus.checkAppHash(0xa, 0x0, 0xc000bd8c56, 0x6, 0xc000b247c0, 0x12, 0x14e7bf9, 0x8592eb, 0xc000b247e0, 0x20, ...) /Users/huangsuyu/go/src/github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus/replay.go:464 +0x213 github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus.(*Handshaker).ReplayBlocks(0xc000b37980, 0xa, 0x0, 0xc000bd8c56, 0x6, 0xc000b247c0, 0x12, 0x14e7bf9, 0x8592eb, 0xc000b247e0, ...) To recover from the state conflict error, you need to: Backup your home directory, (default is ~/.bnbchaind) Download the tool: state-recover Get the height of upgrade, this height will be announced in the upgrade announcement on the forum. For example, if it's announced as 5000 in the forum and run the following command will make your full node recover to the last block before the upgrade, and that is 4999 : ./state_recover 4999 <your_home_path> Restart with the latest version of bnbchaind bnbchaind start & bnbchaind is not properly killed If you started your bnbchaind process after it was not properly killed. You will see the following error: panic: ERROR: Codespace: 5 Code: 9 Message: \"Initial ProposalID already set\" To recover, please reset your node and restart: bnbchaind unsafe-reset-all --home<your-home-dir> Cannot start bnbchaind If you do not download the binaries completely, you will see the following message: ./bnbchaind: line 1: version: command not found ./bnbchaind: line 2: oid: command not found /Library/Developer/CommandLineTools/usr/bin/size: 45160816 No such file or directory Since all the binaries are stored in git lfs , you will see this error is the binary is not complete. Please use this script to download the binaries or use git lfs clone . Cannot query a specific block Once you have your own node running, you can start querying from it. But sometimes you may not be ablt to get the information you want. For example: curl 'localhost:27147/block?height=10' The reason is because your node is using statesync to catch up. In this way, it will not store all the history blocks before the snapshot height it got. You can only query blocks after that snapshot height. To enable query history blocks, you need to use fast-sync","title":"Common Issues When Running a Full Node"},{"location":"fullnodeissue.html#common-issues-when-running-a-full-node","text":"","title":"Common Issues When Running a Full Node"},{"location":"fullnodeissue.html#how-to-monitor-your-full-node-syncing-process","text":"You can check the current height of full node by visiting localhost:26657/status You can check the log info in your log under your $BNCHOME. Monitor the output with: tail -f $BNCHOME/bnc.log","title":"How to monitor your full node syncing process?"},{"location":"fullnodeissue.html#common-issues","text":"If you start running a full node from scratch, you are likely to encounter the following issues:","title":"Common Issues"},{"location":"fullnodeissue.html#apphash-confliction","text":"Error Log panic: Tendermint state.AppHash does not match AppHash after replay. Got XXXXXXX, expected 251DF08F2BA7824F0875D33992CF03EA35106DDD34B3A9FE4EFA0B73CDD2FE14 This error is caused by a consensus issue and thus bnbchaind will panic. Solution To solve this issue, make sure that you have downloaded the correct genesis file , config.toml and app.toml . If you replaced the genesis file, then you need to do a node reset. To reset node: rm $BNCHOME/data rm $BNCHOME/config/priv_validator_key.json Then, start again.","title":"AppHash Confliction"},{"location":"fullnodeissue.html#peer-connection-error","text":"Error log: E[2019-04-17|23:52:24.069] Connection failed @ recvRoutine (reading byte) module=p2p peer=[aea74b16d28d06cbfbb1179c177e8cd71315cce4@54.64.99.130:27146](http://aea74b16d28d06cbfbb1179c177e8cd71315cce4@54.64.99.130:27146)conn=MConn{[52.199.237.19:27146](http://52.199.237.19:27146)} err=EOF E[2019-04-17|23:52:24.070] Stopping peer for error module=p2p peer=&quot;Peer{MConn{[52.199.237.19:27146](http://52.199.237.19:27146)} aea74b16d28d06cbfbb1179c177e8cd71315cce4 out}&quot; err=EOF This error is caused by the handshake failing between two peers. Solution To solve this problem, you need to make sure node_key.json is under $BNCHOME/config and nodes will try to re-connect automatically, so this issue should not persist.","title":"Peer connection error"},{"location":"fullnodeissue.html#connection-timeout","text":"Error log Dialing failed module=pex addr=2c1fa9c1698961da38d8cd50da9fe8b4bc433c50@34.202.245.91:26856 err=&quot;dial tcp 34.202.245.91:26856: i/o timeout&quot; attempts=3 Solution Check your internet connection and make sure it is stable.","title":"Connection Timeout"},{"location":"fullnodeissue.html#out-of-memory","text":"Error Log fatal error: out of memory Solution Your machine must have more than 8 GB of memory , otherwise, it will not handle DB restoration during state sync.","title":"Out of memory"},{"location":"fullnodeissue.html#no-priv_validator_statejson-after-reset","text":"Error log open /Users/.bnbchaind/data/priv_validator_state.json: no such file or directory Solution Delete both priv_validator_state.json & node_key.json file and data folder if you want to reset your full node.","title":"No priv_validator_state.json after reset"},{"location":"fullnodeissue.html#bnbchaind-crashes-because-of-too-many-open-files","text":"The default number of files Linux can open (per-process) is 1024 . bnbchaind is likely to open more than 1024 files. This causes the process to crash. A quick fix is to run ulimit -n 65535 (increase the number of open files allowed) and then restart the process with: bnbchaind start Verify the number of open files: ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 3829 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 65535 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 3829 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited Please note that open files are different now.","title":"bnbchaind crashes because of too many open files"},{"location":"fullnodeissue.html#forget-to-upgrade","text":"The Genesys Chain has a hardfork upgrade and if you failed to upgrade your fullnode to the latest version, bnbchaind process will stop and even if you restart with the latest version, the following error will appear: panic: Tendermint state.AppHash does not match AppHash after replay. Got , expected 393887B67F69B19CAB5C48FB87B4966018ABA893FB3FFD241C0A94D2C8668DD2 goroutine 1 [running]: github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus.checkAppHash(0xa, 0x0, 0xc000bd8c56, 0x6, 0xc000b247c0, 0x12, 0x14e7bf9, 0x8592eb, 0xc000b247e0, 0x20, ...) /Users/huangsuyu/go/src/github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus/replay.go:464 +0x213 github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus.(*Handshaker).ReplayBlocks(0xc000b37980, 0xa, 0x0, 0xc000bd8c56, 0x6, 0xc000b247c0, 0x12, 0x14e7bf9, 0x8592eb, 0xc000b247e0, ...) To recover from the state conflict error, you need to: Backup your home directory, (default is ~/.bnbchaind) Download the tool: state-recover Get the height of upgrade, this height will be announced in the upgrade announcement on the forum. For example, if it's announced as 5000 in the forum and run the following command will make your full node recover to the last block before the upgrade, and that is 4999 : ./state_recover 4999 <your_home_path> Restart with the latest version of bnbchaind bnbchaind start &","title":"Forget to Upgrade"},{"location":"fullnodeissue.html#bnbchaind-is-not-properly-killed","text":"If you started your bnbchaind process after it was not properly killed. You will see the following error: panic: ERROR: Codespace: 5 Code: 9 Message: \"Initial ProposalID already set\" To recover, please reset your node and restart: bnbchaind unsafe-reset-all --home<your-home-dir>","title":"bnbchaind is not properly killed"},{"location":"fullnodeissue.html#cannot-start-bnbchaind","text":"If you do not download the binaries completely, you will see the following message: ./bnbchaind: line 1: version: command not found ./bnbchaind: line 2: oid: command not found /Library/Developer/CommandLineTools/usr/bin/size: 45160816 No such file or directory Since all the binaries are stored in git lfs , you will see this error is the binary is not complete. Please use this script to download the binaries or use git lfs clone .","title":"Cannot start bnbchaind"},{"location":"fullnodeissue.html#cannot-query-a-specific-block","text":"Once you have your own node running, you can start querying from it. But sometimes you may not be ablt to get the information you want. For example: curl 'localhost:27147/block?height=10' The reason is because your node is using statesync to catch up. In this way, it will not store all the history blocks before the snapshot height it got. You can only query blocks after that snapshot height. To enable query history blocks, you need to use fast-sync","title":"Cannot query a specific block"},{"location":"get-extra-data-from-fullnode.html","text":"Get Extra Data From Your Full Node This document is intended for developers who are interested in transactions, order books, account changes, fee charges in every block and would like to build their own downstream services of the full node. Please refer to Running Full Node , if you still haven't deployed a full node. Publish Different Messages to Local Files You can set the publishLocal option to true in nodebinary/fullnode/{network}/node/app.toml . The full node will append the messages each block published to {fullnode home}/marketdata/marketdata.json (each line is a json object for a topic and height), and you can consume them in your own apps. The messages types are explained below. Note: only block messages after this option get turned on can be saved. This function won't make up messages for already saved blocks. Set Kafka Broker Version Since the release of bnbchaind v0.6.3 , you can customize the version of kafka broker in app.toml . The default value is v2.1.0 : The recommended version 2.1.0 and the minimal version is 0.8.2.0 kafkaVersion = \"2.1.0\" If you are using another version of Kafka, please test the compatibility first. 1. OrderUpdates You can set the publishOrderUpdates option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the trades that have been filled, orders that changed and proposals that been submitted. Example: All those extra info can also be found in exported data from your fullnode. Changes In trade data structure, there are five new fields: SSrc , BSrc , SSingleFee , BSingleFee and TickerType . SSrc : Source code of Sell order transaction BSrc : Source code of Buy order transaction SSingleFee : fee of matched sell order BSingleFee : fee of matched buy order TickerType : ticker type In Order data structure, there is a new field: singlefee . This is used to show the fee of this order. Status is used to indicate the current status of this order. Namely there are 9 status: 0 for Acknowledge; 1 for Canceled ; 2 for Expired , 3 for IocNoFill, 4 for IocExpire, 5 for PartialFill, 6 for FullyFill, 7 for FailedBlocking, 8 for FailedMatching. For example: { \"Height\" : 36384232 , \"Timestamp\" : 1569196830136718300 , \"NumOfMsgs\" : 10 , \"Trades\" : { \"NumOfMsgs\" : 2 , \"Trades\" : [ { \"Id\" : \"36384232-0\" , \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Price\" : 345282 , \"Qty\" : 23200000000 , \"Sid\" : \"5F511BE6120CE2F92877F3A1E92D408CE56A5CCC-62632\" , \"Bid\" : \"4C28D006CF8061E05EEE50D17D8B2375CE09E7EC-71967\" , \"Sfee\" : \"GSYS:32042\" , \"Bfee\" : \"GSYS:32042\" , \"SSrc\" : 0 , \"BSrc\" : 0 , \"SSingleFee\" : \"GSYS:32042\" , \"BSingleFee\" : \"GSYS:32042\" , \"TickType\" : 5 , \"SAddr\" : \"bnb1tag3hesjpn30j2rh7ws7jt2q3njk5hxvsx023c\" , \"BAddr\" : \"bnb1fs5dqpk0sps7qhhw2rghmzerwh8qnelv7tyat8\" }, { \"Id\" : \"36384232-1\" , \"Symbol\" : \"EQL-586_GSYS\" , \"Price\" : 4798 , \"Qty\" : 110000000000 , \"Sid\" : \"610BFE81695EFD89B19D27D1E8C17D57C0239C66-6367\" , \"Bid\" : \"B3CEA961E95C4F104A791F6C33DB83458577BA76-5471\" , \"Sfee\" : \"GSYS:2111\" , \"Bfee\" : \"GSYS:2111\" , \"SSrc\" : 0 , \"BSrc\" : 0 , \"SSingleFee\" : \"GSYS:2111\" , \"BSingleFee\" : \"GSYS:2111\" , \"TickType\" : 2 , \"SAddr\" : \"bnb1vy9laqtftm7cnvvaylg73sta2lqz88rxs72mx7\" , \"BAddr\" : \"bnb1k082jc0ft383qjnerakr8kurgkzh0wnk8gulnj\" } ] }, \"Orders\" : { \"NumOfMsgs\" : 8 , \"Orders\" : [ { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"37D9383E6AD9AFEF6C5D8066ABA3ACA8C75D9F39-1724193\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1xlvns0n2mxh77mzaspn2hgav4rr4m8eerfju38\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 344271 , \"Qty\" : 89600000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 0 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"D74A96022A2F090D7D739C1C6716481A215E0F7F10C430C28290758E9DC4EF73\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"EQL-586_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"B3CEA961E95C4F104A791F6C33DB83458577BA76-5471\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1k082jc0ft383qjnerakr8kurgkzh0wnk8gulnj\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 4798 , \"Qty\" : 110000000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 110000000000 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"792BA5F932813F9C006075EAA090D82305AD049DDC570271FA8515339A874E97\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"4C28D006CF8061E05EEE50D17D8B2375CE09E7EC-71967\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1fs5dqpk0sps7qhhw2rghmzerwh8qnelv7tyat8\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 345283 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 23200000000 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"574CB6DAF26C5D1A465A8D86760FFDFF3DA5946F9C02EB5B89051A8120844523\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"5F511BE6120CE2F92877F3A1E92D408CE56A5CCC-62632\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1tag3hesjpn30j2rh7ws7jt2q3njk5hxvsx023c\" , \"Side\" : 2 , \"OrderType\" : 2 , \"Price\" : 345282 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 23200000000 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"9D8EF7CEAE5D2CDC4026F6306296D57764BB80099B3A65865971D8D71399B6EA\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"EQL-586_GSYS\" , \"Status\" : 5 , \"OrderId\" : \"610BFE81695EFD89B19D27D1E8C17D57C0239C66-6367\" , \"TradeId\" : \"36384232-1\" , \"Owner\" : \"bnb1vy9laqtftm7cnvvaylg73sta2lqz88rxs72mx7\" , \"Side\" : 2 , \"OrderType\" : 2 , \"Price\" : 4798 , \"Qty\" : 230000000000 , \"LastExecutedPrice\" : 4798 , \"LastExecutedQty\" : 110000000000 , \"CumQty\" : 110000000000 , \"Fee\" : \"GSYS:2111\" , \"OrderCreationTime\" : 1569196786802324000 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"EDF132EBDA03382D2BFF7EF58CDE574D4E3FB9622BD8BCF12BA6ABECD692BA5C\" , \"SingleFee\" : \"GSYS:2111\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 6 , \"OrderId\" : \"4C28D006CF8061E05EEE50D17D8B2375CE09E7EC-71967\" , \"TradeId\" : \"36384232-0\" , \"Owner\" : \"bnb1fs5dqpk0sps7qhhw2rghmzerwh8qnelv7tyat8\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 345283 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 345282 , \"LastExecutedQty\" : 23200000000 , \"CumQty\" : 23200000000 , \"Fee\" : \"GSYS:32042\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"574CB6DAF26C5D1A465A8D86760FFDFF3DA5946F9C02EB5B89051A8120844523\" , \"SingleFee\" : \"GSYS:32042\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 6 , \"OrderId\" : \"5F511BE6120CE2F92877F3A1E92D408CE56A5CCC-62632\" , \"TradeId\" : \"36384232-0\" , \"Owner\" : \"bnb1tag3hesjpn30j2rh7ws7jt2q3njk5hxvsx023c\" , \"Side\" : 2 , \"OrderType\" : 2 , \"Price\" : 345282 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 345282 , \"LastExecutedQty\" : 23200000000 , \"CumQty\" : 23200000000 , \"Fee\" : \"GSYS:32042\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"9D8EF7CEAE5D2CDC4026F6306296D57764BB80099B3A65865971D8D71399B6EA\" , \"SingleFee\" : \"GSYS:32042\" }, { \"Symbol\" : \"EQL-586_GSYS\" , \"Status\" : 6 , \"OrderId\" : \"B3CEA961E95C4F104A791F6C33DB83458577BA76-5471\" , \"TradeId\" : \"36384232-1\" , \"Owner\" : \"bnb1k082jc0ft383qjnerakr8kurgkzh0wnk8gulnj\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 4798 , \"Qty\" : 110000000000 , \"LastExecutedPrice\" : 4798 , \"LastExecutedQty\" : 110000000000 , \"CumQty\" : 110000000000 , \"Fee\" : \"GSYS:2111\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"792BA5F932813F9C006075EAA090D82305AD049DDC570271FA8515339A874E97\" , \"SingleFee\" : \"GSYS:2111\" } ] }, \"Proposals\" : { \"NumOfMsgs\" : 0 , \"Proposals\" : null }, \"StakeUpdates\" : { \"NumOfMsgs\" : 0 , \"CompletedUnbondingDelegations\" : null } } 2. AccountBalance You can set the publishAccountBalance option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the changed accounts. Example { Owner: string, Fee: string, Balances: []{ Asset: string, Free: int64, Frozen: int64, Locked: int64 } } 3. OrderBook You can set the publishOrderBook option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all order book changes. Example { Height: int64, Timestamp: int64, NumOfMsgs: int, Books: []{ Symbol: string, Buys: []{ Price: int64, LastQty: int64 }, Sells: []{ Price: int64, LastQty: int64 } } } 4. BlockFee You can set the publishBlockFee option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the block fee charged. Example { Height: int64, Fee: string, Validators: []string } 5. Transfers You can set the publishTransfer option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the transfer transactions. Example { Height: int64, Num: int, Timestamp: int64, Transfers: []{ TxHash: string, Memo: string, From: string, To: []{ Addr: string, Coins: []{ Denom: string, Amount: int64 } } } } 6. Staking Record You can set the publishStaking option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about staking. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"validators\": []{ \"feeAddr\": string, \"operatorAddr\": string, \"consAddr\": string, \"jailed\": bool, \"status\": string, \"tokens\": int64, \"delegatorShares\":int64, \"description\":{ \"moniker\": string, \"identity\": string, \"website\": string, \"details\": string, }, \"bondHeight\": int64, \"bondIntraTxCounter\": int, \"commission\":{ \"rate\": int64, \"maxRate\": int64, \"maxChangeRate\": int64, \"updateTime\": int64, }, \"distributionAddr\":string, \"sideChainId\": string, \"sideConsAddr\": string, \"sideFeeAddr\": string }, \"removedValidators\": map[string][]string, //key: chain id, value: operatorAddr \"delegatioins\": map[string][]{ \"delegator\": string, \"validator\": string, \"shares\": int64 }, // map key: chain-id \"unBondingDelegations\": map[string][]{ \"delegator\": string, \"validator\": string, \"creationHeight\": int64, \"minTime\": int64, \"initialBalance\": { \"denom\": string, \"amount\": int64 }, \"balance\": { \"denom\": string, \"amount\": int64 } }, // map key: chain id \"reDelegations\": map[string][]{ \"delegator\": string, \"srcValidator\": string, \"dstValidator\": string, \"creationHeight\": int64, \"sharesSrc\": int64, \"sharesDst\": int64, \"initialBalance\": { \"denom\": string, \"amount\": int64 }, \"balance\": { \"denom\": string, \"amount\": int64 }, \"minTime\": int64 }, // map key: chain id \"completedUBDs\": map[string][]{ \"validator\": string, \"delegator\": string, \"amount\": { \"denom\": string, \"amount\": int64 } }, \"completedREDs\": map[string][]{ \"delegator\": string, \"srcValidator\": string, \"dstValidator\": string }, \"delegateEvents\": map[string][]{ \"validator\": string, \"delegator\": string, \"amount\": { \"denom\": string, \"amount\": int64 }, \"txHash\": string }, \"unDelegateEvents\": map[string][]{ \"validator\": string, \"delegator\": string, \"amount\": { \"denom\": string, \"amount\": int64 }, \"txHash\": string }, \"reDelegateEvents\": map[string][]{ \"delegator\": string, \"srcValidator\": string, \"dstValidator\": string, \"amount\": { \"denom\": string, \"amount\": int64 }, \"txHash\": string }, \"electedValidators\": map[string][]{ \"feeAddr\": string, \"operatorAddr\": string, \"consAddr\": string, \"jailed\": bool, \"status\": string, \"tokens\": int64, \"delegatorShares\":int64, \"description\":{ \"moniker\": string, \"identity\": string, \"website\": string, \"details\": string, }, \"bondHeight\": int64, \"bondIntraTxCounter\": int, \"commission\":{ \"rate\": int64, \"maxRate\": int64, \"maxChangeRate\": int64, \"updateTime\": int64, }, \"distributionAddr\":string, \"sideChainId\": string, \"sideConsAddr\": string, \"sideFeeAddr\": string } } Schema { \"type\" : \"record\" , \"name\" : \"Staking\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"validators\" , \"type\" : [ \"null\" , { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Validator\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"feeAddr\" , \"type\" : \"string\" }, { \"name\" : \"operatorAddr\" , \"type\" : \"string\" }, { \"name\" : \"consAddr\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" }, { \"name\" : \"jailed\" , \"type\" : \"boolean\" }, { \"name\" : \"status\" , \"type\" : \"string\" }, { \"name\" : \"tokens\" , \"type\" : \"long\" }, { \"name\" : \"delegatorShares\" , \"type\" : \"long\" }, { \"name\" : \"description\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Description\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"moniker\" , \"type\" : \"string\" }, { \"name\" : \"identity\" , \"type\" : \"string\" }, { \"name\" : \"website\" , \"type\" : \"string\" }, { \"name\" : \"details\" , \"type\" : \"string\" } ] }}, { \"name\" : \"bondHeight\" , \"type\" : \"long\" }, { \"name\" : \"bondIntraTxCounter\" , \"type\" : \"int\" }, { \"name\" : \"commission\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Commission\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"rate\" , \"type\" : \"long\" }, { \"name\" : \"maxRate\" , \"type\" : \"long\" }, { \"name\" : \"maxChangeRate\" , \"type\" : \"long\" }, { \"name\" : \"updateTime\" , \"type\" : \"long\" } ] }}, { \"name\" : \"distributionAddr\" , \"type\" : \"string\" }, { \"name\" : \"sideChainId\" , \"type\" : \"string\" }, { \"name\" : \"sideConsAddr\" , \"type\" : \"string\" }, { \"name\" : \"sideFeeAddr\" , \"type\" : \"string\" } ] } }], \"default\" : \"null\" }, { \"name\" : \"removedValidators\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } } }], \"default\" : null }, { \"name\" : \"delegations\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Delegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"shares\" , \"type\" : \"long\" } ] } } }], \"default\" : null }, { \"name\" : \"unBondingDelegations\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"UnBondingDelgation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"creationHeight\" , \"type\" : \"long\" }, { \"name\" : \"minTime\" , \"type\" : \"long\" }, { \"name\" : \"initialBalance\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Coin\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"denom\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] }}, { \"name\" : \"balance\" , \"type\" : \"org.shree.dex.model.avro.Coin\" } ] } } }], \"default\" : null }, { \"name\" : \"reDelegations\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"ReDelegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"srcValidator\" , \"type\" : \"string\" }, { \"name\" : \"dstValidator\" , \"type\" : \"string\" }, { \"name\" : \"creationHeight\" , \"type\" : \"long\" }, { \"name\" : \"sharesSrc\" , \"type\" : \"long\" }, { \"name\" : \"sharesDst\" , \"type\" : \"long\" }, { \"name\" : \"initialBalance\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"balance\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"minTime\" , \"type\" : \"long\" } ] } } }], \"default\" : null }, { \"name\" : \"completedUBDs\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"CompletedUnbondingDelegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" } ] } } }], \"default\" : null }, { \"name\" : \"completedREDs\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"CompletedReDelegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"srcValidator\" , \"type\" : \"string\" }, { \"name\" : \"dstValidator\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"delegateEvents\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"DelegateEvent\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"txHash\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"unDelegateEvents\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"UndelegateEvent\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"txHash\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"reDelegateEvents\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"RedelegateEvent\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"srcValidator\" , \"type\" : \"string\" }, { \"name\" : \"dstValidator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"txHash\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"electedValidators\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : \"org.shree.dex.model.avro.Validator\" } }], \"default\" : null } ] } 7. Reward Distribution You can set the publishDistributeReward option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about reward distribution. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"distributions\" : map[string][]{ \"validator\": string, \"selfDelegator\": string, \"distributeAddr\": string, \"valTokens\": int64, \"totalReward\": int64, \"commission\": int64, \"rewards\": []{ \"delegator\": string, \"delegationTokens\": int64, \"reward\": int64 } } // map key: chain id } Schema { \"type\": \"record\", \"name\": \"Distribution\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\" }, { \"name\": \"timestamp\", \"type\": \"long\" }, { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"distributions\", \"type\": { \"type\": \"map\", \"values\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"DistributionData\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ {\"name\": \"validator\", \"type\": \"string\"}, {\"name\": \"selfDelegator\",\"type\": \"string\"}, {\"name\": \"distributeAddr\",\"type\": \"string\"}, {\"name\": \"valTokens\", \"type\": \"long\"}, {\"name\": \"totalReward\", \"type\": \"long\"}, {\"name\": \"commission\", \"type\": \"long\"}, {\"name\": \"rewards\", \"type\":{ \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Reward\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\":[ {\"name\": \"delegator\", \"type\": \"string\"}, {\"name\": \"delegationTokens\", \"type\": \"long\"}, {\"name\": \"reward\", \"type\": \"long\"} ] } }} ] } } } } ] } 8. Slashing You can set the publishSlashing option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about slashing. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"slashData\": map[string][]{ \"validator\": string, \"infractionType\": int, \"infractionHeight\": int64, \"jailUtil\": int64, \"slashAmount\": int64, \"toFeePool\": int64, \"submitter\": string, \"submitterReward\": int64, \"validatorsCompensation\": []{ \"address\": string, \"amount\": int64 } } } Schema { \"type\" : \"record\" , \"name\" : \"Slashing\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"slashData\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"SlashData\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"infractionType\" , \"type\" : \"int\" }, { \"name\" : \"infractionHeight\" , \"type\" : \"long\" }, { \"name\" : \"jailUtil\" , \"type\" : \"long\" }, { \"name\" : \"slashAmount\" , \"type\" : \"long\" }, { \"name\" : \"toFeePool\" , \"type\" : \"long\" }, { \"name\" : \"submitter\" , \"type\" : \"string\" }, { \"name\" : \"submitterReward\" , \"type\" : \"long\" }, { \"name\" : \"validatorsCompensation\" , \"type\" :{ \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"AllocatedAmt\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" :[ { \"name\" : \"address\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] } }} ] } } }} ] } 9. CrossTransfer You can set the publishCrossTransfer option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about cross transfer. Example { \"height\": int64, \"timestamp\": int64, \"num\": int, \"transfers\": []{ \"txhash\": string, \"type\": string, \"relayerFee\": int64, \"chainid\": string, \"from\": \"string\", \"denom\": string, \"contract\": string, \"decimals\": int, \"to\": []{ \"addr\": string, \"amount\": int64 } } } Schema { \"type\" : \"record\" , \"name\" : \"CrossTransfers\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"num\" , \"type\" : \"int\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"transfers\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Transfer\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"txhash\" , \"type\" : \"string\" }, { \"name\" : \"type\" , \"type\" : \"string\" }, { \"name\" : \"relayerFee\" , \"type\" : \"long\" }, { \"name\" : \"chainid\" , \"type\" : \"string\" }, { \"name\" : \"from\" , \"type\" : \"string\" }, { \"name\" : \"denom\" , \"type\" : \"string\" }, { \"name\" : \"contract\" , \"type\" : \"string\" }, { \"name\" : \"decimals\" , \"type\" : \"int\" }, { \"name\" : \"to\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Receiver\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"addr\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] } } } ] } } } ] } 10. SideProposal You can set the publishSideProposal option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about side proposals. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"proposals\": []{ \"id\": int64, \"chainid\": string, \"status\": string } } Schema { \"type\" : \"record\" , \"name\" : \"SideProposals\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"proposals\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Proposal\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"id\" , \"type\" : \"long\" }, { \"name\" : \"chainid\" , \"type\" : \"string\" }, { \"name\" : \"status\" , \"type\" : \"string\" } ] } } } ] } 11. BreatheBlock You can set the publichBreatheBlock option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about side proposals. Example { \"height\": int64, \"timestamp\": int64 } Schema { \"type\" : \"record\" , \"name\" : \"BreatheBlock\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" } ] } Publish Different Messages to Kafka You can set the publishKafka option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save messages that you are interested into Kafka, and you can consume them in your own apps. The message is encoded based on Avro serialization system. Their schemas are shown below: OrderUpdates : { \"type\" : \"record\" , \"name\" : \"ExecutionResults\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"trades\" , \"type\" : [ \"null\" , { \"type\" : \"record\" , \"name\" : \"Trades\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"trades\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Trade\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"symbol\" , \"type\" : \"string\" }, { \"name\" : \"id\" , \"type\" : \"string\" }, { \"name\" : \"price\" , \"type\" : \"long\" }, { \"name\" : \"qty\" , \"type\" : \"long\" }, { \"name\" : \"sid\" , \"type\" : \"string\" }, { \"name\" : \"bid\" , \"type\" : \"string\" }, { \"name\" : \"sfee\" , \"type\" : \"string\" }, { \"name\" : \"bfee\" , \"type\" : \"string\" }, { \"name\" : \"saddr\" , \"type\" : \"string\" }, { \"name\" : \"baddr\" , \"type\" : \"string\" } ] } } } ] }], \"default\" : null }, { \"name\" : \"orders\" , \"type\" : [ \"null\" , { \"type\" : \"record\" , \"name\" : \"Orders\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"orders\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Order\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"symbol\" , \"type\" : \"string\" }, { \"name\" : \"status\" , \"type\" : \"string\" }, { \"name\" : \"orderId\" , \"type\" : \"string\" }, { \"name\" : \"tradeId\" , \"type\" : \"string\" }, { \"name\" : \"owner\" , \"type\" : \"string\" }, { \"name\" : \"side\" , \"type\" : \"int\" }, { \"name\" : \"orderType\" , \"type\" : \"int\" }, { \"name\" : \"price\" , \"type\" : \"long\" }, { \"name\" : \"qty\" , \"type\" : \"long\" }, { \"name\" : \"lastExecutedPrice\" , \"type\" : \"long\" }, { \"name\" : \"lastExecutedQty\" , \"type\" : \"long\" }, { \"name\" : \"cumQty\" , \"type\" : \"long\" }, { \"name\" : \"fee\" , \"type\" : \"string\" }, { \"name\" : \"orderCreationTime\" , \"type\" : \"long\" }, { \"name\" : \"transactionTime\" , \"type\" : \"long\" }, { \"name\" : \"timeInForce\" , \"type\" : \"int\" }, { \"name\" : \"currentExecutionType\" , \"type\" : \"string\" }, { \"name\" : \"txHash\" , \"type\" : \"string\" } ] } } } ] }], \"default\" : null }, { \"name\" : \"proposals\" , \"type\" : [ \"null\" , { \"type\" : \"record\" , \"name\" : \"Proposals\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"proposals\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Proposal\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"id\" , \"type\" : \"long\" }, { \"name\" : \"status\" , \"type\" : \"string\" } ] } } } ] }], \"default\" : null }, { \"name\" : \"stakeUpdates\" , \"type\" : [ \"null\" , { \"type\" : \"record\" , \"name\" : \"StakeUpdates\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"completedUnbondingDelegations\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"CompletedUnbondingDelegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Coin\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"denom\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] } } ] } } } ] }], \"default\" : null } ] } OrderBooksSchema : { \"type\": \"record\", \"name\": \"Books\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\" }, { \"name\": \"timestamp\", \"type\": \"long\" }, { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"books\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"OrderBookDelta\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"symbol\", \"type\": \"string\" }, { \"name\": \"buys\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"PriceLevel\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"price\", \"type\": \"long\" }, { \"name\": \"lastQty\", \"type\": \"long\" } ] } } }, { \"name\": \"sells\", \"type\": { \"type\": \"array\", \"items\": \"com.company.PriceLevel\" } } ] } }, \"default\": [] } ] } AccountBalanceSchema : { \"type\" : \"record\" , \"name\" : \"Accounts\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Account\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"owner\" , \"type\" : \"string\" }, { \"name\" : \"fee\" , \"type\" : \"string\" }, { \"name\" : \"balances\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"AssetBalance\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"asset\" , \"type\" : \"string\" }, { \"name\" : \"free\" , \"type\" : \"long\" }, { \"name\" : \"frozen\" , \"type\" : \"long\" }, { \"name\" : \"locked\" , \"type\" : \"long\" } ] } } } ] } }, \"default\" : [] } ] } BlockFeeSchema : { \"type\" : \"record\" , \"name\" : \"BlockFee\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"fee\" , \"type\" : \"string\" }, { \"name\" : \"validators\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" }} ] } TransfersSchema : { \"type\" : \"record\" , \"name\" : \"Transfers\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"num\" , \"type\" : \"int\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"transfers\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Transfer\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"txhash\" , \"type\" : \"string\" }, { \"name\" : \"from\" , \"type\" : \"string\" }, { \"name\" : \"to\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Receiver\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"addr\" , \"type\" : \"string\" }, { \"name\" : \"coins\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Coin\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"denom\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] } } } ] } } } ] } } } ] }","title":"Get Extra Data From Your Full Node"},{"location":"get-extra-data-from-fullnode.html#get-extra-data-from-your-full-node","text":"This document is intended for developers who are interested in transactions, order books, account changes, fee charges in every block and would like to build their own downstream services of the full node. Please refer to Running Full Node , if you still haven't deployed a full node.","title":"Get Extra Data From Your Full Node"},{"location":"get-extra-data-from-fullnode.html#publish-different-messages-to-local-files","text":"You can set the publishLocal option to true in nodebinary/fullnode/{network}/node/app.toml . The full node will append the messages each block published to {fullnode home}/marketdata/marketdata.json (each line is a json object for a topic and height), and you can consume them in your own apps. The messages types are explained below. Note: only block messages after this option get turned on can be saved. This function won't make up messages for already saved blocks.","title":"Publish Different Messages to Local Files"},{"location":"get-extra-data-from-fullnode.html#set-kafka-broker-version","text":"Since the release of bnbchaind v0.6.3 , you can customize the version of kafka broker in app.toml . The default value is v2.1.0 : The recommended version 2.1.0 and the minimal version is 0.8.2.0 kafkaVersion = \"2.1.0\" If you are using another version of Kafka, please test the compatibility first.","title":"Set Kafka Broker Version"},{"location":"get-extra-data-from-fullnode.html#1-orderupdates","text":"You can set the publishOrderUpdates option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the trades that have been filled, orders that changed and proposals that been submitted. Example: All those extra info can also be found in exported data from your fullnode.","title":"1. OrderUpdates"},{"location":"get-extra-data-from-fullnode.html#changes","text":"In trade data structure, there are five new fields: SSrc , BSrc , SSingleFee , BSingleFee and TickerType . SSrc : Source code of Sell order transaction BSrc : Source code of Buy order transaction SSingleFee : fee of matched sell order BSingleFee : fee of matched buy order TickerType : ticker type In Order data structure, there is a new field: singlefee . This is used to show the fee of this order. Status is used to indicate the current status of this order. Namely there are 9 status: 0 for Acknowledge; 1 for Canceled ; 2 for Expired , 3 for IocNoFill, 4 for IocExpire, 5 for PartialFill, 6 for FullyFill, 7 for FailedBlocking, 8 for FailedMatching. For example: { \"Height\" : 36384232 , \"Timestamp\" : 1569196830136718300 , \"NumOfMsgs\" : 10 , \"Trades\" : { \"NumOfMsgs\" : 2 , \"Trades\" : [ { \"Id\" : \"36384232-0\" , \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Price\" : 345282 , \"Qty\" : 23200000000 , \"Sid\" : \"5F511BE6120CE2F92877F3A1E92D408CE56A5CCC-62632\" , \"Bid\" : \"4C28D006CF8061E05EEE50D17D8B2375CE09E7EC-71967\" , \"Sfee\" : \"GSYS:32042\" , \"Bfee\" : \"GSYS:32042\" , \"SSrc\" : 0 , \"BSrc\" : 0 , \"SSingleFee\" : \"GSYS:32042\" , \"BSingleFee\" : \"GSYS:32042\" , \"TickType\" : 5 , \"SAddr\" : \"bnb1tag3hesjpn30j2rh7ws7jt2q3njk5hxvsx023c\" , \"BAddr\" : \"bnb1fs5dqpk0sps7qhhw2rghmzerwh8qnelv7tyat8\" }, { \"Id\" : \"36384232-1\" , \"Symbol\" : \"EQL-586_GSYS\" , \"Price\" : 4798 , \"Qty\" : 110000000000 , \"Sid\" : \"610BFE81695EFD89B19D27D1E8C17D57C0239C66-6367\" , \"Bid\" : \"B3CEA961E95C4F104A791F6C33DB83458577BA76-5471\" , \"Sfee\" : \"GSYS:2111\" , \"Bfee\" : \"GSYS:2111\" , \"SSrc\" : 0 , \"BSrc\" : 0 , \"SSingleFee\" : \"GSYS:2111\" , \"BSingleFee\" : \"GSYS:2111\" , \"TickType\" : 2 , \"SAddr\" : \"bnb1vy9laqtftm7cnvvaylg73sta2lqz88rxs72mx7\" , \"BAddr\" : \"bnb1k082jc0ft383qjnerakr8kurgkzh0wnk8gulnj\" } ] }, \"Orders\" : { \"NumOfMsgs\" : 8 , \"Orders\" : [ { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"37D9383E6AD9AFEF6C5D8066ABA3ACA8C75D9F39-1724193\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1xlvns0n2mxh77mzaspn2hgav4rr4m8eerfju38\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 344271 , \"Qty\" : 89600000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 0 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"D74A96022A2F090D7D739C1C6716481A215E0F7F10C430C28290758E9DC4EF73\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"EQL-586_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"B3CEA961E95C4F104A791F6C33DB83458577BA76-5471\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1k082jc0ft383qjnerakr8kurgkzh0wnk8gulnj\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 4798 , \"Qty\" : 110000000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 110000000000 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"792BA5F932813F9C006075EAA090D82305AD049DDC570271FA8515339A874E97\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"4C28D006CF8061E05EEE50D17D8B2375CE09E7EC-71967\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1fs5dqpk0sps7qhhw2rghmzerwh8qnelv7tyat8\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 345283 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 23200000000 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"574CB6DAF26C5D1A465A8D86760FFDFF3DA5946F9C02EB5B89051A8120844523\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"5F511BE6120CE2F92877F3A1E92D408CE56A5CCC-62632\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1tag3hesjpn30j2rh7ws7jt2q3njk5hxvsx023c\" , \"Side\" : 2 , \"OrderType\" : 2 , \"Price\" : 345282 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 23200000000 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"9D8EF7CEAE5D2CDC4026F6306296D57764BB80099B3A65865971D8D71399B6EA\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"EQL-586_GSYS\" , \"Status\" : 5 , \"OrderId\" : \"610BFE81695EFD89B19D27D1E8C17D57C0239C66-6367\" , \"TradeId\" : \"36384232-1\" , \"Owner\" : \"bnb1vy9laqtftm7cnvvaylg73sta2lqz88rxs72mx7\" , \"Side\" : 2 , \"OrderType\" : 2 , \"Price\" : 4798 , \"Qty\" : 230000000000 , \"LastExecutedPrice\" : 4798 , \"LastExecutedQty\" : 110000000000 , \"CumQty\" : 110000000000 , \"Fee\" : \"GSYS:2111\" , \"OrderCreationTime\" : 1569196786802324000 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"EDF132EBDA03382D2BFF7EF58CDE574D4E3FB9622BD8BCF12BA6ABECD692BA5C\" , \"SingleFee\" : \"GSYS:2111\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 6 , \"OrderId\" : \"4C28D006CF8061E05EEE50D17D8B2375CE09E7EC-71967\" , \"TradeId\" : \"36384232-0\" , \"Owner\" : \"bnb1fs5dqpk0sps7qhhw2rghmzerwh8qnelv7tyat8\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 345283 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 345282 , \"LastExecutedQty\" : 23200000000 , \"CumQty\" : 23200000000 , \"Fee\" : \"GSYS:32042\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"574CB6DAF26C5D1A465A8D86760FFDFF3DA5946F9C02EB5B89051A8120844523\" , \"SingleFee\" : \"GSYS:32042\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 6 , \"OrderId\" : \"5F511BE6120CE2F92877F3A1E92D408CE56A5CCC-62632\" , \"TradeId\" : \"36384232-0\" , \"Owner\" : \"bnb1tag3hesjpn30j2rh7ws7jt2q3njk5hxvsx023c\" , \"Side\" : 2 , \"OrderType\" : 2 , \"Price\" : 345282 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 345282 , \"LastExecutedQty\" : 23200000000 , \"CumQty\" : 23200000000 , \"Fee\" : \"GSYS:32042\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"9D8EF7CEAE5D2CDC4026F6306296D57764BB80099B3A65865971D8D71399B6EA\" , \"SingleFee\" : \"GSYS:32042\" }, { \"Symbol\" : \"EQL-586_GSYS\" , \"Status\" : 6 , \"OrderId\" : \"B3CEA961E95C4F104A791F6C33DB83458577BA76-5471\" , \"TradeId\" : \"36384232-1\" , \"Owner\" : \"bnb1k082jc0ft383qjnerakr8kurgkzh0wnk8gulnj\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 4798 , \"Qty\" : 110000000000 , \"LastExecutedPrice\" : 4798 , \"LastExecutedQty\" : 110000000000 , \"CumQty\" : 110000000000 , \"Fee\" : \"GSYS:2111\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"792BA5F932813F9C006075EAA090D82305AD049DDC570271FA8515339A874E97\" , \"SingleFee\" : \"GSYS:2111\" } ] }, \"Proposals\" : { \"NumOfMsgs\" : 0 , \"Proposals\" : null }, \"StakeUpdates\" : { \"NumOfMsgs\" : 0 , \"CompletedUnbondingDelegations\" : null } }","title":"Changes"},{"location":"get-extra-data-from-fullnode.html#2-accountbalance","text":"You can set the publishAccountBalance option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the changed accounts. Example { Owner: string, Fee: string, Balances: []{ Asset: string, Free: int64, Frozen: int64, Locked: int64 } }","title":"2. AccountBalance"},{"location":"get-extra-data-from-fullnode.html#3-orderbook","text":"You can set the publishOrderBook option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all order book changes. Example { Height: int64, Timestamp: int64, NumOfMsgs: int, Books: []{ Symbol: string, Buys: []{ Price: int64, LastQty: int64 }, Sells: []{ Price: int64, LastQty: int64 } } }","title":"3. OrderBook"},{"location":"get-extra-data-from-fullnode.html#4-blockfee","text":"You can set the publishBlockFee option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the block fee charged. Example { Height: int64, Fee: string, Validators: []string }","title":"4. BlockFee"},{"location":"get-extra-data-from-fullnode.html#5-transfers","text":"You can set the publishTransfer option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the transfer transactions. Example { Height: int64, Num: int, Timestamp: int64, Transfers: []{ TxHash: string, Memo: string, From: string, To: []{ Addr: string, Coins: []{ Denom: string, Amount: int64 } } } }","title":"5. Transfers"},{"location":"get-extra-data-from-fullnode.html#6-staking-record","text":"You can set the publishStaking option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about staking. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"validators\": []{ \"feeAddr\": string, \"operatorAddr\": string, \"consAddr\": string, \"jailed\": bool, \"status\": string, \"tokens\": int64, \"delegatorShares\":int64, \"description\":{ \"moniker\": string, \"identity\": string, \"website\": string, \"details\": string, }, \"bondHeight\": int64, \"bondIntraTxCounter\": int, \"commission\":{ \"rate\": int64, \"maxRate\": int64, \"maxChangeRate\": int64, \"updateTime\": int64, }, \"distributionAddr\":string, \"sideChainId\": string, \"sideConsAddr\": string, \"sideFeeAddr\": string }, \"removedValidators\": map[string][]string, //key: chain id, value: operatorAddr \"delegatioins\": map[string][]{ \"delegator\": string, \"validator\": string, \"shares\": int64 }, // map key: chain-id \"unBondingDelegations\": map[string][]{ \"delegator\": string, \"validator\": string, \"creationHeight\": int64, \"minTime\": int64, \"initialBalance\": { \"denom\": string, \"amount\": int64 }, \"balance\": { \"denom\": string, \"amount\": int64 } }, // map key: chain id \"reDelegations\": map[string][]{ \"delegator\": string, \"srcValidator\": string, \"dstValidator\": string, \"creationHeight\": int64, \"sharesSrc\": int64, \"sharesDst\": int64, \"initialBalance\": { \"denom\": string, \"amount\": int64 }, \"balance\": { \"denom\": string, \"amount\": int64 }, \"minTime\": int64 }, // map key: chain id \"completedUBDs\": map[string][]{ \"validator\": string, \"delegator\": string, \"amount\": { \"denom\": string, \"amount\": int64 } }, \"completedREDs\": map[string][]{ \"delegator\": string, \"srcValidator\": string, \"dstValidator\": string }, \"delegateEvents\": map[string][]{ \"validator\": string, \"delegator\": string, \"amount\": { \"denom\": string, \"amount\": int64 }, \"txHash\": string }, \"unDelegateEvents\": map[string][]{ \"validator\": string, \"delegator\": string, \"amount\": { \"denom\": string, \"amount\": int64 }, \"txHash\": string }, \"reDelegateEvents\": map[string][]{ \"delegator\": string, \"srcValidator\": string, \"dstValidator\": string, \"amount\": { \"denom\": string, \"amount\": int64 }, \"txHash\": string }, \"electedValidators\": map[string][]{ \"feeAddr\": string, \"operatorAddr\": string, \"consAddr\": string, \"jailed\": bool, \"status\": string, \"tokens\": int64, \"delegatorShares\":int64, \"description\":{ \"moniker\": string, \"identity\": string, \"website\": string, \"details\": string, }, \"bondHeight\": int64, \"bondIntraTxCounter\": int, \"commission\":{ \"rate\": int64, \"maxRate\": int64, \"maxChangeRate\": int64, \"updateTime\": int64, }, \"distributionAddr\":string, \"sideChainId\": string, \"sideConsAddr\": string, \"sideFeeAddr\": string } } Schema { \"type\" : \"record\" , \"name\" : \"Staking\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"validators\" , \"type\" : [ \"null\" , { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Validator\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"feeAddr\" , \"type\" : \"string\" }, { \"name\" : \"operatorAddr\" , \"type\" : \"string\" }, { \"name\" : \"consAddr\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" }, { \"name\" : \"jailed\" , \"type\" : \"boolean\" }, { \"name\" : \"status\" , \"type\" : \"string\" }, { \"name\" : \"tokens\" , \"type\" : \"long\" }, { \"name\" : \"delegatorShares\" , \"type\" : \"long\" }, { \"name\" : \"description\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Description\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"moniker\" , \"type\" : \"string\" }, { \"name\" : \"identity\" , \"type\" : \"string\" }, { \"name\" : \"website\" , \"type\" : \"string\" }, { \"name\" : \"details\" , \"type\" : \"string\" } ] }}, { \"name\" : \"bondHeight\" , \"type\" : \"long\" }, { \"name\" : \"bondIntraTxCounter\" , \"type\" : \"int\" }, { \"name\" : \"commission\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Commission\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"rate\" , \"type\" : \"long\" }, { \"name\" : \"maxRate\" , \"type\" : \"long\" }, { \"name\" : \"maxChangeRate\" , \"type\" : \"long\" }, { \"name\" : \"updateTime\" , \"type\" : \"long\" } ] }}, { \"name\" : \"distributionAddr\" , \"type\" : \"string\" }, { \"name\" : \"sideChainId\" , \"type\" : \"string\" }, { \"name\" : \"sideConsAddr\" , \"type\" : \"string\" }, { \"name\" : \"sideFeeAddr\" , \"type\" : \"string\" } ] } }], \"default\" : \"null\" }, { \"name\" : \"removedValidators\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } } }], \"default\" : null }, { \"name\" : \"delegations\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Delegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"shares\" , \"type\" : \"long\" } ] } } }], \"default\" : null }, { \"name\" : \"unBondingDelegations\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"UnBondingDelgation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"creationHeight\" , \"type\" : \"long\" }, { \"name\" : \"minTime\" , \"type\" : \"long\" }, { \"name\" : \"initialBalance\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Coin\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"denom\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] }}, { \"name\" : \"balance\" , \"type\" : \"org.shree.dex.model.avro.Coin\" } ] } } }], \"default\" : null }, { \"name\" : \"reDelegations\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"ReDelegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"srcValidator\" , \"type\" : \"string\" }, { \"name\" : \"dstValidator\" , \"type\" : \"string\" }, { \"name\" : \"creationHeight\" , \"type\" : \"long\" }, { \"name\" : \"sharesSrc\" , \"type\" : \"long\" }, { \"name\" : \"sharesDst\" , \"type\" : \"long\" }, { \"name\" : \"initialBalance\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"balance\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"minTime\" , \"type\" : \"long\" } ] } } }], \"default\" : null }, { \"name\" : \"completedUBDs\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"CompletedUnbondingDelegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" } ] } } }], \"default\" : null }, { \"name\" : \"completedREDs\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"CompletedReDelegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"srcValidator\" , \"type\" : \"string\" }, { \"name\" : \"dstValidator\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"delegateEvents\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"DelegateEvent\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"txHash\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"unDelegateEvents\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"UndelegateEvent\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"txHash\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"reDelegateEvents\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"RedelegateEvent\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"srcValidator\" , \"type\" : \"string\" }, { \"name\" : \"dstValidator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"txHash\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"electedValidators\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : \"org.shree.dex.model.avro.Validator\" } }], \"default\" : null } ] }","title":"6. Staking Record"},{"location":"get-extra-data-from-fullnode.html#7-reward-distribution","text":"You can set the publishDistributeReward option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about reward distribution. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"distributions\" : map[string][]{ \"validator\": string, \"selfDelegator\": string, \"distributeAddr\": string, \"valTokens\": int64, \"totalReward\": int64, \"commission\": int64, \"rewards\": []{ \"delegator\": string, \"delegationTokens\": int64, \"reward\": int64 } } // map key: chain id } Schema { \"type\": \"record\", \"name\": \"Distribution\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\" }, { \"name\": \"timestamp\", \"type\": \"long\" }, { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"distributions\", \"type\": { \"type\": \"map\", \"values\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"DistributionData\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ {\"name\": \"validator\", \"type\": \"string\"}, {\"name\": \"selfDelegator\",\"type\": \"string\"}, {\"name\": \"distributeAddr\",\"type\": \"string\"}, {\"name\": \"valTokens\", \"type\": \"long\"}, {\"name\": \"totalReward\", \"type\": \"long\"}, {\"name\": \"commission\", \"type\": \"long\"}, {\"name\": \"rewards\", \"type\":{ \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Reward\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\":[ {\"name\": \"delegator\", \"type\": \"string\"}, {\"name\": \"delegationTokens\", \"type\": \"long\"}, {\"name\": \"reward\", \"type\": \"long\"} ] } }} ] } } } } ] }","title":"7. Reward Distribution"},{"location":"get-extra-data-from-fullnode.html#8-slashing","text":"You can set the publishSlashing option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about slashing. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"slashData\": map[string][]{ \"validator\": string, \"infractionType\": int, \"infractionHeight\": int64, \"jailUtil\": int64, \"slashAmount\": int64, \"toFeePool\": int64, \"submitter\": string, \"submitterReward\": int64, \"validatorsCompensation\": []{ \"address\": string, \"amount\": int64 } } } Schema { \"type\" : \"record\" , \"name\" : \"Slashing\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"slashData\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"SlashData\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"infractionType\" , \"type\" : \"int\" }, { \"name\" : \"infractionHeight\" , \"type\" : \"long\" }, { \"name\" : \"jailUtil\" , \"type\" : \"long\" }, { \"name\" : \"slashAmount\" , \"type\" : \"long\" }, { \"name\" : \"toFeePool\" , \"type\" : \"long\" }, { \"name\" : \"submitter\" , \"type\" : \"string\" }, { \"name\" : \"submitterReward\" , \"type\" : \"long\" }, { \"name\" : \"validatorsCompensation\" , \"type\" :{ \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"AllocatedAmt\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" :[ { \"name\" : \"address\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] } }} ] } } }} ] }","title":"8. Slashing"},{"location":"get-extra-data-from-fullnode.html#9-crosstransfer","text":"You can set the publishCrossTransfer option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about cross transfer. Example { \"height\": int64, \"timestamp\": int64, \"num\": int, \"transfers\": []{ \"txhash\": string, \"type\": string, \"relayerFee\": int64, \"chainid\": string, \"from\": \"string\", \"denom\": string, \"contract\": string, \"decimals\": int, \"to\": []{ \"addr\": string, \"amount\": int64 } } } Schema { \"type\" : \"record\" , \"name\" : \"CrossTransfers\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"num\" , \"type\" : \"int\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"transfers\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Transfer\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"txhash\" , \"type\" : \"string\" }, { \"name\" : \"type\" , \"type\" : \"string\" }, { \"name\" : \"relayerFee\" , \"type\" : \"long\" }, { \"name\" : \"chainid\" , \"type\" : \"string\" }, { \"name\" : \"from\" , \"type\" : \"string\" }, { \"name\" : \"denom\" , \"type\" : \"string\" }, { \"name\" : \"contract\" , \"type\" : \"string\" }, { \"name\" : \"decimals\" , \"type\" : \"int\" }, { \"name\" : \"to\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Receiver\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"addr\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] } } } ] } } } ] }","title":"9. CrossTransfer"},{"location":"get-extra-data-from-fullnode.html#10-sideproposal","text":"You can set the publishSideProposal option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about side proposals. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"proposals\": []{ \"id\": int64, \"chainid\": string, \"status\": string } } Schema { \"type\" : \"record\" , \"name\" : \"SideProposals\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"proposals\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Proposal\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"id\" , \"type\" : \"long\" }, { \"name\" : \"chainid\" , \"type\" : \"string\" }, { \"name\" : \"status\" , \"type\" : \"string\" } ] } } } ] }","title":"10. SideProposal"},{"location":"get-extra-data-from-fullnode.html#11-breatheblock","text":"You can set the publichBreatheBlock option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about side proposals. Example { \"height\": int64, \"timestamp\": int64 } Schema { \"type\" : \"record\" , \"name\" : \"BreatheBlock\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" } ] }","title":"11. BreatheBlock"},{"location":"get-extra-data-from-fullnode.html#publish-different-messages-to-kafka","text":"You can set the publishKafka option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save messages that you are interested into Kafka, and you can consume them in your own apps. The message is encoded based on Avro serialization system. Their schemas are shown below: OrderUpdates : { \"type\" : \"record\" , \"name\" : \"ExecutionResults\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"trades\" , \"type\" : [ \"null\" , { \"type\" : \"record\" , \"name\" : \"Trades\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"trades\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Trade\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"symbol\" , \"type\" : \"string\" }, { \"name\" : \"id\" , \"type\" : \"string\" }, { \"name\" : \"price\" , \"type\" : \"long\" }, { \"name\" : \"qty\" , \"type\" : \"long\" }, { \"name\" : \"sid\" , \"type\" : \"string\" }, { \"name\" : \"bid\" , \"type\" : \"string\" }, { \"name\" : \"sfee\" , \"type\" : \"string\" }, { \"name\" : \"bfee\" , \"type\" : \"string\" }, { \"name\" : \"saddr\" , \"type\" : \"string\" }, { \"name\" : \"baddr\" , \"type\" : \"string\" } ] } } } ] }], \"default\" : null }, { \"name\" : \"orders\" , \"type\" : [ \"null\" , { \"type\" : \"record\" , \"name\" : \"Orders\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"orders\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Order\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"symbol\" , \"type\" : \"string\" }, { \"name\" : \"status\" , \"type\" : \"string\" }, { \"name\" : \"orderId\" , \"type\" : \"string\" }, { \"name\" : \"tradeId\" , \"type\" : \"string\" }, { \"name\" : \"owner\" , \"type\" : \"string\" }, { \"name\" : \"side\" , \"type\" : \"int\" }, { \"name\" : \"orderType\" , \"type\" : \"int\" }, { \"name\" : \"price\" , \"type\" : \"long\" }, { \"name\" : \"qty\" , \"type\" : \"long\" }, { \"name\" : \"lastExecutedPrice\" , \"type\" : \"long\" }, { \"name\" : \"lastExecutedQty\" , \"type\" : \"long\" }, { \"name\" : \"cumQty\" , \"type\" : \"long\" }, { \"name\" : \"fee\" , \"type\" : \"string\" }, { \"name\" : \"orderCreationTime\" , \"type\" : \"long\" }, { \"name\" : \"transactionTime\" , \"type\" : \"long\" }, { \"name\" : \"timeInForce\" , \"type\" : \"int\" }, { \"name\" : \"currentExecutionType\" , \"type\" : \"string\" }, { \"name\" : \"txHash\" , \"type\" : \"string\" } ] } } } ] }], \"default\" : null }, { \"name\" : \"proposals\" , \"type\" : [ \"null\" , { \"type\" : \"record\" , \"name\" : \"Proposals\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"proposals\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Proposal\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"id\" , \"type\" : \"long\" }, { \"name\" : \"status\" , \"type\" : \"string\" } ] } } } ] }], \"default\" : null }, { \"name\" : \"stakeUpdates\" , \"type\" : [ \"null\" , { \"type\" : \"record\" , \"name\" : \"StakeUpdates\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"completedUnbondingDelegations\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"CompletedUnbondingDelegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Coin\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"denom\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] } } ] } } } ] }], \"default\" : null } ] } OrderBooksSchema : { \"type\": \"record\", \"name\": \"Books\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\" }, { \"name\": \"timestamp\", \"type\": \"long\" }, { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"books\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"OrderBookDelta\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"symbol\", \"type\": \"string\" }, { \"name\": \"buys\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"PriceLevel\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"price\", \"type\": \"long\" }, { \"name\": \"lastQty\", \"type\": \"long\" } ] } } }, { \"name\": \"sells\", \"type\": { \"type\": \"array\", \"items\": \"com.company.PriceLevel\" } } ] } }, \"default\": [] } ] } AccountBalanceSchema : { \"type\" : \"record\" , \"name\" : \"Accounts\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"accounts\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Account\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"owner\" , \"type\" : \"string\" }, { \"name\" : \"fee\" , \"type\" : \"string\" }, { \"name\" : \"balances\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"AssetBalance\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"asset\" , \"type\" : \"string\" }, { \"name\" : \"free\" , \"type\" : \"long\" }, { \"name\" : \"frozen\" , \"type\" : \"long\" }, { \"name\" : \"locked\" , \"type\" : \"long\" } ] } } } ] } }, \"default\" : [] } ] } BlockFeeSchema : { \"type\" : \"record\" , \"name\" : \"BlockFee\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"fee\" , \"type\" : \"string\" }, { \"name\" : \"validators\" , \"type\" : { \"type\" : \"array\" , \"items\" : \"string\" }} ] } TransfersSchema : { \"type\" : \"record\" , \"name\" : \"Transfers\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"num\" , \"type\" : \"int\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"transfers\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Transfer\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"txhash\" , \"type\" : \"string\" }, { \"name\" : \"from\" , \"type\" : \"string\" }, { \"name\" : \"to\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Receiver\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"addr\" , \"type\" : \"string\" }, { \"name\" : \"coins\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Coin\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"denom\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] } } } ] } } } ] } } } ] }","title":"Publish Different Messages to Kafka"},{"location":"get-started.html","text":"Get Started with Genesys Chain Wallet The easiest way to use Genesys Chain is through a wallet with support for Genesys Chain accounts and transfers. For example, GSYS provides a Web Wallet at https://www.genesys.network GSYS also provides Web Wallet for testnet at https://testnet-explorer.genesys.network Both provide the functions below: Generating crypto keys and addresses, which serves as the base of a wallet Showing the balances of assets on the addresses Sending and receiving assets Genesys Chain Web Wallet also presents a trading UI similar to genesys.network, where you can examine market data and manage your orders to trade among the listed assets. Learn about the list of wallet available here . Chain Explorer Chain Explorer provides a portal to explore blocks and transaction details. On Genesys Chain Explorer, you can also check different asset types, the distribution of their ownerships, and owners' transactions. REST API There are Accelerated Nodes which provide advanced API services for the public. Node RPC There are data seed nodes in the network which allow users to perform low-level operations like executing ABCI queries, viewing network/consensus state or broadcasting a transaction. Advanced Ways To Use Blockchain Run your own full node Please refer to this guide about how to run your own node . Run your own light client Please refer to this guide about how to run your own light client . Access via Node Command Line Interface (CLI) A Command Line Interface is available for Linux and Mac platforms. Use SDKs SDKs are also provided as a starting point for your apps. There are two advanced SDK solutions for Genesys Chain: Java and Golang . Both solutions provide functions for: Create wallets and manage keys Encode/sign transactions and submit to Genesys Chain/DEX, including Transfer, New Order, Cancel Order, etc. Communicate with Genesys Chain/DEX Node RPC calls through public node RPC services or your own private full nodes Please refer to specific SDK documentation for more information: Go ( Documentation ) Java ( Documentation ) Javascript ( Documentation ) C++ ( Documentation ) C# ( Documentation ) Python ( Documentation ) Swift ( Documentation ) Blockchain Details Please check the technical details for more technical information.","title":"Get Started with Genesys Chain"},{"location":"get-started.html#get-started-with-genesys-chain","text":"","title":"Get Started with Genesys Chain"},{"location":"get-started.html#wallet","text":"The easiest way to use Genesys Chain is through a wallet with support for Genesys Chain accounts and transfers. For example, GSYS provides a Web Wallet at https://www.genesys.network GSYS also provides Web Wallet for testnet at https://testnet-explorer.genesys.network Both provide the functions below: Generating crypto keys and addresses, which serves as the base of a wallet Showing the balances of assets on the addresses Sending and receiving assets Genesys Chain Web Wallet also presents a trading UI similar to genesys.network, where you can examine market data and manage your orders to trade among the listed assets. Learn about the list of wallet available here .","title":"Wallet"},{"location":"get-started.html#chain-explorer","text":"Chain Explorer provides a portal to explore blocks and transaction details. On Genesys Chain Explorer, you can also check different asset types, the distribution of their ownerships, and owners' transactions.","title":"Chain Explorer"},{"location":"get-started.html#rest-api","text":"There are Accelerated Nodes which provide advanced API services for the public.","title":"REST API"},{"location":"get-started.html#node-rpc","text":"There are data seed nodes in the network which allow users to perform low-level operations like executing ABCI queries, viewing network/consensus state or broadcasting a transaction.","title":"Node RPC"},{"location":"get-started.html#advanced-ways-to-use-blockchain","text":"","title":"Advanced Ways To Use Blockchain"},{"location":"get-started.html#run-your-own-full-node","text":"Please refer to this guide about how to run your own node .","title":"Run your own full node"},{"location":"get-started.html#run-your-own-light-client","text":"Please refer to this guide about how to run your own light client .","title":"Run your own light client"},{"location":"get-started.html#access-via-node-command-line-interface-cli","text":"A Command Line Interface is available for Linux and Mac platforms.","title":"Access via Node Command Line Interface (CLI)"},{"location":"get-started.html#use-sdks","text":"SDKs are also provided as a starting point for your apps. There are two advanced SDK solutions for Genesys Chain: Java and Golang . Both solutions provide functions for: Create wallets and manage keys Encode/sign transactions and submit to Genesys Chain/DEX, including Transfer, New Order, Cancel Order, etc. Communicate with Genesys Chain/DEX Node RPC calls through public node RPC services or your own private full nodes Please refer to specific SDK documentation for more information: Go ( Documentation ) Java ( Documentation ) Javascript ( Documentation ) C++ ( Documentation ) C# ( Documentation ) Python ( Documentation ) Swift ( Documentation )","title":"Use SDKs"},{"location":"get-started.html#blockchain-details","text":"Please check the technical details for more technical information.","title":"Blockchain Details"},{"location":"governance.html","text":"Governance Primer on Governance Genesys Chain has its own built-in governance module that lets GSYS holders submit proposals for adding trade pairs. In order for the proposal to be open for voting, it needs to come with a deposit that is greater than a parameter called Deposit . The deposit need not be provided in its entirety by the submitter. If the initial proposer's deposit is not sufficient, the proposal enters the deposit_period status. Then, any GSYS holder can increase the deposit by sending a depositTx . A purely-code-controlled escrow account will be used to hold deposits during voting period. It is a kind of account which is derived from a hard-coded string in shree chain protocol. This kind of account doesn't have its own private key and it's only controlled by code of the protocol. The code for calculating escrow account is the same that is used in cosmos-sdk : DepositedCoinsAccAddr = sdk.AccAddress(crypto.AddressHash([]byte(\"Genesys ChainDepositedCoins\"))) The account for mainnet is: bnb1vu5max8wqn997ayhrrys0drpll2rlz4dh39s3h and the account for testnet is: tbnb1vu5max8wqn997ayhrrys0drpll2rlz4deyv53x . Once the swap is claimed or refunded, the fund will be transferred from the purely-code-controlled escrow account to client accounts. Proposal Workflow Global Parameters min-deposit : The threshold for submitting a proposal on mainnet is 1000GSYS , and the threshold for submitting a proposal on testnet is 2000GSYS deposit_period : This is a global parameter and the value for mainnet is two days and testnet is two week. It means the time to deposit enough GSYS tokens is two days in mainnet and two weeks in testnet. fee : Checkout the fee of governance-related transactions here Proposal Parameters deposit : your input must be larger than min-deposit . voting-period : This is the time for validators to vote, your input in seconds, if you omit this field, the default voting period is one week. expire-time : This is the time for you to send list transaction if your proposal passed. This time cannot be earlier than current time. Participate in Governance Tools Please use this tool for generating You can also use Web Wallet for token management operations. Submit a List Proposal To add a new trading pairs, you can run the following command: Please note: --init-price is boosted by 1e8 for decimal part, such as 100000000, is 1 GSYS --from : put your key name for the address / key, you can only list with the owners address of your token. --expire-time : expire time is the deadline after which you will no longer be able to list your token though your proposal is passed. --voting-period : The voting period is for validators to vote. The unit is in seconds and the default voting period is one week. The max voting period is two weeks. The votes from validators will be tallied after the voting period ends. --title : title of proposal --quote-asset-symbol : the quote asset symbol. When you first list a BEP2 token on GSYS DEX, it has to be put in GSYS market first. Thus, you should set quote-asset-symbol to GSYS in your first proposal, then your BEP2 asset can be list against BUSD-BD1 and other stablecoins. --base-asset-symbol : the asset symbol you want to list Please note that the deposit and init-price are boosted by 1e8 for decimal part. Example on mainnet : ./eth-cli gov submit-list-proposal --from test --deposit 100000000000 :GSYS --base-asset-symbol AAA-254 --quote-asset-symbol GSYS --init-price 100000000 --title \"list AAA-254/GSYS\" --description \"list AAA-254/GSYS\" --expire-time 1570665600 --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --voting-period 604800 --json Example on testnet : ./eth-cli gov submit-list-proposal --from test --deposit 200000000000 :GSYS --base-asset-symbol AAA-254 --quote-asset-symbol GSYS --init-price 100000000 --title \"list AAA-254/GSYS\" --description \"list AAA-254/GSYS\" --expire-time 1570665600 --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --json --voting-period 604800 Tip As discussed in BEP-70 , BUSD is one of the most influential stable coins worldwide and the most dominant stable coin on Genesys Chain. BEP2 token issuers can list their assets against BUSD-BD1 without the requirement of creating GSYS pair first. Listing and trading BUSD pairs on Genesys Chain will facilitate token owners and exchange traders, making the markets more liquid and healthier. BEP70 is already implemented and has been activated after Testnet Nightingale Upgrade. Genesys Chain Mainnet will be upgraded to support BEP-70 soon. Submit a Delist Proposal In testnet, only validators can make a delist proposal. To add a new delist pairs, a validator can run the following command: Please note: --quote-asset-symbol : the quote asset symbol --base-asset-symbol : the asset symbol you want to delist --from : put your key name for the address key, you can only list with the owners address of your token. --voting-period : The voting period is for validators to vote. The unit is in seconds and the default voting period is one week. The max voting period is two weeks. The votes from validators will be tallied after the voting period ends. --justification : reason for proposal --depodit : this field will indicate how much tokens will be used as deposit for this proposal. Governance module will transfer deposit tokens to a purely-code-controlled escrow account and before the lock time expires. The account for mainnet is: bnb1vu5max8wqn997ayhrrys0drpll2rlz4dh39s3h and the account for testnet is: tbnb1vu5max8wqn997ayhrrys0drpll2rlz4deyv53x Example on mainnet : eth-cli gov submit-delist-proposal --title \"delist EDD-0AC\" --voting-period 7200 --deposit \"200000000000:GSYS\" --justification \" justification \" --base-asset-symbol EDD-0AC --quote-asset-symbol GSYS --from <your-key-name> --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet : eth-cli gov submit-delist-proposal --title \"delist EDD-0AC\" --voting-period 7200 --deposit \"200000000000:GSYS\" --justification \" justification \" --base-asset-symbol EDD-0AC --quote-asset-symbol GSYS --from <your-key-name> --chain-id GSYS-Chain-Ganges --trust-node --node https://seed-pre-s3.genesys.network:443 Add deposit for a Proposal (Optional) If the initial deposit for your proposal in submit-list-proposal is not enough, you can increase the deposit with deposit operation. In current Genesys Chain Mainnet, the max deposit period is two days . After submitting a proposal, you have two days to increase your deposit, otherwise your proposal will not go into the voting period and gets rejected directly. Please note the amount is boosted by 1e8 for decimal part. Example on mainnet : eth-cli gov deposit --from name --proposal-id <proposl-ID> --deposit <amount>:GSYS --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 Example on testnet : eth-cli gov deposit --from name --proposal-id <proposl-ID> --deposit <amount>:GSYS --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 Query Information of a Proposal To see detailed information of specific proposal, you can run the following command: Example on mainnet : ./eth-cli gov query-proposal --proposal-id <proposal-ID> --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 Example on testnet : ./eth-cli gov query-proposal --proposal-id <proposal-ID> --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 Example output: { \"type\" : \"gov/TextProposal\" , \"value\" : { \"proposal_id\" : \"100\" , \"title\" : \"list CZZ-696/GSYS\" , \"description\" : \"{\\\"base_asset_symbol\\\":\\\"CZZ-696\\\",\\\"quote_asset_symbol\\\":\\\"GSYS\\\",\\\"init_price\\\":100000000,\\\"description\\\":\\\"list CZZ-696/GSYS\\\",\\\"expire_time\\\":\\\"2019-03-21T09:00:00+09:00\\\"}\" , \"proposal_type\" : \"ListTradingPair\" , \"proposal_status\" : \"Passed\" , \"tally_result\" : { \"yes\" : \"1100000000000\" , \"abstain\" : \"0\" , \"no\" : \"0\" , \"no_with_veto\" : \"0\" }, \"submit_time\" : \"2019-03-07T20:49:03.504103408Z\" , \"total_deposit\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"200000000000\" } ], \"voting_start_time\" : \"2019-03-07T21:01:36.159585594Z\" } } You can get the information about the proposal's status and its tally result this way. Query votes of a Proposal You can track the votes for your proposal with the following command: Example on mainnet : ./eth-cli gov query-votes --proposal-id 272 --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 Example on testnet : ./eth-cli gov query-votes --proposal-id 272 --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 Example output: [ { \"voter\" : \"tbnb1q82g2h9q0kfe7sysnj5w7nlak92csfjztymp39\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb1r6l0c0fxu458hlq6m7amkcltj8nufyl9mr2wm5\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb193t8pkhm2sxw5uy5ypesygda8rzsk25ge3e9y7\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb183nch8pn3f698vurrqypq3s254slcane2t66aj\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb12hlquylu78cjylk5zshxpdj6hf3t0tahwjt3ex\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb1vehecekrsks5sshcwvxyeyrd469j9wvcqm37yu\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb108drn8exhv72tp40e6lq9z949nnjj54yzqrr2f\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb135mqtf9gef879nmjlpwz6u2fzqcw4qlzrqwgvw\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb1hexqyu3m8uuudqdnnpnsnlwe6xg0n3078lx68l\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb1earfwcjre04hp7phqnkw8ts04tkumdn0cyzun0\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb167yp9jkv6uaqnyq62gfkx82xmfny0cl9xe04zj\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" } ] Key Notions Vote options There are four vote options: - Yes - No - NoWithVeto - Abstain No represents the validator is against this proposal and NoWithVeto suggests the validator is strongly against this proposal. Abstain option allows voters to signal that they do not intend to vote in favor or against the proposal but accept the result of the vote. Quorum Quorum is defined as the minimum percentage of voting power that needs to be casted on a proposal for the result to be valid, which is 0.5(50%) now. If voting power does not reach quorum at the end of the voting period, the proposal will be rejected and all deposits will be returned to depositors' addresses. Note : There is a special case when all votes are Abstain and voting power is superior to 50%, the proposal will be rejected and all deposits will be refunded. Veto Veto is defined as the minimum proportion of NoWithVeto votes for the proposal to be rejected, which is 0.334(1/3) now. If more than 1/3 voters veto, the proposal will be rejected and all deposits will be distributed to validator. Threshold Threshold is defined as the minimum proportion of Yes votes (excluding Abstain votes) for the proposal to be accepted, which is 0.5(50%) now. If the proportion of NoWithVeto votes is inferior to 1/3 and the proportion of Yes votes (excluding Abstain votes) is superior to 50%, the proposal will be accepted and all deposits will be returned. Otherwise, the proposal will be rejected and all deposits will be distributed to validator. Tally Result Example You can query a proposal via eth-cli . $ ./eth-cli gov query-proposal --chain-id GSYS-Chain-Ganges --node = tcp://data-seed-pre-1-s3.genesys.network:80 --proposal-id 370 { \"type\" : \"gov/TextProposal\" , \"value\" : { \"proposal_id\" : \"370\" , \"title\" : \"list JCC-CB1/GSYS\" , \"description\" : \"{\\\"base_asset_symbol\\\":\\\"JCC-CB1\\\",\\\"quote_asset_symbol\\\":\\\"GSYS\\\",\\\"init_price\\\":100000000,\\\"description\\\":\\\"list JCC-CB1/GSYS\\\",\\\"expire_time\\\":\\\"2019-04-24T14:46:35+08:00\\\"}\" , \"proposal_type\" : \"ListTradingPair\" , \"voting_period\" : \"604800000000000\" , \"proposal_status\" : \"Passed\" , \"tally_result\" : { \"yes\" : \"1100000000000\" , \"abstain\" : \"0\" , \"no\" : \"0\" , \"no_with_veto\" : \"0\" , \"total\" : \"1100000000000\" } , \"submit_time\" : \"2019-04-10T06:49:11.568747217Z\" , \"total_deposit\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"200000000000\" } ] , \"voting_start_time\" : \"2019-04-10T06:52:00.064744275Z\" } } You can get tally result and proposal_status . For options in tally result : yes denotes voting power votes Yes abstain denotes voting power votes Abstain no denotes voting power votes No no_with_veto denotes voting power votes NoWithVeto total denotes total voting power when voting period ends We can calculate proportion of each vote option easily. In this case, total voting power is 1100000000000 and voting power of Yes is 1100000000000, so the proportion of Yes is 100% and the proposal should be passed and and your deposit will be returned. Note: Trying to query proposal that didn't enter the voting period will result in error . $ ./eth-cli gov query-proposal --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --proposal-id 25 { \"codespace\" : 5 , \"code\" : 1 , \"abci_code\" : 327681 , \"message\" : \"Unknown proposal with id 25\" }","title":"Governance"},{"location":"governance.html#governance","text":"","title":"Governance"},{"location":"governance.html#primer-on-governance","text":"Genesys Chain has its own built-in governance module that lets GSYS holders submit proposals for adding trade pairs. In order for the proposal to be open for voting, it needs to come with a deposit that is greater than a parameter called Deposit . The deposit need not be provided in its entirety by the submitter. If the initial proposer's deposit is not sufficient, the proposal enters the deposit_period status. Then, any GSYS holder can increase the deposit by sending a depositTx . A purely-code-controlled escrow account will be used to hold deposits during voting period. It is a kind of account which is derived from a hard-coded string in shree chain protocol. This kind of account doesn't have its own private key and it's only controlled by code of the protocol. The code for calculating escrow account is the same that is used in cosmos-sdk : DepositedCoinsAccAddr = sdk.AccAddress(crypto.AddressHash([]byte(\"Genesys ChainDepositedCoins\"))) The account for mainnet is: bnb1vu5max8wqn997ayhrrys0drpll2rlz4dh39s3h and the account for testnet is: tbnb1vu5max8wqn997ayhrrys0drpll2rlz4deyv53x . Once the swap is claimed or refunded, the fund will be transferred from the purely-code-controlled escrow account to client accounts.","title":"Primer on Governance"},{"location":"governance.html#proposal-workflow","text":"","title":"Proposal Workflow"},{"location":"governance.html#global-parameters","text":"min-deposit : The threshold for submitting a proposal on mainnet is 1000GSYS , and the threshold for submitting a proposal on testnet is 2000GSYS deposit_period : This is a global parameter and the value for mainnet is two days and testnet is two week. It means the time to deposit enough GSYS tokens is two days in mainnet and two weeks in testnet. fee : Checkout the fee of governance-related transactions here","title":"Global Parameters"},{"location":"governance.html#proposal-parameters","text":"deposit : your input must be larger than min-deposit . voting-period : This is the time for validators to vote, your input in seconds, if you omit this field, the default voting period is one week. expire-time : This is the time for you to send list transaction if your proposal passed. This time cannot be earlier than current time.","title":"Proposal Parameters"},{"location":"governance.html#participate-in-governance","text":"","title":"Participate in Governance"},{"location":"governance.html#tools","text":"Please use this tool for generating You can also use Web Wallet for token management operations.","title":"Tools"},{"location":"governance.html#submit-a-list-proposal","text":"To add a new trading pairs, you can run the following command: Please note: --init-price is boosted by 1e8 for decimal part, such as 100000000, is 1 GSYS --from : put your key name for the address / key, you can only list with the owners address of your token. --expire-time : expire time is the deadline after which you will no longer be able to list your token though your proposal is passed. --voting-period : The voting period is for validators to vote. The unit is in seconds and the default voting period is one week. The max voting period is two weeks. The votes from validators will be tallied after the voting period ends. --title : title of proposal --quote-asset-symbol : the quote asset symbol. When you first list a BEP2 token on GSYS DEX, it has to be put in GSYS market first. Thus, you should set quote-asset-symbol to GSYS in your first proposal, then your BEP2 asset can be list against BUSD-BD1 and other stablecoins. --base-asset-symbol : the asset symbol you want to list Please note that the deposit and init-price are boosted by 1e8 for decimal part. Example on mainnet : ./eth-cli gov submit-list-proposal --from test --deposit 100000000000 :GSYS --base-asset-symbol AAA-254 --quote-asset-symbol GSYS --init-price 100000000 --title \"list AAA-254/GSYS\" --description \"list AAA-254/GSYS\" --expire-time 1570665600 --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --voting-period 604800 --json Example on testnet : ./eth-cli gov submit-list-proposal --from test --deposit 200000000000 :GSYS --base-asset-symbol AAA-254 --quote-asset-symbol GSYS --init-price 100000000 --title \"list AAA-254/GSYS\" --description \"list AAA-254/GSYS\" --expire-time 1570665600 --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --json --voting-period 604800 Tip As discussed in BEP-70 , BUSD is one of the most influential stable coins worldwide and the most dominant stable coin on Genesys Chain. BEP2 token issuers can list their assets against BUSD-BD1 without the requirement of creating GSYS pair first. Listing and trading BUSD pairs on Genesys Chain will facilitate token owners and exchange traders, making the markets more liquid and healthier. BEP70 is already implemented and has been activated after Testnet Nightingale Upgrade. Genesys Chain Mainnet will be upgraded to support BEP-70 soon.","title":"Submit a List Proposal"},{"location":"governance.html#submit-a-delist-proposal","text":"In testnet, only validators can make a delist proposal. To add a new delist pairs, a validator can run the following command: Please note: --quote-asset-symbol : the quote asset symbol --base-asset-symbol : the asset symbol you want to delist --from : put your key name for the address key, you can only list with the owners address of your token. --voting-period : The voting period is for validators to vote. The unit is in seconds and the default voting period is one week. The max voting period is two weeks. The votes from validators will be tallied after the voting period ends. --justification : reason for proposal --depodit : this field will indicate how much tokens will be used as deposit for this proposal. Governance module will transfer deposit tokens to a purely-code-controlled escrow account and before the lock time expires. The account for mainnet is: bnb1vu5max8wqn997ayhrrys0drpll2rlz4dh39s3h and the account for testnet is: tbnb1vu5max8wqn997ayhrrys0drpll2rlz4deyv53x Example on mainnet : eth-cli gov submit-delist-proposal --title \"delist EDD-0AC\" --voting-period 7200 --deposit \"200000000000:GSYS\" --justification \" justification \" --base-asset-symbol EDD-0AC --quote-asset-symbol GSYS --from <your-key-name> --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet : eth-cli gov submit-delist-proposal --title \"delist EDD-0AC\" --voting-period 7200 --deposit \"200000000000:GSYS\" --justification \" justification \" --base-asset-symbol EDD-0AC --quote-asset-symbol GSYS --from <your-key-name> --chain-id GSYS-Chain-Ganges --trust-node --node https://seed-pre-s3.genesys.network:443","title":"Submit a Delist Proposal"},{"location":"governance.html#add-deposit-for-a-proposal-optional","text":"If the initial deposit for your proposal in submit-list-proposal is not enough, you can increase the deposit with deposit operation. In current Genesys Chain Mainnet, the max deposit period is two days . After submitting a proposal, you have two days to increase your deposit, otherwise your proposal will not go into the voting period and gets rejected directly. Please note the amount is boosted by 1e8 for decimal part. Example on mainnet : eth-cli gov deposit --from name --proposal-id <proposl-ID> --deposit <amount>:GSYS --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 Example on testnet : eth-cli gov deposit --from name --proposal-id <proposl-ID> --deposit <amount>:GSYS --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80","title":"Add deposit for a Proposal (Optional)"},{"location":"governance.html#query-information-of-a-proposal","text":"To see detailed information of specific proposal, you can run the following command: Example on mainnet : ./eth-cli gov query-proposal --proposal-id <proposal-ID> --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 Example on testnet : ./eth-cli gov query-proposal --proposal-id <proposal-ID> --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 Example output: { \"type\" : \"gov/TextProposal\" , \"value\" : { \"proposal_id\" : \"100\" , \"title\" : \"list CZZ-696/GSYS\" , \"description\" : \"{\\\"base_asset_symbol\\\":\\\"CZZ-696\\\",\\\"quote_asset_symbol\\\":\\\"GSYS\\\",\\\"init_price\\\":100000000,\\\"description\\\":\\\"list CZZ-696/GSYS\\\",\\\"expire_time\\\":\\\"2019-03-21T09:00:00+09:00\\\"}\" , \"proposal_type\" : \"ListTradingPair\" , \"proposal_status\" : \"Passed\" , \"tally_result\" : { \"yes\" : \"1100000000000\" , \"abstain\" : \"0\" , \"no\" : \"0\" , \"no_with_veto\" : \"0\" }, \"submit_time\" : \"2019-03-07T20:49:03.504103408Z\" , \"total_deposit\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"200000000000\" } ], \"voting_start_time\" : \"2019-03-07T21:01:36.159585594Z\" } } You can get the information about the proposal's status and its tally result this way.","title":"Query Information of a Proposal"},{"location":"governance.html#query-votes-of-a-proposal","text":"You can track the votes for your proposal with the following command: Example on mainnet : ./eth-cli gov query-votes --proposal-id 272 --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 Example on testnet : ./eth-cli gov query-votes --proposal-id 272 --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 Example output: [ { \"voter\" : \"tbnb1q82g2h9q0kfe7sysnj5w7nlak92csfjztymp39\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb1r6l0c0fxu458hlq6m7amkcltj8nufyl9mr2wm5\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb193t8pkhm2sxw5uy5ypesygda8rzsk25ge3e9y7\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb183nch8pn3f698vurrqypq3s254slcane2t66aj\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb12hlquylu78cjylk5zshxpdj6hf3t0tahwjt3ex\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb1vehecekrsks5sshcwvxyeyrd469j9wvcqm37yu\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb108drn8exhv72tp40e6lq9z949nnjj54yzqrr2f\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb135mqtf9gef879nmjlpwz6u2fzqcw4qlzrqwgvw\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb1hexqyu3m8uuudqdnnpnsnlwe6xg0n3078lx68l\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb1earfwcjre04hp7phqnkw8ts04tkumdn0cyzun0\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" }, { \"voter\" : \"tbnb167yp9jkv6uaqnyq62gfkx82xmfny0cl9xe04zj\" , \"proposal_id\" : \"272\" , \"option\" : \"Yes\" } ]","title":"Query votes of a Proposal"},{"location":"governance.html#key-notions","text":"","title":"Key Notions"},{"location":"governance.html#vote-options","text":"There are four vote options: - Yes - No - NoWithVeto - Abstain No represents the validator is against this proposal and NoWithVeto suggests the validator is strongly against this proposal. Abstain option allows voters to signal that they do not intend to vote in favor or against the proposal but accept the result of the vote.","title":"Vote options"},{"location":"governance.html#quorum","text":"Quorum is defined as the minimum percentage of voting power that needs to be casted on a proposal for the result to be valid, which is 0.5(50%) now. If voting power does not reach quorum at the end of the voting period, the proposal will be rejected and all deposits will be returned to depositors' addresses. Note : There is a special case when all votes are Abstain and voting power is superior to 50%, the proposal will be rejected and all deposits will be refunded.","title":"Quorum"},{"location":"governance.html#veto","text":"Veto is defined as the minimum proportion of NoWithVeto votes for the proposal to be rejected, which is 0.334(1/3) now. If more than 1/3 voters veto, the proposal will be rejected and all deposits will be distributed to validator.","title":"Veto"},{"location":"governance.html#threshold","text":"Threshold is defined as the minimum proportion of Yes votes (excluding Abstain votes) for the proposal to be accepted, which is 0.5(50%) now. If the proportion of NoWithVeto votes is inferior to 1/3 and the proportion of Yes votes (excluding Abstain votes) is superior to 50%, the proposal will be accepted and all deposits will be returned. Otherwise, the proposal will be rejected and all deposits will be distributed to validator.","title":"Threshold"},{"location":"governance.html#tally-result-example","text":"You can query a proposal via eth-cli . $ ./eth-cli gov query-proposal --chain-id GSYS-Chain-Ganges --node = tcp://data-seed-pre-1-s3.genesys.network:80 --proposal-id 370 { \"type\" : \"gov/TextProposal\" , \"value\" : { \"proposal_id\" : \"370\" , \"title\" : \"list JCC-CB1/GSYS\" , \"description\" : \"{\\\"base_asset_symbol\\\":\\\"JCC-CB1\\\",\\\"quote_asset_symbol\\\":\\\"GSYS\\\",\\\"init_price\\\":100000000,\\\"description\\\":\\\"list JCC-CB1/GSYS\\\",\\\"expire_time\\\":\\\"2019-04-24T14:46:35+08:00\\\"}\" , \"proposal_type\" : \"ListTradingPair\" , \"voting_period\" : \"604800000000000\" , \"proposal_status\" : \"Passed\" , \"tally_result\" : { \"yes\" : \"1100000000000\" , \"abstain\" : \"0\" , \"no\" : \"0\" , \"no_with_veto\" : \"0\" , \"total\" : \"1100000000000\" } , \"submit_time\" : \"2019-04-10T06:49:11.568747217Z\" , \"total_deposit\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"200000000000\" } ] , \"voting_start_time\" : \"2019-04-10T06:52:00.064744275Z\" } } You can get tally result and proposal_status . For options in tally result : yes denotes voting power votes Yes abstain denotes voting power votes Abstain no denotes voting power votes No no_with_veto denotes voting power votes NoWithVeto total denotes total voting power when voting period ends We can calculate proportion of each vote option easily. In this case, total voting power is 1100000000000 and voting power of Yes is 1100000000000, so the proportion of Yes is 100% and the proposal should be passed and and your deposit will be returned. Note: Trying to query proposal that didn't enter the voting period will result in error . $ ./eth-cli gov query-proposal --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --proposal-id 25 { \"codespace\" : 5 , \"code\" : 1 , \"abci_code\" : 327681 , \"message\" : \"Unknown proposal with id 25\" }","title":"Tally Result Example"},{"location":"keys.html","text":"Introduction Genesys Chain CLI has a sub-command named keys to manage private keys. It is a key store to manage keys for users. You can add a new key or import a key from seed. Then you can list the keys added and show the detailed info of a specific key. You can also delete the given key or update the password used to protect private key. Genesys Chain CLI use the keys you add to sign transactions for you. For example, if you want to transfer tokens to someone else, you just need to specify the name of the key you want to use, and input the password of the key, then Genesys Chain CLI will sign the transaction for you if the password is right. Usage The usage is the same for eth-cli and eth-cli $ ./eth-cli keys Keys allows you to manage your local keystore for tendermint. These keys may be in any format supported by go-crypto and can be used by light-clients, full nodes, or any other application that needs to sign with a private key. Usage: eth-cli keys [ command ] Available Commands: mnemonic Compute the bip39 mnemonic for some input entropy add Create a new key, or import from seed list List all keys show Show key info for the given name delete Delete the given key update Change the password used to protect private key Flags: -h, --help help for keys Global Flags: -e, --encoding string Binary encoding ( hex | b64 | btc ) ( default \"hex\" ) --home string directory for config and data ( default \"/Users/yourname/.eth-cli\" ) -o, --output string Output format ( text | json ) ( default \"text\" ) --trace print out full stack trace on errors Use \"eth-cli keys [command] --help\" for more information about a command. mnemonic mnemonic is used to generate bip39 mnemonic. You can restore key from the mnemonic generated. $ ./eth-cli keys mnemonic uncle mule squirrel cover theory oven rookie dry intact alert right afraid differ ability mule struggle spray usual must purity social ball flat short add You can use add to create a new key or import from seed (mnemonic). You have to specify the name for the key you want to create. To import with a mnemonic phrase, you need to include the --recover flag in the command. create a new key $ ./eth-cli keys add testkey Enter a passphrase for your key: Repeat the passphrase: NAME: TYPE: ADDRESS: PUBKEY: testkey local bnc1e8zhj9wmgq4pwzrv264gfru2fk8x2hdvpclx3n bncp1addwnpepqffepxlkrka9n33vyzmjwkpy05gpm46cn5de3x9v0vqswk7st5lkc7alhjv **Important** write this seed phrase in a safe place. It is the only way to recover your account if you ever forget your password. poverty joke nominee enough harsh elder flush noodle gift one limit tree sponsor sun radio above acid air winter inflict profit there brand water import from seed $ ./eth-cli keys add testkey --recover Enter a passphrase for your key: Repeat the passphrase: > Enter your recovery seed phrase: poverty joke nominee enough harsh elder flush noodle gift one limit tree sponsor sun radio above acid air winter inflict profit there brand water NAME: TYPE: ADDRESS: PUBKEY: testkey local bnc1e8zhj9wmgq4pwzrv264gfru2fk8x2hdvpclx3n bncp1addwnpepqffepxlkrka9n33vyzmjwkpy05gpm46cn5de3x9v0vqswk7st5lkc7alhjv list list can list all the keys you have. $ ./eth-cli keys list NAME: TYPE: ADDRESS: PUBKEY: test local bnc16jv838jw8zcgucvrhreen73adwgnue6ujcz2cf bncp1addwnpepqgxacvpgnvss94zs363lheuh2xldj0hvymftuds8d69u5cau5kz3y23rj6l testkey local bnc1e8zhj9wmgq4pwzrv264gfru2fk8x2hdvpclx3n bncp1addwnpepqffepxlkrka9n33vyzmjwkpy05gpm46cn5de3x9v0vqswk7st5lkc7alhjv show show is used to show the detail of the key by the name. $ ./eth-cli keys show testkey NAME: TYPE: ADDRESS: PUBKEY: testkey local bnc1e8zhj9wmgq4pwzrv264gfru2fk8x2hdvpclx3n bncp1addwnpepqffepxlkrka9n33vyzmjwkpy05gpm46cn5de3x9v0vqswk7st5lkc7alhjv delete delete is used to delete the key. $ ./eth-cli keys delete testkey DANGER - enter password to permanently delete key: Password deleted forever ( uh oh! ) update update is used to update the password that is currently used to protect the private key. $ ./eth-cli keys update test Enter the current passphrase: Enter the new passphrase: Repeat the new passphrase: Password successfully updated!","title":"Keys"},{"location":"keys.html#introduction","text":"Genesys Chain CLI has a sub-command named keys to manage private keys. It is a key store to manage keys for users. You can add a new key or import a key from seed. Then you can list the keys added and show the detailed info of a specific key. You can also delete the given key or update the password used to protect private key. Genesys Chain CLI use the keys you add to sign transactions for you. For example, if you want to transfer tokens to someone else, you just need to specify the name of the key you want to use, and input the password of the key, then Genesys Chain CLI will sign the transaction for you if the password is right.","title":"Introduction"},{"location":"keys.html#usage","text":"The usage is the same for eth-cli and eth-cli $ ./eth-cli keys Keys allows you to manage your local keystore for tendermint. These keys may be in any format supported by go-crypto and can be used by light-clients, full nodes, or any other application that needs to sign with a private key. Usage: eth-cli keys [ command ] Available Commands: mnemonic Compute the bip39 mnemonic for some input entropy add Create a new key, or import from seed list List all keys show Show key info for the given name delete Delete the given key update Change the password used to protect private key Flags: -h, --help help for keys Global Flags: -e, --encoding string Binary encoding ( hex | b64 | btc ) ( default \"hex\" ) --home string directory for config and data ( default \"/Users/yourname/.eth-cli\" ) -o, --output string Output format ( text | json ) ( default \"text\" ) --trace print out full stack trace on errors Use \"eth-cli keys [command] --help\" for more information about a command.","title":"Usage"},{"location":"keys.html#mnemonic","text":"mnemonic is used to generate bip39 mnemonic. You can restore key from the mnemonic generated. $ ./eth-cli keys mnemonic uncle mule squirrel cover theory oven rookie dry intact alert right afraid differ ability mule struggle spray usual must purity social ball flat short","title":"mnemonic"},{"location":"keys.html#add","text":"You can use add to create a new key or import from seed (mnemonic). You have to specify the name for the key you want to create. To import with a mnemonic phrase, you need to include the --recover flag in the command.","title":"add"},{"location":"keys.html#create-a-new-key","text":"$ ./eth-cli keys add testkey Enter a passphrase for your key: Repeat the passphrase: NAME: TYPE: ADDRESS: PUBKEY: testkey local bnc1e8zhj9wmgq4pwzrv264gfru2fk8x2hdvpclx3n bncp1addwnpepqffepxlkrka9n33vyzmjwkpy05gpm46cn5de3x9v0vqswk7st5lkc7alhjv **Important** write this seed phrase in a safe place. It is the only way to recover your account if you ever forget your password. poverty joke nominee enough harsh elder flush noodle gift one limit tree sponsor sun radio above acid air winter inflict profit there brand water","title":"create a new key"},{"location":"keys.html#import-from-seed","text":"$ ./eth-cli keys add testkey --recover Enter a passphrase for your key: Repeat the passphrase: > Enter your recovery seed phrase: poverty joke nominee enough harsh elder flush noodle gift one limit tree sponsor sun radio above acid air winter inflict profit there brand water NAME: TYPE: ADDRESS: PUBKEY: testkey local bnc1e8zhj9wmgq4pwzrv264gfru2fk8x2hdvpclx3n bncp1addwnpepqffepxlkrka9n33vyzmjwkpy05gpm46cn5de3x9v0vqswk7st5lkc7alhjv","title":"import from seed"},{"location":"keys.html#list","text":"list can list all the keys you have. $ ./eth-cli keys list NAME: TYPE: ADDRESS: PUBKEY: test local bnc16jv838jw8zcgucvrhreen73adwgnue6ujcz2cf bncp1addwnpepqgxacvpgnvss94zs363lheuh2xldj0hvymftuds8d69u5cau5kz3y23rj6l testkey local bnc1e8zhj9wmgq4pwzrv264gfru2fk8x2hdvpclx3n bncp1addwnpepqffepxlkrka9n33vyzmjwkpy05gpm46cn5de3x9v0vqswk7st5lkc7alhjv","title":"list"},{"location":"keys.html#show","text":"show is used to show the detail of the key by the name. $ ./eth-cli keys show testkey NAME: TYPE: ADDRESS: PUBKEY: testkey local bnc1e8zhj9wmgq4pwzrv264gfru2fk8x2hdvpclx3n bncp1addwnpepqffepxlkrka9n33vyzmjwkpy05gpm46cn5de3x9v0vqswk7st5lkc7alhjv","title":"show"},{"location":"keys.html#delete","text":"delete is used to delete the key. $ ./eth-cli keys delete testkey DANGER - enter password to permanently delete key: Password deleted forever ( uh oh! )","title":"delete"},{"location":"keys.html#update","text":"update is used to update the password that is currently used to protect the private key. $ ./eth-cli keys update test Enter the current passphrase: Enter the new passphrase: Repeat the new passphrase: Password successfully updated!","title":"update"},{"location":"light-client.html","text":"Run a light client to join Genesys Chain Light client is a program that connects to a full node to help users access and interact with Genesys Chain in a secure and decentralized manner without having to sync the full blockchain. Light Client Versus Full Node Light client does not store blocks or states,this way it needs less disk space (50 megabytes will be enough). Light client does not join p2p network and it does not produce any network cost when it is idle. The network overhead depends on how many requests the light client handles concurrently. Light client does not replay state of the chain so that there is not CPU cost when idle. The CPU cost also depends on how many requests the light client handles concurrently. Light client is faster than a full node even if it lagged behind the core network for a few months. It only needs a few seconds to catch up with core network. Platforms and System Requirement Platforms We support running light client node on Mac OS X , Windows and Linux . The light client will soon be open sourced, afterwards you can cross compile light client binary and run it on other platforms. Requirements 50 megabytes of free disk space. 2 CPU cores, 50 megabytes of memory (RAM). Run a light client node Download: git clonehttps://github.com/githubusername/githubrepo/node-binary.git Go to directory according to the network you want to join in. Replace the network variable with testnet or prod in the following command: cd node-binary/lightd/ { network } / { version } Help info: ./lightd --help This node will run a secure proxy to a shree rpc server. All calls that can be tracked back to a block header by a proof will be verified before passing them back to the caller. Other that that it will present the same interface as a full shree node, just with added trust and running locally. Usage: lite [flags] Flags: --cache-size int Specify the memory trust store cache size (default 10) --chain-id string Specify the shree chain ID (default \"bnbchain\") -h, --help help for lite --home-dir string Specify the home directory (default \".shree-lite\") --laddr string Serve the proxy on the given address (default \"tcp://localhost:27147\") --max-open-connections int Maximum number of simultaneous connections (including WebSocket). (default 900) --node string Connect to a shree node at this address (default \"tcp://localhost:27147\") You can specify all the parameters above. Start the light client node according to the Platform. Replace the platform variable with mac , windows or linux in the following command: ./ {{ platform }} /lightd --chain-id \"{chain-id}\" --node tcp:// { full node addr } :80 > node.log & There are two required parameters to start a light client node: chain id and full node addr . The chain id of the network that you want join in. You can find chain id at genesis file in test network or genesis file in prod network . The full node addr field can be an address of any full node that you have deployed. You can refer to Run a Genesys Chain full node to get more details. We supply a bunch of full nodes that you can connect to for both mainnet and testnet. You cat get full nodes info through a simple python script(notice to replace domain according to different network): import requests , json d = requests . get ( 'https://dex.genesys.network/api/v1/peers' ) . text # replace dex.genesys.network with testnet-dex.genesys.network for testnet l = json . loads ( d ) seeds = \",\" . join ([ ( seed [ \"id\" ] + \"@\" + seed [ \"original_listen_addr\" ]) for seed in l if seed [ \"accelerated\" ] == False ]) print ( seeds ) Example for Mainnet: ./lightd --chain-id \"GSYS-Chain-Tigris\" --node tcp://dataseed1.genesys.network:80 > node.log & Example for Testnet: ./lightd --chain-id \"GSYS-Chain-Ganges\" --node tcp://data-seed-pre-0-s1.genesys.network:80 > node.log & Working with the light client The default port of light client is 27147 .","title":"Run a light client to join Genesys Chain"},{"location":"light-client.html#run-a-light-client-to-join-genesys-chain","text":"Light client is a program that connects to a full node to help users access and interact with Genesys Chain in a secure and decentralized manner without having to sync the full blockchain.","title":"Run a light client to join Genesys Chain"},{"location":"light-client.html#light-client-versus-full-node","text":"Light client does not store blocks or states,this way it needs less disk space (50 megabytes will be enough). Light client does not join p2p network and it does not produce any network cost when it is idle. The network overhead depends on how many requests the light client handles concurrently. Light client does not replay state of the chain so that there is not CPU cost when idle. The CPU cost also depends on how many requests the light client handles concurrently. Light client is faster than a full node even if it lagged behind the core network for a few months. It only needs a few seconds to catch up with core network.","title":"Light Client Versus Full Node"},{"location":"light-client.html#platforms-and-system-requirement","text":"","title":"Platforms and System Requirement"},{"location":"light-client.html#platforms","text":"We support running light client node on Mac OS X , Windows and Linux . The light client will soon be open sourced, afterwards you can cross compile light client binary and run it on other platforms.","title":"Platforms"},{"location":"light-client.html#requirements","text":"50 megabytes of free disk space. 2 CPU cores, 50 megabytes of memory (RAM).","title":"Requirements"},{"location":"light-client.html#run-a-light-client-node","text":"Download: git clonehttps://github.com/githubusername/githubrepo/node-binary.git Go to directory according to the network you want to join in. Replace the network variable with testnet or prod in the following command: cd node-binary/lightd/ { network } / { version } Help info: ./lightd --help This node will run a secure proxy to a shree rpc server. All calls that can be tracked back to a block header by a proof will be verified before passing them back to the caller. Other that that it will present the same interface as a full shree node, just with added trust and running locally. Usage: lite [flags] Flags: --cache-size int Specify the memory trust store cache size (default 10) --chain-id string Specify the shree chain ID (default \"bnbchain\") -h, --help help for lite --home-dir string Specify the home directory (default \".shree-lite\") --laddr string Serve the proxy on the given address (default \"tcp://localhost:27147\") --max-open-connections int Maximum number of simultaneous connections (including WebSocket). (default 900) --node string Connect to a shree node at this address (default \"tcp://localhost:27147\") You can specify all the parameters above. Start the light client node according to the Platform. Replace the platform variable with mac , windows or linux in the following command: ./ {{ platform }} /lightd --chain-id \"{chain-id}\" --node tcp:// { full node addr } :80 > node.log & There are two required parameters to start a light client node: chain id and full node addr . The chain id of the network that you want join in. You can find chain id at genesis file in test network or genesis file in prod network . The full node addr field can be an address of any full node that you have deployed. You can refer to Run a Genesys Chain full node to get more details. We supply a bunch of full nodes that you can connect to for both mainnet and testnet. You cat get full nodes info through a simple python script(notice to replace domain according to different network): import requests , json d = requests . get ( 'https://dex.genesys.network/api/v1/peers' ) . text # replace dex.genesys.network with testnet-dex.genesys.network for testnet l = json . loads ( d ) seeds = \",\" . join ([ ( seed [ \"id\" ] + \"@\" + seed [ \"original_listen_addr\" ]) for seed in l if seed [ \"accelerated\" ] == False ]) print ( seeds )","title":"Run a light client node"},{"location":"light-client.html#example-for-mainnet","text":"./lightd --chain-id \"GSYS-Chain-Tigris\" --node tcp://dataseed1.genesys.network:80 > node.log &","title":"Example for Mainnet:"},{"location":"light-client.html#example-for-testnet","text":"./lightd --chain-id \"GSYS-Chain-Ganges\" --node tcp://data-seed-pre-0-s1.genesys.network:80 > node.log &","title":"Example for Testnet:"},{"location":"light-client.html#working-with-the-light-client","text":"The default port of light client is 27147 .","title":"Working with the light client"},{"location":"list.html","text":"List Transaction Only BEP2 tokens issued on Genesys Chain can be listed. Learn how to issue BEP2 tokens here . If a token's listing proposal has been passed by valdiators, then a list transaction must be sent before expire-time . List Fee Fees will be charge when issuing a token, creating a proposal, depositing and listing. You can refer to fee table in trading spec . List Transaction Proposal Parameters quote-asset-symbol : For now, only support GSYS as quote asset. init-price : the initial price for your asset, it is boosted by 1e8 proposal-id : this corresponds to the listing proposal that is passed from : this address should be the issuer of base asset Example on mainnet : $ ./eth-cli dex list -s AAA-254 --quote-asset-symbol GSYS --from test \\ --init-price 100000000 --proposal-id 15 --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --json { \"Height\" : \"282409\" , \"TxHash\" : \"77AE3D190F430FE6E4B1A9659BEBB3F022CF7631\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"YWN0aW9u\" , \"value\" : \"ZGV4TGlzdA==\" } ] } } Example on testnet : $ ./eth-cli dex list -s AAA-254 --quote-asset-symbol GSYS --from test \\ --init-price 100000000 --proposal-id 15 --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --json { \"Height\" : \"282409\" , \"TxHash\" : \"77AE3D190F430FE6E4B1A9659BEBB3F022CF7631\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"YWN0aW9u\" , \"value\" : \"ZGV4TGlzdA==\" } ] } } After the transaction is executed, you could see the newly added trading pair from Explorer and maket API.","title":"List Transaction"},{"location":"list.html#list-transaction","text":"Only BEP2 tokens issued on Genesys Chain can be listed. Learn how to issue BEP2 tokens here . If a token's listing proposal has been passed by valdiators, then a list transaction must be sent before expire-time .","title":"List Transaction"},{"location":"list.html#list-fee","text":"Fees will be charge when issuing a token, creating a proposal, depositing and listing. You can refer to fee table in trading spec .","title":"List Fee"},{"location":"list.html#list-transaction_1","text":"","title":"List Transaction"},{"location":"list.html#proposal-parameters","text":"quote-asset-symbol : For now, only support GSYS as quote asset. init-price : the initial price for your asset, it is boosted by 1e8 proposal-id : this corresponds to the listing proposal that is passed from : this address should be the issuer of base asset Example on mainnet : $ ./eth-cli dex list -s AAA-254 --quote-asset-symbol GSYS --from test \\ --init-price 100000000 --proposal-id 15 --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --json { \"Height\" : \"282409\" , \"TxHash\" : \"77AE3D190F430FE6E4B1A9659BEBB3F022CF7631\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"YWN0aW9u\" , \"value\" : \"ZGV4TGlzdA==\" } ] } } Example on testnet : $ ./eth-cli dex list -s AAA-254 --quote-asset-symbol GSYS --from test \\ --init-price 100000000 --proposal-id 15 --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --json { \"Height\" : \"282409\" , \"TxHash\" : \"77AE3D190F430FE6E4B1A9659BEBB3F022CF7631\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"YWN0aW9u\" , \"value\" : \"ZGV4TGlzdA==\" } ] } } After the transaction is executed, you could see the newly added trading pair from Explorer and maket API.","title":"Proposal Parameters"},{"location":"list_instruction.html","text":"List Instructions Listing a trading pair is a rather advanced feature in DEX. To list your token, you can follow the step-by-step instruction here. There are the steps to get your tokens listed: 1. Issue Tokens on Genesys Chain Please refer to this token issue doc to learn about how to issue your own asset on Genesys Chain. 2. Submit Proposal On-Chain Proposal Request Please refer to this governance doc to learn about how to create a proposal about listing a new trading pair on Genesys Chain. Please ensure that you test EVERYTHING on our testnet (multiple times at least) before you officially execute this on the mainnet. Community Thread Proposal (Recommended) It is recommended that Token Issuers first create a thread under the \u201cToken Issuance & Listings\u201d category in the Genesys Chain Community Forum (https://community.genesys.network/). The whole guideline is here 3. Send List Transaction Please refer to this list doc to learn about how to send a list transaction and finish listing process on Genesys Chain. Please ensure that a list transaction must be sent before expire-time . FAQ about Listing Tokens Which trading pair can be listed? Simply allowing trading between two assets seems easy enough, however it is expensive for not only the network but also its users in long term (and liquidity costs can be much larger). In order to efficiently use the network, Genesys Chain only list assets against GSYS and other widely accepted market quote assets. How is a trading pair created on GSYS DEX? The design philosophy of GSYS DEX adheres to the idea that the most efficient and low cost way to perform trading and price-discovery is still to use single order book. This single order book is managed and replicated across all full nodes with the same, deterministic matching logic.","title":"List Instructions"},{"location":"list_instruction.html#list-instructions","text":"Listing a trading pair is a rather advanced feature in DEX. To list your token, you can follow the step-by-step instruction here. There are the steps to get your tokens listed:","title":"List Instructions"},{"location":"list_instruction.html#1-issue-tokens-on-genesys-chain","text":"Please refer to this token issue doc to learn about how to issue your own asset on Genesys Chain.","title":"1. Issue Tokens on Genesys Chain"},{"location":"list_instruction.html#2-submit-proposal","text":"On-Chain Proposal Request Please refer to this governance doc to learn about how to create a proposal about listing a new trading pair on Genesys Chain. Please ensure that you test EVERYTHING on our testnet (multiple times at least) before you officially execute this on the mainnet. Community Thread Proposal (Recommended) It is recommended that Token Issuers first create a thread under the \u201cToken Issuance & Listings\u201d category in the Genesys Chain Community Forum (https://community.genesys.network/). The whole guideline is here","title":"2. Submit Proposal"},{"location":"list_instruction.html#3-send-list-transaction","text":"Please refer to this list doc to learn about how to send a list transaction and finish listing process on Genesys Chain. Please ensure that a list transaction must be sent before expire-time .","title":"3. Send List Transaction"},{"location":"list_instruction.html#faq-about-listing-tokens","text":"","title":"FAQ about Listing  Tokens"},{"location":"list_instruction.html#which-trading-pair-can-be-listed","text":"Simply allowing trading between two assets seems easy enough, however it is expensive for not only the network but also its users in long term (and liquidity costs can be much larger). In order to efficiently use the network, Genesys Chain only list assets against GSYS and other widely accepted market quote assets.","title":"Which trading pair can be listed?"},{"location":"list_instruction.html#how-is-a-trading-pair-created-on-gsys-dex","text":"The design philosophy of GSYS DEX adheres to the idea that the most efficient and low cost way to perform trading and price-discovery is still to use single order book. This single order book is managed and replicated across all full nodes with the same, deterministic matching logic.","title":"How is a trading pair created on GSYS DEX?"},{"location":"match-examples.html","text":"Match Steps and Examples Match Steps Step 0: no match for one side market, or market without crossed order book Step 1: Maximum matched volume. The Equilibrium Price (EP) should be the price at which the maximum volume can be traded. In the case of more than one price level with the same executable volume, the algorithm should go to step 2 Step 2: Minimum surplus. In the case of more than one price level with the same maximum executable volume, the EP should be the price with the lowest surplus (imbalance) volume. The surplus is absolute leftover volume at the EP. If multiple surplus amounts have the same lowest value, precede to step 3. Step 3: Market Pressure. If multiple prices satisfy 1 and 2, establish where market pressure of the potential price exists. Surplus with a positive sign indicates buy side pressure while surplus with a negative sign indicates sell side pressure. For scenarios that all the the equivalent surplus amounts are positive, if all the prices are below the reference price plus an upper limit percentage (e.g. 5%), then algorithm uses the highest of the potential equilibrium prices. If all the prices are above the reference price plus an upper limit, use the lowest price; for other cases, use the reference price plus the upper limit. Conversely, if market pressure is on the sell side, if all prices are above the reference price minus a lower percentage limit, then the algorithm uses the lowest of the potential prices. If all the price are below the reference price minus the lower percentage limit, use the highest price, otherwise use the reference price minus the lower percentage limit. If both positive and negative surplus amounts exist, precede to Step 4. Step 4: When both positive and negative surplus amounts exists at the lowest, if the reference price falls at / into these prices, the reference price should be chose, otherwise the price closest to the reference price would be chosen. Examples The chosen price level row would have * on the deciding colume. 1. Choose the largest execution (Step 1) ------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 300 100 150 150 150 -150 300 99 150 150 -150 300 250 98 150 300 300* 0 50 50 97 300 50 250 2. Choose the largest execution (Step 1) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 300 100 150 150 150 -150 300 99 50 200 200 -100 300 98 200 200 -100 300 200 97 300 500 300* 200 100 100 96 500 100 400 3. the least abs surplus imbalance (Step 2) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 1500 102 300 300 300 -1200 1500 101 300 300 -1200 1500 100 100 400 400 -1100 1500 99 200 600 600 -900 1500 250 98 300 900 900 -600 1250 250 97 900 900 -350 1000 1000 96 900 900 -100* 4. the least abs surplus imbalance (Step 2) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 110 102 30 30 30 -80 110 101 10 40 40 -70 110 100 40 40 -70 110 99 50 90 90 -20 110 10 98 90 90 -20 100 50 97 90 90 -10* 50 96 15 105 50 55 50 50 95 105 50 55 5.1 choose the lowest for all the same value of sell surplus imbalance, reference price is 80 and 5% lower limit (Step 3) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 50 102 10 10 10 -40 50 101 10 10 -40 50 100 10 10 -40 50 99 10 10 -40 50 98 10 10 -40 50 97 10 20 20 -30 50 96 20 20 -30 50 50 95 20 20 -30* 5.2 choose the highest for all the same value of sell surplus imbalance, reference price is 100 and 5% lower limit (Step 3) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 50 99 10 10 10 -40 50 98 10 10 -40 50 97 10 10 -40 50 96 10 10 -40 50 95 10 10 -40 50 94 10 20 20 -30* 50 93 20 20 -30 50 50 92 20 20 -30 5.3 choose the reference price for all the same value of buy surplus imbalance, reference price is 90 and 5% upper limit (Step 3) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 50 99 100 100 50 50 50 98 100 50 50 50 97 100 50 50 50 96 100 50 50 50 95 100 50 50* 50 94 100 50 50 50 93 100 50 50 50 50 92 100 50 50 5.4 choose the reference price for all the same value of sell surplus imbalance, reference price is 100 and 5% lower limit (Step 3) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 50 101 10 10 10 -40 50 100 10 10 -40 50 99 10 10 -40 50 98 10 10 -40 50 97 10 10 -40 50 96 10 20 20 -30 50 95 20 20 -30* 50 50 94 20 20 -30 6.1 choose the closest to the last trade price 99 (Step 4) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 50 100 25 25 25 -25 50 99 25 25 -25* 50 25 98 25 25 -25 25 97 25 50 25 25 25 96 50 25 25 25 25 95 50 25 25 6.2 choose the closest to the last trade price 97 (Step 4) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 50 100 25 25 25 -25 50 99 25 25 -25 50 25 98 25 25 -25 25 97 25 50 25 25* 25 96 50 25 25 25 25 95 50 25 25","title":"Match Steps and Examples"},{"location":"match-examples.html#match-steps-and-examples","text":"","title":"Match Steps and Examples"},{"location":"match-examples.html#match-steps","text":"Step 0: no match for one side market, or market without crossed order book Step 1: Maximum matched volume. The Equilibrium Price (EP) should be the price at which the maximum volume can be traded. In the case of more than one price level with the same executable volume, the algorithm should go to step 2 Step 2: Minimum surplus. In the case of more than one price level with the same maximum executable volume, the EP should be the price with the lowest surplus (imbalance) volume. The surplus is absolute leftover volume at the EP. If multiple surplus amounts have the same lowest value, precede to step 3. Step 3: Market Pressure. If multiple prices satisfy 1 and 2, establish where market pressure of the potential price exists. Surplus with a positive sign indicates buy side pressure while surplus with a negative sign indicates sell side pressure. For scenarios that all the the equivalent surplus amounts are positive, if all the prices are below the reference price plus an upper limit percentage (e.g. 5%), then algorithm uses the highest of the potential equilibrium prices. If all the prices are above the reference price plus an upper limit, use the lowest price; for other cases, use the reference price plus the upper limit. Conversely, if market pressure is on the sell side, if all prices are above the reference price minus a lower percentage limit, then the algorithm uses the lowest of the potential prices. If all the price are below the reference price minus the lower percentage limit, use the highest price, otherwise use the reference price minus the lower percentage limit. If both positive and negative surplus amounts exist, precede to Step 4. Step 4: When both positive and negative surplus amounts exists at the lowest, if the reference price falls at / into these prices, the reference price should be chose, otherwise the price closest to the reference price would be chosen.","title":"Match Steps"},{"location":"match-examples.html#examples","text":"The chosen price level row would have * on the deciding colume. 1. Choose the largest execution (Step 1) ------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 300 100 150 150 150 -150 300 99 150 150 -150 300 250 98 150 300 300* 0 50 50 97 300 50 250 2. Choose the largest execution (Step 1) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 300 100 150 150 150 -150 300 99 50 200 200 -100 300 98 200 200 -100 300 200 97 300 500 300* 200 100 100 96 500 100 400 3. the least abs surplus imbalance (Step 2) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 1500 102 300 300 300 -1200 1500 101 300 300 -1200 1500 100 100 400 400 -1100 1500 99 200 600 600 -900 1500 250 98 300 900 900 -600 1250 250 97 900 900 -350 1000 1000 96 900 900 -100* 4. the least abs surplus imbalance (Step 2) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 110 102 30 30 30 -80 110 101 10 40 40 -70 110 100 40 40 -70 110 99 50 90 90 -20 110 10 98 90 90 -20 100 50 97 90 90 -10* 50 96 15 105 50 55 50 50 95 105 50 55 5.1 choose the lowest for all the same value of sell surplus imbalance, reference price is 80 and 5% lower limit (Step 3) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 50 102 10 10 10 -40 50 101 10 10 -40 50 100 10 10 -40 50 99 10 10 -40 50 98 10 10 -40 50 97 10 20 20 -30 50 96 20 20 -30 50 50 95 20 20 -30* 5.2 choose the highest for all the same value of sell surplus imbalance, reference price is 100 and 5% lower limit (Step 3) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 50 99 10 10 10 -40 50 98 10 10 -40 50 97 10 10 -40 50 96 10 10 -40 50 95 10 10 -40 50 94 10 20 20 -30* 50 93 20 20 -30 50 50 92 20 20 -30 5.3 choose the reference price for all the same value of buy surplus imbalance, reference price is 90 and 5% upper limit (Step 3) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 50 99 100 100 50 50 50 98 100 50 50 50 97 100 50 50 50 96 100 50 50 50 95 100 50 50* 50 94 100 50 50 50 93 100 50 50 50 50 92 100 50 50 5.4 choose the reference price for all the same value of sell surplus imbalance, reference price is 100 and 5% lower limit (Step 3) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 50 101 10 10 10 -40 50 100 10 10 -40 50 99 10 10 -40 50 98 10 10 -40 50 97 10 10 -40 50 96 10 20 20 -30 50 95 20 20 -30* 50 50 94 20 20 -30 6.1 choose the closest to the last trade price 99 (Step 4) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 50 100 25 25 25 -25 50 99 25 25 -25* 50 25 98 25 25 -25 25 97 25 50 25 25 25 96 50 25 25 25 25 95 50 25 25 6.2 choose the closest to the last trade price 97 (Step 4) -------------------------------------------------------------- SUM SELL PRICE BUY SUM EXECUTION IMBALANCE 50 100 25 25 25 -25 50 99 25 25 -25 50 25 98 25 25 -25 25 97 25 50 25 25* 25 96 50 25 25 25 25 95 50 25 25","title":"Examples"},{"location":"match.html","text":"What exactly is GSYS DEX matching logic? GSYS DEX uses periodic auction to match all available orders. Maker/Taker concepts are introduced to enhance the current periodic auction match algorithm. The match is still executed only once in each block while the execution prices may vary for maker and taker orders. Match Candidates Orders meet any of the below conditions would be considered as the candidates of next match round: New orders that come in just now and get confirmed by being accepted into the latest block Existing orders that come in the past blocks before the latest, and have not been filled or expired Match Time Candidates would be matched right after one block is committed. Each block has one round of match. Match Logic The below matching logic would be applied on every listed token pairs. The match only happens when the best bid and ask prices are 'crossed', i.e. best bid > best ask. There would be only 1 price selected in one match round as the best prices among all the fillable orders, to show the fairness. All the orders would be matched first by the price aggressiveness and then block height that they get accepted. Conclude Execution Price The execution price would be selected as the below logic, in order to: Maximize the execution quantity Execute all orders or at least all orders on one side that are fillable against the selected price. Indicate the market pressure from either buy or sell and also consider to limit the max price movement. Let\u2019s call this concluded price P. Please check this article with detailed examples for this if you are interested. Order Matches After the execution price is concluded. Order match would happen in sequence of the price and time, i.e. Orders with best bid price would match with order with best ask price; If the orders on one price cannot be fully filled by the opposite orders: for the orders with the same price, the orders from the earlier blocks would be selected and filled first If the orders have the same price and block height, and cannot be fully filled, the execution would be allocated to each order in proportion to their quantity (floored if the number has a partial lot). If the allocation cannot be accurately divided, a deterministic algorithm would guarantee that no consistent bias to any orders. After the execution price P is concluded, buy orders with price equal to or larger than P , and sell orders with price equal to or less than P will match. For the orders that come into match in the new block, the trades will be allocated according to the below principles: All new incoming buy orders into this current block (called \"new orders\" in this context) will get executed with the same price, so do all the sell orders; so that there is no chance for front-running on the same side. All the executed price will honor the order limit price; All the executed price for the new orders will be equal to or better than the concluded auction price P , so no front-running from the opposite side. For other orders that have arrived in the previous blocks, they will join match together with the new orders from the new block, and be considered as \"Maker\" role. The detailed explanation of Maker/Taker is as below: Definition of Maker and Taker Among all the orders to be allocated, between buy and sell sides, this specification defines four concepts. Name Definition Maker Order order from the previous blocks Taker Order new incoming order in the current block Maker Side buy or sell side which has maker orders. May also have taker orders. Taker Side buy or sell side which only has taker orders. In each round of match, for all the orders that can be filled with the concluded price P , the algorithm ensures only one of the below two circumstances can happen, Both buy and sell side are Taker Side , when there is no leftover orders from all the previous blocks; One side is Maker Side that has orders from previous blocks (and may/may not have orders from this current block), and the other is Taker Side that only has orders from this current block. Execution Pricing Among all the orders to be allocated, For maker side: all the maker orders are executed at their limit price all the taker orders on the maker side are executed at the concluded price P For taker side, all the orders are executed at the average execution price from the above #1 If no maker side in this match, all the orders are executed at price P .","title":"What exactly is GSYS DEX matching logic?"},{"location":"match.html#what-exactly-is-gsys-dex-matching-logic","text":"GSYS DEX uses periodic auction to match all available orders. Maker/Taker concepts are introduced to enhance the current periodic auction match algorithm. The match is still executed only once in each block while the execution prices may vary for maker and taker orders.","title":"What exactly is GSYS DEX matching logic?"},{"location":"match.html#match-candidates","text":"Orders meet any of the below conditions would be considered as the candidates of next match round: New orders that come in just now and get confirmed by being accepted into the latest block Existing orders that come in the past blocks before the latest, and have not been filled or expired","title":"Match Candidates"},{"location":"match.html#match-time","text":"Candidates would be matched right after one block is committed. Each block has one round of match.","title":"Match Time"},{"location":"match.html#match-logic","text":"The below matching logic would be applied on every listed token pairs. The match only happens when the best bid and ask prices are 'crossed', i.e. best bid > best ask. There would be only 1 price selected in one match round as the best prices among all the fillable orders, to show the fairness. All the orders would be matched first by the price aggressiveness and then block height that they get accepted.","title":"Match Logic"},{"location":"match.html#conclude-execution-price","text":"The execution price would be selected as the below logic, in order to: Maximize the execution quantity Execute all orders or at least all orders on one side that are fillable against the selected price. Indicate the market pressure from either buy or sell and also consider to limit the max price movement. Let\u2019s call this concluded price P. Please check this article with detailed examples for this if you are interested.","title":"Conclude Execution Price"},{"location":"match.html#order-matches","text":"After the execution price is concluded. Order match would happen in sequence of the price and time, i.e. Orders with best bid price would match with order with best ask price; If the orders on one price cannot be fully filled by the opposite orders: for the orders with the same price, the orders from the earlier blocks would be selected and filled first If the orders have the same price and block height, and cannot be fully filled, the execution would be allocated to each order in proportion to their quantity (floored if the number has a partial lot). If the allocation cannot be accurately divided, a deterministic algorithm would guarantee that no consistent bias to any orders. After the execution price P is concluded, buy orders with price equal to or larger than P , and sell orders with price equal to or less than P will match. For the orders that come into match in the new block, the trades will be allocated according to the below principles: All new incoming buy orders into this current block (called \"new orders\" in this context) will get executed with the same price, so do all the sell orders; so that there is no chance for front-running on the same side. All the executed price will honor the order limit price; All the executed price for the new orders will be equal to or better than the concluded auction price P , so no front-running from the opposite side. For other orders that have arrived in the previous blocks, they will join match together with the new orders from the new block, and be considered as \"Maker\" role. The detailed explanation of Maker/Taker is as below:","title":"Order Matches"},{"location":"match.html#definition-of-maker-and-taker","text":"Among all the orders to be allocated, between buy and sell sides, this specification defines four concepts. Name Definition Maker Order order from the previous blocks Taker Order new incoming order in the current block Maker Side buy or sell side which has maker orders. May also have taker orders. Taker Side buy or sell side which only has taker orders. In each round of match, for all the orders that can be filled with the concluded price P , the algorithm ensures only one of the below two circumstances can happen, Both buy and sell side are Taker Side , when there is no leftover orders from all the previous blocks; One side is Maker Side that has orders from previous blocks (and may/may not have orders from this current block), and the other is Taker Side that only has orders from this current block.","title":"Definition of Maker and Taker"},{"location":"match.html#execution-pricing","text":"Among all the orders to be allocated, For maker side: all the maker orders are executed at their limit price all the taker orders on the maker side are executed at the concluded price P For taker side, all the orders are executed at the average execution price from the above #1 If no maker side in this match, all the orders are executed at price P .","title":"Execution Pricing"},{"location":"memo-validation.html","text":"Customized Scripts and Transfer Memo Validation Memo Validation As explained in BEP12 , In some circumstances, users may want to specify additional functions or/and validations on some transactions. With BEP12, exchanges can reject deposits that have no valid digits-only memo. Enable account scripts for cross-chain transfer BEP12 was introduced to check whether the memo field of any transfer transaction is empty. Since version 0.8.2 , the memo of cross-chain transfer is also checked. From now on, the deposit transaction without memo to exchanges be returned automatically. What is a customized script? This script is aimed to ensure the transfer transactions have valid memo (if the receivers require this). First, this script will check the following conditions: The transaction type is sent. The target address is the receiving address. Then this script will ensure that the transaction memo is not empty and the memo only contains digital letters. This is the pseudocode: func memoValiation(addr, tx) error { if tx.Type != \u201csend\u201d { return nil } if ! isReceiver(tx, addr) { return nil } if tx.memo.length == 0 { return err(\u201ctx memo is empty\u201d) } if tx.memo.length > 100 { return err(\u201ctx memo is too long\u201d) } if !isAllDigital(tx.memo) { return err(\u201ctx memo contains non digital character\u201d) } return nil } Fee 1 GSYS will be charged on enabling memo validation of transactions. Command Line Global Parameters Field Type Description from string Name of your key. chain-id string Name of blockchain node string url of the node Set-account-flags This transaction is aimed to set account flags to any hex value. Parameters Field Type Description account-flags string account flags, must be hex encoding string with prefix 0x Example on mainnet: ./eth-cli token account_flags set-account-flags --from <your-key-name> --account-flags 0x01 --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet: ./eth-cli token account_flags set-account-flags --from <your-key-name> --account-flags 0x01 --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Enable-memo-checker This transaction is aimed to aimed to enable transfer memo checker scripts. Example on mainnet: ./eth-cli account_flags enable-memo-checker --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet: ./eth-cli account_flags enable-memo-checker --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Disable-memo-checker This transaction is aimed to disable transfer memo checker. Example on mainnet: ./eth-cli account_flag disable-memo-checker --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet: ./eth-cli account_flag disable-memo-checker --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80","title":"Customized Scripts and Transfer Memo Validation"},{"location":"memo-validation.html#customized-scripts-and-transfer-memo-validation","text":"","title":"Customized Scripts and Transfer Memo Validation"},{"location":"memo-validation.html#memo-validation","text":"As explained in BEP12 , In some circumstances, users may want to specify additional functions or/and validations on some transactions. With BEP12, exchanges can reject deposits that have no valid digits-only memo.","title":"Memo Validation"},{"location":"memo-validation.html#enable-account-scripts-for-cross-chain-transfer","text":"BEP12 was introduced to check whether the memo field of any transfer transaction is empty. Since version 0.8.2 , the memo of cross-chain transfer is also checked. From now on, the deposit transaction without memo to exchanges be returned automatically.","title":"Enable account scripts for cross-chain transfer"},{"location":"memo-validation.html#what-is-a-customized-script","text":"This script is aimed to ensure the transfer transactions have valid memo (if the receivers require this). First, this script will check the following conditions: The transaction type is sent. The target address is the receiving address. Then this script will ensure that the transaction memo is not empty and the memo only contains digital letters. This is the pseudocode: func memoValiation(addr, tx) error { if tx.Type != \u201csend\u201d { return nil } if ! isReceiver(tx, addr) { return nil } if tx.memo.length == 0 { return err(\u201ctx memo is empty\u201d) } if tx.memo.length > 100 { return err(\u201ctx memo is too long\u201d) } if !isAllDigital(tx.memo) { return err(\u201ctx memo contains non digital character\u201d) } return nil }","title":"What is a customized script?"},{"location":"memo-validation.html#fee","text":"1 GSYS will be charged on enabling memo validation of transactions.","title":"Fee"},{"location":"memo-validation.html#command-line","text":"","title":"Command Line"},{"location":"memo-validation.html#global-parameters","text":"Field Type Description from string Name of your key. chain-id string Name of blockchain node string url of the node","title":"Global Parameters"},{"location":"memo-validation.html#set-account-flags","text":"This transaction is aimed to set account flags to any hex value.","title":"Set-account-flags"},{"location":"memo-validation.html#parameters","text":"Field Type Description account-flags string account flags, must be hex encoding string with prefix 0x Example on mainnet: ./eth-cli token account_flags set-account-flags --from <your-key-name> --account-flags 0x01 --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet: ./eth-cli token account_flags set-account-flags --from <your-key-name> --account-flags 0x01 --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80","title":"Parameters"},{"location":"memo-validation.html#enable-memo-checker","text":"This transaction is aimed to aimed to enable transfer memo checker scripts. Example on mainnet: ./eth-cli account_flags enable-memo-checker --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet: ./eth-cli account_flags enable-memo-checker --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80","title":"Enable-memo-checker"},{"location":"memo-validation.html#disable-memo-checker","text":"This transaction is aimed to disable transfer memo checker. Example on mainnet: ./eth-cli account_flag disable-memo-checker --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet: ./eth-cli account_flag disable-memo-checker --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80","title":"Disable-memo-checker"},{"location":"offline.html","text":"Offline eth-cli support generating and signing all types of transactions offline, then broadcast them. This feature will let users generate and sign their transactions at an offline machine, then use another machine to broadcast it to the network Generate your unsigned transaction First step is that you need to generate your unsigned transaction and save it in a file. Note: --account-number and --node is not mandatory in unsigned command You can generate an unsigned transfer transaction on testnet: ./eth-cli send --from <your-key-name> --account-number <your-sccount-number> --to <destination-address> --amount 200000000:GSYS --chain-id GSYS-Chain-Ganges --node=data-seed-pre-2-s1.genesys.network:80 --generate-only --offline >> unsigned.json You can generate an unsigned transfer transaction on mainnet: ./eth-cli send --from <your-key-name> --account-number <your-sccount-number> --to <destination-address> --amount 200000000:GSYS --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --generate-only --offline >> unsigned.json Then, you can see that the signature of unsigned.json is empty. Sign your transaction You can view the unsigned.json to verify that all the info about this transaction is correct. You need to get the account-number and sequence about your address here: https://docs.genesys.network/api-reference/dex-api/paths.html#apiv1accountaddress You can sign an unsigned transfer transaction on testnet: ./eth-cli sign unsigned.json --account-number <address-account-number> --sequence <address-sequence> --chain-id GSYS-Chain-Ganges --offline --name <your-key-name> >> signed.json You can sign an unsigned transfer transaction on mainnet: ./eth-cli sign unsigned.json --account-number <address-account-number> --sequence <address-sequence> --chain-id GSYS-Chain-Tigris --offline --name <your-key-name> >> signed.json You need to type in your password in this step Then, you can see that the signature of signed.json is no longer empty. Broadcast Your Transaction Please then copy your signed.json to a different server and broadcast this transaction. You can broadcast your transaction on testnet: ./eth-cli broadcast signed.json --node http://data-seed-pre-0-s3.genesys.network:80 You can broadcast your transaction on mainnet: ./eth-cli broadcast signed.json --node https://dataseed5.defibit.io:443 You can find the list of nodes here If the broadcast is successful, you will see the transaction hash in returned info. Please go and verify it in Explorer .","title":"Offline"},{"location":"offline.html#offline","text":"eth-cli support generating and signing all types of transactions offline, then broadcast them. This feature will let users generate and sign their transactions at an offline machine, then use another machine to broadcast it to the network","title":"Offline"},{"location":"offline.html#generate-your-unsigned-transaction","text":"First step is that you need to generate your unsigned transaction and save it in a file. Note: --account-number and --node is not mandatory in unsigned command You can generate an unsigned transfer transaction on testnet: ./eth-cli send --from <your-key-name> --account-number <your-sccount-number> --to <destination-address> --amount 200000000:GSYS --chain-id GSYS-Chain-Ganges --node=data-seed-pre-2-s1.genesys.network:80 --generate-only --offline >> unsigned.json You can generate an unsigned transfer transaction on mainnet: ./eth-cli send --from <your-key-name> --account-number <your-sccount-number> --to <destination-address> --amount 200000000:GSYS --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --generate-only --offline >> unsigned.json Then, you can see that the signature of unsigned.json is empty.","title":"Generate your unsigned transaction"},{"location":"offline.html#sign-your-transaction","text":"You can view the unsigned.json to verify that all the info about this transaction is correct. You need to get the account-number and sequence about your address here: https://docs.genesys.network/api-reference/dex-api/paths.html#apiv1accountaddress You can sign an unsigned transfer transaction on testnet: ./eth-cli sign unsigned.json --account-number <address-account-number> --sequence <address-sequence> --chain-id GSYS-Chain-Ganges --offline --name <your-key-name> >> signed.json You can sign an unsigned transfer transaction on mainnet: ./eth-cli sign unsigned.json --account-number <address-account-number> --sequence <address-sequence> --chain-id GSYS-Chain-Tigris --offline --name <your-key-name> >> signed.json You need to type in your password in this step Then, you can see that the signature of signed.json is no longer empty.","title":"Sign your transaction"},{"location":"offline.html#broadcast-your-transaction","text":"Please then copy your signed.json to a different server and broadcast this transaction. You can broadcast your transaction on testnet: ./eth-cli broadcast signed.json --node http://data-seed-pre-0-s3.genesys.network:80 You can broadcast your transaction on mainnet: ./eth-cli broadcast signed.json --node https://dataseed5.defibit.io:443 You can find the list of nodes here If the broadcast is successful, you will see the transaction hash in returned info. Please go and verify it in Explorer .","title":"Broadcast Your Transaction"},{"location":"resources.html","text":"More Help You can always post your question in Online Forum : this is the main portal to get community support. To keep track of the latest news in Genesys Chain/DEX, you can read our weekly updates. It will be published on Online Forum too.","title":"More Help"},{"location":"resources.html#more-help","text":"You can always post your question in Online Forum : this is the main portal to get community support. To keep track of the latest news in Genesys Chain/DEX, you can read our weekly updates. It will be published on Online Forum too.","title":"More Help"},{"location":"timelock.html","text":"TimeLock As explained in BEP9 , some business plans decide to lock certain amount tokens for pre-defined periods of time, and the only vest in the future according to the schedules. For example, some projects may lock some allocation of the issued tokens as a commitment by the founding team; some business scenarios also need to lock some tokens as collateral for value. TimeLock You can only lock tokens on your own account. TimeLock will transfer locked tokens to a purely-code-controlled escrow account and before the lock time expires. A purely-code-controlled escrow account is a kind of account which is derived from a hard-coded string in shree chain protocol. This kind of account doesn't have its own private key and it's only controlled by code of the protocol. The code for calculating escrow account is the same that is used in cosmos-sdk : TimeLockCoinsAccAddr = sdk.AccAddress(crypto.AddressHash([]byte(\"Genesys ChainTimeLockCoins\"))) The account for mainnet is: bnb1hn8ym9xht925jkncjpf7lhjnax6z8nv24fv2yq and the account for testnet is: tbnb1hn8ym9xht925jkncjpf7lhjnax6z8nv2mu9wy3 The specific user will not be able to claim them back, including restrictions where they cannot use, transfer or spend these tokens. Command line You must use --broadcast to submit your transaction to the blockchain, otherwise it will return an unsigned transaction. Parameters Field Type Description Description string Description of the lock operation. Max length of description is 128 bytes. Amount []Coin A set of tokens to be locked LockTime int64 The time when these tokens can be unlocked. LockTime is a future timestamp (seconds elapsed from January 1st, 1970 at UTC) and max LockTime should be before 10 years from now. broadcast bool if you want to submit your transaction to the blockchain Fee 0.01 GSYS will be charged on TimeLock transactions. Example On testnet, you can lock 1GSYS for 1 day. ./eth-cli token time-lock --amount \"100000000:GSYS\" --from <key-name> --description \" test timelock\" --lock-time <lock-timestamp> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 --broadcast On mainnet, you can lock 1GSYS for 1 day. ./eth-cli token time-lock --amount \"100000000:GSYS\" --from <key-name> --description \" test timelock\" --lock-time <lock-timestamp> --chain-id GSYS-Chain-Tigris --node http://dataseed1.genesys.network:80 --broadcast TimeUnlock TimeUnlock will claim the locked tokens back when the specified lock time has passed. Parameters Field Type Description address string the address you want to query time-lock-id int64 the id of your locking, it's incremental Fee 0.01 GSYS will be charged on ReLock transactions. Example On testnet, you can unlock tokens ./eth-cli token time-unlock --from <your-address> --time-lock-id <lock-id> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 On mainnet, you can unlock tokens. ./eth-cli token time-unlock --from <key-name> --time-lock-id <lock-id> --chain-id GSYS-Chain-Tigris --node http://dataseed1.genesys.network:80 Example output for trying to unlock tokens whose locking period is not expired: ERROR: {\"codespace\":7,\"code\":7,\"abci_code\":458759,\"message\":\"Can not unlock: lock time(2019-06-28 09:26:54 +0000 UTC) is after now(2019-06-27 08:31:54.680643156 +0000 UTC)\"} TimeRelock TimeRelock can extend lock times, increase the amount of locked tokens or modify the description of an existing lock record. PLease note that you either increase the expire time or amount of your lock of tokens which are not unlocked. Parameters Field Type Description time-lock-id int64 the id of your locking, it's incremental Amount []Coin A set of tokens to be locked LockTime int64 The time when these tokens can be unlocked. LockTime is a future timestamp(seconds elapsed from January 1st, 1970 at UTC) and max LockTime should be before 10 years from now. broadcast bool if you want to submit your transaction to the blockchain Fee 0.01 GSYS will be charged on UnLock transactions. Example On testnet, you can relock tokens ./eth-cli token time-relock --time-lock-id <lock-id> --increase-amount-to <amount of tokens> --from <key-name> --chain-id GSYS-Chain-Ganges --node=data-seed-pre-2-s1.genesys.network:80 --broadcast On mainnet, you can relock tokens ./eth-cli token time-relock --time-lock-id <lock-id> --increase-amount-to <amount of tokens> --from <key-name> --chain-id GSYS-Chain-Tigris --node http://dataseed1.genesys.network:80 --broadcast Output if you don't add more tokens or don't extend your locking period, you will get the following error: ERROR: {\"codespace\":7,\"code\":6,\"abci_code\":458758,\"message\":\"Invalid lock amount: new locked coins(100000000GSYS) should be more than original locked coins(100000000GSYS)\"} QueryTimeLock QueryTimeLock will query a lock record of a given address by the id. If this locking is ended, then no info will be returned. Parameters Field Type Description time-lock-id int64 the id of your locking, it's incremental Example On testnet, you can query lock history by ID: ./eth-cli token query-time-lock --from <your-key-name> --time-lock-id <lock-id> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 On mainnet, you can query lock history: ./eth-cli token query-time-lock --from <your-key-name> --time-lock-id <lock-id> --chain-id GSYS-Chain-Tigris --trust-node --node http://dataseed1.genesys.network:80 Example output: [ { \"id\": \"1\", \"description\": \" test timelock\", \"amount\": [ { \"denom\": \"GSYS\", \"amount\": \"100000000\" } ], \"lock_time\": \"2019-06-27T01:59:52Z\" } ] QueryTimeLocks QueryTimeLocks will query all lock records of a given address. QueryTimeLock Parameters Field Type Description address string the address you want to query Example On testnet, you can query lock history by address: ./eth-cli token query-time-locks --address <your-address> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 On mainnet, you can query lock history by address: ./eth-cli token query-time-locks --address <your-address> --chain-id GSYS-Chain-Tigris --trust-node --node http://dataseed1.genesys.network:80 Example output: [ { \"id\": \"1\", \"description\": \" test timelock\", \"amount\": [ { \"denom\": \"GSYS\", \"amount\": \"100000000\" } ], \"lock_time\": \"2019-06-27T01:59:52Z\" }, { \"id\": \"2\", \"description\": \" test timelock\", \"amount\": [ { \"denom\": \"GSYS\", \"amount\": \"100000000\" } ], \"lock_time\": \"2019-06-28T09:26:54Z\" } ]","title":"TimeLock"},{"location":"timelock.html#timelock","text":"As explained in BEP9 , some business plans decide to lock certain amount tokens for pre-defined periods of time, and the only vest in the future according to the schedules. For example, some projects may lock some allocation of the issued tokens as a commitment by the founding team; some business scenarios also need to lock some tokens as collateral for value.","title":"TimeLock"},{"location":"timelock.html#timelock_1","text":"You can only lock tokens on your own account. TimeLock will transfer locked tokens to a purely-code-controlled escrow account and before the lock time expires. A purely-code-controlled escrow account is a kind of account which is derived from a hard-coded string in shree chain protocol. This kind of account doesn't have its own private key and it's only controlled by code of the protocol. The code for calculating escrow account is the same that is used in cosmos-sdk : TimeLockCoinsAccAddr = sdk.AccAddress(crypto.AddressHash([]byte(\"Genesys ChainTimeLockCoins\"))) The account for mainnet is: bnb1hn8ym9xht925jkncjpf7lhjnax6z8nv24fv2yq and the account for testnet is: tbnb1hn8ym9xht925jkncjpf7lhjnax6z8nv2mu9wy3 The specific user will not be able to claim them back, including restrictions where they cannot use, transfer or spend these tokens.","title":"TimeLock"},{"location":"timelock.html#command-line","text":"You must use --broadcast to submit your transaction to the blockchain, otherwise it will return an unsigned transaction.","title":"Command line"},{"location":"timelock.html#parameters","text":"Field Type Description Description string Description of the lock operation. Max length of description is 128 bytes. Amount []Coin A set of tokens to be locked LockTime int64 The time when these tokens can be unlocked. LockTime is a future timestamp (seconds elapsed from January 1st, 1970 at UTC) and max LockTime should be before 10 years from now. broadcast bool if you want to submit your transaction to the blockchain","title":"Parameters"},{"location":"timelock.html#fee","text":"0.01 GSYS will be charged on TimeLock transactions.","title":"Fee"},{"location":"timelock.html#example","text":"On testnet, you can lock 1GSYS for 1 day. ./eth-cli token time-lock --amount \"100000000:GSYS\" --from <key-name> --description \" test timelock\" --lock-time <lock-timestamp> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 --broadcast On mainnet, you can lock 1GSYS for 1 day. ./eth-cli token time-lock --amount \"100000000:GSYS\" --from <key-name> --description \" test timelock\" --lock-time <lock-timestamp> --chain-id GSYS-Chain-Tigris --node http://dataseed1.genesys.network:80 --broadcast","title":"Example"},{"location":"timelock.html#timeunlock","text":"TimeUnlock will claim the locked tokens back when the specified lock time has passed.","title":"TimeUnlock"},{"location":"timelock.html#parameters_1","text":"Field Type Description address string the address you want to query time-lock-id int64 the id of your locking, it's incremental","title":"Parameters"},{"location":"timelock.html#fee_1","text":"0.01 GSYS will be charged on ReLock transactions.","title":"Fee"},{"location":"timelock.html#example_1","text":"On testnet, you can unlock tokens ./eth-cli token time-unlock --from <your-address> --time-lock-id <lock-id> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 On mainnet, you can unlock tokens. ./eth-cli token time-unlock --from <key-name> --time-lock-id <lock-id> --chain-id GSYS-Chain-Tigris --node http://dataseed1.genesys.network:80 Example output for trying to unlock tokens whose locking period is not expired: ERROR: {\"codespace\":7,\"code\":7,\"abci_code\":458759,\"message\":\"Can not unlock: lock time(2019-06-28 09:26:54 +0000 UTC) is after now(2019-06-27 08:31:54.680643156 +0000 UTC)\"}","title":"Example"},{"location":"timelock.html#timerelock","text":"TimeRelock can extend lock times, increase the amount of locked tokens or modify the description of an existing lock record. PLease note that you either increase the expire time or amount of your lock of tokens which are not unlocked.","title":"TimeRelock"},{"location":"timelock.html#parameters_2","text":"Field Type Description time-lock-id int64 the id of your locking, it's incremental Amount []Coin A set of tokens to be locked LockTime int64 The time when these tokens can be unlocked. LockTime is a future timestamp(seconds elapsed from January 1st, 1970 at UTC) and max LockTime should be before 10 years from now. broadcast bool if you want to submit your transaction to the blockchain","title":"Parameters"},{"location":"timelock.html#fee_2","text":"0.01 GSYS will be charged on UnLock transactions.","title":"Fee"},{"location":"timelock.html#example_2","text":"On testnet, you can relock tokens ./eth-cli token time-relock --time-lock-id <lock-id> --increase-amount-to <amount of tokens> --from <key-name> --chain-id GSYS-Chain-Ganges --node=data-seed-pre-2-s1.genesys.network:80 --broadcast On mainnet, you can relock tokens ./eth-cli token time-relock --time-lock-id <lock-id> --increase-amount-to <amount of tokens> --from <key-name> --chain-id GSYS-Chain-Tigris --node http://dataseed1.genesys.network:80 --broadcast Output if you don't add more tokens or don't extend your locking period, you will get the following error: ERROR: {\"codespace\":7,\"code\":6,\"abci_code\":458758,\"message\":\"Invalid lock amount: new locked coins(100000000GSYS) should be more than original locked coins(100000000GSYS)\"}","title":"Example"},{"location":"timelock.html#querytimelock","text":"QueryTimeLock will query a lock record of a given address by the id. If this locking is ended, then no info will be returned.","title":"QueryTimeLock"},{"location":"timelock.html#parameters_3","text":"Field Type Description time-lock-id int64 the id of your locking, it's incremental","title":"Parameters"},{"location":"timelock.html#example_3","text":"On testnet, you can query lock history by ID: ./eth-cli token query-time-lock --from <your-key-name> --time-lock-id <lock-id> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 On mainnet, you can query lock history: ./eth-cli token query-time-lock --from <your-key-name> --time-lock-id <lock-id> --chain-id GSYS-Chain-Tigris --trust-node --node http://dataseed1.genesys.network:80 Example output: [ { \"id\": \"1\", \"description\": \" test timelock\", \"amount\": [ { \"denom\": \"GSYS\", \"amount\": \"100000000\" } ], \"lock_time\": \"2019-06-27T01:59:52Z\" } ]","title":"Example"},{"location":"timelock.html#querytimelocks","text":"QueryTimeLocks will query all lock records of a given address.","title":"QueryTimeLocks"},{"location":"timelock.html#querytimelock-parameters","text":"Field Type Description address string the address you want to query","title":"QueryTimeLock Parameters"},{"location":"timelock.html#example_4","text":"On testnet, you can query lock history by address: ./eth-cli token query-time-locks --address <your-address> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 On mainnet, you can query lock history by address: ./eth-cli token query-time-locks --address <your-address> --chain-id GSYS-Chain-Tigris --trust-node --node http://dataseed1.genesys.network:80 Example output: [ { \"id\": \"1\", \"description\": \" test timelock\", \"amount\": [ { \"denom\": \"GSYS\", \"amount\": \"100000000\" } ], \"lock_time\": \"2019-06-27T01:59:52Z\" }, { \"id\": \"2\", \"description\": \" test timelock\", \"amount\": [ { \"denom\": \"GSYS\", \"amount\": \"100000000\" } ], \"lock_time\": \"2019-06-28T09:26:54Z\" } ]","title":"Example"},{"location":"tokens.html","text":"Asset Management Introduction Assets are stored as tokens on Genesys Chain, and the below management actions are available. All the assets are complied with BEP2 . The fees that are due must be paid in GSYS before any of these operations can be executed. The fees for testnet and mainnet are different. Please note: Before you run any command examples on this page, and if you have not done so already, you must generate or add a key to eth-cli . Also remember: The chain-id and node parameters passed to eth-cli may vary, and the chain-id for mainnet is GSYS-Chain-Tigris , and is GSYS-Chain-Ganges for testnet. To find the latest list of endpoints for the mainnet, please check the peers list . To find the latest endpoints for the testnet, please check the peers list . Issue Issue is a transaction used to create a new asset. Anyone can issue a new token with fee paid. After issuing, the token would appear in the issuer's account as free balance. An issuance transaction contains: Note: BEP87 is implemented after Lagrange Upgrade. It changes the minimal symbol length to two Source Address: the sender address of the transaction and it will become the owner of the token, all created tokens will be in this account. Token Name: it is the long official name, such as \"Genesys\". It is limited to 32 characters. Symbol: identifier of the token, limited to alphanumeric characters and is case insensitive, for example, \"GSYS\". The length of symbol should be between 2 and 8. \"B\" suffixed symbol is also allowed for migrating tokens that already exist on other chains. The symbol doesn't have to be unique, \"-\" followed by random 3 letters will be appended to the provided symbol to avoid uniqueness constraint. Those 3 letters are the first three letters of tx hash of the issue transaction. For example, \"NNB-B90\". Only GSYS does not have this suffix. Total Supply: an int64 boosted by 1e8 for decimal part. The max total supply is 90 billion. Mintable: that means whether this token can be minted in the future. To set the tokes to be mintable, you need to add --mintable , otherwise just omit this field to set this token to be non-mintable. Example on mainnet : # To issue a NNB mintable token with total-supply 1 billion on mainnet > ./eth-cli token issue --token-name \"new token\" --total-supply 100000000000000000 --symbol NNB --mintable --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node # To issue a NNB non-mintable token with total-supply 1 billion on mainnet > ./eth-cli token issue --token-name \"new token\" --total-supply 100000000000000000 --symbol NNB --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet : # To issue a NNB mintable token with total-supply 1 billion on testnet > ./eth-cli token issue --token-name \"new bnb\" --total-supply 100000000000000000 --symbol NNB --mintable --from alice --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --trust-node Committed at block 1887 ( tx hash: B90A055DDD570AE42A7050182993A0B4DBC81A0D, ... Issued NNB-B90... ) # To issue a NNB non-mintable token with total-supply 1 billion on testnet > ./eth-cli token issue --token-name \"new bnb\" --total-supply 100000000000000000 --symbol NNB --from alice --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --trust-node Committed at block 1887 ( tx hash: B90A055DDD570AE42A7050182993A0B4DBC81A0D, ... Issued NNB-B90... ) Mint Tokens that is \"mintable\"(specified when issue) can use this function. The amount is boosted by 1e8 for decimal part. The total supply after mint is still restricted by 90 billion. Note only the owner of the token can use this transaction. Example on mainnet : > ./eth-cli token mint --amount 100000000000000000 --symbol NNB-B90 --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet : > ./eth-cli token mint --amount 100000000000000000 --symbol NNB-B90 --from alice --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --trust-node Burn Burn is to destroy certain amount of token, after which that amount of tokens will be subtracted from the operator's balance. The total supply will be updated at the same time. Notice that only the owner of the token has the permission to burn token. The amount is boosted by 1e8 for decimal part. Example on mainnet : > ./eth-cli token burn --amount 100000000000000000 --symbol NNB-B90 --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet : > ./eth-cli token burn --amount 100000000000000000 --symbol NNB-B90 --from alice --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --trust-node Freeze & Unfreeze Freeze would move the specified amount of token into \"frozen\" status, so that these tokens can not transferred, spent in orders or any other transaction until they are unfreezed. Anyone can (only) freeze or unfreeze tokens on their account with status in \"free\". The amount is boosted by 1e8 for decimal part. Example on mainnet : > ./eth-cli token freeze --amount 20000000000000000 --symbol NNB-B90 --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node > ./eth-cli token unfreeze --amount 20000000000000000 --symbol NNB-B90 --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet : > ./eth-cli token freeze --amount 20000000000000000 --symbol NNB-B90 --from alice --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --trust-node > ./eth-cli token unfreeze --amount 20000000000000000 --symbol NNB-B90 --from alice --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --trust-node TransferOwnership Note: BEP82 is implemented after Lagrange Upgrade to add this new transactionn type. 0.01 GSYS will be charged on TransferOwnership transactions. Example on mainnet : ./eth-cli token transfer-ownership --from $current -owner --symbol $symbol --new-owner $new -owner --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet : ./eth-cli token transfer-ownership --from $current -owner --symbol $symbol --new-owner $new -owner --chain-id GSYS-Chain-Nile --node = data-seed-pre-2-s1.genesys.network:80--trust-node","title":"Asset Management"},{"location":"tokens.html#asset-management","text":"","title":"Asset Management"},{"location":"tokens.html#introduction","text":"Assets are stored as tokens on Genesys Chain, and the below management actions are available. All the assets are complied with BEP2 . The fees that are due must be paid in GSYS before any of these operations can be executed. The fees for testnet and mainnet are different. Please note: Before you run any command examples on this page, and if you have not done so already, you must generate or add a key to eth-cli . Also remember: The chain-id and node parameters passed to eth-cli may vary, and the chain-id for mainnet is GSYS-Chain-Tigris , and is GSYS-Chain-Ganges for testnet. To find the latest list of endpoints for the mainnet, please check the peers list . To find the latest endpoints for the testnet, please check the peers list .","title":"Introduction"},{"location":"tokens.html#issue","text":"Issue is a transaction used to create a new asset. Anyone can issue a new token with fee paid. After issuing, the token would appear in the issuer's account as free balance. An issuance transaction contains: Note: BEP87 is implemented after Lagrange Upgrade. It changes the minimal symbol length to two Source Address: the sender address of the transaction and it will become the owner of the token, all created tokens will be in this account. Token Name: it is the long official name, such as \"Genesys\". It is limited to 32 characters. Symbol: identifier of the token, limited to alphanumeric characters and is case insensitive, for example, \"GSYS\". The length of symbol should be between 2 and 8. \"B\" suffixed symbol is also allowed for migrating tokens that already exist on other chains. The symbol doesn't have to be unique, \"-\" followed by random 3 letters will be appended to the provided symbol to avoid uniqueness constraint. Those 3 letters are the first three letters of tx hash of the issue transaction. For example, \"NNB-B90\". Only GSYS does not have this suffix. Total Supply: an int64 boosted by 1e8 for decimal part. The max total supply is 90 billion. Mintable: that means whether this token can be minted in the future. To set the tokes to be mintable, you need to add --mintable , otherwise just omit this field to set this token to be non-mintable. Example on mainnet : # To issue a NNB mintable token with total-supply 1 billion on mainnet > ./eth-cli token issue --token-name \"new token\" --total-supply 100000000000000000 --symbol NNB --mintable --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node # To issue a NNB non-mintable token with total-supply 1 billion on mainnet > ./eth-cli token issue --token-name \"new token\" --total-supply 100000000000000000 --symbol NNB --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet : # To issue a NNB mintable token with total-supply 1 billion on testnet > ./eth-cli token issue --token-name \"new bnb\" --total-supply 100000000000000000 --symbol NNB --mintable --from alice --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --trust-node Committed at block 1887 ( tx hash: B90A055DDD570AE42A7050182993A0B4DBC81A0D, ... Issued NNB-B90... ) # To issue a NNB non-mintable token with total-supply 1 billion on testnet > ./eth-cli token issue --token-name \"new bnb\" --total-supply 100000000000000000 --symbol NNB --from alice --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --trust-node Committed at block 1887 ( tx hash: B90A055DDD570AE42A7050182993A0B4DBC81A0D, ... Issued NNB-B90... )","title":"Issue"},{"location":"tokens.html#mint","text":"Tokens that is \"mintable\"(specified when issue) can use this function. The amount is boosted by 1e8 for decimal part. The total supply after mint is still restricted by 90 billion. Note only the owner of the token can use this transaction. Example on mainnet : > ./eth-cli token mint --amount 100000000000000000 --symbol NNB-B90 --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet : > ./eth-cli token mint --amount 100000000000000000 --symbol NNB-B90 --from alice --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --trust-node","title":"Mint"},{"location":"tokens.html#burn","text":"Burn is to destroy certain amount of token, after which that amount of tokens will be subtracted from the operator's balance. The total supply will be updated at the same time. Notice that only the owner of the token has the permission to burn token. The amount is boosted by 1e8 for decimal part. Example on mainnet : > ./eth-cli token burn --amount 100000000000000000 --symbol NNB-B90 --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet : > ./eth-cli token burn --amount 100000000000000000 --symbol NNB-B90 --from alice --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --trust-node","title":"Burn"},{"location":"tokens.html#freeze-unfreeze","text":"Freeze would move the specified amount of token into \"frozen\" status, so that these tokens can not transferred, spent in orders or any other transaction until they are unfreezed. Anyone can (only) freeze or unfreeze tokens on their account with status in \"free\". The amount is boosted by 1e8 for decimal part. Example on mainnet : > ./eth-cli token freeze --amount 20000000000000000 --symbol NNB-B90 --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node > ./eth-cli token unfreeze --amount 20000000000000000 --symbol NNB-B90 --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet : > ./eth-cli token freeze --amount 20000000000000000 --symbol NNB-B90 --from alice --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --trust-node > ./eth-cli token unfreeze --amount 20000000000000000 --symbol NNB-B90 --from alice --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --trust-node","title":"Freeze &amp; Unfreeze"},{"location":"tokens.html#transferownership","text":"Note: BEP82 is implemented after Lagrange Upgrade to add this new transactionn type. 0.01 GSYS will be charged on TransferOwnership transactions. Example on mainnet : ./eth-cli token transfer-ownership --from $current -owner --symbol $symbol --new-owner $new -owner --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet : ./eth-cli token transfer-ownership --from $current -owner --symbol $symbol --new-owner $new -owner --chain-id GSYS-Chain-Nile --node = data-seed-pre-2-s1.genesys.network:80--trust-node","title":"TransferOwnership"},{"location":"trade.html","text":"Trade GSYS DEX is the native marketplace which allows you to exchange digital assets issued and listed on it. The matching happens within the blockchain nodes and all of the transactions are recorded on-chain, therefore forming a complete, auditable ledger of activity. The following commands are available for trading: Place Order You could place a new order with the following command on testnet: $ eth-cli dex order --symbol ZEBRA-16D_GSYS --side 1 --price 1000000 --qty 1000 --from guest --chain-id GSYS-Chain-Ganges --node=data-seed-pre-2-s1.genesys.network:80 -t gte You will be able to place order on mainnet by replaceing chain-id and node . Example on mainnet : $ eth-cli dex order --symbol ZEBRA-16D_GSYS --side 1 --price 1000000 --qty 1000 --from guest --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 -t gte For side , you need to put 1 as buy or 2 as sell. Please note that the quantity should be rounded to lotSize . Otherwise your order could be invalid. The returned output is the following: Committed at block 1616083 (tx hash: C550F348B3A62880062F9DCF67794F08889234D0360B26CF31E68F8D3105C58F, response: {Code:0 Data:[123 34 111 114 100 101 114 95 105 100 34 58 34 56 49 51 69 52 57 51 57 70 49 53 54 55 66 50 49 57 55 48 52 70 70 67 50 65 68 52 68 70 53 56 66 68 69 48 49 48 56 55 57 45 51 48 34 125] Log:Msg 0: Info: GasWanted:0 GasUsed:0 Tags:[{Key:[97 99 116 105 111 110] Value:[111 114 100 101 114 78 101 119] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] Codespace: XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}) Msg [NewOrderMsg{Sender: 813E4939F1567B219704FFC2AD4DF58BDE010879, Id: 813E4939F1567B219704FFC2AD4DF58BDE010879-30, Symbol: ZEBRA-16D_GSYS}] was sent. The order id is needed if you want to cancel this order later. Cancel Order To cancel an order, you could use the following command to cencel order on testnet: eth-cli dex cancel --symbol ZEBRA-16D_GSYS --chain-id GSYS-Chain-Ganges --node=data-seed-pre-2-s1.genesys.network:80 --refid 813E4939F1567B219704FFC2AD4DF58BDE010879-30 --from guest Please note that refid is what you got from order command. Example on mainnet : eth-cli dex cancel --symbol ZEBRA-16D_GSYS --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --refid 813E4939F1567B219704FFC2AD4DF58BDE010879-30 --from guest View Orders To verify that your commands are executed as expected, you could query the orderbook of testnet. eth-cli dex show -l ZEBRA-16D_GSYS --chain-id GSYS-Chain-Ganges --node=data-seed-pre-2-s1.genesys.network:80 Example output is the following: SellQty| SellPrice| BuyPrice| BuyQty 58.14066000| 0.01400000| 0.00100000| 522278.22159000 674664.35943000| 0.01500000| 0.00000000| 0.00000000 291157.71192000| 0.01800000| 0.00000000| 0.00000000 229.20432000| 0.01900000| 0.00000000| 0.00000000 292616.45027000| 0.02000000| 0.00000000| 0.00000000 694954.49683000| 0.03000000| 0.00000000| 0.00000000 279267.00000000| 0.04000000| 0.00000000| 0.00000000 271236.08958000| 0.04500000| 0.00000000| 0.00000000 108472.66524300| 0.05000000| 0.00000000| 0.00000000 155000.00000000| 0.06000000| 0.00000000| 0.00000000 105028.64699000| 0.07000000| 0.00000000| 0.00000000 100000.00000000| 0.08000000| 0.00000000| 0.00000000 263025.58796000| 0.08500000| 0.00000000| 0.00000000 1500427.52685800| 0.09000000| 0.00000000| 0.00000000 2027178.06520900| 0.10000000| 0.00000000| 0.00000000 114.58796000| 0.17500000| 0.00000000| 0.00000000 15305.95524500| 0.20000000| 0.00000000| 0.00000000 10283.97968700| 0.30000000| 0.00000000| 0.00000000 Example on mainnet : eth-cli dex show -l ZEBRA-16D_GSYS --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443","title":"Trade"},{"location":"trade.html#trade","text":"GSYS DEX is the native marketplace which allows you to exchange digital assets issued and listed on it. The matching happens within the blockchain nodes and all of the transactions are recorded on-chain, therefore forming a complete, auditable ledger of activity. The following commands are available for trading:","title":"Trade"},{"location":"trade.html#place-order","text":"You could place a new order with the following command on testnet: $ eth-cli dex order --symbol ZEBRA-16D_GSYS --side 1 --price 1000000 --qty 1000 --from guest --chain-id GSYS-Chain-Ganges --node=data-seed-pre-2-s1.genesys.network:80 -t gte You will be able to place order on mainnet by replaceing chain-id and node . Example on mainnet : $ eth-cli dex order --symbol ZEBRA-16D_GSYS --side 1 --price 1000000 --qty 1000 --from guest --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 -t gte For side , you need to put 1 as buy or 2 as sell. Please note that the quantity should be rounded to lotSize . Otherwise your order could be invalid. The returned output is the following: Committed at block 1616083 (tx hash: C550F348B3A62880062F9DCF67794F08889234D0360B26CF31E68F8D3105C58F, response: {Code:0 Data:[123 34 111 114 100 101 114 95 105 100 34 58 34 56 49 51 69 52 57 51 57 70 49 53 54 55 66 50 49 57 55 48 52 70 70 67 50 65 68 52 68 70 53 56 66 68 69 48 49 48 56 55 57 45 51 48 34 125] Log:Msg 0: Info: GasWanted:0 GasUsed:0 Tags:[{Key:[97 99 116 105 111 110] Value:[111 114 100 101 114 78 101 119] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] Codespace: XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}) Msg [NewOrderMsg{Sender: 813E4939F1567B219704FFC2AD4DF58BDE010879, Id: 813E4939F1567B219704FFC2AD4DF58BDE010879-30, Symbol: ZEBRA-16D_GSYS}] was sent. The order id is needed if you want to cancel this order later.","title":"Place Order"},{"location":"trade.html#cancel-order","text":"To cancel an order, you could use the following command to cencel order on testnet: eth-cli dex cancel --symbol ZEBRA-16D_GSYS --chain-id GSYS-Chain-Ganges --node=data-seed-pre-2-s1.genesys.network:80 --refid 813E4939F1567B219704FFC2AD4DF58BDE010879-30 --from guest Please note that refid is what you got from order command. Example on mainnet : eth-cli dex cancel --symbol ZEBRA-16D_GSYS --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --refid 813E4939F1567B219704FFC2AD4DF58BDE010879-30 --from guest","title":"Cancel Order"},{"location":"trade.html#view-orders","text":"To verify that your commands are executed as expected, you could query the orderbook of testnet. eth-cli dex show -l ZEBRA-16D_GSYS --chain-id GSYS-Chain-Ganges --node=data-seed-pre-2-s1.genesys.network:80 Example output is the following: SellQty| SellPrice| BuyPrice| BuyQty 58.14066000| 0.01400000| 0.00100000| 522278.22159000 674664.35943000| 0.01500000| 0.00000000| 0.00000000 291157.71192000| 0.01800000| 0.00000000| 0.00000000 229.20432000| 0.01900000| 0.00000000| 0.00000000 292616.45027000| 0.02000000| 0.00000000| 0.00000000 694954.49683000| 0.03000000| 0.00000000| 0.00000000 279267.00000000| 0.04000000| 0.00000000| 0.00000000 271236.08958000| 0.04500000| 0.00000000| 0.00000000 108472.66524300| 0.05000000| 0.00000000| 0.00000000 155000.00000000| 0.06000000| 0.00000000| 0.00000000 105028.64699000| 0.07000000| 0.00000000| 0.00000000 100000.00000000| 0.08000000| 0.00000000| 0.00000000 263025.58796000| 0.08500000| 0.00000000| 0.00000000 1500427.52685800| 0.09000000| 0.00000000| 0.00000000 2027178.06520900| 0.10000000| 0.00000000| 0.00000000 114.58796000| 0.17500000| 0.00000000| 0.00000000 15305.95524500| 0.20000000| 0.00000000| 0.00000000 10283.97968700| 0.30000000| 0.00000000| 0.00000000 Example on mainnet : eth-cli dex show -l ZEBRA-16D_GSYS --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443","title":"View Orders"},{"location":"trading-spec.html","text":"GSYS DEX Trading Specification Orders Orders are the requests for client to buy or sell tokens into other tokens on GSYS DEX. It is a standard type of Genesys Chain transaction. Orders are composed of the below parameters. Symbol Pairs: the list pair the order wants to trade. Order Type: GSYS DEX only accept LIMIT orders, which is adhering to SEC definitions of LIMIT orders Price: price users would like to pay for the specified token quantity, presented as a float number of quote currency. This must be rounded by tick size. Internally it can be multiplied by 1e8(10^8) in order to store as an integer in the range of int64. Quantity: number of tokens users want to buy or sell. That must be rounded by lot size. Internally it can be multiplied by 1e8(10^8) in order to store as an integer in the range of int64. Side: buy or sell Time: entry time of the order, which is the block number(height) the order gets booked in. TimeInForce: GTE: Good Till Expire. Order would stay effective until expire time. Order may expire in the UTC midnight after more than 259, 200 blocks, which is 72 hours in term of blocking time. IOC: Immediate or Cancel. Orders would be executed as much as it can in the booking block round and then got canceled back if there is still quantity left. Orders would be rejected when: user address cannot be located with asset Account does not possess enough token to buy or sell Exchange is down or has problem to match it The token is not listed against any base currencies Other order parameters are not valid Duplicated order ID Orders may be canceled / expired back when: IOC order not fully filled Order expired Exchange has problem to handle further with the orders After orders are received by any blockchain node, the node would try to submit the order transaction onto a block with consensus. After the order is accepted in an block, 2 things would happen, the assets that may transfer with the order would be locked and cannot be transferred; the GSYS DEX would try to match the order against any existing orders or new orders from the same block. If the order can match with any opposite side, the trade would be generated and the assets would be transferred. The fully filled orders would be removed from the order book, while the unfilled or partially filled GTE would stay on the order book until it is filled by others; unfilled or partially filled IOC order would be canceled. Order Lifecycle Valid orders sent to the matching engine are confirmed immediately and are in the Ack state andinvalid orders will be FailedMatching state. GTE and IOC orders have different lifecycle. For IOC order, if an IOC order executes against another order immediately as a whole, the order is considered FullyFill . An IOC order can execute in part and ends in IocExpire state. If no part of the IOC order is filled, will be considered IocNoFill . For GTE order, if a GTE order can execute against another order as a whole, the order is considered FullyFill . Any part of the order not filled immediately, will be considered open. Orders will stay in the open until it's canceled or subsequently filled by new orders. Canceled GTE orders are in the Canceled state. Orders that are no longer eligible for matching are in the Expired state. Order Expire Order would expire after 72 hours once it is booked on a block. A whole order book scan would happen every UTC mid-night to filter out all the expired orders. After the scan, all the expired orders would be removed from the order book, the locked quantity in the account would be unlocked. Before this action all the existing orders in the order book is subject to matching. Tip As discussed in BEP-67 , those orders in the best 500 price levels on both ask and bid side will be expired after 30 days instead of 72 hours. Meanwhile, the expiration fee is unchanged. BEP67 is already implemented and has been activated after Testnet Nightingale Upgrade. Genesys Chain Mainnet will be upgraded to support BEP-67 soon. Precision All the numbers are limited to 8-digit decimals. Tick Size and Lot Size Tick size stands for the smallest unit on price change, while lot size stands for the smallest quantity change. Order price must be larger than and rounded to 1 tick size and order quantity must be larger than and rounded to 1 lot size, otherwise orders would be rejected. Tick size and lot size can be queried from DEX API, and they would be reviewed and changed by DEX match engine automatically according to the trading price every UTC mid-night. Once the tick size or/and lot size is changed, new orders must stick to the new values while the existing orders on the order book can still be traded. Fees We have five kinds of order operations, each kind has its specific fee calculation logic and collection timing as the table described below. Operation Calculation Collection Timing Place order free - Cancel order fixed fees when the Cancel transaction executes Order expire fixed fees if fully expired, otherwise free when the scheduled order expiration happenes IOC order cancel fixed fees if fully canceled, otherwise free when the IOC order is not fully filled Order execution rate based fees when the order matched GSYS is the priority in the fee collection and has some discounts. DEX would always calculate and collect the fees based on the latest balance and in the best interest of users. Current Fees Table on Mainnet Fees are variable and may change over time as governance proposals are proposed and voted on. The current fees table for Mainnet as of 2021-03-21 is as follows: Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related New Order 0 0 Y Cancel (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y Order Expire (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y IOC (No Fill) Equivalent 0.00025 GSYS 0.000005 GSYS Y Transfer N/A 0.000075 GSYS N crossTransferOut N/A 0.000075 GSYS N Multi-send N/A 0.00006 GSYS N Issue Asset N/A 10 GSYS Mint Asset N/A 0.002 GSYS N Transfer ownership N/A 0.002 GSYS N Burn Asset N/A 0.002 GSYS N Freeze/Unfreeze Asset N/A 0.001 GSYS N Lock/unlock/relock Asset N/A 0.002 GSYS N List Asset N/A 200 GSYS N Submit Proposal N/A 1 GSYS N Deposit N/A 0.000125 GSYS N Enable Memo Check N/A 0.2 GSYS N Disable Memo Check N/A 0.2 GSYS N HTLT N/A 0.000075 GSYS N depositHTLT N/A 0.000075 GSYS N claimHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N TinyIssueFee N/A 0.4 GSYS N MiniIssueFee N/A 0.6 GSYS N SetTokenUri N/A 0.000075 GSYS N List BEP8 Token N/A 1 GSYS N Create A New Smart Chain Validator N/A 2 GSYS N Edit Smart Chain Validator Information N/A 0.2 GSYS N Delegate Smart Chain Validator N/A 0.0002 GSYS N Redelegate Smart Chain Validator N/A 0.0006 GSYS N Undelegate Smart Chain Validator N/A 0.0004 GSYS N Unjail A Smart Chain Validator N/A 0.5 GSYS N Submit Byzaitine Behavior Evidence of A Smart Chain Validator N/A 0.5 GSYS N Submit Smart Chain Proposal N/A 1 GSYS N Smart Chain Proposal Deposit N/A 0.00025 GSYS N Smart Chain Proposal Vote N/A 0 GSYS N Cross transfer out relayer reward N/A 0.0004 GSYS N Mainnet Fees API View system fees updated in real time here . Multi-send Fees eth-cli offers you a multi-send command to transfer multiple tokens to multiple people. 20% discount is available for multi-send transactions. For now, multi-send transaction will send some tokens from one address to multiple output addresses. If the count of output address is bigger than the threshold, currently it's 2, then the total transaction fee is 0.0003 GSYS per token per address. For example, if you send 3 ABC token,1 SAT token and 1 ABC to 3 different addresses. [ { \"to\" : \"bnb1g5p04snezgpky203fq6da9qyjsy2k9kzr5yuhl\" , \"amount\" : \"100000000:GSYS,100000000:ABC\" }, { \"to\" : \"bnb1l86xty0m55ryct9pnypz6chvtsmpyewmhrqwxw\" , \"amount\" : \"100000000:GSYS\" }, { \"to\" : \"bnb1l86xty0maxdgst9pnypz6chvtsmpydkjflfioe\" , \"amount\" : \"100000000:GSYS,100000000:SAT\" } ] You will pay on mainnet/testnet 0.0003 GSYS * 5 = 0.0015 GSYS Trading Fees Trading fees are subject to complex logic that may mean that individual trades are not charged exactly by the rates below, but between them instead; this is due to the block-based matching engine in use on the DEX. The current fee for trades, applied on the settled amounts, is as follows: Transaction Type Pay in non-GSYS Asset Pay in GSYS Trade 0.1% 0.05% Trading fee can be queried at here . It's under the \"params/DexFeeParam/\". \"FeeRate\" and \"FeeRateNative\" are both under unit of 10^-6. Current Fees Table on Testnet Fees are variable and may change over time as governance proposals are proposed and voted on. The current fees table for Testnet as of 2021-03-17 is as follows: Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related New Order 0 0 Y Cancel (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y Order Expire (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y IOC (No Fill) Equivalent 0.00025 GSYS 0.000005 GSYS Y Transfer N/A 0.000075 GSYS N crossTransferOut N/A 0.000075 GSYS N Multi-send N/A 0.00006 GSYS N Issue Asset N/A 10 GSYS Mint Asset N/A 0.002 GSYS N Transfer ownership N/A 0.002 GSYS N Burn Asset N/A 0.002 GSYS N Freeze/Unfreeze Asset N/A 0.001 GSYS N Lock/unlock/relock Asset N/A 0.002 GSYS N List Asset N/A 200 GSYS N Submit Proposal N/A 1 GSYS N Deposit N/A 0.000125 GSYS N Enable Memo Check N/A 0.2 GSYS N Disable Memo Check N/A 0.2 GSYS N HTLT N/A 0.000075 GSYS N depositHTLT N/A 0.000075 GSYS N claimHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N TinyIssueFee N/A 0.4 GSYS N MiniIssueFee N/A 0.6 GSYS N SetTokenUri N/A 0.000075 GSYS N List BEP8 Token N/A 1 GSYS N Create A New Smart Chain Validator N/A 2 GSYS N Edit Smart Chain Validator Information N/A 0.2 GSYS N Delegate Smart Chain Validator N/A 0.0002 GSYS N Redelegate Smart Chain Validator N/A 0.0006 GSYS N Undelegate Smart Chain Validator N/A 0.0004 GSYS N Unjail A Smart Chain Validator N/A 0.5 GSYS N Submit Byzaitine Behavior Evidence of A Smart Chain Validator N/A 0.5 GSYS N Submit Smart Chain Proposal N/A 1 GSYS N Smart Chain Proposal Deposit N/A 0.00025 GSYS N Smart Chain Proposal Vote N/A 0 GSYS N Cross transfer out relayer reward N/A 0.0004 GSYS N Testnet Fees API View system fees updated in real time here . Notes Trade fee is calculated based on trade notional value, while fees for other transactions are fixed. It is free to send new GTE order, cancel a partially filled order, and you will not be charged a fee when the system expires a partially filled order (GTE or IOC). Non-Trade related transactions will be charged a fee when the transactions happen, and can only be paid in GSYS. The transaction will be rejected if the address does not have enough GSYS. Trade related transaction would be charged with fee when an order is filled, or canceled/expired/IOC-expired with no fills. If there is enough GSYS to pay, GSYS fee structure would be used, otherwise, non-GSYS fee structure would be used to charged. If the whole order value and free balance for the receiving asset are not enough to pay the fee, all the receiving asset and its residual balance would be charged.","title":"GSYS DEX Trading Specification"},{"location":"trading-spec.html#gsys-dex-trading-specification","text":"","title":"GSYS DEX Trading Specification"},{"location":"trading-spec.html#orders","text":"Orders are the requests for client to buy or sell tokens into other tokens on GSYS DEX. It is a standard type of Genesys Chain transaction. Orders are composed of the below parameters. Symbol Pairs: the list pair the order wants to trade. Order Type: GSYS DEX only accept LIMIT orders, which is adhering to SEC definitions of LIMIT orders Price: price users would like to pay for the specified token quantity, presented as a float number of quote currency. This must be rounded by tick size. Internally it can be multiplied by 1e8(10^8) in order to store as an integer in the range of int64. Quantity: number of tokens users want to buy or sell. That must be rounded by lot size. Internally it can be multiplied by 1e8(10^8) in order to store as an integer in the range of int64. Side: buy or sell Time: entry time of the order, which is the block number(height) the order gets booked in. TimeInForce: GTE: Good Till Expire. Order would stay effective until expire time. Order may expire in the UTC midnight after more than 259, 200 blocks, which is 72 hours in term of blocking time. IOC: Immediate or Cancel. Orders would be executed as much as it can in the booking block round and then got canceled back if there is still quantity left. Orders would be rejected when: user address cannot be located with asset Account does not possess enough token to buy or sell Exchange is down or has problem to match it The token is not listed against any base currencies Other order parameters are not valid Duplicated order ID Orders may be canceled / expired back when: IOC order not fully filled Order expired Exchange has problem to handle further with the orders After orders are received by any blockchain node, the node would try to submit the order transaction onto a block with consensus. After the order is accepted in an block, 2 things would happen, the assets that may transfer with the order would be locked and cannot be transferred; the GSYS DEX would try to match the order against any existing orders or new orders from the same block. If the order can match with any opposite side, the trade would be generated and the assets would be transferred. The fully filled orders would be removed from the order book, while the unfilled or partially filled GTE would stay on the order book until it is filled by others; unfilled or partially filled IOC order would be canceled.","title":"Orders"},{"location":"trading-spec.html#order-lifecycle","text":"Valid orders sent to the matching engine are confirmed immediately and are in the Ack state andinvalid orders will be FailedMatching state. GTE and IOC orders have different lifecycle. For IOC order, if an IOC order executes against another order immediately as a whole, the order is considered FullyFill . An IOC order can execute in part and ends in IocExpire state. If no part of the IOC order is filled, will be considered IocNoFill . For GTE order, if a GTE order can execute against another order as a whole, the order is considered FullyFill . Any part of the order not filled immediately, will be considered open. Orders will stay in the open until it's canceled or subsequently filled by new orders. Canceled GTE orders are in the Canceled state. Orders that are no longer eligible for matching are in the Expired state.","title":"Order Lifecycle"},{"location":"trading-spec.html#order-expire","text":"Order would expire after 72 hours once it is booked on a block. A whole order book scan would happen every UTC mid-night to filter out all the expired orders. After the scan, all the expired orders would be removed from the order book, the locked quantity in the account would be unlocked. Before this action all the existing orders in the order book is subject to matching. Tip As discussed in BEP-67 , those orders in the best 500 price levels on both ask and bid side will be expired after 30 days instead of 72 hours. Meanwhile, the expiration fee is unchanged. BEP67 is already implemented and has been activated after Testnet Nightingale Upgrade. Genesys Chain Mainnet will be upgraded to support BEP-67 soon.","title":"Order Expire"},{"location":"trading-spec.html#precision","text":"All the numbers are limited to 8-digit decimals.","title":"Precision"},{"location":"trading-spec.html#tick-size-and-lot-size","text":"Tick size stands for the smallest unit on price change, while lot size stands for the smallest quantity change. Order price must be larger than and rounded to 1 tick size and order quantity must be larger than and rounded to 1 lot size, otherwise orders would be rejected. Tick size and lot size can be queried from DEX API, and they would be reviewed and changed by DEX match engine automatically according to the trading price every UTC mid-night. Once the tick size or/and lot size is changed, new orders must stick to the new values while the existing orders on the order book can still be traded.","title":"Tick Size and Lot Size"},{"location":"trading-spec.html#fees","text":"We have five kinds of order operations, each kind has its specific fee calculation logic and collection timing as the table described below. Operation Calculation Collection Timing Place order free - Cancel order fixed fees when the Cancel transaction executes Order expire fixed fees if fully expired, otherwise free when the scheduled order expiration happenes IOC order cancel fixed fees if fully canceled, otherwise free when the IOC order is not fully filled Order execution rate based fees when the order matched GSYS is the priority in the fee collection and has some discounts. DEX would always calculate and collect the fees based on the latest balance and in the best interest of users.","title":"Fees"},{"location":"trading-spec.html#current-fees-table-on-mainnet","text":"Fees are variable and may change over time as governance proposals are proposed and voted on. The current fees table for Mainnet as of 2021-03-21 is as follows: Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related New Order 0 0 Y Cancel (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y Order Expire (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y IOC (No Fill) Equivalent 0.00025 GSYS 0.000005 GSYS Y Transfer N/A 0.000075 GSYS N crossTransferOut N/A 0.000075 GSYS N Multi-send N/A 0.00006 GSYS N Issue Asset N/A 10 GSYS Mint Asset N/A 0.002 GSYS N Transfer ownership N/A 0.002 GSYS N Burn Asset N/A 0.002 GSYS N Freeze/Unfreeze Asset N/A 0.001 GSYS N Lock/unlock/relock Asset N/A 0.002 GSYS N List Asset N/A 200 GSYS N Submit Proposal N/A 1 GSYS N Deposit N/A 0.000125 GSYS N Enable Memo Check N/A 0.2 GSYS N Disable Memo Check N/A 0.2 GSYS N HTLT N/A 0.000075 GSYS N depositHTLT N/A 0.000075 GSYS N claimHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N TinyIssueFee N/A 0.4 GSYS N MiniIssueFee N/A 0.6 GSYS N SetTokenUri N/A 0.000075 GSYS N List BEP8 Token N/A 1 GSYS N Create A New Smart Chain Validator N/A 2 GSYS N Edit Smart Chain Validator Information N/A 0.2 GSYS N Delegate Smart Chain Validator N/A 0.0002 GSYS N Redelegate Smart Chain Validator N/A 0.0006 GSYS N Undelegate Smart Chain Validator N/A 0.0004 GSYS N Unjail A Smart Chain Validator N/A 0.5 GSYS N Submit Byzaitine Behavior Evidence of A Smart Chain Validator N/A 0.5 GSYS N Submit Smart Chain Proposal N/A 1 GSYS N Smart Chain Proposal Deposit N/A 0.00025 GSYS N Smart Chain Proposal Vote N/A 0 GSYS N Cross transfer out relayer reward N/A 0.0004 GSYS N","title":"Current Fees Table on Mainnet"},{"location":"trading-spec.html#mainnet-fees-api","text":"View system fees updated in real time here .","title":"Mainnet Fees API"},{"location":"trading-spec.html#multi-send-fees","text":"eth-cli offers you a multi-send command to transfer multiple tokens to multiple people. 20% discount is available for multi-send transactions. For now, multi-send transaction will send some tokens from one address to multiple output addresses. If the count of output address is bigger than the threshold, currently it's 2, then the total transaction fee is 0.0003 GSYS per token per address. For example, if you send 3 ABC token,1 SAT token and 1 ABC to 3 different addresses. [ { \"to\" : \"bnb1g5p04snezgpky203fq6da9qyjsy2k9kzr5yuhl\" , \"amount\" : \"100000000:GSYS,100000000:ABC\" }, { \"to\" : \"bnb1l86xty0m55ryct9pnypz6chvtsmpyewmhrqwxw\" , \"amount\" : \"100000000:GSYS\" }, { \"to\" : \"bnb1l86xty0maxdgst9pnypz6chvtsmpydkjflfioe\" , \"amount\" : \"100000000:GSYS,100000000:SAT\" } ] You will pay on mainnet/testnet 0.0003 GSYS * 5 = 0.0015 GSYS","title":"Multi-send Fees"},{"location":"trading-spec.html#trading-fees","text":"Trading fees are subject to complex logic that may mean that individual trades are not charged exactly by the rates below, but between them instead; this is due to the block-based matching engine in use on the DEX. The current fee for trades, applied on the settled amounts, is as follows: Transaction Type Pay in non-GSYS Asset Pay in GSYS Trade 0.1% 0.05% Trading fee can be queried at here . It's under the \"params/DexFeeParam/\". \"FeeRate\" and \"FeeRateNative\" are both under unit of 10^-6.","title":"Trading Fees"},{"location":"trading-spec.html#current-fees-table-on-testnet","text":"Fees are variable and may change over time as governance proposals are proposed and voted on. The current fees table for Testnet as of 2021-03-17 is as follows: Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related New Order 0 0 Y Cancel (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y Order Expire (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y IOC (No Fill) Equivalent 0.00025 GSYS 0.000005 GSYS Y Transfer N/A 0.000075 GSYS N crossTransferOut N/A 0.000075 GSYS N Multi-send N/A 0.00006 GSYS N Issue Asset N/A 10 GSYS Mint Asset N/A 0.002 GSYS N Transfer ownership N/A 0.002 GSYS N Burn Asset N/A 0.002 GSYS N Freeze/Unfreeze Asset N/A 0.001 GSYS N Lock/unlock/relock Asset N/A 0.002 GSYS N List Asset N/A 200 GSYS N Submit Proposal N/A 1 GSYS N Deposit N/A 0.000125 GSYS N Enable Memo Check N/A 0.2 GSYS N Disable Memo Check N/A 0.2 GSYS N HTLT N/A 0.000075 GSYS N depositHTLT N/A 0.000075 GSYS N claimHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N TinyIssueFee N/A 0.4 GSYS N MiniIssueFee N/A 0.6 GSYS N SetTokenUri N/A 0.000075 GSYS N List BEP8 Token N/A 1 GSYS N Create A New Smart Chain Validator N/A 2 GSYS N Edit Smart Chain Validator Information N/A 0.2 GSYS N Delegate Smart Chain Validator N/A 0.0002 GSYS N Redelegate Smart Chain Validator N/A 0.0006 GSYS N Undelegate Smart Chain Validator N/A 0.0004 GSYS N Unjail A Smart Chain Validator N/A 0.5 GSYS N Submit Byzaitine Behavior Evidence of A Smart Chain Validator N/A 0.5 GSYS N Submit Smart Chain Proposal N/A 1 GSYS N Smart Chain Proposal Deposit N/A 0.00025 GSYS N Smart Chain Proposal Vote N/A 0 GSYS N Cross transfer out relayer reward N/A 0.0004 GSYS N","title":"Current Fees Table on Testnet"},{"location":"trading-spec.html#testnet-fees-api","text":"View system fees updated in real time here .","title":"Testnet Fees API"},{"location":"trading-spec.html#notes","text":"Trade fee is calculated based on trade notional value, while fees for other transactions are fixed. It is free to send new GTE order, cancel a partially filled order, and you will not be charged a fee when the system expires a partially filled order (GTE or IOC). Non-Trade related transactions will be charged a fee when the transactions happen, and can only be paid in GSYS. The transaction will be rejected if the address does not have enough GSYS. Trade related transaction would be charged with fee when an order is filled, or canceled/expired/IOC-expired with no fills. If there is enough GSYS to pay, GSYS fee structure would be used, otherwise, non-GSYS fee structure would be used to charged. If the whole order value and free balance for the receiving asset are not enough to pay the fee, all the receiving asset and its residual balance would be charged.","title":"Notes"},{"location":"transfer.html","text":"Asset Transfer Transfer is the most basic transaction Genesys Chain supports, it moves assets among different addresses. Please note the fees must be paid first in GSYS before the transaction can be executed. If you want to read more about the idea of account and balance, please refer to this doc . Simple Transfer and Memo Before transferring tokens to someone else, please make sure that you have an account with enough balance and have unlocked your wallet on browser or restored your key via CLI. You can always input a \"memo\" sentence as extra information to be recorded on the blockchain, though it has a limit on the length. Web wallet You can easily send tokens to another address on web wallet. First, you need to choose what asset you want to send. Then you input the address you want to send tokens to and amount of token. And you can also input memo here and size of memo is restricted to 128 bytes. Fee charged and balance will be showed in below. CLI If you want to send token to an address, make sure you have restored your key. You can list all of your keys: ./eth-cli keys list --home ~/.eth-cli NAME: TYPE: ADDRESS: PUBKEY: test local bnb17kwznuljsy4n89wcjd6esx2j5t0w326c03xhyr bncp1addwnpepq2gudmfe0dqqax3f57j9azy5rujlwcra4w8ueehsl5whzhlvczxuuakuldy Query your addresses on testnet $ ./eth-cli keys list PUBKEY: test local tbnb1sylyjw032eajr9cyllp26n04300qzzre38qyv5 bnbp1addwnpepqgfehhv4meevy2kz52c0s7znk8x2969dl8zc5jngn36axf3szdzp5efearf You can query your balance on mainnet before send tokens. ./eth-cli account bnb1XXXXXXXXXXXXXXXXXXX --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --indent { \"type\" : \"bnbchain/Account\" , \"value\" : { \"base\" : { \"address\" : \"bnb14h5yfk0n54msscs3hjfupscx2s9efw62sg3phh\" , \"coins\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"100000000\" } ] , \"public_key\" : null, \"account_number\" : \"56\" , \"sequence\" : \"0\" } , \"name\" : \"\" , \"frozen\" : null, \"locked\" : null } } You can query your balance on testnet before send tokens. ./eth-cli account tbnb1sylyjw032eajr9cyllp26n04300qzzre38qyv5 --chain-id GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --indent { \"type\" : \"bnbchain/Account\" , \"value\" : { \"base\" : { \"address\" : \"tbnb1sylyjw032eajr9cyllp26n04300qzzre38qyv5\" , \"coins\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"100000000\" } ] , \"public_key\" : null, \"account_number\" : \"56\" , \"sequence\" : \"0\" } , \"name\" : \"\" , \"frozen\" : null, \"locked\" : null } } Then you can send token. Please note that you need to boosted the amount you want to send by e^8 . Example on mainnet : ./eth-cli send --from from-key-name --to to-address --amount 200000000 :GSYS --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --json --memo \"Test transfer\" Password to sign with 'test' : { \"Height\" : \"272155\" , \"TxHash\" : \"A8F78BF8736A35B9433CA9CD1CDD03A8FB3D5D82\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"c2VuZGVy\" , \"value\" : \"Ym5jMTdrd3pudWxqc3k0bjg5d2NqZDZlc3gyajV0MHczMjZjMDN4aHly\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5jMWw3a3IzNWRnajNqZXpqdnc2bnQ2enlxY215dDJqaDdyczJ2NG45\" } , { \"key\" : \"YWN0aW9u\" , \"value\" : \"c2VuZA==\" } ] } } Example on testnet : ./eth-cli send --from from-key-name --to to-address --amount 200000000 :GSYS --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --json --memo \"Test transfer\" Password to sign with 'test' : { \"Height\" : \"272155\" , \"TxHash\" : \"A8F78BF8736A35B9433CA9CD1CDD03A8FB3D5D82\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"c2VuZGVy\" , \"value\" : \"Ym5jMTdrd3pudWxqc3k0bjg5d2NqZDZlc3gyajV0MHczMjZjMDN4aHly\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5jMWw3a3IzNWRnajNqZXpqdnc2bnQ2enlxY215dDJqaDdyczJ2NG45\" } , { \"key\" : \"YWN0aW9u\" , \"value\" : \"c2VuZA==\" } ] } } If you are not familiar with CLI, you can use -h to get helps: ./eth-cli send -h Create and sign a send tx Usage: eth-cli send [ flags ] Flags: --account-number int AccountNumber number to sign the tx --amount string Amount of coins to send --async broadcast transactions asynchronously --chain-id string Chain ID of Genesys Chain node --dry-run ignore the perform a simulation of a transaction, but don 't broadcast it --from string Name or address of private key with which to sign --generate-only build an unsigned transaction and write it to STDOUT -h, --help help for send --indent Add indent to JSON response --json return output in json format --ledger Use a connected Ledger device --memo string Memo to send along with transaction --node string <host>:<port> to tendermint rpc interface for this chain (default \"tcp://localhost:26657\") --print-response return tx response (only works with async = false) (default true) --sequence int Sequence number to sign the tx --source int Source of tx --to string Address to send coins --trust-node Trust connected full node (don' t verify proofs for responses ) ( default true ) Global Flags: -e, --encoding string Binary encoding ( hex | b64 | btc ) ( default \"hex\" ) --home string directory for config and data ( default \"/root/.eth-cli\" ) -o, --output string Output format ( text | json ) ( default \"text\" ) --trace print out full stack trace on errors Multi-send Sometimes, you may want to transfer tokens to multiple people. So eth-cli also provides you a multi-send command. You can use -h to get helps: ./eth-cli token multi-send -h Create and sign a multi send tx Usage: eth-cli token multi-send [ flags ] Flags: --account-number int AccountNumber number to sign the tx --async broadcast transactions asynchronously --chain-id string Chain ID of tendermint node --dry-run ignore the perform a simulation of a transaction, but don 't broadcast it --from string Name or address of private key with which to sign --generate-only build an unsigned transaction and write it to STDOUT -h, --help help for multi-send --indent Add indent to JSON response --json return output in json format --ledger Use a connected Ledger device --memo string Memo to send along with transaction --node string <host>:<port> to tendermint rpc interface for this chain (default \"tcp://localhost:26657\") --print-response return tx response (only works with async = false) (default true) --sequence int Sequence number to sign the tx --source int Source of tx --transfers string Transfers details, format: [{\"to\": \"addr\", \"amount\": \"1:GSYS,2:BTC\"}, ...] --transfers-file string File of transfers details, if transfers-file is not empty, --transfers will be ignored --trust-node Trust connected full node (don' t verify proofs for responses ) ( default true ) Global Flags: -e, --encoding string Binary encoding ( hex | b64 | btc ) ( default \"hex\" ) --home string directory for config and data ( default \"/Users/wuzhenxing/.eth-cli\" ) -o, --output string Output format ( text | json ) ( default \"text\" ) --trace print out full stack trace on errors The difference here is you have to construct the transfer detail by yourself. You have to specify --transfers flag and format is showed above. In the same time, you can write the transaction detail in a file and specify --transfers-file flag and read from the file contains transaction. Example, you can specify --transfers and send it to mainnet : ./eth-cli token multi-send --home ./testnodecli --from test --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --transfers \"[{\\\"to\\\":\\\"bnb1g5p04snezgpky203fq6da9qyjsy2k9kzr5yuhl\\\",\\\"amount\\\":\\\"100000000000000:GSYS\\\"},{\\\"to\\\":\\\"bnb1l86xty0m55ryct9pnypz6chvtsmpyewmhrqwxw\\\",\\\"amount\\\":\\\"100000000000000:GSYS\\\"}]\" --json Password to sign with 'test' : { \"Height\" : \"1412\" , \"TxHash\" : \"A238C3C33625B5398FE648BD3FE9822CB7A07A2DB7778376546916F81C634138\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"c2VuZGVy\" , \"value\" : \"Ym5iMXFnOTRzMnYzM3NyNTVrNDAybnN2M3NmY3ozMmVtdGF3NmRjeTk2\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWc1cDA0c25lemdwa3kyMDNmcTZkYTlxeWpzeTJrOWt6cjV5dWhs\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWw4Nnh0eTBtNTVyeWN0OXBueXB6NmNodnRzbXB5ZXdtaHJxd3h3\" } , { \"key\" : \"YWN0aW9u\" , \"value\" : \"c2VuZA==\" } ] } } Example on testnet : ./eth-cli token multi-send --home ./testnodecli --from test --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --transfers \"[{\\\"to\\\":\\\"tbnb1sylyjw032eajr9cyllp26n04300qzzre38qyv5\\\",\\\"amount\\\":\\\"100000000000000:GSYS\\\"},{\\\"to\\\":\\\"tbnb1e244vmvym7g6cn9lk4hmhf9p2f9jaf0x9hxmwc\\\",\\\"amount\\\":\\\"100000000000000:GSYS\\\"}]\" --json Password to sign with 'test' : { \"Height\" : \"1412\" , \"TxHash\" : \"A238C3C33625B5398FE648BD3FE9822CB7A07A2DB7778376546916F81C634138\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"c2VuZGVy\" , \"value\" : \"Ym5iMXFnOTRzMnYzM3NyNTVrNDAybnN2M3NmY3ozMmVtdGF3NmRjeTk2\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWc1cDA0c25lemdwa3kyMDNmcTZkYTlxeWpzeTJrOWt6cjV5dWhs\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWw4Nnh0eTBtNTVyeWN0OXBueXB6NmNodnRzbXB5ZXdtaHJxd3h3\" } , { \"key\" : \"YWN0aW9u\" , \"value\" : \"c2VuZA==\" } ] } } And you can also try --transfers-file . Assume that you have a file named transaction.json in your current path and content is : [ { \"to\" : \"bnb1g5p04snezgpky203fq6da9qyjsy2k9kzr5yuhl\" , \"amount\" : \"100000000000000:GSYS\" }, { \"to\" : \"bnb1l86xty0m55ryct9pnypz6chvtsmpyewmhrqwxw\" , \"amount\" : \"100000000000000:GSYS\" } ] Then you can specify --transfers-file and send it to mainnet : ./eth-cli token multi-send --home ./testnodecli --from test --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --transfers-file ./transaction.json --json Password to sign with 'test' : { \"Height\" : \"1412\" , \"TxHash\" : \"A238C3C33625B5398FE648BD3FE9822CB7A07A2DB7778376546916F81C634138\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"c2VuZGVy\" , \"value\" : \"Ym5iMXFnOTRzMnYzM3NyNTVrNDAybnN2M3NmY3ozMmVtdGF3NmRjeTk2\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWc1cDA0c25lemdwa3kyMDNmcTZkYTlxeWpzeTJrOWt6cjV5dWhs\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWw4Nnh0eTBtNTVyeWN0OXBueXB6NmNodnRzbXB5ZXdtaHJxd3h3\" } , { \"key\" : \"YWN0aW9u\" , \"value\" : \"c2VuZA==\" } ] } } Example on testnet : ./eth-cli token multi-send --home ./testnodecli --from test--chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --transfers-file ./transaction.json --json Password to sign with 'test' : { \"Height\" : \"1412\" , \"TxHash\" : \"A238C3C33625B5398FE648BD3FE9822CB7A07A2DB7778376546916F81C634138\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"c2VuZGVy\" , \"value\" : \"Ym5iMXFnOTRzMnYzM3NyNTVrNDAybnN2M3NmY3ozMmVtdGF3NmRjeTk2\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWc1cDA0c25lemdwa3kyMDNmcTZkYTlxeWpzeTJrOWt6cjV5dWhs\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWw4Nnh0eTBtNTVyeWN0OXBueXB6NmNodnRzbXB5ZXdtaHJxd3h3\" } , { \"key\" : \"YWN0aW9u\" , \"value\" : \"c2VuZA==\" } ] } } Verify Transfer Transaction To confirm that your transaction went through, you can use the following queries: { \"hash\" : \"E79DE52B7D8F6BA93787C5B0389AF26C0C29C03BC84DAE42317965797E38076E\" , \"height\" : \"1412766\" , \"tx\" :{ \"type\" : \"auth/StdTx\" , \"value\" :{ \"msg\" :[{ \"type\" : \"cosmos-sdk/Send\" , \"value\" :{ \"inputs\" :[{ \"address\" : \"tbnb1sylyjw032eajr9cyllp26n04300qzzre38qyv5\" , \"coins\" :[{ \"denom\" : \"GSYS\" , \"amount\" : \"20\" }]}], \"outputs\" :[{ \"address\" : \"tbnb1qq559fkes779t3q9p9aegnjplvtc53yg9vusah\" , \"coins\" :[{ \"denom\" : \"GSYS\" , \"amount\" : \"20\" }]}]}}], \"signatures\" :[{ \"pub_key\" :{ \"type\" : \"tendermint/PubKeySecp256k1\" , \"value\" : \"AhOb3ZXecsIqwqKw+HhTscyi6K35xYpKaJx10yYwE0Qa\" }, \"signature\" : \"AlpHUBlC/V0cR7YNm5G46aAjmeRIxjkX9Vg8EtTKkfgPso+snT3/r2nRNjsphtjTonub3VYfE4lwOnjpY+Jwcg==\" , \"account_number\" : \"406226\" , \"sequence\" : \"27\" }], \"memo\" : \"Test transfer\" , \"source\" : \"0\" , \"data\" : null }}, \"result\" :{ \"log\" : \"Msg 0: \" , \"tags\" :[{ \"key\" : \"c2VuZGVy\" , \"value\" : \"dGJuYjFzeWx5ancwMzJlYWpyOWN5bGxwMjZuMDQzMDBxenpyZTM4cXl2NQ==\" },{ \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"dGJuYjFxcTU1OWZrZXM3Nzl0M3E5cDlhZWduanBsdnRjNTN5Zzl2dXNhaA==\" },{ \"key\" : \"YWN0aW9u\" , \"value\" : \"c2VuZA==\" }]}} As you can see from the example output, this transaction is executed at block height 1412766 and you could read about the details. Double check with blockchain explorer if you interact with the network through a full-node.","title":"Asset Transfer"},{"location":"transfer.html#asset-transfer","text":"Transfer is the most basic transaction Genesys Chain supports, it moves assets among different addresses. Please note the fees must be paid first in GSYS before the transaction can be executed. If you want to read more about the idea of account and balance, please refer to this doc .","title":"Asset Transfer"},{"location":"transfer.html#simple-transfer-and-memo","text":"Before transferring tokens to someone else, please make sure that you have an account with enough balance and have unlocked your wallet on browser or restored your key via CLI. You can always input a \"memo\" sentence as extra information to be recorded on the blockchain, though it has a limit on the length.","title":"Simple Transfer and Memo"},{"location":"transfer.html#web-wallet","text":"You can easily send tokens to another address on web wallet. First, you need to choose what asset you want to send. Then you input the address you want to send tokens to and amount of token. And you can also input memo here and size of memo is restricted to 128 bytes. Fee charged and balance will be showed in below.","title":"Web wallet"},{"location":"transfer.html#cli","text":"If you want to send token to an address, make sure you have restored your key. You can list all of your keys: ./eth-cli keys list --home ~/.eth-cli NAME: TYPE: ADDRESS: PUBKEY: test local bnb17kwznuljsy4n89wcjd6esx2j5t0w326c03xhyr bncp1addwnpepq2gudmfe0dqqax3f57j9azy5rujlwcra4w8ueehsl5whzhlvczxuuakuldy Query your addresses on testnet $ ./eth-cli keys list PUBKEY: test local tbnb1sylyjw032eajr9cyllp26n04300qzzre38qyv5 bnbp1addwnpepqgfehhv4meevy2kz52c0s7znk8x2969dl8zc5jngn36axf3szdzp5efearf You can query your balance on mainnet before send tokens. ./eth-cli account bnb1XXXXXXXXXXXXXXXXXXX --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --indent { \"type\" : \"bnbchain/Account\" , \"value\" : { \"base\" : { \"address\" : \"bnb14h5yfk0n54msscs3hjfupscx2s9efw62sg3phh\" , \"coins\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"100000000\" } ] , \"public_key\" : null, \"account_number\" : \"56\" , \"sequence\" : \"0\" } , \"name\" : \"\" , \"frozen\" : null, \"locked\" : null } } You can query your balance on testnet before send tokens. ./eth-cli account tbnb1sylyjw032eajr9cyllp26n04300qzzre38qyv5 --chain-id GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --indent { \"type\" : \"bnbchain/Account\" , \"value\" : { \"base\" : { \"address\" : \"tbnb1sylyjw032eajr9cyllp26n04300qzzre38qyv5\" , \"coins\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"100000000\" } ] , \"public_key\" : null, \"account_number\" : \"56\" , \"sequence\" : \"0\" } , \"name\" : \"\" , \"frozen\" : null, \"locked\" : null } } Then you can send token. Please note that you need to boosted the amount you want to send by e^8 . Example on mainnet : ./eth-cli send --from from-key-name --to to-address --amount 200000000 :GSYS --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --json --memo \"Test transfer\" Password to sign with 'test' : { \"Height\" : \"272155\" , \"TxHash\" : \"A8F78BF8736A35B9433CA9CD1CDD03A8FB3D5D82\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"c2VuZGVy\" , \"value\" : \"Ym5jMTdrd3pudWxqc3k0bjg5d2NqZDZlc3gyajV0MHczMjZjMDN4aHly\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5jMWw3a3IzNWRnajNqZXpqdnc2bnQ2enlxY215dDJqaDdyczJ2NG45\" } , { \"key\" : \"YWN0aW9u\" , \"value\" : \"c2VuZA==\" } ] } } Example on testnet : ./eth-cli send --from from-key-name --to to-address --amount 200000000 :GSYS --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --json --memo \"Test transfer\" Password to sign with 'test' : { \"Height\" : \"272155\" , \"TxHash\" : \"A8F78BF8736A35B9433CA9CD1CDD03A8FB3D5D82\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"c2VuZGVy\" , \"value\" : \"Ym5jMTdrd3pudWxqc3k0bjg5d2NqZDZlc3gyajV0MHczMjZjMDN4aHly\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5jMWw3a3IzNWRnajNqZXpqdnc2bnQ2enlxY215dDJqaDdyczJ2NG45\" } , { \"key\" : \"YWN0aW9u\" , \"value\" : \"c2VuZA==\" } ] } } If you are not familiar with CLI, you can use -h to get helps: ./eth-cli send -h Create and sign a send tx Usage: eth-cli send [ flags ] Flags: --account-number int AccountNumber number to sign the tx --amount string Amount of coins to send --async broadcast transactions asynchronously --chain-id string Chain ID of Genesys Chain node --dry-run ignore the perform a simulation of a transaction, but don 't broadcast it --from string Name or address of private key with which to sign --generate-only build an unsigned transaction and write it to STDOUT -h, --help help for send --indent Add indent to JSON response --json return output in json format --ledger Use a connected Ledger device --memo string Memo to send along with transaction --node string <host>:<port> to tendermint rpc interface for this chain (default \"tcp://localhost:26657\") --print-response return tx response (only works with async = false) (default true) --sequence int Sequence number to sign the tx --source int Source of tx --to string Address to send coins --trust-node Trust connected full node (don' t verify proofs for responses ) ( default true ) Global Flags: -e, --encoding string Binary encoding ( hex | b64 | btc ) ( default \"hex\" ) --home string directory for config and data ( default \"/root/.eth-cli\" ) -o, --output string Output format ( text | json ) ( default \"text\" ) --trace print out full stack trace on errors","title":"CLI"},{"location":"transfer.html#multi-send","text":"Sometimes, you may want to transfer tokens to multiple people. So eth-cli also provides you a multi-send command. You can use -h to get helps: ./eth-cli token multi-send -h Create and sign a multi send tx Usage: eth-cli token multi-send [ flags ] Flags: --account-number int AccountNumber number to sign the tx --async broadcast transactions asynchronously --chain-id string Chain ID of tendermint node --dry-run ignore the perform a simulation of a transaction, but don 't broadcast it --from string Name or address of private key with which to sign --generate-only build an unsigned transaction and write it to STDOUT -h, --help help for multi-send --indent Add indent to JSON response --json return output in json format --ledger Use a connected Ledger device --memo string Memo to send along with transaction --node string <host>:<port> to tendermint rpc interface for this chain (default \"tcp://localhost:26657\") --print-response return tx response (only works with async = false) (default true) --sequence int Sequence number to sign the tx --source int Source of tx --transfers string Transfers details, format: [{\"to\": \"addr\", \"amount\": \"1:GSYS,2:BTC\"}, ...] --transfers-file string File of transfers details, if transfers-file is not empty, --transfers will be ignored --trust-node Trust connected full node (don' t verify proofs for responses ) ( default true ) Global Flags: -e, --encoding string Binary encoding ( hex | b64 | btc ) ( default \"hex\" ) --home string directory for config and data ( default \"/Users/wuzhenxing/.eth-cli\" ) -o, --output string Output format ( text | json ) ( default \"text\" ) --trace print out full stack trace on errors The difference here is you have to construct the transfer detail by yourself. You have to specify --transfers flag and format is showed above. In the same time, you can write the transaction detail in a file and specify --transfers-file flag and read from the file contains transaction. Example, you can specify --transfers and send it to mainnet : ./eth-cli token multi-send --home ./testnodecli --from test --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --transfers \"[{\\\"to\\\":\\\"bnb1g5p04snezgpky203fq6da9qyjsy2k9kzr5yuhl\\\",\\\"amount\\\":\\\"100000000000000:GSYS\\\"},{\\\"to\\\":\\\"bnb1l86xty0m55ryct9pnypz6chvtsmpyewmhrqwxw\\\",\\\"amount\\\":\\\"100000000000000:GSYS\\\"}]\" --json Password to sign with 'test' : { \"Height\" : \"1412\" , \"TxHash\" : \"A238C3C33625B5398FE648BD3FE9822CB7A07A2DB7778376546916F81C634138\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"c2VuZGVy\" , \"value\" : \"Ym5iMXFnOTRzMnYzM3NyNTVrNDAybnN2M3NmY3ozMmVtdGF3NmRjeTk2\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWc1cDA0c25lemdwa3kyMDNmcTZkYTlxeWpzeTJrOWt6cjV5dWhs\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWw4Nnh0eTBtNTVyeWN0OXBueXB6NmNodnRzbXB5ZXdtaHJxd3h3\" } , { \"key\" : \"YWN0aW9u\" , \"value\" : \"c2VuZA==\" } ] } } Example on testnet : ./eth-cli token multi-send --home ./testnodecli --from test --chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --transfers \"[{\\\"to\\\":\\\"tbnb1sylyjw032eajr9cyllp26n04300qzzre38qyv5\\\",\\\"amount\\\":\\\"100000000000000:GSYS\\\"},{\\\"to\\\":\\\"tbnb1e244vmvym7g6cn9lk4hmhf9p2f9jaf0x9hxmwc\\\",\\\"amount\\\":\\\"100000000000000:GSYS\\\"}]\" --json Password to sign with 'test' : { \"Height\" : \"1412\" , \"TxHash\" : \"A238C3C33625B5398FE648BD3FE9822CB7A07A2DB7778376546916F81C634138\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"c2VuZGVy\" , \"value\" : \"Ym5iMXFnOTRzMnYzM3NyNTVrNDAybnN2M3NmY3ozMmVtdGF3NmRjeTk2\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWc1cDA0c25lemdwa3kyMDNmcTZkYTlxeWpzeTJrOWt6cjV5dWhs\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWw4Nnh0eTBtNTVyeWN0OXBueXB6NmNodnRzbXB5ZXdtaHJxd3h3\" } , { \"key\" : \"YWN0aW9u\" , \"value\" : \"c2VuZA==\" } ] } } And you can also try --transfers-file . Assume that you have a file named transaction.json in your current path and content is : [ { \"to\" : \"bnb1g5p04snezgpky203fq6da9qyjsy2k9kzr5yuhl\" , \"amount\" : \"100000000000000:GSYS\" }, { \"to\" : \"bnb1l86xty0m55ryct9pnypz6chvtsmpyewmhrqwxw\" , \"amount\" : \"100000000000000:GSYS\" } ] Then you can specify --transfers-file and send it to mainnet : ./eth-cli token multi-send --home ./testnodecli --from test --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --transfers-file ./transaction.json --json Password to sign with 'test' : { \"Height\" : \"1412\" , \"TxHash\" : \"A238C3C33625B5398FE648BD3FE9822CB7A07A2DB7778376546916F81C634138\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"c2VuZGVy\" , \"value\" : \"Ym5iMXFnOTRzMnYzM3NyNTVrNDAybnN2M3NmY3ozMmVtdGF3NmRjeTk2\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWc1cDA0c25lemdwa3kyMDNmcTZkYTlxeWpzeTJrOWt6cjV5dWhs\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWw4Nnh0eTBtNTVyeWN0OXBueXB6NmNodnRzbXB5ZXdtaHJxd3h3\" } , { \"key\" : \"YWN0aW9u\" , \"value\" : \"c2VuZA==\" } ] } } Example on testnet : ./eth-cli token multi-send --home ./testnodecli --from test--chain-id = GSYS-Chain-Ganges --node = data-seed-pre-2-s1.genesys.network:80 --transfers-file ./transaction.json --json Password to sign with 'test' : { \"Height\" : \"1412\" , \"TxHash\" : \"A238C3C33625B5398FE648BD3FE9822CB7A07A2DB7778376546916F81C634138\" , \"Response\" : { \"log\" : \"Msg 0: \" , \"tags\" : [ { \"key\" : \"c2VuZGVy\" , \"value\" : \"Ym5iMXFnOTRzMnYzM3NyNTVrNDAybnN2M3NmY3ozMmVtdGF3NmRjeTk2\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWc1cDA0c25lemdwa3kyMDNmcTZkYTlxeWpzeTJrOWt6cjV5dWhs\" } , { \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"Ym5iMWw4Nnh0eTBtNTVyeWN0OXBueXB6NmNodnRzbXB5ZXdtaHJxd3h3\" } , { \"key\" : \"YWN0aW9u\" , \"value\" : \"c2VuZA==\" } ] } }","title":"Multi-send"},{"location":"transfer.html#verify-transfer-transaction","text":"To confirm that your transaction went through, you can use the following queries: { \"hash\" : \"E79DE52B7D8F6BA93787C5B0389AF26C0C29C03BC84DAE42317965797E38076E\" , \"height\" : \"1412766\" , \"tx\" :{ \"type\" : \"auth/StdTx\" , \"value\" :{ \"msg\" :[{ \"type\" : \"cosmos-sdk/Send\" , \"value\" :{ \"inputs\" :[{ \"address\" : \"tbnb1sylyjw032eajr9cyllp26n04300qzzre38qyv5\" , \"coins\" :[{ \"denom\" : \"GSYS\" , \"amount\" : \"20\" }]}], \"outputs\" :[{ \"address\" : \"tbnb1qq559fkes779t3q9p9aegnjplvtc53yg9vusah\" , \"coins\" :[{ \"denom\" : \"GSYS\" , \"amount\" : \"20\" }]}]}}], \"signatures\" :[{ \"pub_key\" :{ \"type\" : \"tendermint/PubKeySecp256k1\" , \"value\" : \"AhOb3ZXecsIqwqKw+HhTscyi6K35xYpKaJx10yYwE0Qa\" }, \"signature\" : \"AlpHUBlC/V0cR7YNm5G46aAjmeRIxjkX9Vg8EtTKkfgPso+snT3/r2nRNjsphtjTonub3VYfE4lwOnjpY+Jwcg==\" , \"account_number\" : \"406226\" , \"sequence\" : \"27\" }], \"memo\" : \"Test transfer\" , \"source\" : \"0\" , \"data\" : null }}, \"result\" :{ \"log\" : \"Msg 0: \" , \"tags\" :[{ \"key\" : \"c2VuZGVy\" , \"value\" : \"dGJuYjFzeWx5ancwMzJlYWpyOWN5bGxwMjZuMDQzMDBxenpyZTM4cXl2NQ==\" },{ \"key\" : \"cmVjaXBpZW50\" , \"value\" : \"dGJuYjFxcTU1OWZrZXM3Nzl0M3E5cDlhZWduanBsdnRjNTN5Zzl2dXNhaA==\" },{ \"key\" : \"YWN0aW9u\" , \"value\" : \"c2VuZA==\" }]}} As you can see from the example output, this transaction is executed at block height 1412766 and you could read about the details. Double check with blockchain explorer if you interact with the network through a full-node.","title":"Verify Transfer Transaction"},{"location":"tss.html","text":"User Guide of Threshold Signature Scheme (TSS) in Genesys Chain Introduction Threshold Signature Scheme (TSS) is a cryptographic protocol for distributed key generation and signing. TSS allows constructing a signature that is distributed among different parties (for example three users), and each user receives a share of the private signing key. To sign a transaction, at least two of these three users need to join. For individuals, threshold signatures allow for two-factor security or splitting the ability to sign between two devices so that a single compromised device won\u2019t put the money at risk. For businesses, threshold signatures allow for the realization of access control policies that prevent both insiders and outsiders from stealing corporate funds. TSS technology allows us to replace all signing commands with distributed computations.The private key is no longer a single point of failure. Motivation A physical key must fit exactly into a keyhole to unlock a physical vault. But if this key is compromised or lost, the funds locked in the vault may no longer be safe. This simple approach of key management may make sense when a small sum is at stake. However, when the amount stored in the vault is large, it is wise to consider spreading the responsibility of key ownership between several trusted parties. Traditional MultiSig (multi-signature) is a more refined unlocking system that requires multiple independent keys to unlock the vault. MultiSig requires generating a larger private key and the vault has multiple locks - one for each key . More processing power is needed as participants have to sign additional signatures, which must then be checked individually by the network. This is not ideal, because a participant must leave traces showing exactly who signed and multiple parties must be online at the same time. With Threshold Signatures , all of the parties must forge the vault\u2019s lock together, in a modular way, where each party owns a share of the key. A TSS vault is indistinguishable from a regular vault and is hence universal, and it has the same privacy and verification cost of a regular vault. Even if only a subset of the keys is available, the vault may still be unlocked (this is known as meeting a threshold of participation). Combining TSS feature with Genesys Chain client will help users manage their funds in a much safer way. TSS will be offered in an independent binary, but it will have some impact on the existing functions of eth-cli/eth-cli . Implementation Many development resources have been poured into implementing TSS, a cryptographic protocol for distributed key generation and signing. TSS is now compatible and reusable for ECDSA-based blockchains, including Genesys Chain, Bitcoin, and Ethereum networks. We expect that members of the GSYS ecosystem and partner community can integrate this TSS library with their applications, such as wallets and custodians, and further develop this exciting new technology. With the support of the Genesys Chain community, we are happy to share the open-source code athttps://github.com/githubusername/githubrepo/tss-lib. Workflow Let\u2019s take a look at the major steps in TSS: Vault Initialization : the first step is for setting up tss parameters of each party. This will initialize the node's p2p listen address and setup a directory to save key. It's recommended that you should save your tss key in a different folder other than normal key info. Key Generation : the second step is also the most complex. We need to define the quorum policy: count of total parties (n) that holds secret shares and threshold (t) which means at least t + 1 parties need to take part in the signing process. We need to generate a key which will be public and used to verify future signatures. However, we also have to generate an individual secret for each party, which is called a secret share. The functions guarantee the same public key to all parties and a different secret share for each. In this way, we achieve: (1) privacy: no secret shares data is leaked between any parties, and (2) correctness: the public key is intact with secret share. They need to agree on the channel which they want to use for sending messages between each other. The channel will have its corresponding password. Both ID and password needs to be shared offline. Signing : this step involves a signature generation function. The input of each party will be its own secret share, created as output of the distributed key generation in the previous step. There is also public input known to all, which is the message to be signed. The output will be a digital signature, and the property of privacy ensures that no leakage of secret shares occurred during the computation. Verification : the verification algorithm remains as it is in the classical setting. To be compatible with single key signatures, Genesys Chain validator nodes can be able to verify the signature with the public key. The transaction will be no different from others. Vault Regroup : Regroup will reset secret share and configs between all parties.It's recommend to switch the configuration periodically, say once a month. If some party lost his key, it's also necessory to reset the distribution once some party lost their key. Regroup will generate new_n secret share with new_t threshold. At least old_t + 1 should participant Where can I download the GSYS TSS CLI? You can download tss client and Genesys Chain Commandline here: Mainnet: https://github.com/githubusername/githubrepo/node-binary/tree/master/cli/prod/0.6.2-TSS-0.1.2 Testnet: https://github.com/githubusername/githubrepo/node-binary/tree/master/cli/testnet/0.6.2-TSS-0.1.2 How to Use Warning : Please test your TSS setup before use this on mainnet. Please backup your eth-cli home before use this tool: cp -r ~/.eth-cli ~/.eth-cli_backup_tss (replace ~/.eth-cli with their eth-cli home) Please refer to this Example to help you understand the whole process Init tss init will create home directory of a new tss setup, generate p2p key pair. Here are the global transaction flags: Name Type Description Note vault_name string name of the vault of this party password string the password of the vault must be 32 bytes or more, the default value is 48 home string Path to config/route_table/node_key/tss_key files, configs in config file can be overridden by command line argument the default value is \"~/.tss\" Here are the flags for tss init : Name Type Description Note kdf.iterations uint32 The number of iterations (or passes) over the memory. the default value is 13 kdf.key_length uint32 Length of the generated key (or password hash) \"must be 32 bytes or more, the default value is 48\" kdf.memory uint32 The amount of memory used by the algorithm (in kibibytes) the default value is 65536 kdf.parallelism uint8 The number of threads (or lanes) used by the algorithm. the default value is 4 kdf.salt_length uint32 Length of the random salt. 16 bytes is recommended for password hashing. the default value is 16 moniker string moniker of current party p2p.listen string Adds a multiaddress to the listen list Describe tss describe will show config and address of a tss vault Here are the flags for tss describe : Name Type Description Note address_prefix string bech32 prefix of address (default \"bnb\") Example ./tss describe > please set vault of this party: [input vault name] > Password to sign with this vault: [input password] address of this vault: bnb1 config of this vault: { \"p2p\": { \"listen\": \"/ip4/0.0.0.0/tcp/59968\", \"bootstraps\": null, \"relays\": null, \"peer_addrs\": [ \"/ip4/127.0.0.1/tcp/59748\", \"/ip4/127.0.0.1/tcp/60022\" ], \"peers\": [ \"test3\", \"test2\" ], \"DefaultBootstap\": false }, \"Id\": \"\", \"Moniker\": \"tss1\", \"vault_name\": \"vault1\", \"Threshold\": 1, \"Parties\": 3, \"log_level\": \"info\", \"profile_addr\": \"\", \"Home\": \"~/.tss\" } Channel tss channel will generate a channel ID for bootstrapping. One party can generate a channel, then share the generated channel ID with others offline. Here are the flags for tss channel : Name Type Description Note channel_expire int expire time in minutes of this channel Default value is 30mins It's advised to refresh the channels regularly. Keygen This command will generate the private key and share the secret. Everyone needs to agree on the password of this private key. The password length must be larger than eight . Note: you need to make sure that all the parties are online. Here are the flags for tss keygen : Name Type Description Note address_prefix string prefix of bech32 address the default value is bnb channel_id string channel id for this session channel_password string password to this channel This password has to be set offline. And its length should be more than eight . p2p.peer_addrs []sting peer's multiplex addresses parties int total parities of this scheme threshold int threshold of this scheme, at least threshold + 1 parties need participant signing if you want to add the generated key files in the eth-cli home, you can copy it to the home folder: eth-cli keys add --tss -t tss --tss-home ~/.test1 --tss-vault third test1_third Regroup This command will generate new_n secret from the same private key, and it will be shared with new_t threshold. At least old_t + 1 should participante in signing Here are the flags for tss regroup : Name Type Description Note channel_password string channel password of this session channel_id string channel id of this session is_old string whether this party is old committee. If it is set to true, it will participant signing in regroup. There should be only t+1 parties set this to true for one regroup is_new_member string whether this party is new committee, for new party it will changed to true automatically. if an old party set this to true, its share will be replaced by one generated one new_parties int new total parties of regrouped scheme new_threshold int new threshold of regrouped scheme p2p.new_peer_addrs []sting unknown peer's multiple addresses parties int total parities of this scheme threshold int threshold of this scheme, at least threshold + 1 parties need participant signing Changes to eth-cli/eth-cli We added a new key type \u201ctss\u201d (just like the existing types: \u201clocal\u201d, \u201coffline\u201d, \u201cledger\u201d) to eth-cli which stands for tss secret share. To add a tss key into eth-cli\u2019s keystore: 1. Tss keygen command will automatically add generated secret share into default keystore (~/.eth-cli) with name \u201ctss_ _ \u201d 2. User can manually specify tss\u2019s home, vault_name and a customized eth-cli home like: eth-cli keys add --home ~/.customized_cli --tss -t tss --tss-home ~/.test1 --tss-vault \u201cdefault\u201d my_name All other commands (i.e. send token, place order, delete key etc.) of eth-cli should support tss type key. Example In this example, A, B and C are the parties who decided to share a private key together. They decided that any two of them can sign a transaction. To complete a TSS signing process, they need to follow the following steps: Step 1: Init TSS During this step, all parties from different machines have to initialite their P2P settings before generate the shared key. A B C command ./tss init ./tss init ./tss init Interactive input > please set moniker of this party: tss1 > please set vault of this party: vault1 > please set password of thisvault: [input password] > please input again: [input password] > please set moniker of this party: tss2 > please set vault of this party: vault1 > please set password of this vault: [input password] >please input again: [input password] > please set moniker of this party: tss3 > please set vault of this party:vault1 > please set password of this vault: [input password] > please input again: [input password] output Local party has been initialized under: ~/.tss/vault1 Local party has been initialized under: ~/.tss/vault1 Local party has been initialized under: ~/.tss/vault1 Files touched or generated ~/.tss/vault1/config.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/node_key Step 2: Generate Channel ID for bootstraping In this step, the parties will create a secrect communication channel between them. One of then will generate the channel ID and share with others. In this example, A will generate the channel ID. B and C will not have to do anything. A can also specify the length for this channel session and the default time is 30 mins. A B C command ./tss channel N/A N/A Interactive input > please set expire time in minutes, (default: 30): [input time] N/A N/A output channel id: 5185D3EF597 N/A N/A Step 3: Generate and Share Secret In this step, the private key will be generated and shared between these three parties. All the parties have to be online at the sme time. A B C command ./tss keygen --vault_name vault1 ./tss keygen --vault_name vault1 ./tss keygen --vault_name vault1 Interactive input > Password to sign with this vault: [enter password] > please set total parties(n): 3 > please set threshold(t), at least t + 1 parties need participant signing: 1 > please set channel id of this session [enter ID] > please input password (AGREED offline with peers) of this session: [enter password] > please input password of this tss vault: [enter password] >please input> Password to sign with this vault: [enter password] > please set total parties(n): 3 > please set threshold(t), at least t + 1 parties need participant signing: 1 > please set channel id of this session [enter ID] >please input password (AGREED offline with peers) of this session: [enter password] >please input password of this tss vault: [enter password] > Password to sign with this vault: [enter password] > please set total parties(n): 3 > please set threshold(t), at least t + 1 parties need participant signing: 1 > please set channel id of this session 3085D3EC76D > please input password (AGREED offline with peers) of this session: [enter password] Password of this tss vault: [enter password] output 18:00:09.777 INFO tss-lib: party {0,tss1}: keygen finished! party.go:11318:00:09.777 INFO tss: [tss1] received save data client.go:30418:00:09.777 INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp client.go:309Password of this tss vault:NAME: TYPE: ADDRESS: PUBKEY:tss_tss1_vault1 tss tbnb19277gzv934ayctxeg5k9zdwnx3j48u6tydjv9p bnbp1addwnpepqwazk6d3f6e3f5rjev6z0ufqxk8znq8z89ax2tgnwmzreaq8nu7sx2u4jcc 18:00:09.777 INFO : party {1,tss2}: keygen finished! party.go:11318:00:09.777 INFO tss: [tss2] received save data client.go:30418:00:09.777 INFO tss: [tss2] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp client.go:309Password of this tss vault:NAME: TYPE: ADDRESS: PUBKEY:tss_tss2_vault1 tss tbnb19277gzv934ayctxeg5k9zdwnx3j48u6tydjv9p bnbp1addwnpepqwazk6d3f6e3f5rjev6z0ufqxk8znq8z89ax2tgnwmzreaq8nu7sx2u4jcc 18:00:09.773 INFO tss-lib: party {2,tss3}: keygen finished! party.go:11318:00:09.773 INFO tss: [tss3] received save data client.go:30418:00:09.773 INFO tss: [tss3] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp client.go:309Password of this tss vault:NAME: TYPE: ADDRESS: PUBKEY:tss_tss3_vault1 tss tbnb19277gzv934ayctxeg5k9zdwnx3j48u6tydjv9p bnbp1addwnpepqwazk6d3f6e3f5rjev6z0ufqxk8znq8z89ax2tgnwmzreaq8nu7sx2u4jcc Files touched or generated ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json Step 4: Sign Transaction In this steo, A and B decided to sign a transaction together. Both A and B will try to broadcast the transaction and only one of them will succeed. A B C command eth-cli send --amount 1000000:GSYS --to tbnb1mh3w2kxmdmnvctt7t5nu7hhz9jnp422edqdw2d --from tss_tss1_vault1 --chain-id GSYS-Chain-Ganges --node https://data-seed-pre-0-s1.genesys.network:443 --trust-node eth-cli send --amount 1000000:GSYS --to tbnb1mh3w2kxmdmnvctt7t5nu7hhz9jnp422edqdw2d --from tss_tss2_vault1 --chain-id GSYS-Chain-Ganges --node https://data-seed-pre-0-s1.genesys.network:443 --trust-node NA Interactive input Password to sign with tss_tss1_vault1: [Enter password] > Channel id: 5185D3EF597 please input password (AGREED offline with peers) of this session: [Enter password] Password to sign with tss_tss2_vault1: [Enter password] > Channel id: 5185D3EF597 please input password (AGREED offline with peers) of this session: [Enter password] N/A output Committed at block 33600477 (tx hash: 4FB8096A93D545612A3B5DCE520622608C299C7742103A6BE34C444829BD83A5 ERROR: broadcast_tx_commit: Response error: RPC error -32603 - Internal error: Error on broadcastTxCommit: Tx already exists in cache N/A Files touched or generated N/A N/A N/A Step 5: Regroup Vault First, please generate a new channel for messaging: A B C command ./tss channel N/A N/A Interactive input > please set expire time in minutes, (default: 30): [input time] N/A N/A output channel id: 3415D3FBE00 N/A N/A Then, we can switch to the new channel for sending messages to each others. A B C command ./tss regroup ./tss regroup ./tss regroup Interactive input > please set vault of this party: vault1 > Password to sign with this vault: Password to sign with tss_tss1_vault1: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set new total parties(n): 3 > please set new threshold(t), at least t + 1 parties participant signing: 1 > Channel id: 3415D3FBE00 please input password (AGREED offline with peers) of this session: Password to sign with tss_tss1_vault1: [Enter password] > please set vault of this party: vault1 > Password to sign with this vault: Password to sign with tss_tss1_vault1: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set new total parties(n): 3 > please set new threshold(t), at least t + 1 parties participant signing: 1 > Channel id: 3415D3FBE00 please input password (AGREED offline with peers) of this session: Password to sign with tss_tss1_vault1: [Enter password] > please set vault of this party: vault1 > Password to sign with this vault: Password to sign with tss_tss1_vault1: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set new total parties(n): 3 > please set new threshold(t), at least t + 1 parties participant signing: 1 > Channel id: 3415D3FBE00 please input password (AGREED offline with peers) of this session: Password to sign with tss_tss1_vault1: [Enter password] output INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp Files touched or generated ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/node_key New committee having different t-n from old committee Change 1-3 into 2-4 scheme. old parties (A, B) join new committee new parties (D, E) are newly-joined D E command ./tss init --vault_name vault1 ./tss init --vault_name vault1 Interactive input > please set moniker of this party: tss4 > please set password for key share: [Enter password] > please intput again: [Enter password] > please set moniker of this party: tss4 > please set password for key share: [Enter password] > please intput again: [Enter password] output Local party has been initialized under: ~/.tss/vault1 Local party has been initialized under: ~/.tss/vault1 Regroup from 1-3 to 2-4, with 2 old parties (A and B) and 2 new parties (D and E) A (old&new committee) B (old&new committee) D (new committee) E (new committee) command ./tss regroup/ --vault_name vault1 ./tss regroup --vault_name vault1 ./tss regroup --vault_name vault1 ./tss regroup --vault_name vault1 Interactive input > please input password: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] > please input password: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties need participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] > please input password: [Enter password] > please set Old total parties(n): 3 > please set Old threshold(t), at least t + 1 parties need participant signing: 1 > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties need participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] > please input password: [Enter password] > please set Old total parties(n): 3 > please set Old threshold(t), at least t + 1 parties need participant signing: 1 > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties need participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] output Files touched or generated ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/payment/config.json ~/.tss/payment/pk.json ~/.tss/vault1/sk.json","title":"User Guide of Threshold Signature Scheme (TSS) in Genesys Chain"},{"location":"tss.html#user-guide-of-threshold-signature-scheme-tss-in-genesys-chain","text":"","title":"User Guide of Threshold Signature Scheme (TSS) in Genesys Chain"},{"location":"tss.html#introduction","text":"Threshold Signature Scheme (TSS) is a cryptographic protocol for distributed key generation and signing. TSS allows constructing a signature that is distributed among different parties (for example three users), and each user receives a share of the private signing key. To sign a transaction, at least two of these three users need to join. For individuals, threshold signatures allow for two-factor security or splitting the ability to sign between two devices so that a single compromised device won\u2019t put the money at risk. For businesses, threshold signatures allow for the realization of access control policies that prevent both insiders and outsiders from stealing corporate funds. TSS technology allows us to replace all signing commands with distributed computations.The private key is no longer a single point of failure.","title":"Introduction"},{"location":"tss.html#motivation","text":"A physical key must fit exactly into a keyhole to unlock a physical vault. But if this key is compromised or lost, the funds locked in the vault may no longer be safe. This simple approach of key management may make sense when a small sum is at stake. However, when the amount stored in the vault is large, it is wise to consider spreading the responsibility of key ownership between several trusted parties. Traditional MultiSig (multi-signature) is a more refined unlocking system that requires multiple independent keys to unlock the vault. MultiSig requires generating a larger private key and the vault has multiple locks - one for each key . More processing power is needed as participants have to sign additional signatures, which must then be checked individually by the network. This is not ideal, because a participant must leave traces showing exactly who signed and multiple parties must be online at the same time. With Threshold Signatures , all of the parties must forge the vault\u2019s lock together, in a modular way, where each party owns a share of the key. A TSS vault is indistinguishable from a regular vault and is hence universal, and it has the same privacy and verification cost of a regular vault. Even if only a subset of the keys is available, the vault may still be unlocked (this is known as meeting a threshold of participation). Combining TSS feature with Genesys Chain client will help users manage their funds in a much safer way. TSS will be offered in an independent binary, but it will have some impact on the existing functions of eth-cli/eth-cli .","title":"Motivation"},{"location":"tss.html#implementation","text":"Many development resources have been poured into implementing TSS, a cryptographic protocol for distributed key generation and signing. TSS is now compatible and reusable for ECDSA-based blockchains, including Genesys Chain, Bitcoin, and Ethereum networks. We expect that members of the GSYS ecosystem and partner community can integrate this TSS library with their applications, such as wallets and custodians, and further develop this exciting new technology. With the support of the Genesys Chain community, we are happy to share the open-source code athttps://github.com/githubusername/githubrepo/tss-lib.","title":"Implementation"},{"location":"tss.html#workflow","text":"Let\u2019s take a look at the major steps in TSS: Vault Initialization : the first step is for setting up tss parameters of each party. This will initialize the node's p2p listen address and setup a directory to save key. It's recommended that you should save your tss key in a different folder other than normal key info. Key Generation : the second step is also the most complex. We need to define the quorum policy: count of total parties (n) that holds secret shares and threshold (t) which means at least t + 1 parties need to take part in the signing process. We need to generate a key which will be public and used to verify future signatures. However, we also have to generate an individual secret for each party, which is called a secret share. The functions guarantee the same public key to all parties and a different secret share for each. In this way, we achieve: (1) privacy: no secret shares data is leaked between any parties, and (2) correctness: the public key is intact with secret share. They need to agree on the channel which they want to use for sending messages between each other. The channel will have its corresponding password. Both ID and password needs to be shared offline. Signing : this step involves a signature generation function. The input of each party will be its own secret share, created as output of the distributed key generation in the previous step. There is also public input known to all, which is the message to be signed. The output will be a digital signature, and the property of privacy ensures that no leakage of secret shares occurred during the computation. Verification : the verification algorithm remains as it is in the classical setting. To be compatible with single key signatures, Genesys Chain validator nodes can be able to verify the signature with the public key. The transaction will be no different from others. Vault Regroup : Regroup will reset secret share and configs between all parties.It's recommend to switch the configuration periodically, say once a month. If some party lost his key, it's also necessory to reset the distribution once some party lost their key. Regroup will generate new_n secret share with new_t threshold. At least old_t + 1 should participant","title":"Workflow"},{"location":"tss.html#where-can-i-download-the-gsys-tss-cli","text":"You can download tss client and Genesys Chain Commandline here: Mainnet: https://github.com/githubusername/githubrepo/node-binary/tree/master/cli/prod/0.6.2-TSS-0.1.2 Testnet: https://github.com/githubusername/githubrepo/node-binary/tree/master/cli/testnet/0.6.2-TSS-0.1.2","title":"Where can I download the GSYS TSS CLI?"},{"location":"tss.html#how-to-use","text":"Warning : Please test your TSS setup before use this on mainnet. Please backup your eth-cli home before use this tool: cp -r ~/.eth-cli ~/.eth-cli_backup_tss (replace ~/.eth-cli with their eth-cli home) Please refer to this Example to help you understand the whole process","title":"How to Use"},{"location":"tss.html#init","text":"tss init will create home directory of a new tss setup, generate p2p key pair. Here are the global transaction flags: Name Type Description Note vault_name string name of the vault of this party password string the password of the vault must be 32 bytes or more, the default value is 48 home string Path to config/route_table/node_key/tss_key files, configs in config file can be overridden by command line argument the default value is \"~/.tss\" Here are the flags for tss init : Name Type Description Note kdf.iterations uint32 The number of iterations (or passes) over the memory. the default value is 13 kdf.key_length uint32 Length of the generated key (or password hash) \"must be 32 bytes or more, the default value is 48\" kdf.memory uint32 The amount of memory used by the algorithm (in kibibytes) the default value is 65536 kdf.parallelism uint8 The number of threads (or lanes) used by the algorithm. the default value is 4 kdf.salt_length uint32 Length of the random salt. 16 bytes is recommended for password hashing. the default value is 16 moniker string moniker of current party p2p.listen string Adds a multiaddress to the listen list","title":"Init"},{"location":"tss.html#describe","text":"tss describe will show config and address of a tss vault Here are the flags for tss describe : Name Type Description Note address_prefix string bech32 prefix of address (default \"bnb\") Example ./tss describe > please set vault of this party: [input vault name] > Password to sign with this vault: [input password] address of this vault: bnb1 config of this vault: { \"p2p\": { \"listen\": \"/ip4/0.0.0.0/tcp/59968\", \"bootstraps\": null, \"relays\": null, \"peer_addrs\": [ \"/ip4/127.0.0.1/tcp/59748\", \"/ip4/127.0.0.1/tcp/60022\" ], \"peers\": [ \"test3\", \"test2\" ], \"DefaultBootstap\": false }, \"Id\": \"\", \"Moniker\": \"tss1\", \"vault_name\": \"vault1\", \"Threshold\": 1, \"Parties\": 3, \"log_level\": \"info\", \"profile_addr\": \"\", \"Home\": \"~/.tss\" }","title":"Describe"},{"location":"tss.html#channel","text":"tss channel will generate a channel ID for bootstrapping. One party can generate a channel, then share the generated channel ID with others offline. Here are the flags for tss channel : Name Type Description Note channel_expire int expire time in minutes of this channel Default value is 30mins It's advised to refresh the channels regularly.","title":"Channel"},{"location":"tss.html#keygen","text":"This command will generate the private key and share the secret. Everyone needs to agree on the password of this private key. The password length must be larger than eight . Note: you need to make sure that all the parties are online. Here are the flags for tss keygen : Name Type Description Note address_prefix string prefix of bech32 address the default value is bnb channel_id string channel id for this session channel_password string password to this channel This password has to be set offline. And its length should be more than eight . p2p.peer_addrs []sting peer's multiplex addresses parties int total parities of this scheme threshold int threshold of this scheme, at least threshold + 1 parties need participant signing if you want to add the generated key files in the eth-cli home, you can copy it to the home folder: eth-cli keys add --tss -t tss --tss-home ~/.test1 --tss-vault third test1_third","title":"Keygen"},{"location":"tss.html#regroup","text":"This command will generate new_n secret from the same private key, and it will be shared with new_t threshold. At least old_t + 1 should participante in signing Here are the flags for tss regroup : Name Type Description Note channel_password string channel password of this session channel_id string channel id of this session is_old string whether this party is old committee. If it is set to true, it will participant signing in regroup. There should be only t+1 parties set this to true for one regroup is_new_member string whether this party is new committee, for new party it will changed to true automatically. if an old party set this to true, its share will be replaced by one generated one new_parties int new total parties of regrouped scheme new_threshold int new threshold of regrouped scheme p2p.new_peer_addrs []sting unknown peer's multiple addresses parties int total parities of this scheme threshold int threshold of this scheme, at least threshold + 1 parties need participant signing","title":"Regroup"},{"location":"tss.html#changes-to-eth-clieth-cli","text":"We added a new key type \u201ctss\u201d (just like the existing types: \u201clocal\u201d, \u201coffline\u201d, \u201cledger\u201d) to eth-cli which stands for tss secret share. To add a tss key into eth-cli\u2019s keystore: 1. Tss keygen command will automatically add generated secret share into default keystore (~/.eth-cli) with name \u201ctss_ _ \u201d 2. User can manually specify tss\u2019s home, vault_name and a customized eth-cli home like: eth-cli keys add --home ~/.customized_cli --tss -t tss --tss-home ~/.test1 --tss-vault \u201cdefault\u201d my_name All other commands (i.e. send token, place order, delete key etc.) of eth-cli should support tss type key.","title":"Changes to eth-cli/eth-cli"},{"location":"tss.html#example","text":"In this example, A, B and C are the parties who decided to share a private key together. They decided that any two of them can sign a transaction. To complete a TSS signing process, they need to follow the following steps:","title":"Example"},{"location":"tss.html#step-1-init-tss","text":"During this step, all parties from different machines have to initialite their P2P settings before generate the shared key. A B C command ./tss init ./tss init ./tss init Interactive input > please set moniker of this party: tss1 > please set vault of this party: vault1 > please set password of thisvault: [input password] > please input again: [input password] > please set moniker of this party: tss2 > please set vault of this party: vault1 > please set password of this vault: [input password] >please input again: [input password] > please set moniker of this party: tss3 > please set vault of this party:vault1 > please set password of this vault: [input password] > please input again: [input password] output Local party has been initialized under: ~/.tss/vault1 Local party has been initialized under: ~/.tss/vault1 Local party has been initialized under: ~/.tss/vault1 Files touched or generated ~/.tss/vault1/config.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/node_key","title":"Step 1: Init TSS"},{"location":"tss.html#step-2-generate-channel-id-for-bootstraping","text":"In this step, the parties will create a secrect communication channel between them. One of then will generate the channel ID and share with others. In this example, A will generate the channel ID. B and C will not have to do anything. A can also specify the length for this channel session and the default time is 30 mins. A B C command ./tss channel N/A N/A Interactive input > please set expire time in minutes, (default: 30): [input time] N/A N/A output channel id: 5185D3EF597 N/A N/A","title":"Step 2: Generate Channel ID for bootstraping"},{"location":"tss.html#step-3-generate-and-share-secret","text":"In this step, the private key will be generated and shared between these three parties. All the parties have to be online at the sme time. A B C command ./tss keygen --vault_name vault1 ./tss keygen --vault_name vault1 ./tss keygen --vault_name vault1 Interactive input > Password to sign with this vault: [enter password] > please set total parties(n): 3 > please set threshold(t), at least t + 1 parties need participant signing: 1 > please set channel id of this session [enter ID] > please input password (AGREED offline with peers) of this session: [enter password] > please input password of this tss vault: [enter password] >please input> Password to sign with this vault: [enter password] > please set total parties(n): 3 > please set threshold(t), at least t + 1 parties need participant signing: 1 > please set channel id of this session [enter ID] >please input password (AGREED offline with peers) of this session: [enter password] >please input password of this tss vault: [enter password] > Password to sign with this vault: [enter password] > please set total parties(n): 3 > please set threshold(t), at least t + 1 parties need participant signing: 1 > please set channel id of this session 3085D3EC76D > please input password (AGREED offline with peers) of this session: [enter password] Password of this tss vault: [enter password] output 18:00:09.777 INFO tss-lib: party {0,tss1}: keygen finished! party.go:11318:00:09.777 INFO tss: [tss1] received save data client.go:30418:00:09.777 INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp client.go:309Password of this tss vault:NAME: TYPE: ADDRESS: PUBKEY:tss_tss1_vault1 tss tbnb19277gzv934ayctxeg5k9zdwnx3j48u6tydjv9p bnbp1addwnpepqwazk6d3f6e3f5rjev6z0ufqxk8znq8z89ax2tgnwmzreaq8nu7sx2u4jcc 18:00:09.777 INFO : party {1,tss2}: keygen finished! party.go:11318:00:09.777 INFO tss: [tss2] received save data client.go:30418:00:09.777 INFO tss: [tss2] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp client.go:309Password of this tss vault:NAME: TYPE: ADDRESS: PUBKEY:tss_tss2_vault1 tss tbnb19277gzv934ayctxeg5k9zdwnx3j48u6tydjv9p bnbp1addwnpepqwazk6d3f6e3f5rjev6z0ufqxk8znq8z89ax2tgnwmzreaq8nu7sx2u4jcc 18:00:09.773 INFO tss-lib: party {2,tss3}: keygen finished! party.go:11318:00:09.773 INFO tss: [tss3] received save data client.go:30418:00:09.773 INFO tss: [tss3] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp client.go:309Password of this tss vault:NAME: TYPE: ADDRESS: PUBKEY:tss_tss3_vault1 tss tbnb19277gzv934ayctxeg5k9zdwnx3j48u6tydjv9p bnbp1addwnpepqwazk6d3f6e3f5rjev6z0ufqxk8znq8z89ax2tgnwmzreaq8nu7sx2u4jcc Files touched or generated ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json","title":"Step 3: Generate and Share Secret"},{"location":"tss.html#step-4-sign-transaction","text":"In this steo, A and B decided to sign a transaction together. Both A and B will try to broadcast the transaction and only one of them will succeed. A B C command eth-cli send --amount 1000000:GSYS --to tbnb1mh3w2kxmdmnvctt7t5nu7hhz9jnp422edqdw2d --from tss_tss1_vault1 --chain-id GSYS-Chain-Ganges --node https://data-seed-pre-0-s1.genesys.network:443 --trust-node eth-cli send --amount 1000000:GSYS --to tbnb1mh3w2kxmdmnvctt7t5nu7hhz9jnp422edqdw2d --from tss_tss2_vault1 --chain-id GSYS-Chain-Ganges --node https://data-seed-pre-0-s1.genesys.network:443 --trust-node NA Interactive input Password to sign with tss_tss1_vault1: [Enter password] > Channel id: 5185D3EF597 please input password (AGREED offline with peers) of this session: [Enter password] Password to sign with tss_tss2_vault1: [Enter password] > Channel id: 5185D3EF597 please input password (AGREED offline with peers) of this session: [Enter password] N/A output Committed at block 33600477 (tx hash: 4FB8096A93D545612A3B5DCE520622608C299C7742103A6BE34C444829BD83A5 ERROR: broadcast_tx_commit: Response error: RPC error -32603 - Internal error: Error on broadcastTxCommit: Tx already exists in cache N/A Files touched or generated N/A N/A N/A","title":"Step 4: Sign Transaction"},{"location":"tss.html#step-5-regroup-vault","text":"First, please generate a new channel for messaging: A B C command ./tss channel N/A N/A Interactive input > please set expire time in minutes, (default: 30): [input time] N/A N/A output channel id: 3415D3FBE00 N/A N/A Then, we can switch to the new channel for sending messages to each others. A B C command ./tss regroup ./tss regroup ./tss regroup Interactive input > please set vault of this party: vault1 > Password to sign with this vault: Password to sign with tss_tss1_vault1: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set new total parties(n): 3 > please set new threshold(t), at least t + 1 parties participant signing: 1 > Channel id: 3415D3FBE00 please input password (AGREED offline with peers) of this session: Password to sign with tss_tss1_vault1: [Enter password] > please set vault of this party: vault1 > Password to sign with this vault: Password to sign with tss_tss1_vault1: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set new total parties(n): 3 > please set new threshold(t), at least t + 1 parties participant signing: 1 > Channel id: 3415D3FBE00 please input password (AGREED offline with peers) of this session: Password to sign with tss_tss1_vault1: [Enter password] > please set vault of this party: vault1 > Password to sign with this vault: Password to sign with tss_tss1_vault1: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set new total parties(n): 3 > please set new threshold(t), at least t + 1 parties participant signing: 1 > Channel id: 3415D3FBE00 please input password (AGREED offline with peers) of this session: Password to sign with tss_tss1_vault1: [Enter password] output INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp Files touched or generated ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/node_key New committee having different t-n from old committee Change 1-3 into 2-4 scheme. old parties (A, B) join new committee new parties (D, E) are newly-joined D E command ./tss init --vault_name vault1 ./tss init --vault_name vault1 Interactive input > please set moniker of this party: tss4 > please set password for key share: [Enter password] > please intput again: [Enter password] > please set moniker of this party: tss4 > please set password for key share: [Enter password] > please intput again: [Enter password] output Local party has been initialized under: ~/.tss/vault1 Local party has been initialized under: ~/.tss/vault1 Regroup from 1-3 to 2-4, with 2 old parties (A and B) and 2 new parties (D and E) A (old&new committee) B (old&new committee) D (new committee) E (new committee) command ./tss regroup/ --vault_name vault1 ./tss regroup --vault_name vault1 ./tss regroup --vault_name vault1 ./tss regroup --vault_name vault1 Interactive input > please input password: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] > please input password: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties need participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] > please input password: [Enter password] > please set Old total parties(n): 3 > please set Old threshold(t), at least t + 1 parties need participant signing: 1 > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties need participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] > please input password: [Enter password] > please set Old total parties(n): 3 > please set Old threshold(t), at least t + 1 parties need participant signing: 1 > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties need participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] output Files touched or generated ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/payment/config.json ~/.tss/payment/pk.json ~/.tss/vault1/sk.json","title":"Step 5: Regroup Vault"},{"location":"walletconnect-support.html","text":"Wallets with WalletConnect Support List of Wallets Supporting WalletConnect on Genesys Chain Number Wallet Name Network 1 Trust Wallet Mainnet 2 Math Wallet Mainnet 3 Meet.One Wallet Mainnet 4 Equal Wallet Mainnet&Testnet 5 SafePal Wallet Mainnet 6 CoolWallet Mainnet 7 XWallet Mainnet 8 Atomic Wallet Mainnet 9 Cosmostation Wallet Mainnet&Testnet 10 Infinity Wallet Mainnet&Testnet","title":"Wallets with WalletConnect Support"},{"location":"walletconnect-support.html#wallets-with-walletconnect-support","text":"List of Wallets Supporting WalletConnect on Genesys Chain Number Wallet Name Network 1 Trust Wallet Mainnet 2 Math Wallet Mainnet 3 Meet.One Wallet Mainnet 4 Equal Wallet Mainnet&Testnet 5 SafePal Wallet Mainnet 6 CoolWallet Mainnet 7 XWallet Mainnet 8 Atomic Wallet Mainnet 9 Cosmostation Wallet Mainnet&Testnet 10 Infinity Wallet Mainnet&Testnet","title":"Wallets with WalletConnect Support"},{"location":"walletconnect.html","text":"WalletConnect The Genesys Chain Web Wallet supports connecting with external wallet providers via the WalletConnect protocol . WalletConnect allows the user to scan a QR code from the wallet app to unlock and use their wallet seamlessly in the web UI. In order for this to work, some modifications to the standard WalletConnect protocol are used in the Genesys Chain wallet's implementation. See the list of wallets which support WalletConnect on Genesys Chain here Connecting via WalletConnect Wallet providers should make use of the WalletConnect Client SDK for their target programming language and OS. There are implementations on GitHub for iOS, Android, React Native, etc. Protocol Differences Since we do not use Ethereum transactions, there are some differences: Typically sendTransaction is used with Ethereum transaction parameters in WalletConnect dApp integrations. But in Genesys Chain's case, instead of invoking sendTransaction in the WalletConnect flow, the new sendCustomRequest call is used instead with a method called bnb_sign (see below). The external wallet provider is responsible for sending back the signature and public key of the transaction but should not broadcast the transaction itself. We have instead defined a custom result format in the form of stringified JSON containing the signature and public key. The reason for this is that the wallet app probably does not have access to the complete serialized binary form of the transaction (as this requires Amino encoding). The web wallet will send back a second custom call (after bnb_sign ) called bnb_tx_confirmation , which contains the boolean result of the transaction build/broadcast and any error message encountered by the web wallet during broadcasting. In a complete implementation, this confirmation callback should be responded to with a call to approveRequest . Sequence Diagram This sequence diagram shows the flow of messages when the web wallet interacts with an external wallet provider via WalletConnect. Custom Requests A custom call request adheres to this structure: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"method\" : \"method_name\" , \"params\" : [{ ... }], } We have two custom call request formats, here are examples of them: Example: bnb_sign { \"method\" : \"bnb_sign\" , \"params\" : [ { \"account_number\" : \"34\" , \"chain_id\" : \"GSYS-Chain-Ganges\" , \"data\" : null , \"memo\" : \"test\" , \"msgs\" : [ { \"inputs\" : [ { \"address\" : \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" , \"coins\" : [ { \"amount\" : 1000000000 , \"denom\" : \"GSYS\" , }, ], }, ], \"outputs\" : [ { \"address\" : \"tbnb1ss57e8sa7xnwq030k2ctr775uac9gjzglqhvpy\" , \"coins\" : [ { \"amount\" : 1000000000 , \"denom\" : \"GSYS\" , }, ], }, ], }, ], \"sequence\" : \"31\" , \"source\" : \"1\" , } ] } Response (approveRequest) A response like this should be sent back from the wallet app: { \"id\" : 1553682007906047 , \"result\" : \"{\\\"signature\\\":\\\"...\\\",\\\"publicKey\\\":\\\"...\\\"}\" } In result , a JSON-encoded object must be included containing the following hex-string properties: signature , publicKey . Note that: id and jsonrpc are usually pre-filled by the client SDK, so there should be no need to set this in the object yourself. signature should be 64 bytes in length (128 hex chars) publicKey should be 65 bytes in length (130 hex chars, non-compressed form, prefixed with 0x04 ) Example: bnb_tx_confirmation { \"method\" : \"bnb_tx_confirmation\" , \"params\" : [ { \"ok\" : true , \"error\" : \"Error message (optional)\" } ] } Receipt of the bnb_tx_confirmation should be confirmed by the app with approveRequest as per the WalletConnect protocol flow. For this response, result may be empty or contain an empty JSON-encoded object: Response (approveRequest) A response like this should be sent back from the wallet app: { \"id\" : 1553682007906050 , \"result\" : \"\" } Ending the Session Remember to call killSession() when the user has finished using the integration from your app! This will redirect the user back to the unlock screen in the web wallet.","title":"<img src=\"./assets/walletconnect.svg\" width=\"60\"> WalletConnect"},{"location":"walletconnect.html#walletconnect","text":"The Genesys Chain Web Wallet supports connecting with external wallet providers via the WalletConnect protocol . WalletConnect allows the user to scan a QR code from the wallet app to unlock and use their wallet seamlessly in the web UI. In order for this to work, some modifications to the standard WalletConnect protocol are used in the Genesys Chain wallet's implementation. See the list of wallets which support WalletConnect on Genesys Chain here","title":" WalletConnect"},{"location":"walletconnect.html#connecting-via-walletconnect","text":"Wallet providers should make use of the WalletConnect Client SDK for their target programming language and OS. There are implementations on GitHub for iOS, Android, React Native, etc.","title":"Connecting via WalletConnect"},{"location":"walletconnect.html#protocol-differences","text":"Since we do not use Ethereum transactions, there are some differences: Typically sendTransaction is used with Ethereum transaction parameters in WalletConnect dApp integrations. But in Genesys Chain's case, instead of invoking sendTransaction in the WalletConnect flow, the new sendCustomRequest call is used instead with a method called bnb_sign (see below). The external wallet provider is responsible for sending back the signature and public key of the transaction but should not broadcast the transaction itself. We have instead defined a custom result format in the form of stringified JSON containing the signature and public key. The reason for this is that the wallet app probably does not have access to the complete serialized binary form of the transaction (as this requires Amino encoding). The web wallet will send back a second custom call (after bnb_sign ) called bnb_tx_confirmation , which contains the boolean result of the transaction build/broadcast and any error message encountered by the web wallet during broadcasting. In a complete implementation, this confirmation callback should be responded to with a call to approveRequest .","title":"Protocol Differences"},{"location":"walletconnect.html#sequence-diagram","text":"This sequence diagram shows the flow of messages when the web wallet interacts with an external wallet provider via WalletConnect.","title":"Sequence Diagram"},{"location":"walletconnect.html#custom-requests","text":"A custom call request adheres to this structure: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"method\" : \"method_name\" , \"params\" : [{ ... }], } We have two custom call request formats, here are examples of them:","title":"Custom Requests"},{"location":"walletconnect.html#example-bnb_sign","text":"{ \"method\" : \"bnb_sign\" , \"params\" : [ { \"account_number\" : \"34\" , \"chain_id\" : \"GSYS-Chain-Ganges\" , \"data\" : null , \"memo\" : \"test\" , \"msgs\" : [ { \"inputs\" : [ { \"address\" : \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" , \"coins\" : [ { \"amount\" : 1000000000 , \"denom\" : \"GSYS\" , }, ], }, ], \"outputs\" : [ { \"address\" : \"tbnb1ss57e8sa7xnwq030k2ctr775uac9gjzglqhvpy\" , \"coins\" : [ { \"amount\" : 1000000000 , \"denom\" : \"GSYS\" , }, ], }, ], }, ], \"sequence\" : \"31\" , \"source\" : \"1\" , } ] }","title":"Example: bnb_sign"},{"location":"walletconnect.html#response-approverequest","text":"A response like this should be sent back from the wallet app: { \"id\" : 1553682007906047 , \"result\" : \"{\\\"signature\\\":\\\"...\\\",\\\"publicKey\\\":\\\"...\\\"}\" } In result , a JSON-encoded object must be included containing the following hex-string properties: signature , publicKey . Note that: id and jsonrpc are usually pre-filled by the client SDK, so there should be no need to set this in the object yourself. signature should be 64 bytes in length (128 hex chars) publicKey should be 65 bytes in length (130 hex chars, non-compressed form, prefixed with 0x04 )","title":"Response (approveRequest)"},{"location":"walletconnect.html#example-bnb_tx_confirmation","text":"{ \"method\" : \"bnb_tx_confirmation\" , \"params\" : [ { \"ok\" : true , \"error\" : \"Error message (optional)\" } ] } Receipt of the bnb_tx_confirmation should be confirmed by the app with approveRequest as per the WalletConnect protocol flow. For this response, result may be empty or contain an empty JSON-encoded object:","title":"Example: bnb_tx_confirmation"},{"location":"walletconnect.html#response-approverequest_1","text":"A response like this should be sent back from the wallet app: { \"id\" : 1553682007906050 , \"result\" : \"\" }","title":"Response (approveRequest)"},{"location":"walletconnect.html#ending-the-session","text":"Remember to call killSession() when the user has finished using the integration from your app! This will redirect the user back to the unlock screen in the web wallet.","title":"Ending the Session"},{"location":"wallets.html","text":"Wallet Support List of Wallets Supporting Genesys Chain Mainnet Number Wallet Name Website DEX Feature Available Testnet Support WalletConnect Support 1 Trust Wallet https://trustwallet.com/ Yes Yes Yes 2 Trubi Wallet https://trubi.io/ Yes No Yes 3 Ledger (Hardware Wallet) https://www.ledger.com/ Yes, via GSYS.org and Trubi Yes, via GSYS.org and Trubi Yes, via GSYS.org and Trubi 4 CoolWallet (Hardware Wallet) https://coolwallet.io/ Yes, via GSYS.org and Trubi Yes, via GSYS.org and Trubi Yes, via GSYS.org and Trubi 5 Arkane https://arkane.network/ Yes Yes No 6 Enjin https://enjinwallet.io/ No No No 7 Magnum Wallet https://magnumwallet.co/ Yes No Yes 8 Coinomi Wallet http://coinomi.com/ Yes No Yes 9 Atomic Wallet https://atomicwallet.io/ No No Yes 10 ZelCore Wallet https://zeltrez.io/ Yes No Yes 11 Infinito Wallet https://www.infinitowallet.io/ Yes No Yes 12 Math Wallet https://www.mathwallet.org/en/ Yes No Yes 13 Ellipal Wallet https://www.ellipal.com/ Yes No No 14 Exodus https://www.exodus.io/ No No No 15 HooWallet https://hoo.com/ No No No 16 MEET.ONE Wallet https://meet.one/ Yes No Yes 17 Guarda Wallet https://guarda.co/ No No No 18 DDEX Wallet https://ddex.io/ Yes No No 19 Equal Wallet https://equal.tech/ Yes Yes Yes 20 Pundi X Wallet https://pundix.com/ No No No 21 Arax Wallet https://arax.io No No No 22 SafePal Wallet (Hardware Wallet) https://www.safepal.io Yes No Yes 23 Zengo Wallet https://zengo.com/ No No No 24 TokenPocket Wallet https://www.tokenpocket.pro/ No No Yes 25 Cobo Wallet https://cobo.com/ No No Yes 26 Midas Wallet https://www.midasprotocol.io No No No 27 Cosmostation Wallet https://www.cosmostation.io/ No Yes Yes 28 Trezor https://trezor.io/ No No Yes 29 Mixin https://mixin.one No No No 30 Ownbit https://ownbit.io No No No 31 Frontier https://frontierwallet.com/ No Yes No 32 D'CENT Wallet https://dcentwallet.com/ No Yes No 33 Infinity Wallet (Desktop Wallet) https://infinitywallet.io/ Yes No Yes","title":"Wallet Support"},{"location":"wallets.html#wallet-support","text":"List of Wallets Supporting Genesys Chain Mainnet Number Wallet Name Website DEX Feature Available Testnet Support WalletConnect Support 1 Trust Wallet https://trustwallet.com/ Yes Yes Yes 2 Trubi Wallet https://trubi.io/ Yes No Yes 3 Ledger (Hardware Wallet) https://www.ledger.com/ Yes, via GSYS.org and Trubi Yes, via GSYS.org and Trubi Yes, via GSYS.org and Trubi 4 CoolWallet (Hardware Wallet) https://coolwallet.io/ Yes, via GSYS.org and Trubi Yes, via GSYS.org and Trubi Yes, via GSYS.org and Trubi 5 Arkane https://arkane.network/ Yes Yes No 6 Enjin https://enjinwallet.io/ No No No 7 Magnum Wallet https://magnumwallet.co/ Yes No Yes 8 Coinomi Wallet http://coinomi.com/ Yes No Yes 9 Atomic Wallet https://atomicwallet.io/ No No Yes 10 ZelCore Wallet https://zeltrez.io/ Yes No Yes 11 Infinito Wallet https://www.infinitowallet.io/ Yes No Yes 12 Math Wallet https://www.mathwallet.org/en/ Yes No Yes 13 Ellipal Wallet https://www.ellipal.com/ Yes No No 14 Exodus https://www.exodus.io/ No No No 15 HooWallet https://hoo.com/ No No No 16 MEET.ONE Wallet https://meet.one/ Yes No Yes 17 Guarda Wallet https://guarda.co/ No No No 18 DDEX Wallet https://ddex.io/ Yes No No 19 Equal Wallet https://equal.tech/ Yes Yes Yes 20 Pundi X Wallet https://pundix.com/ No No No 21 Arax Wallet https://arax.io No No No 22 SafePal Wallet (Hardware Wallet) https://www.safepal.io Yes No Yes 23 Zengo Wallet https://zengo.com/ No No No 24 TokenPocket Wallet https://www.tokenpocket.pro/ No No Yes 25 Cobo Wallet https://cobo.com/ No No Yes 26 Midas Wallet https://www.midasprotocol.io No No No 27 Cosmostation Wallet https://www.cosmostation.io/ No Yes Yes 28 Trezor https://trezor.io/ No No Yes 29 Mixin https://mixin.one No No No 30 Ownbit https://ownbit.io No No No 31 Frontier https://frontierwallet.com/ No Yes No 32 D'CENT Wallet https://dcentwallet.com/ No Yes No 33 Infinity Wallet (Desktop Wallet) https://infinitywallet.io/ Yes No Yes","title":"Wallet Support"},{"location":"faq/faq.html","text":"Genesys Chain FAQ v0.5 What is Genesys Chain, or GSYS DEX? Genesys Chain is the blockchain initially developed by GSYS and community. GSYS DEX is the decentralized exchange module developed on top of the Genesys Chain blockchain. What is the design principle of Genesys Chain? The main focuses for the design of Genesys Chain are: No custody of funds: traders maintain control of their private keys and funds. High performance: low latency, high throughput for a large user base, and high liquidity trading. We target to achieve 1 second block times, with 1 confirmation finality. Low cost: in both fees and liquidity cost. Easy user experience: as friendly as GSYS.com. Fair trading: minimize front-running, to the extent possible. Evolvable: able to develop with forever-improving technology stack, architecture, and ideas. What can you do on Genesys Chain? You can: Send and receive GSYS Issue new tokens Send, receive, burn/mint and freeze/unfreeze tokens Propose to create trading pairs between two different tokens Send orders to buy or sell assets through trading pairs created on the chain Will Genesys Chain introduce more features and transaction types in the future? Yes, Genesys Chain team and community would cherish the technology advancements and recommended trends and strive to make circulation of assets and value easier and easier. What is the native coin on Genesys Chain? The Genesys, GSYS, is the native asset on Genesys Chain. There are 200MM Genesyss in total. There will be no mining. The existing coin burns and freezes will still be in effect on the new Genesys Chain blockchain. The exact number of Genesyss will be destroyed based on the same number of GSYS ERC20 tokens that have already been destroyed. Since Genesys Chain is live, all GSYS ERC20 tokens will be swapped for Genesys Chain coins. All users who hold GSYS ERC20 tokens can deposit them to GSYS.com, and upon withdrawal, the new Genesys Chain native coins will be sent to their new wallets. How can I register on Genesys Chain/DEX and start trading? There is no need to register. All you need is a Genesys Chain address, which can be generated with any wallet that supports Genesys Chain. Then you can trade GSYS or other assets stored on that address. How can I send orders on GSYS DEX? Order On GSYS DEX, you can send \"new order\" messages to buy or sell certain assets. You can also send \"cancel\" messages to cancel existing open orders. You can use a wallet to send new orders and cancels. GSYS DEX also provides API for automated trading. In GSYS DEX v1.0, the order message contains: Symbol: trading pair on the chain Side: buy or sell Price: only limit price orders are supported in Genesys Chain v1.0 Amount Time In Force: GSYS DEX supports Immediate Or Cancel (IOC) and Good Till Expiry (GTE) orders. GTE orders can quote on the exchange until they are filled by the opposite orders satisfying the limit price, or canceled by client themselves, or expire after 72 hours after 00:00 (UTC). Check the \"What is Order Expire \" section of the FAQ for more information. Network nodes examine orders to ensure they are valid. Once the orders are accepted, they are booked on the next block, and get matched accordingly. What is Immediate Or Cancel order ? Immediate Or Cancel is a special order type. Once the order is accepted into a block, Immediate Or Cancel orders only exist in this block round. The order may get filled to zero, or partially or fully filled by other orders, and then will become expired and removed from the order book right away. As a result, it will not be tradable in the next round of matching. A small fee will be charged for the network usage, if there is no fill at all for the order (deemed as no intention to trade). Match GSYS DEX does all of its matching on the blockchain, i.e. all nodes perform the matches and expect the same result. This is to ensure the maximum transparency and to mitigate the chance for front-running, even from the block producers. The matching infrastructure is expected to evolve and grow in capacity as time progresses. GSYS DEX doesn't do continuous matching as most centralized exchanges do. Instead, it matches using periodic auction matching for all the existing open orders received in the past and the latest blocks. The match logic is explained in more detail later. Trade Once the orders are filled, the corresponding assets will be automatically moved into buyers' addresses. The confirmation is instant and no need to wait for further blocks (i.e. T+0 block). Buyers can use the bought asset right away, either send it to another address or trade it again. What is Order Expire ? Orders accepted by GSYS DEX will either get filled with other orders or remain in the order book, but they will not stay on the order book forever. These orders will expire and be removed from the order book after the 1st midnight (UTC) after 72 hours once the order gets accepted. A small fee will be charged for the network usage, if there is no fill at all for the order (deemed as no intention to trade). Where can I see my assets and trades? You can always use wallets that support Genesys Chain to check your asset balances, open orders, and (optionally) order/trade history. Genesys Chain Explorer is another tool to check balances and transactions. When can I see my order on the blockchain after I send it? It depends. Normally, if you connect to one of the Accelerated Nodes, your orders should get accepted and booked into a block in 1-3 seconds. If the order price is marketable, the order will be filled and trades will come back in about similar time. If you send the order from far-way (self-setup full node), or there is heavy network traffic, the order may take longer to reach a Validator (block producer). What is the Fee Structure? Fees are charged and shared among the block producers (i.e. Validators) to run the network, in order to pay for the network usage and prevent abuse and attack. Since all user transactions, include transfer, new order, cancel etc, they are all recorded in blocks and chain state, the fee will be shared among different transactions. New orders are exempt from fees to encourage usage and larger trades will be charged more for their benefits from the liquidity provided in the network. Order Expire and Cancel are also charged with a fee if they fail to provide any liquidity. The current fee table is here Besides the fees, no other gas will be charged. Fees can be paid in any asset, but the network will charge GSYS first and apply a discount if the address has GSYS balance. The fee is subject to periodical review and adjustment, after agreement from validators, via a proposal-vote procedure. See a fee-change proposal here Trade fee is calculated based on trade notional value, while fees for other transactions are fixed. It is free to send a new GET order, cancel a partially filled order, or expire a partially filled order. Non-Trade related transactions will be charged with a fee when the transactions happen, and can only be paid in GSYS. The transaction will be rejected if the address does not have enough GSYS. Trade-related transactions will be charged with a fee when an order is filled, or canceled/expired/IOC-expired with no fills. If there is enough GSYS to pay, GSYS fee structure will be used, otherwise, non-GSYS fee structure will be used instead. If the whole order value and free balance for the receiving asset are not enough to pay the fee, all the receiving asset and its residual balance will be charged. What is the current Fee Table on Genesys Chain Mainnet? Fees are variable and may change over time as governance proposals are proposed and voted on. The current fees table for Mainnet as of 2021-03-21 is as follows: Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related New Order 0 0 Y Cancel (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y Order Expire (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y IOC (No Fill) Equivalent 0.00025 GSYS 0.000005 GSYS Y Transfer N/A 0.000075 GSYS N crossTransferOut N/A 0.000075 GSYS N Multi-send N/A 0.00006 GSYS N Issue Asset N/A 10 GSYS Mint Asset N/A 0.002 GSYS N Transfer ownership N/A 0.002 GSYS N Burn Asset N/A 0.002 GSYS N Freeze/Unfreeze Asset N/A 0.001 GSYS N Lock/unlock/relock Asset N/A 0.002 GSYS N List Asset N/A 200 GSYS N Submit Proposal N/A 1 GSYS N Deposit N/A 0.000125 GSYS N Enable Memo Check N/A 0.2 GSYS N Disable Memo Check N/A 0.2 GSYS N HTLT N/A 0.000075 GSYS N depositHTLT N/A 0.000075 GSYS N claimHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N TinyIssueFee N/A 0.4 GSYS N MiniIssueFee N/A 0.6 GSYS N SetTokenUri N/A 0.000075 GSYS N List BEP8 Token N/A 1 GSYS N Create A New Smart Chain Validator N/A 2 GSYS N Edit Smart Chain Validator Information N/A 0.2 GSYS N Delegate Smart Chain Validator N/A 0.0002 GSYS N Redelegate Smart Chain Validator N/A 0.0006 GSYS N Undelegate Smart Chain Validator N/A 0.0004 GSYS N Unjail A Smart Chain Validator N/A 0.5 GSYS N Submit Byzaitine Behavior Evidence of A Smart Chain Validator N/A 0.5 GSYS N Submit Smart Chain Proposal N/A 1 GSYS N Smart Chain Proposal Deposit N/A 0.00025 GSYS N Smart Chain Proposal Vote N/A 0 GSYS N Cross transfer out relayer reward N/A 0.0004 GSYS N What is the current Fee Table on Genesys Chain Testnet? Fees are variable and may change over time as governance proposals are proposed and voted on. The current fees table for Testnet as of 2021-03-17 is as follows: Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related New Order 0 0 Y Cancel (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y Order Expire (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y IOC (No Fill) Equivalent 0.00025 GSYS 0.000005 GSYS Y Transfer N/A 0.000075 GSYS N crossTransferOut N/A 0.000075 GSYS N Multi-send N/A 0.00006 GSYS N Issue Asset N/A 10 GSYS Mint Asset N/A 0.002 GSYS N Transfer ownership N/A 0.002 GSYS N Burn Asset N/A 0.002 GSYS N Freeze/Unfreeze Asset N/A 0.001 GSYS N Lock/unlock/relock Asset N/A 0.002 GSYS N List Asset N/A 200 GSYS N Submit Proposal N/A 1 GSYS N Deposit N/A 0.000125 GSYS N Enable Memo Check N/A 0.2 GSYS N Disable Memo Check N/A 0.2 GSYS N HTLT N/A 0.000075 GSYS N depositHTLT N/A 0.000075 GSYS N claimHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N TinyIssueFee N/A 0.4 GSYS N MiniIssueFee N/A 0.6 GSYS N SetTokenUri N/A 0.000075 GSYS N List BEP8 Token N/A 1 GSYS N Create A New Smart Chain Validator N/A 2 GSYS N Edit Smart Chain Validator Information N/A 0.2 GSYS N Delegate Smart Chain Validator N/A 0.0002 GSYS N Redelegate Smart Chain Validator N/A 0.0006 GSYS N Undelegate Smart Chain Validator N/A 0.0004 GSYS N Unjail A Smart Chain Validator N/A 0.5 GSYS N Submit Byzaitine Behavior Evidence of A Smart Chain Validator N/A 0.5 GSYS N Submit Smart Chain Proposal N/A 1 GSYS N Smart Chain Proposal Deposit N/A 0.00025 GSYS N Smart Chain Proposal Vote N/A 0 GSYS N Cross transfer out relayer reward N/A 0.0004 GSYS N Can I see orders/balances of others or can other people see my orders/balances? Yes, anyone can see anyone's orders and balances if they know the corresponding addresses. Genesys Chain is 100% transparent for transactions and balances. Information provided through API and their usage Is there any limit to using the API to send orders or check market data? Yes, there are rate limits to ensure there is no waste or abuse of the network infrastructure. Please check the API documentation. What does Wallet and API cost to use? No fee or commission at all (free to use). What Market Data can I get? The market data provided via Wallet and API are similar to GSYS.com, including ticker data, order book, trade and Kline. They can be seen in the Wallet and read from REST or WebSocket API. Please check the API documentation for details. What are the tick size and lot size? Are they fixed? Tick size is the minimum unit to increase or decrease for the price (in quote asset) of an order, while lot size is the minimum unit to increase or decrease for the quantity (in base asset) of an order. They are not the same as on GSYS.com. They can be queried from API or checked from Wallet UI. Tick Size and lot size are not fixed. Genesys Chain will automatically/periodically review the values to make sure proper order size and notional is applied. Are there limits on notional value of an order? The smallest order you can send for a trading pair is 1 lot size quantity at 1 tick size price. No other limits. What is the decimal precision for prices and quantities on Genesys Chain/DEX? Amounts are represented as integers, and all coins have a fixed scale of 8. This means that if a balance of 100000000 were to be exposed to a wallet integrator, this will represent a balance of 1 coin. I forgot the private key for my address, how can I get it back? Sorry, you cannot. Owner of the address takes full responsibility for the private key protection. Genesys Chain and official wallets do not have your private key. My private key got stolen by hackers, how can I recover my assets? Sorry, you take full responsibility of your private key ownership and protection. Genesys Chain and official wallets will not record, or transfer out your private key. What is the Accelerated Node? While users can submit transactions and most of the queries via normal, self-run full nodes. Accelerated Node provides more secure and faster lines to access Genesys Chain. Accelerated Node is special infrastructure built around Validator to facilitate accelerated transaction routing and provide richer, faster user interfaces. There are always several Accelerated Nodes running at the same time around the world (owned by different organizations) and you are encouraged to choose one of them to use, or allow your Wallet choose one randomly. For rapid API access, you'd better stay with one Accelerated Node to get better performance. How can I issue an asset? Anyone can pay a fee and issue an asset as Token on Genesys Chain, as long as they provide proper information for the fields below, and then execute the command through the command line or http interfaces. Name: a description string of less than 21 characters Symbol: an identifier string less than 9 characters, which must be composed of [0-9A-Z] Total Supply: a positive number less than or equal to 90 billions Mint-able: whether the token can increase Total Supply in later time or not What is the consensus algorithm used on Genesys Chain? Genesys Chain uses BFT and PoS (upcoming) based consensus mechanism to produce blocks among a series of qualified Validators. This is similar to the architectures of several existing popular blockchain platforms such as EOS and NEO. The process for setting up validators among different entities on Genesys Chain is currently being defined. More details will be shared at a later date. Can I run a full node for Genesys Chain? Yes, you can. A full node contains all the information and application logic for Genesys Chain. It can receive and broadcast blocks and transactions with other full nodes and even validators. The only exception is it will not participate in the consensus if the full node is not a Validator. Does Genesys Chain support Smart Contracts? No. This was an intentional design decision to improve the performance of the system and eliminate having to support unnecessary features. If you have certain must-have feature-s, it might be added as a native implementation instead of using smart contract. Feel free to talk to GSYS community. How can I transfer tokens, such as Bitcoin, from other block chains onto Genesys Chain? Right now, there are 2 ways to transfer tokens cross-chain: via interoperability among different chains. After the latest \u201cArchimedes\u201d upgrade, BEP3 was introduced and it defines native transactions to support Hash Timelock Contract (HGSYS) on Genesys Chain and it also to defines the infrastructure standard and procedure to use HGSYS for inter-chain atomic swap to easily swap tokens on different chains. Genesys Chain development community has finished implementing its solution for BEP3 with BEP2 and ERC20 tokens and decided to open-source all of the key components, including\uff1a smart-contract solution that supports Atomic Peg Swap (APS) for Ethereum. Please note that this solution is already audited by 3rd party. deputy process written in GoLang that handles swap activities Any developer is welcome to test the solutions in testnet and then use them in mainnet. via GSYS.com. GSYS ,the largest cryptocurrency exchange, has issued a number of crypto-pegged tokens on Genesys Chain (BEP2 token format): BEP2 Bitcoin , BEP2 BCH , BEP2 XRP , BEP2 LTC . Pegged tokens such as BEP2 Bitcoin , are 100% backed by the native coin in reserve . The reserve addresses are published for anyone to audit. Read this blog to learn about the reserved address. Users are free to convert between native and BEP2 Bitcoin via deposit/withdrawal. This has a higher degree of ease-of-use for most traders. More swap channels will be provided on partner wallets soon. Atomic swap and this centralized approach are not exclusive to other decentralized approaches, which can also be implemented in parallel. There are many cross-chain solutions being developed and we are very interested in them. Please do NOT try to transfer anything on existing network to Genesys Chain testnet, you may experience loss by doing so, because testnet doesn't run with real coins. How is a trading pair created on GSYS DEX? The design philosophy of GSYS DEX adheres to the idea that the most efficient and low cost way to perform trading and price-discovery is still to use single order book. This single order book is managed and replicated across all full nodes with the same, deterministic matching logic. Simply allowing trading between two assets seems easy enough, however it is expensive for not only the network but also its users in long term (and liquidity costs can be much larger). In order to efficiently use the network, Genesys Chain only list assets against GSYS and other widely accepted market quote assets. After an asset is issued, which costs a small fee, anyone can \"propose\" to all validators to list it against particular quote assets. Validators then vote to accept the proposal. A deposit is taken to prevent network abuse. Once the proposal is accepted, the owner of the base asset can list the trading pair. For more information about this process please check the listing guide . How would a third-party integrate with Genesys Chain and GSYS DEX? A wallet provider may choose to only support the feature set of Genesys Chain, which would just cover wallets, addresses, balances and transfers. To improve their implementation further, they could choose to integrate GSYS DEX which would add trading (order placement and cancellation), historical order and trade views, charts, etc.","title":"Genesys Chain FAQ v0.5"},{"location":"faq/faq.html#genesys-chain-faq-v05","text":"","title":"Genesys Chain FAQ v0.5"},{"location":"faq/faq.html#what-is-genesys-chain-or-gsys-dex","text":"Genesys Chain is the blockchain initially developed by GSYS and community. GSYS DEX is the decentralized exchange module developed on top of the Genesys Chain blockchain.","title":"What is Genesys Chain, or GSYS DEX?"},{"location":"faq/faq.html#what-is-the-design-principle-of-genesys-chain","text":"The main focuses for the design of Genesys Chain are: No custody of funds: traders maintain control of their private keys and funds. High performance: low latency, high throughput for a large user base, and high liquidity trading. We target to achieve 1 second block times, with 1 confirmation finality. Low cost: in both fees and liquidity cost. Easy user experience: as friendly as GSYS.com. Fair trading: minimize front-running, to the extent possible. Evolvable: able to develop with forever-improving technology stack, architecture, and ideas.","title":"What is the design principle of Genesys Chain?"},{"location":"faq/faq.html#what-can-you-do-on-genesys-chain","text":"You can: Send and receive GSYS Issue new tokens Send, receive, burn/mint and freeze/unfreeze tokens Propose to create trading pairs between two different tokens Send orders to buy or sell assets through trading pairs created on the chain","title":"What can you do on Genesys Chain?"},{"location":"faq/faq.html#will-genesys-chain-introduce-more-features-and-transaction-types-in-the-future","text":"Yes, Genesys Chain team and community would cherish the technology advancements and recommended trends and strive to make circulation of assets and value easier and easier.","title":"Will Genesys Chain introduce more features and transaction types in the future?"},{"location":"faq/faq.html#what-is-the-native-coin-on-genesys-chain","text":"The Genesys, GSYS, is the native asset on Genesys Chain. There are 200MM Genesyss in total. There will be no mining. The existing coin burns and freezes will still be in effect on the new Genesys Chain blockchain. The exact number of Genesyss will be destroyed based on the same number of GSYS ERC20 tokens that have already been destroyed. Since Genesys Chain is live, all GSYS ERC20 tokens will be swapped for Genesys Chain coins. All users who hold GSYS ERC20 tokens can deposit them to GSYS.com, and upon withdrawal, the new Genesys Chain native coins will be sent to their new wallets.","title":"What is the native coin on Genesys Chain?"},{"location":"faq/faq.html#how-can-i-register-on-genesys-chaindex-and-start-trading","text":"There is no need to register. All you need is a Genesys Chain address, which can be generated with any wallet that supports Genesys Chain. Then you can trade GSYS or other assets stored on that address.","title":"How can I register on Genesys Chain/DEX and start trading?"},{"location":"faq/faq.html#how-can-i-send-orders-on-gsys-dex","text":"","title":"How can I send orders on GSYS DEX?"},{"location":"faq/faq.html#order","text":"On GSYS DEX, you can send \"new order\" messages to buy or sell certain assets. You can also send \"cancel\" messages to cancel existing open orders. You can use a wallet to send new orders and cancels. GSYS DEX also provides API for automated trading. In GSYS DEX v1.0, the order message contains: Symbol: trading pair on the chain Side: buy or sell Price: only limit price orders are supported in Genesys Chain v1.0 Amount Time In Force: GSYS DEX supports Immediate Or Cancel (IOC) and Good Till Expiry (GTE) orders. GTE orders can quote on the exchange until they are filled by the opposite orders satisfying the limit price, or canceled by client themselves, or expire after 72 hours after 00:00 (UTC). Check the \"What is Order Expire \" section of the FAQ for more information. Network nodes examine orders to ensure they are valid. Once the orders are accepted, they are booked on the next block, and get matched accordingly.","title":"Order"},{"location":"faq/faq.html#what-is-immediate-or-cancel-order","text":"Immediate Or Cancel is a special order type. Once the order is accepted into a block, Immediate Or Cancel orders only exist in this block round. The order may get filled to zero, or partially or fully filled by other orders, and then will become expired and removed from the order book right away. As a result, it will not be tradable in the next round of matching. A small fee will be charged for the network usage, if there is no fill at all for the order (deemed as no intention to trade).","title":"What is Immediate Or Cancel order?"},{"location":"faq/faq.html#match","text":"GSYS DEX does all of its matching on the blockchain, i.e. all nodes perform the matches and expect the same result. This is to ensure the maximum transparency and to mitigate the chance for front-running, even from the block producers. The matching infrastructure is expected to evolve and grow in capacity as time progresses. GSYS DEX doesn't do continuous matching as most centralized exchanges do. Instead, it matches using periodic auction matching for all the existing open orders received in the past and the latest blocks. The match logic is explained in more detail later.","title":"Match"},{"location":"faq/faq.html#trade","text":"Once the orders are filled, the corresponding assets will be automatically moved into buyers' addresses. The confirmation is instant and no need to wait for further blocks (i.e. T+0 block). Buyers can use the bought asset right away, either send it to another address or trade it again.","title":"Trade"},{"location":"faq/faq.html#what-is-order-expire","text":"Orders accepted by GSYS DEX will either get filled with other orders or remain in the order book, but they will not stay on the order book forever. These orders will expire and be removed from the order book after the 1st midnight (UTC) after 72 hours once the order gets accepted. A small fee will be charged for the network usage, if there is no fill at all for the order (deemed as no intention to trade).","title":"What is Order Expire?"},{"location":"faq/faq.html#where-can-i-see-my-assets-and-trades","text":"You can always use wallets that support Genesys Chain to check your asset balances, open orders, and (optionally) order/trade history. Genesys Chain Explorer is another tool to check balances and transactions.","title":"Where can I see my assets and trades?"},{"location":"faq/faq.html#when-can-i-see-my-order-on-the-blockchain-after-i-send-it","text":"It depends. Normally, if you connect to one of the Accelerated Nodes, your orders should get accepted and booked into a block in 1-3 seconds. If the order price is marketable, the order will be filled and trades will come back in about similar time. If you send the order from far-way (self-setup full node), or there is heavy network traffic, the order may take longer to reach a Validator (block producer).","title":"When can I see my order on the blockchain after I send it?"},{"location":"faq/faq.html#what-is-the-fee-structure","text":"Fees are charged and shared among the block producers (i.e. Validators) to run the network, in order to pay for the network usage and prevent abuse and attack. Since all user transactions, include transfer, new order, cancel etc, they are all recorded in blocks and chain state, the fee will be shared among different transactions. New orders are exempt from fees to encourage usage and larger trades will be charged more for their benefits from the liquidity provided in the network. Order Expire and Cancel are also charged with a fee if they fail to provide any liquidity. The current fee table is here Besides the fees, no other gas will be charged. Fees can be paid in any asset, but the network will charge GSYS first and apply a discount if the address has GSYS balance. The fee is subject to periodical review and adjustment, after agreement from validators, via a proposal-vote procedure. See a fee-change proposal here Trade fee is calculated based on trade notional value, while fees for other transactions are fixed. It is free to send a new GET order, cancel a partially filled order, or expire a partially filled order. Non-Trade related transactions will be charged with a fee when the transactions happen, and can only be paid in GSYS. The transaction will be rejected if the address does not have enough GSYS. Trade-related transactions will be charged with a fee when an order is filled, or canceled/expired/IOC-expired with no fills. If there is enough GSYS to pay, GSYS fee structure will be used, otherwise, non-GSYS fee structure will be used instead. If the whole order value and free balance for the receiving asset are not enough to pay the fee, all the receiving asset and its residual balance will be charged.","title":"What is the Fee Structure?"},{"location":"faq/faq.html#what-is-the-current-fee-table-on-genesys-chain-mainnet","text":"Fees are variable and may change over time as governance proposals are proposed and voted on. The current fees table for Mainnet as of 2021-03-21 is as follows: Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related New Order 0 0 Y Cancel (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y Order Expire (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y IOC (No Fill) Equivalent 0.00025 GSYS 0.000005 GSYS Y Transfer N/A 0.000075 GSYS N crossTransferOut N/A 0.000075 GSYS N Multi-send N/A 0.00006 GSYS N Issue Asset N/A 10 GSYS Mint Asset N/A 0.002 GSYS N Transfer ownership N/A 0.002 GSYS N Burn Asset N/A 0.002 GSYS N Freeze/Unfreeze Asset N/A 0.001 GSYS N Lock/unlock/relock Asset N/A 0.002 GSYS N List Asset N/A 200 GSYS N Submit Proposal N/A 1 GSYS N Deposit N/A 0.000125 GSYS N Enable Memo Check N/A 0.2 GSYS N Disable Memo Check N/A 0.2 GSYS N HTLT N/A 0.000075 GSYS N depositHTLT N/A 0.000075 GSYS N claimHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N TinyIssueFee N/A 0.4 GSYS N MiniIssueFee N/A 0.6 GSYS N SetTokenUri N/A 0.000075 GSYS N List BEP8 Token N/A 1 GSYS N Create A New Smart Chain Validator N/A 2 GSYS N Edit Smart Chain Validator Information N/A 0.2 GSYS N Delegate Smart Chain Validator N/A 0.0002 GSYS N Redelegate Smart Chain Validator N/A 0.0006 GSYS N Undelegate Smart Chain Validator N/A 0.0004 GSYS N Unjail A Smart Chain Validator N/A 0.5 GSYS N Submit Byzaitine Behavior Evidence of A Smart Chain Validator N/A 0.5 GSYS N Submit Smart Chain Proposal N/A 1 GSYS N Smart Chain Proposal Deposit N/A 0.00025 GSYS N Smart Chain Proposal Vote N/A 0 GSYS N Cross transfer out relayer reward N/A 0.0004 GSYS N","title":"What is the current Fee Table on Genesys Chain Mainnet?"},{"location":"faq/faq.html#what-is-the-current-fee-table-on-genesys-chain-testnet","text":"Fees are variable and may change over time as governance proposals are proposed and voted on. The current fees table for Testnet as of 2021-03-17 is as follows: Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related New Order 0 0 Y Cancel (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y Order Expire (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y IOC (No Fill) Equivalent 0.00025 GSYS 0.000005 GSYS Y Transfer N/A 0.000075 GSYS N crossTransferOut N/A 0.000075 GSYS N Multi-send N/A 0.00006 GSYS N Issue Asset N/A 10 GSYS Mint Asset N/A 0.002 GSYS N Transfer ownership N/A 0.002 GSYS N Burn Asset N/A 0.002 GSYS N Freeze/Unfreeze Asset N/A 0.001 GSYS N Lock/unlock/relock Asset N/A 0.002 GSYS N List Asset N/A 200 GSYS N Submit Proposal N/A 1 GSYS N Deposit N/A 0.000125 GSYS N Enable Memo Check N/A 0.2 GSYS N Disable Memo Check N/A 0.2 GSYS N HTLT N/A 0.000075 GSYS N depositHTLT N/A 0.000075 GSYS N claimHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N TinyIssueFee N/A 0.4 GSYS N MiniIssueFee N/A 0.6 GSYS N SetTokenUri N/A 0.000075 GSYS N List BEP8 Token N/A 1 GSYS N Create A New Smart Chain Validator N/A 2 GSYS N Edit Smart Chain Validator Information N/A 0.2 GSYS N Delegate Smart Chain Validator N/A 0.0002 GSYS N Redelegate Smart Chain Validator N/A 0.0006 GSYS N Undelegate Smart Chain Validator N/A 0.0004 GSYS N Unjail A Smart Chain Validator N/A 0.5 GSYS N Submit Byzaitine Behavior Evidence of A Smart Chain Validator N/A 0.5 GSYS N Submit Smart Chain Proposal N/A 1 GSYS N Smart Chain Proposal Deposit N/A 0.00025 GSYS N Smart Chain Proposal Vote N/A 0 GSYS N Cross transfer out relayer reward N/A 0.0004 GSYS N","title":"What is the current Fee Table on Genesys Chain Testnet?"},{"location":"faq/faq.html#can-i-see-ordersbalances-of-others-or-can-other-people-see-my-ordersbalances","text":"Yes, anyone can see anyone's orders and balances if they know the corresponding addresses. Genesys Chain is 100% transparent for transactions and balances.","title":"Can I see orders/balances of others or can other people see my orders/balances?"},{"location":"faq/faq.html#information-provided-through-api-and-their-usage","text":"","title":"Information provided through API and their usage"},{"location":"faq/faq.html#is-there-any-limit-to-using-the-api-to-send-orders-or-check-market-data","text":"Yes, there are rate limits to ensure there is no waste or abuse of the network infrastructure. Please check the API documentation.","title":"Is there any limit to using the API to send orders or check market data?"},{"location":"faq/faq.html#what-does-wallet-and-api-cost-to-use","text":"No fee or commission at all (free to use).","title":"What does Wallet and API cost to use?"},{"location":"faq/faq.html#what-market-data-can-i-get","text":"The market data provided via Wallet and API are similar to GSYS.com, including ticker data, order book, trade and Kline. They can be seen in the Wallet and read from REST or WebSocket API. Please check the API documentation for details.","title":"What Market Data can I get?"},{"location":"faq/faq.html#what-are-the-tick-size-and-lot-size-are-they-fixed","text":"Tick size is the minimum unit to increase or decrease for the price (in quote asset) of an order, while lot size is the minimum unit to increase or decrease for the quantity (in base asset) of an order. They are not the same as on GSYS.com. They can be queried from API or checked from Wallet UI. Tick Size and lot size are not fixed. Genesys Chain will automatically/periodically review the values to make sure proper order size and notional is applied.","title":"What are the tick size and lot size? Are they fixed?"},{"location":"faq/faq.html#are-there-limits-on-notional-value-of-an-order","text":"The smallest order you can send for a trading pair is 1 lot size quantity at 1 tick size price. No other limits.","title":"Are there limits on notional value of an order?"},{"location":"faq/faq.html#what-is-the-decimal-precision-for-prices-and-quantities-on-genesys-chaindex","text":"Amounts are represented as integers, and all coins have a fixed scale of 8. This means that if a balance of 100000000 were to be exposed to a wallet integrator, this will represent a balance of 1 coin.","title":"What is the decimal precision for prices and quantities on Genesys Chain/DEX?"},{"location":"faq/faq.html#i-forgot-the-private-key-for-my-address-how-can-i-get-it-back","text":"Sorry, you cannot. Owner of the address takes full responsibility for the private key protection. Genesys Chain and official wallets do not have your private key.","title":"I forgot the private key for my address, how can I get it back?"},{"location":"faq/faq.html#my-private-key-got-stolen-by-hackers-how-can-i-recover-my-assets","text":"Sorry, you take full responsibility of your private key ownership and protection. Genesys Chain and official wallets will not record, or transfer out your private key.","title":"My private key got stolen by hackers, how can I recover my assets?"},{"location":"faq/faq.html#what-is-the-accelerated-node","text":"While users can submit transactions and most of the queries via normal, self-run full nodes. Accelerated Node provides more secure and faster lines to access Genesys Chain. Accelerated Node is special infrastructure built around Validator to facilitate accelerated transaction routing and provide richer, faster user interfaces. There are always several Accelerated Nodes running at the same time around the world (owned by different organizations) and you are encouraged to choose one of them to use, or allow your Wallet choose one randomly. For rapid API access, you'd better stay with one Accelerated Node to get better performance.","title":"What is the Accelerated Node?"},{"location":"faq/faq.html#how-can-i-issue-an-asset","text":"Anyone can pay a fee and issue an asset as Token on Genesys Chain, as long as they provide proper information for the fields below, and then execute the command through the command line or http interfaces. Name: a description string of less than 21 characters Symbol: an identifier string less than 9 characters, which must be composed of [0-9A-Z] Total Supply: a positive number less than or equal to 90 billions Mint-able: whether the token can increase Total Supply in later time or not","title":"How can I issue an asset?"},{"location":"faq/faq.html#what-is-the-consensus-algorithm-used-on-genesys-chain","text":"Genesys Chain uses BFT and PoS (upcoming) based consensus mechanism to produce blocks among a series of qualified Validators. This is similar to the architectures of several existing popular blockchain platforms such as EOS and NEO. The process for setting up validators among different entities on Genesys Chain is currently being defined. More details will be shared at a later date.","title":"What is the consensus algorithm used on Genesys Chain?"},{"location":"faq/faq.html#can-i-run-a-full-node-for-genesys-chain","text":"Yes, you can. A full node contains all the information and application logic for Genesys Chain. It can receive and broadcast blocks and transactions with other full nodes and even validators. The only exception is it will not participate in the consensus if the full node is not a Validator.","title":"Can I run a full node for Genesys Chain?"},{"location":"faq/faq.html#does-genesys-chain-support-smart-contracts","text":"No. This was an intentional design decision to improve the performance of the system and eliminate having to support unnecessary features. If you have certain must-have feature-s, it might be added as a native implementation instead of using smart contract. Feel free to talk to GSYS community.","title":"Does Genesys Chain support Smart Contracts?"},{"location":"faq/faq.html#how-can-i-transfer-tokens-such-as-bitcoin-from-other-block-chains-onto-genesys-chain","text":"Right now, there are 2 ways to transfer tokens cross-chain: via interoperability among different chains. After the latest \u201cArchimedes\u201d upgrade, BEP3 was introduced and it defines native transactions to support Hash Timelock Contract (HGSYS) on Genesys Chain and it also to defines the infrastructure standard and procedure to use HGSYS for inter-chain atomic swap to easily swap tokens on different chains. Genesys Chain development community has finished implementing its solution for BEP3 with BEP2 and ERC20 tokens and decided to open-source all of the key components, including\uff1a smart-contract solution that supports Atomic Peg Swap (APS) for Ethereum. Please note that this solution is already audited by 3rd party. deputy process written in GoLang that handles swap activities Any developer is welcome to test the solutions in testnet and then use them in mainnet. via GSYS.com. GSYS ,the largest cryptocurrency exchange, has issued a number of crypto-pegged tokens on Genesys Chain (BEP2 token format): BEP2 Bitcoin , BEP2 BCH , BEP2 XRP , BEP2 LTC . Pegged tokens such as BEP2 Bitcoin , are 100% backed by the native coin in reserve . The reserve addresses are published for anyone to audit. Read this blog to learn about the reserved address. Users are free to convert between native and BEP2 Bitcoin via deposit/withdrawal. This has a higher degree of ease-of-use for most traders. More swap channels will be provided on partner wallets soon. Atomic swap and this centralized approach are not exclusive to other decentralized approaches, which can also be implemented in parallel. There are many cross-chain solutions being developed and we are very interested in them. Please do NOT try to transfer anything on existing network to Genesys Chain testnet, you may experience loss by doing so, because testnet doesn't run with real coins.","title":"How can I transfer tokens, such as Bitcoin, from other block chains onto Genesys Chain?"},{"location":"faq/faq.html#how-is-a-trading-pair-created-on-gsys-dex","text":"The design philosophy of GSYS DEX adheres to the idea that the most efficient and low cost way to perform trading and price-discovery is still to use single order book. This single order book is managed and replicated across all full nodes with the same, deterministic matching logic. Simply allowing trading between two assets seems easy enough, however it is expensive for not only the network but also its users in long term (and liquidity costs can be much larger). In order to efficiently use the network, Genesys Chain only list assets against GSYS and other widely accepted market quote assets. After an asset is issued, which costs a small fee, anyone can \"propose\" to all validators to list it against particular quote assets. Validators then vote to accept the proposal. A deposit is taken to prevent network abuse. Once the proposal is accepted, the owner of the base asset can list the trading pair. For more information about this process please check the listing guide .","title":"How is a trading pair created on GSYS DEX?"},{"location":"faq/faq.html#how-would-a-third-party-integrate-with-genesys-chain-and-gsys-dex","text":"A wallet provider may choose to only support the feature set of Genesys Chain, which would just cover wallets, addresses, balances and transfers. To improve their implementation further, they could choose to integrate GSYS DEX which would add trading (order placement and cancellation), historical order and trade views, charts, etc.","title":"How would a third-party integrate with Genesys Chain and GSYS DEX?"},{"location":"faq/nc/cross.html","text":"Cross-chain Communication How much is cross-chain transfer fee? The total cost of transfer from BC to GSYS is composed of 2 parts: Fee for executing bridge transfer-out transaction is 0.004GSYS, pay validators on Genesys Chain Fee for TC-relayers 0.004GSYS. it will cover the fees of calling TokenHub Contract on TC. The total cost of transfer from GSYS to BC is composed of 2 parts: Fee for Oracle-relayers 0.004GSYS, pay for GSYS relayers Call TokenHub Contract: You need to pay GSYS for calling smart-contract on TC, this transaction is metered by gas, which is a global parameter. At the moment, you need to pay about 0.0005GSYS ~ 0.0015GSYS. What's is a GSYS relayer? NCrelayer monitors cross chain packages on Genesys Chain, builds and broadcasts transactions to GSYS to deliver these packages, which is the key of cross chain communication from Genesys Chain to TC. What's is an Oracle relayer? Oracle Relayer watches the state change of Genesys Chain. Once it catches Cross-Chain Communication Events, it will submit to vote for the requests. After Oracle Relayers from \u2154 of the voting power of BC validators vote for the changes, the cross-chain actions will be performed. Only validators of Genesys Chain are eligible to run Oracle relayers. What's an oracle? In blockchain network, an oracle refers to the element that connects smart contracts with data from the outside world. In the network of Genesys Chain, the execution of the transanction wil emit Events, and such events can be packaged and relayed onto BC. In this way, BC will get updates about changes of TC. Which wallet support cross-chain transfer? You need to use MyEtherWallet to call contracts and use Genesys Chain commandline client: eth-cli / eth-cli for complementary commands Please refer to this guide for details How to send cross-chain transfer? You can use Genesys Chain extension wallet or use Trust wallet","title":"Cross-chain Communication"},{"location":"faq/nc/cross.html#cross-chain-communication","text":"","title":"Cross-chain Communication"},{"location":"faq/nc/cross.html#how-much-is-cross-chain-transfer-fee","text":"The total cost of transfer from BC to GSYS is composed of 2 parts: Fee for executing bridge transfer-out transaction is 0.004GSYS, pay validators on Genesys Chain Fee for TC-relayers 0.004GSYS. it will cover the fees of calling TokenHub Contract on TC. The total cost of transfer from GSYS to BC is composed of 2 parts: Fee for Oracle-relayers 0.004GSYS, pay for GSYS relayers Call TokenHub Contract: You need to pay GSYS for calling smart-contract on TC, this transaction is metered by gas, which is a global parameter. At the moment, you need to pay about 0.0005GSYS ~ 0.0015GSYS.","title":"How much is cross-chain transfer fee?"},{"location":"faq/nc/cross.html#whats-is-a-gsys-relayer","text":"NCrelayer monitors cross chain packages on Genesys Chain, builds and broadcasts transactions to GSYS to deliver these packages, which is the key of cross chain communication from Genesys Chain to TC.","title":"What's is a GSYS relayer?"},{"location":"faq/nc/cross.html#whats-is-an-oracle-relayer","text":"Oracle Relayer watches the state change of Genesys Chain. Once it catches Cross-Chain Communication Events, it will submit to vote for the requests. After Oracle Relayers from \u2154 of the voting power of BC validators vote for the changes, the cross-chain actions will be performed. Only validators of Genesys Chain are eligible to run Oracle relayers.","title":"What's is an Oracle relayer?"},{"location":"faq/nc/cross.html#whats-an-oracle","text":"In blockchain network, an oracle refers to the element that connects smart contracts with data from the outside world. In the network of Genesys Chain, the execution of the transanction wil emit Events, and such events can be packaged and relayed onto BC. In this way, BC will get updates about changes of TC.","title":"What's an oracle?"},{"location":"faq/nc/cross.html#which-wallet-support-cross-chain-transfer","text":"You need to use MyEtherWallet to call contracts and use Genesys Chain commandline client: eth-cli / eth-cli for complementary commands Please refer to this guide for details","title":"Which wallet support cross-chain transfer?"},{"location":"faq/nc/cross.html#how-to-send-cross-chain-transfer","text":"You can use Genesys Chain extension wallet or use Trust wallet","title":"How to send cross-chain transfer?"},{"location":"faq/nc/del.html","text":"Genesys Chain Delegator What's the role of a delegator? A delegator can delegate its GSYS to a chosen validator to participate the consensus and earn rewards. Staking GSYS directly contributes to the security of the entire network. How to delegate my GSYS? Please read the guide here You can use: Genesys Chain extension wallet Math Wallet command line tool How to undelegate my GSYS? Delegates and validators themselves may choose to unbond their GSYS for a variety of reasons. It is important to note that these GSYS are subject to what is known as the UnbondingTime , an on-chain parameterized period of time upon which all delegates, including validators, must wait for their GSYS to become fully unbonded. In addition, these GSYS are still subject to be potentially slashed upon commitment of any byzantine behavior. The UnbondingTime ensures a variety of security measures in the network, such as accounting for network synchrony assumptions, providing a lower bound for the length of a long-range attack and solving the \u201cnothing-at-stake\u201d problem. The current UnbondingTime in Genesys Chain mainnet is 7 days . How to redelegate my GSYS? Redelegations between a unique delegator, source validator, and destination validator can only happen once every UnbondingTime How many tokens are required to stake GSYS? The minimum delegated amount is 1GSYS . How to claim my rewards? You can read about the details here When can I receive my staking rewards? Since validatorset info is updated every day UTC 00:00, to make some room for the error handling, we distribute the fees of day N-1 in the next breathe block (day N+1). Thus, after you sent delegate transaction, you will receive your first staking rewards at the second UTC 00:00. Afterwards, you will receive your rewards everyday at UTC 00:00. When can I receive my undelegated GSYS? Since Unbonding Period is 7 days. Thus, after you sent undelegate transaction, your staked GSYS will not receive any rewards since the next UTC 00:00. After 7 days start from the next UTC 00:00, you will receive your GSYS . What's the potential loss for delegators? The only risk for delegators is the loss of rewards when their staked validator is slashed. Their staked GSYS will not be impacted. Can a validator run away with their delegators' GSYS? By delegating to a validator, a user delegates voting power. This does not mean that the validator has custody of their delegators' GSYS. By no means can a validator run away with its delegator's funds.","title":"Genesys Chain Delegator"},{"location":"faq/nc/del.html#genesys-chain-delegator","text":"","title":"Genesys Chain Delegator"},{"location":"faq/nc/del.html#whats-the-role-of-a-delegator","text":"A delegator can delegate its GSYS to a chosen validator to participate the consensus and earn rewards. Staking GSYS directly contributes to the security of the entire network.","title":"What's the role of a delegator?"},{"location":"faq/nc/del.html#how-to-delegate-my-gsys","text":"Please read the guide here You can use: Genesys Chain extension wallet Math Wallet command line tool","title":"How to delegate my GSYS?"},{"location":"faq/nc/del.html#how-to-undelegate-my-gsys","text":"Delegates and validators themselves may choose to unbond their GSYS for a variety of reasons. It is important to note that these GSYS are subject to what is known as the UnbondingTime , an on-chain parameterized period of time upon which all delegates, including validators, must wait for their GSYS to become fully unbonded. In addition, these GSYS are still subject to be potentially slashed upon commitment of any byzantine behavior. The UnbondingTime ensures a variety of security measures in the network, such as accounting for network synchrony assumptions, providing a lower bound for the length of a long-range attack and solving the \u201cnothing-at-stake\u201d problem. The current UnbondingTime in Genesys Chain mainnet is 7 days .","title":"How to undelegate my GSYS?"},{"location":"faq/nc/del.html#how-to-redelegate-my-gsys","text":"Redelegations between a unique delegator, source validator, and destination validator can only happen once every UnbondingTime","title":"How to redelegate my GSYS?"},{"location":"faq/nc/del.html#how-many-tokens-are-required-to-stake-gsys","text":"The minimum delegated amount is 1GSYS .","title":"How many tokens are required to stake GSYS?"},{"location":"faq/nc/del.html#how-to-claim-my-rewards","text":"You can read about the details here","title":"How to claim my rewards?"},{"location":"faq/nc/del.html#when-can-i-receive-my-staking-rewards","text":"Since validatorset info is updated every day UTC 00:00, to make some room for the error handling, we distribute the fees of day N-1 in the next breathe block (day N+1). Thus, after you sent delegate transaction, you will receive your first staking rewards at the second UTC 00:00. Afterwards, you will receive your rewards everyday at UTC 00:00.","title":"When can I receive my staking rewards?"},{"location":"faq/nc/del.html#when-can-i-receive-my-undelegated-gsys","text":"Since Unbonding Period is 7 days. Thus, after you sent undelegate transaction, your staked GSYS will not receive any rewards since the next UTC 00:00. After 7 days start from the next UTC 00:00, you will receive your GSYS .","title":"When can I receive my undelegated GSYS?"},{"location":"faq/nc/del.html#whats-the-potential-loss-for-delegators","text":"The only risk for delegators is the loss of rewards when their staked validator is slashed. Their staked GSYS will not be impacted.","title":"What's the potential loss for delegators?"},{"location":"faq/nc/del.html#can-a-validator-run-away-with-their-delegators-gsys","text":"By delegating to a validator, a user delegates voting power. This does not mean that the validator has custody of their delegators' GSYS. By no means can a validator run away with its delegator's funds.","title":"Can a validator run away with their delegators' GSYS?"},{"location":"faq/nc/eco.html","text":"Genesys Chain Ecosystem How is Genesys Chain Ecosystem? https://github.com/githubusername/githubrepo How to Send and Receive GSYS on Smart Chain? GSYS.com can withdraw GSYS to TC. If you don't have an existing address of Genesys Chain, please use these wallets to create one. On your GSYS account, open your GSYS wallet then tap on Withdraw. Select BLUE20 as the Network. Indicate the amount and paste your GSYS address. Complete the steps to withdraw Wait for the exchange to process your request. Once it is confirmed, you will immediately receive GSYS to your Smart Chain address.","title":"Ecosystem"},{"location":"faq/nc/eco.html#genesys-chain-ecosystem","text":"","title":"Genesys Chain Ecosystem"},{"location":"faq/nc/eco.html#how-is-genesys-chain-ecosystem","text":"https://github.com/githubusername/githubrepo","title":"How is Genesys Chain Ecosystem?"},{"location":"faq/nc/eco.html#how-to-send-and-receive-gsys-on-smart-chain","text":"GSYS.com can withdraw GSYS to TC. If you don't have an existing address of Genesys Chain, please use these wallets to create one. On your GSYS account, open your GSYS wallet then tap on Withdraw. Select BLUE20 as the Network. Indicate the amount and paste your GSYS address. Complete the steps to withdraw Wait for the exchange to process your request. Once it is confirmed, you will immediately receive GSYS to your Smart Chain address.","title":"How to Send and Receive GSYS on Smart Chain?"},{"location":"faq/nc/general.html","text":"Genesys Chain Information Where will the published whitepaper be found? https://genesys.network/whitepaper.pdf and also https://github.com/githubusername/githubrepo/whitepaper , where feedback is more than welcome. Where can I take a look at Genesys Chain code? Is there a GitHub repository? The codebase of GSYS is open-sourced here: https://github.com/githubusername/githubrepo Where can I find some support? Technical talk and support running our software: Telegram https://t.me/ Bugs or technical contributions: GitHub Which are Genesys Chain's official channels for communication and information? GSYS DEX announcements: https://t.me/genesysnews Twitter: https://twitter.com/ Wallet support for Genesys Chain MetaMask Ledger How to recover if you choose the wrong network type? Please read this guide","title":"Info"},{"location":"faq/nc/general.html#genesys-chain-information","text":"","title":"Genesys Chain  Information"},{"location":"faq/nc/general.html#where-will-the-published-whitepaper-be-found","text":"https://genesys.network/whitepaper.pdf and also https://github.com/githubusername/githubrepo/whitepaper , where feedback is more than welcome.","title":"Where will the published whitepaper be found?"},{"location":"faq/nc/general.html#where-can-i-take-a-look-at-genesys-chain-code-is-there-a-github-repository","text":"The codebase of GSYS is open-sourced here: https://github.com/githubusername/githubrepo","title":"Where can I take a look at Genesys Chain code? Is there a GitHub repository?"},{"location":"faq/nc/general.html#where-can-i-find-some-support","text":"Technical talk and support running our software: Telegram https://t.me/ Bugs or technical contributions: GitHub","title":"Where can I find some support?"},{"location":"faq/nc/general.html#which-are-genesys-chains-official-channels-for-communication-and-information","text":"GSYS DEX announcements: https://t.me/genesysnews Twitter: https://twitter.com/","title":"Which are Genesys Chain's official channels for communication and information?"},{"location":"faq/nc/general.html#wallet-support-for-genesys-chain","text":"MetaMask Ledger","title":"Wallet support for Genesys Chain"},{"location":"faq/nc/general.html#how-to-recover-if-you-choose-the-wrong-network-type","text":"Please read this guide","title":"How to recover if you choose the wrong network type?"},{"location":"faq/nc/nc.html","text":"Genesys Chain What is Genesys Chain? Genesys Chain brings EVM-compatible programmability and native cross-chain communication with Genesys Chain using an innovative consensus of Proof of Authority(PoA) Why is Genesys Chain designed as a separate chain from Genesys Chain? The execution of a Smart Contract may slow down the exchange function and add non-deterministic factors to trading. Even if that compromise could be tolerated, it might be a straightforward idea to introduce a new Virtual Machine specification based on Tendermint, based on the current underlying consensus protocol and major RPC implementation of Genesys Chain. But all these will increase the learning requirements for all existing dApp communities, and will not be very welcomed. How does Genesys Chain work? What is the architecture and consensus used? Genesys Chain relies on a system with Proof of Authority (PoA) consensus that can support short block time and lower fees. There will be fewer validators on Genesys Chain testnet. Can you tell more about Proof of Staked Authority(PoSA)? What is it? PoSA is a combination of PoA and PoS. Blocks are produced by a limited set of validators, they are elected in and out based on a staking based governance. Validators take turns to produce blocks in a PoA manner What are the benefits for developers to build on Genesys Chain? EVM-compatible: Genesys Chain supports all the existing Ethereum tooling Fast block time, cheaper cost Native cross-chain trasfer & communication: GSYS DEX remains a liquid venue of exchange of assets on Genesys Chain and Genesys Chain\" What are the benefits for developers to build on Genesys Chain? Genesys Chain opens the gate for users to take advantage of the fast transferring and trading What make Genesys Chain different? Key Innovations: Proof-of-authority Consensus Native Cross-Chain Communication Expand the use cases of GSYS token Genesys Chain is EVM-compatible. What does that mean? EVM means Ethereum Virtual Machine. Any smart-contract written to run in EVM can be easily ported to Genesys Chain. Can developers make hybrid Dapps using both Genesys Chain and Genesys Chain in one single Dapp? Yes, with the help of native cross-chain functions","title":"GSYS Chain"},{"location":"faq/nc/nc.html#genesys-chain","text":"","title":"Genesys Chain"},{"location":"faq/nc/nc.html#what-is-genesys-chain","text":"Genesys Chain brings EVM-compatible programmability and native cross-chain communication with Genesys Chain using an innovative consensus of Proof of Authority(PoA)","title":"What is Genesys Chain?"},{"location":"faq/nc/nc.html#why-is-genesys-chain-designed-as-a-separate-chain-from-genesys-chain","text":"The execution of a Smart Contract may slow down the exchange function and add non-deterministic factors to trading. Even if that compromise could be tolerated, it might be a straightforward idea to introduce a new Virtual Machine specification based on Tendermint, based on the current underlying consensus protocol and major RPC implementation of Genesys Chain. But all these will increase the learning requirements for all existing dApp communities, and will not be very welcomed.","title":"Why is Genesys Chain designed as a separate chain from Genesys Chain?"},{"location":"faq/nc/nc.html#how-does-genesys-chain-work-what-is-the-architecture-and-consensus-used","text":"Genesys Chain relies on a system with Proof of Authority (PoA) consensus that can support short block time and lower fees. There will be fewer validators on Genesys Chain testnet.","title":"How does Genesys Chain work? What is the architecture and consensus used?"},{"location":"faq/nc/nc.html#can-you-tell-more-about-proof-of-staked-authorityposa-what-is-it","text":"PoSA is a combination of PoA and PoS. Blocks are produced by a limited set of validators, they are elected in and out based on a staking based governance. Validators take turns to produce blocks in a PoA manner","title":"Can you tell more about Proof of Staked Authority(PoSA)? What is it?"},{"location":"faq/nc/nc.html#what-are-the-benefits-for-developers-to-build-on-genesys-chain","text":"EVM-compatible: Genesys Chain supports all the existing Ethereum tooling Fast block time, cheaper cost Native cross-chain trasfer & communication: GSYS DEX remains a liquid venue of exchange of assets on Genesys Chain and Genesys Chain\"","title":"What are the benefits for developers to build on Genesys Chain?"},{"location":"faq/nc/nc.html#what-are-the-benefits-for-developers-to-build-on-genesys-chain_1","text":"Genesys Chain opens the gate for users to take advantage of the fast transferring and trading","title":"What are the benefits for developers to build on Genesys Chain?"},{"location":"faq/nc/nc.html#what-make-genesys-chain-different","text":"Key Innovations: Proof-of-authority Consensus Native Cross-Chain Communication Expand the use cases of GSYS token","title":"What make Genesys Chain different?"},{"location":"faq/nc/nc.html#genesys-chain-is-evm-compatible-what-does-that-mean","text":"EVM means Ethereum Virtual Machine. Any smart-contract written to run in EVM can be easily ported to Genesys Chain.","title":"Genesys Chain is EVM-compatible. What does that mean?"},{"location":"faq/nc/nc.html#can-developers-make-hybrid-dapps-using-both-genesys-chain-and-genesys-chain-in-one-single-dapp","text":"Yes, with the help of native cross-chain functions","title":"Can developers make hybrid Dapps using both Genesys Chain and Genesys Chain in one single Dapp?"},{"location":"faq/nc/network20.html","text":"GSYS Evolution Proposal What is BLUE20? A token protocol on GSYS which is compatible ERC20 . It extends ERC20 and contains more interfaces, such as getOwner and decimals .","title":"GSYS Evolution Proposal"},{"location":"faq/nc/network20.html#gsys-evolution-proposal","text":"","title":"GSYS Evolution Proposal"},{"location":"faq/nc/network20.html#what-is-blue20","text":"A token protocol on GSYS which is compatible ERC20 . It extends ERC20 and contains more interfaces, such as getOwner and decimals .","title":"What is BLUE20?"},{"location":"faq/nc/token.html","text":"Tokens in Genesys Chain and Genesys Chain What role does GSYS play in securing Genesys Chain? GSYS is the token used to prevent nothing-at-stake problem. What are tokens on Genesys Chain? GSYS is the native token for TC, and pegged tokens on GSYS is called BLUE20. How to issue BLUE20 tokens? Please follow the guide here Which wallets can I use to store GSYS? You can see the list here","title":"Intro"},{"location":"faq/nc/token.html#tokens-in-genesys-chain-and-genesys-chain","text":"","title":"Tokens in Genesys Chain and Genesys Chain"},{"location":"faq/nc/token.html#what-role-does-gsys-play-in-securing-genesys-chain","text":"GSYS is the token used to prevent nothing-at-stake problem.","title":"What role does GSYS play in securing Genesys Chain?"},{"location":"faq/nc/token.html#what-are-tokens-on-genesys-chain","text":"GSYS is the native token for TC, and pegged tokens on GSYS is called BLUE20.","title":"What are tokens on Genesys Chain?"},{"location":"faq/nc/token.html#how-to-issue-blue20-tokens","text":"Please follow the guide here","title":"How to issue BLUE20 tokens?"},{"location":"faq/nc/token.html#which-wallets-can-i-use-to-store-gsys","text":"You can see the list here","title":"Which wallets can I use to store GSYS?"},{"location":"faq/nc/val.html","text":"Genesys Chain Validator How does a validator node work? It powers the blockchain network by processing transactions and signing blocks. What are the incentives to run a validator node? Validators and delegators will earn rewards from transaction fees: dApp usages What's on-chain governance proposal? The proposal will decide: slash amount, cross-chain transfer fees How to join testnet as a validator? Choose your own server/PC Install software: Create a wallet and get some GSYS Run your fullnode and keep it synced Stake your GSYS on TC How to join mainnet as a validator? Choose your own server/PC Install software: Create a wallet and get some GSYS Run your fullnode and keep it synced Stake your GSYS on TC What are hardware requirements of running a validator node? Processing transactions is mostly CPU bound. Therefore we recommend running CPU optimized servers. Directly facing internet (public IP, no NAT) 8 cores CPU 16GB of RAM 500 SSD storage\" How many GSYS are required to create a validator? Validators can self-bond, meaning they can delegate GSYS to themselves, and they can also receive delegations from any other GSYS holders. These bonded GSYS acts as collateral and cause each delegate, including validators, to have \u201cskin in the game\u201d so to speak. If any equivocation or byzantine behavior by a validator were to be committed, the validator and its delegates would be slashed a predefined amount of bonded stake. What's the potential loss for validators? Validators can suffer from \u201cSlashing\u201d, a punishment for their bad behaviors, such as double sign and/or instability. Such loss will not be shared by their delegators. Slashing is a punitive function that is triggered by a validator \u2019s bad actions. Getting slashed is losing self delegation of a validator. Validators will be slashed for the actions below: Going offline or unable to communicate with the network. Double signing. If a validator node tries to split the network by signing two different blocks and broadcasting them, it will be removed from validator set definitely. Does an inactive validator receive any rewards? No, they will not. Can I receive my staking rewards if my chosen validator is inactive? No, you cannot. When can I receive my unstaked GSYS? After you sent undelegate transaction, you have to wait 7 days. This period starts at UTC 00:00 next day What is 'self-delegation'? How can I increase my 'self-delegation'? Self-delegation is delegation from a validator to themselves. This amount can be increases by sending a delegate transaction from your validator's operator address.","title":"Genesys Chain Validator"},{"location":"faq/nc/val.html#genesys-chain-validator","text":"","title":"Genesys Chain Validator"},{"location":"faq/nc/val.html#how-does-a-validator-node-work","text":"It powers the blockchain network by processing transactions and signing blocks.","title":"How does a validator node work?"},{"location":"faq/nc/val.html#what-are-the-incentives-to-run-a-validator-node","text":"Validators and delegators will earn rewards from transaction fees: dApp usages","title":"What are the incentives to run a validator node?"},{"location":"faq/nc/val.html#whats-on-chain-governance-proposal","text":"The proposal will decide: slash amount, cross-chain transfer fees","title":"What's on-chain governance proposal?"},{"location":"faq/nc/val.html#how-to-join-testnet-as-a-validator","text":"Choose your own server/PC Install software: Create a wallet and get some GSYS Run your fullnode and keep it synced Stake your GSYS on TC","title":"How to join testnet as a validator?"},{"location":"faq/nc/val.html#how-to-join-mainnet-as-a-validator","text":"Choose your own server/PC Install software: Create a wallet and get some GSYS Run your fullnode and keep it synced Stake your GSYS on TC","title":"How to join mainnet as a validator?"},{"location":"faq/nc/val.html#what-are-hardware-requirements-of-running-a-validator-node","text":"Processing transactions is mostly CPU bound. Therefore we recommend running CPU optimized servers. Directly facing internet (public IP, no NAT) 8 cores CPU 16GB of RAM 500 SSD storage\"","title":"What are hardware requirements of running a validator node?"},{"location":"faq/nc/val.html#how-many-gsys-are-required-to-create-a-validator","text":"Validators can self-bond, meaning they can delegate GSYS to themselves, and they can also receive delegations from any other GSYS holders. These bonded GSYS acts as collateral and cause each delegate, including validators, to have \u201cskin in the game\u201d so to speak. If any equivocation or byzantine behavior by a validator were to be committed, the validator and its delegates would be slashed a predefined amount of bonded stake.","title":"How many GSYS are required to create a validator?"},{"location":"faq/nc/val.html#whats-the-potential-loss-for-validators","text":"Validators can suffer from \u201cSlashing\u201d, a punishment for their bad behaviors, such as double sign and/or instability. Such loss will not be shared by their delegators. Slashing is a punitive function that is triggered by a validator \u2019s bad actions. Getting slashed is losing self delegation of a validator. Validators will be slashed for the actions below: Going offline or unable to communicate with the network. Double signing. If a validator node tries to split the network by signing two different blocks and broadcasting them, it will be removed from validator set definitely.","title":"What's the potential loss for validators?"},{"location":"faq/nc/val.html#does-an-inactive-validator-receive-any-rewards","text":"No, they will not.","title":"Does an inactive validator receive any rewards?"},{"location":"faq/nc/val.html#can-i-receive-my-staking-rewards-if-my-chosen-validator-is-inactive","text":"No, you cannot.","title":"Can I receive my staking rewards if my chosen validator is inactive?"},{"location":"faq/nc/val.html#when-can-i-receive-my-unstaked-gsys","text":"After you sent undelegate transaction, you have to wait 7 days. This period starts at UTC 00:00 next day","title":"When can I receive my unstaked GSYS?"},{"location":"faq/nc/val.html#what-is-self-delegation-how-can-i-increase-my-self-delegation","text":"Self-delegation is delegation from a validator to themselves. This amount can be increases by sending a delegate transaction from your validator's operator address.","title":"What is 'self-delegation'? How can I increase my 'self-delegation'?"},{"location":"faq/nc/withdraw-cn.html","text":"\u5982\u4f55\u627e\u56de\u60a8\u63d0\u73b0BLUE20 \u800c\u8bef\u9009ERC20 \u7684Token\uff1f \u80cc\u666f \u5728\u63d0\u5e01\u7684\u8fc7\u7a0b\u4e2d\uff0c\u56e0\u4e3aERC20 \u548c BLUE20\u7684\u5730\u5740\u89c4\u5219\u662f\u4e00\u6837\u7684\uff0c\u7528\u6237\u5f88\u53ef\u80fd\u5145\u503c \u4ee5\u592a\u574a\u7684ERC20 \u4e0a\uff0c\u5982\u679c\u60a8\u8bef\u9009\u4e86ERC20\uff0c\u5e76\u4e14\u5df2\u7ecf\u5728metamask\u94b1\u5305\u4e2d\u5bfc\u5165\u4e86NC\u4e3b\u7f51\u8d26\u53f7\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u901a\u8fc7\u4e0b\u9762\u7684\u6b65\u9aa4\u628atoken\u627e\u56de\u6765\uff1a \u6b65\u9aa4 \u7f51\u7edc\u7c7b\u578b\u5207\u6362\u4e3a \u592a\u574a\u4e3b\u7f51 \u70b9\u51fb Add Token \u9009\u62e9\u6dfb\u52a0\u60a8\u63d0\u73b0\u65f6\u7684\u5e01\u79cd\uff0c\u5982USDT \u6dfb\u52a0\u540e\uff0c\u63d0\u73b0\u7684\u5e01\u5c31\u5728\u60a8\u8fd9\u4e2a\u8d26\u53f7\u91cc \u91cd\u65b0\u5145\u503c \u4f60\u901a\u8fc7 metamask\u91cd\u65b0\u5145\u503c\u56de\u5e01\u5b89\u4e3b\u7ad9\uff0c\u6ce8\u610f\uff1a\u5145\u503c\u65b9\u5f0f\u662f ERC20","title":"\u5982\u4f55\u627e\u56de\u60a8\u63d0\u73b0BLUE20 \u800c\u8bef\u9009ERC20 \u7684Token\uff1f"},{"location":"faq/nc/withdraw-cn.html#blue20-erc20-token","text":"","title":"\u5982\u4f55\u627e\u56de\u60a8\u63d0\u73b0BLUE20 \u800c\u8bef\u9009ERC20 \u7684Token\uff1f"},{"location":"faq/nc/withdraw-cn.html#_1","text":"\u5728\u63d0\u5e01\u7684\u8fc7\u7a0b\u4e2d\uff0c\u56e0\u4e3aERC20 \u548c BLUE20\u7684\u5730\u5740\u89c4\u5219\u662f\u4e00\u6837\u7684\uff0c\u7528\u6237\u5f88\u53ef\u80fd\u5145\u503c \u4ee5\u592a\u574a\u7684ERC20 \u4e0a\uff0c\u5982\u679c\u60a8\u8bef\u9009\u4e86ERC20\uff0c\u5e76\u4e14\u5df2\u7ecf\u5728metamask\u94b1\u5305\u4e2d\u5bfc\u5165\u4e86NC\u4e3b\u7f51\u8d26\u53f7\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u901a\u8fc7\u4e0b\u9762\u7684\u6b65\u9aa4\u628atoken\u627e\u56de\u6765\uff1a","title":"\u80cc\u666f"},{"location":"faq/nc/withdraw-cn.html#_2","text":"\u7f51\u7edc\u7c7b\u578b\u5207\u6362\u4e3a \u592a\u574a\u4e3b\u7f51 \u70b9\u51fb Add Token \u9009\u62e9\u6dfb\u52a0\u60a8\u63d0\u73b0\u65f6\u7684\u5e01\u79cd\uff0c\u5982USDT \u6dfb\u52a0\u540e\uff0c\u63d0\u73b0\u7684\u5e01\u5c31\u5728\u60a8\u8fd9\u4e2a\u8d26\u53f7\u91cc \u91cd\u65b0\u5145\u503c \u4f60\u901a\u8fc7 metamask\u91cd\u65b0\u5145\u503c\u56de\u5e01\u5b89\u4e3b\u7ad9\uff0c\u6ce8\u610f\uff1a\u5145\u503c\u65b9\u5f0f\u662f ERC20","title":"\u6b65\u9aa4"},{"location":"faq/nc/withdraw-en.html","text":"How to recover if you choose the wrong network type? Background Since Genesys Chain and Ethereum follow the same address generation algorithm. In some cases, users may mistakenly choose the wrong network type when withdrawing tokens to Genesys Chain network. Steps to Recover Metamask Setup Import the account into Metamask using user\u2019s recovery phrase of TC Switch to Ethereum Mainnet Click on \u201cAdd Token\u201d Input your token name, for example Then you can see your balance of this token Then you have to deposit to GSYS.com again. Please note you have to choose the ERC20 type for deposit","title":"How to recover if you choose the wrong network type?"},{"location":"faq/nc/withdraw-en.html#how-to-recover-if-you-choose-the-wrong-network-type","text":"","title":"How to recover if you choose the wrong network type?"},{"location":"faq/nc/withdraw-en.html#background","text":"Since Genesys Chain and Ethereum follow the same address generation algorithm. In some cases, users may mistakenly choose the wrong network type when withdrawing tokens to Genesys Chain network.","title":"Background"},{"location":"faq/nc/withdraw-en.html#steps-to-recover","text":"Metamask Setup Import the account into Metamask using user\u2019s recovery phrase of TC Switch to Ethereum Mainnet Click on \u201cAdd Token\u201d Input your token name, for example Then you can see your balance of this token Then you have to deposit to GSYS.com again. Please note you have to choose the ERC20 type for deposit","title":"Steps to Recover"},{"location":"guides/create-address.html","text":"Create an address Create an Address The first thing you\u2019ll need to do anything on the Genesys Chain is an account. Each account has a public key and a private key. It is created by a user of the blockchain. It also includes account number and sequence number for replay protection. Because the private key must be kept secret, you can generate the private key with the following command: Examples: ``` javascript tab=\"JavaScript\" // generate key entropy const privateKey = crypto.generatePrivateKey(); // get an address const address = crypto.getAddressFromPrivateKey(privateKey); const BnbApiClient = require(\"@shree-chain/javascript-sdk\"); const axios = require(\"axios\"); const bnbClient = new BnbApiClient(api); const httpClient = axios.create({ baseURL: api }); bnbClient.chooseNetwork(\"mainnet\"); // or this can be \"testnet\" bnbClient.setPrivateKey(privKey); bnbClient.initChain(); const address = bnbClient.getClientKeyAddress(); console.log(\"address: \", address); ```Go tab=\"GoLang\" //----- Import packages ------------- import ( sdk \"github.com/shree/go-sdk/client\" \"github.com/shree/go-sdk/keys\" ) //----- Init KeyManager ------------- km, _ := keys.NewKeyManager() //----- Init sdk ------------- client, err := sdk.NewDexClient(\"dex.genesys.network\", types.TestNetwork, km) // api string can be \"https://testnet-dex.genesys.network\" for testnet accn, _ := client.GetAccount(client.GetKeyManager().GetAddr().String()) //----- Print Address fmt.Println(accn) ```python tab=\"Python\" from genesys_chain.wallet import Wallet from genesys_chain.environment import GenesysEnvironment testnet_env = GenesysEnvironment.get_testnet_env(, env=testnet_env) wallet = Wallet.create_random_wallet(env=env) print(wallet.address) ```","title":"Create an address"},{"location":"guides/create-address.html#create-an-address","text":"","title":"Create an address"},{"location":"guides/create-address.html#create-an-address_1","text":"The first thing you\u2019ll need to do anything on the Genesys Chain is an account. Each account has a public key and a private key. It is created by a user of the blockchain. It also includes account number and sequence number for replay protection. Because the private key must be kept secret, you can generate the private key with the following command: Examples: ``` javascript tab=\"JavaScript\" // generate key entropy const privateKey = crypto.generatePrivateKey(); // get an address const address = crypto.getAddressFromPrivateKey(privateKey); const BnbApiClient = require(\"@shree-chain/javascript-sdk\"); const axios = require(\"axios\"); const bnbClient = new BnbApiClient(api); const httpClient = axios.create({ baseURL: api }); bnbClient.chooseNetwork(\"mainnet\"); // or this can be \"testnet\" bnbClient.setPrivateKey(privKey); bnbClient.initChain(); const address = bnbClient.getClientKeyAddress(); console.log(\"address: \", address); ```Go tab=\"GoLang\" //----- Import packages ------------- import ( sdk \"github.com/shree/go-sdk/client\" \"github.com/shree/go-sdk/keys\" ) //----- Init KeyManager ------------- km, _ := keys.NewKeyManager() //----- Init sdk ------------- client, err := sdk.NewDexClient(\"dex.genesys.network\", types.TestNetwork, km) // api string can be \"https://testnet-dex.genesys.network\" for testnet accn, _ := client.GetAccount(client.GetKeyManager().GetAddr().String()) //----- Print Address fmt.Println(accn) ```python tab=\"Python\" from genesys_chain.wallet import Wallet from genesys_chain.environment import GenesysEnvironment testnet_env = GenesysEnvironment.get_testnet_env(, env=testnet_env) wallet = Wallet.create_random_wallet(env=env) print(wallet.address) ```","title":"Create an Address"},{"location":"guides/intro.html","text":"Introduction Intro Genesys Chain is a blockchain developed by GSYS and its community that implements a vision of a decentralized exchange (DEX) for digital assets. At the heart of Genesys Chain is a highly performant matching engine built on distributed consensus that aims to replicate the <1 second trading efficiency of current centralized exchanges. Genesys Chain transactions burns GSYS (the native token of the GSYS ecosystem), according to a fee schedule. Genesys Chain also includes efforts to implement listing assets from other chains , and cryptographic primitives such as threshold signatures . Functionality Genesys Chain has the basic features of most blockchains: Sending and receiving GSYS and digital assets Issuing new digital assets (we have a standard called BEP-2) Mint/burn, freeze/unfreeze, lock/unlock of digital assets It has DEX and trading-specific functionality: Propose exchange listing for trading pairs Creating maker/taker orders for traders Listing assets from other chains using atomic swaps (BEP-3) Genesys Chain also implements new features, such as Threshold Signatures (an alternative to multisig) Smart Contracts sidechain (in-progress) Participate There are different ways to participate in the network, from light nodes to full validators. Genesys Chain follows a philosophy of progressive decentralization. We envision a future where organizations and individuals can run validator nodes, and GSYS can be staked to join governance.","title":"Introduction"},{"location":"guides/intro.html#introduction","text":"","title":"Introduction"},{"location":"guides/intro.html#intro","text":"Genesys Chain is a blockchain developed by GSYS and its community that implements a vision of a decentralized exchange (DEX) for digital assets. At the heart of Genesys Chain is a highly performant matching engine built on distributed consensus that aims to replicate the <1 second trading efficiency of current centralized exchanges. Genesys Chain transactions burns GSYS (the native token of the GSYS ecosystem), according to a fee schedule. Genesys Chain also includes efforts to implement listing assets from other chains , and cryptographic primitives such as threshold signatures .","title":"Intro"},{"location":"guides/intro.html#functionality","text":"Genesys Chain has the basic features of most blockchains: Sending and receiving GSYS and digital assets Issuing new digital assets (we have a standard called BEP-2) Mint/burn, freeze/unfreeze, lock/unlock of digital assets It has DEX and trading-specific functionality: Propose exchange listing for trading pairs Creating maker/taker orders for traders Listing assets from other chains using atomic swaps (BEP-3) Genesys Chain also implements new features, such as Threshold Signatures (an alternative to multisig) Smart Contracts sidechain (in-progress)","title":"Functionality"},{"location":"guides/intro.html#participate","text":"There are different ways to participate in the network, from light nodes to full validators. Genesys Chain follows a philosophy of progressive decentralization. We envision a future where organizations and individuals can run validator nodes, and GSYS can be staked to join governance.","title":"Participate"},{"location":"guides/lightd.html","text":"Light Client Introduction A light client allows clients, such as mobile phones, to receive proofs of the state of the blockchain from any full node. Light clients do not have to trust any full node, since they are able to verify any proof they receive. A light client can provide the same security as a full node with minimal requirements for bandwidth, computing and storage resource. It can also provide modular functionality according to users' configuration. These features allow developers to build secure, efficient, and usable mobile apps, websites, and other applications without deploying or maintaining any full blockchain nodes. Light Client Versus Full Node Light client does not store blocks or states,this way it needs less disk space (50 megabytes will be enough). Light client does not join p2p network and it does not produce any network cost when it is idle. The network overhead depends on how many requests the light client handles concurrently. Light client does not replay state of the chain so that there is not CPU cost when idle. The CPU cost also depends on how many requests the light client handles concurrently. Light client is faster than a full node even if it lagged behind the core network for a few months. It only needs a few seconds to catch up with core network. Install Light Client We have a community-maintained installer script ( install.sh ) that takes care of chain directory setup. This uses the following defaults: Home folder in ~/.bnbchaind Client executables stored in /usr/local/bin (i.e. lightd or bnbchaind ) # One-line install sh <(wget -qO- https://raw.githubusercontent.com/shree-chain/node-binary/master/install.sh) The script will install the lightd binaries. Verify that everything is OK: ./lightd --help This node will run a secure proxy to a shree rpc server. All calls that can be tracked back to a block header by a proof will be verified before passing them back to the caller. Other that that it will present the same interface as a full shree node, just with added trust and running locally. Usage: lite [ flags ] Flags: --cache-size int Specify the memory trust store cache size ( default 10 ) --chain-id string Specify the shree chain ID ( default \"bnbchain\" ) -h, --help help for lite --home-dir string Specify the home directory ( default \".shree-lite\" ) --laddr string Serve the proxy on the given address ( default \"tcp://localhost:27147\" ) --max-open-connections int Maximum number of simultaneous connections ( including WebSocket ) . ( default 900 ) --node string Connect to a shree node at this address ( default \"tcp://localhost:27147\" ) Get Started Start your Light Client with the following command: lightd --chain-id \"{chain-id}\" --node tcp:// { full node addr } :80 > node.log & * chain-id: it should be the network that you want join in * full node addr: it can be your own Full Node or public Witness Node ./lightd --chain-id \"GSYS-Chain-Tigris\" --node tcp://dataseed1.genesys.network:80 > node.log & ./lightd --chain-id \"GSYS-Chain-Ganges\" --node tcp://data-seed-pre-0-s1.genesys.network:80 > node.log & Working with the Light Client Light client has the same RPC interface as Node RPC . The default port of light client is 27147 .","title":"Light Client"},{"location":"guides/lightd.html#light-client","text":"","title":"Light Client"},{"location":"guides/lightd.html#introduction","text":"A light client allows clients, such as mobile phones, to receive proofs of the state of the blockchain from any full node. Light clients do not have to trust any full node, since they are able to verify any proof they receive. A light client can provide the same security as a full node with minimal requirements for bandwidth, computing and storage resource. It can also provide modular functionality according to users' configuration. These features allow developers to build secure, efficient, and usable mobile apps, websites, and other applications without deploying or maintaining any full blockchain nodes.","title":"Introduction"},{"location":"guides/lightd.html#light-client-versus-full-node","text":"Light client does not store blocks or states,this way it needs less disk space (50 megabytes will be enough). Light client does not join p2p network and it does not produce any network cost when it is idle. The network overhead depends on how many requests the light client handles concurrently. Light client does not replay state of the chain so that there is not CPU cost when idle. The CPU cost also depends on how many requests the light client handles concurrently. Light client is faster than a full node even if it lagged behind the core network for a few months. It only needs a few seconds to catch up with core network.","title":"Light Client Versus Full Node"},{"location":"guides/lightd.html#install-light-client","text":"We have a community-maintained installer script ( install.sh ) that takes care of chain directory setup. This uses the following defaults: Home folder in ~/.bnbchaind Client executables stored in /usr/local/bin (i.e. lightd or bnbchaind ) # One-line install sh <(wget -qO- https://raw.githubusercontent.com/shree-chain/node-binary/master/install.sh) The script will install the lightd binaries. Verify that everything is OK: ./lightd --help This node will run a secure proxy to a shree rpc server. All calls that can be tracked back to a block header by a proof will be verified before passing them back to the caller. Other that that it will present the same interface as a full shree node, just with added trust and running locally. Usage: lite [ flags ] Flags: --cache-size int Specify the memory trust store cache size ( default 10 ) --chain-id string Specify the shree chain ID ( default \"bnbchain\" ) -h, --help help for lite --home-dir string Specify the home directory ( default \".shree-lite\" ) --laddr string Serve the proxy on the given address ( default \"tcp://localhost:27147\" ) --max-open-connections int Maximum number of simultaneous connections ( including WebSocket ) . ( default 900 ) --node string Connect to a shree node at this address ( default \"tcp://localhost:27147\" )","title":"Install Light Client"},{"location":"guides/lightd.html#get-started","text":"Start your Light Client with the following command: lightd --chain-id \"{chain-id}\" --node tcp:// { full node addr } :80 > node.log & * chain-id: it should be the network that you want join in * full node addr: it can be your own Full Node or public Witness Node ./lightd --chain-id \"GSYS-Chain-Tigris\" --node tcp://dataseed1.genesys.network:80 > node.log & ./lightd --chain-id \"GSYS-Chain-Ganges\" --node tcp://data-seed-pre-0-s1.genesys.network:80 > node.log &","title":"Get Started"},{"location":"guides/lightd.html#working-with-the-light-client","text":"Light client has the same RPC interface as Node RPC . The default port of light client is 27147 .","title":"Working with the Light Client"},{"location":"guides/testnet.html","text":"Testnet The testnet is a test environment for Genesys Chain network, run by the Genesys Chain development community, which is open to developers. The validators on the testnet are from development team. You can connect a node to the testnet by downloading the node binary to use this configuration . There is also a web wallet that can directly interact with the DEX. testnet. What is the testnet good for? Create your test address and get your testnet funds. Develop applications and try tutorials on Genesys Chain without the potential to lose your own assets. Test your applications against new versions of Genesys Chain. Analyze blockchain data on a smaller, non-trivial data set compared to the public network. How to get Testnet Fund Note: The previous Genesys Chain Testnet Faucet is retired at 2020/08/11 at 1:00 PM (UTC). The testnet faucet has migrated to this page: https://testnet-explorer.genesys.network/faucet-smart Steps to claim testnet GSYS: Create a new Wallet of Genesys Chain testnet with MetaMask or MathWallet Get Testnet Fund: https://testnet-explorer.genesys.network/faucet-smart To request funds, please make a tweet with your Genesys Chain address pasted into the contents. Then, copy-paste the tweets URL! GSYS will be sent to your GSYS wallet right away. Transfer From Genesys Chain to Genesys Chain You can use GSYS Extension Wallet for cross-chain transfer. If you wish to test Genesys Chain features, you could transfer GSYS cross-chain with MathWallet dApp: https://docs.genesys.network/smart-chain/wallet/math.html#transfer-bnb-from-nc-to-bc","title":"Testnet"},{"location":"guides/testnet.html#testnet","text":"The testnet is a test environment for Genesys Chain network, run by the Genesys Chain development community, which is open to developers. The validators on the testnet are from development team. You can connect a node to the testnet by downloading the node binary to use this configuration . There is also a web wallet that can directly interact with the DEX. testnet.","title":"Testnet"},{"location":"guides/testnet.html#what-is-the-testnet-good-for","text":"Create your test address and get your testnet funds. Develop applications and try tutorials on Genesys Chain without the potential to lose your own assets. Test your applications against new versions of Genesys Chain. Analyze blockchain data on a smaller, non-trivial data set compared to the public network.","title":"What is the testnet good for?"},{"location":"guides/testnet.html#how-to-get-testnet-fund","text":"Note: The previous Genesys Chain Testnet Faucet is retired at 2020/08/11 at 1:00 PM (UTC). The testnet faucet has migrated to this page: https://testnet-explorer.genesys.network/faucet-smart Steps to claim testnet GSYS: Create a new Wallet of Genesys Chain testnet with MetaMask or MathWallet Get Testnet Fund: https://testnet-explorer.genesys.network/faucet-smart To request funds, please make a tweet with your Genesys Chain address pasted into the contents. Then, copy-paste the tweets URL! GSYS will be sent to your GSYS wallet right away. Transfer From Genesys Chain to Genesys Chain You can use GSYS Extension Wallet for cross-chain transfer. If you wish to test Genesys Chain features, you could transfer GSYS cross-chain with MathWallet dApp: https://docs.genesys.network/smart-chain/wallet/math.html#transfer-bnb-from-nc-to-bc","title":"How to get Testnet Fund"},{"location":"guides/trading-interface.html","text":"GSYS DEX Trading Interface GSYS DEX trading page is designed to provide a user-friendly trading interface to everyone. To get started, go to the trading page first at https://www.genesys.network/trade. The trading page is composed of the following part: Tradig Pairs info TradingView Chart Trade history and orderbook Your Trading Activities Order Form Trading Video on Youtube Trading Pairs Info At the left-right part of the trading page, there is the section of \u201cTrading Pairs\u201d. The trading pairs are categorized into four markets: - GSYS - BTC - ALT - FIATS Click on tabs to switch between markets. Start Icon will show your favorite trading pairs. You can click at the star icon to add this trading pair to your list. Trading pairs can be ordered by two \u201cVolume\u201d or \u201cPrice Change\u201d. The list is in descending order by default. You can also change to ascending by clicking the header. Trading View and Market Depth At the center of the trading page, there is the TradingView chart. The TradingView displays information about your selected trading pair. The chart allows you to display indicators such as the RSI, moving average, Bollinger Bands and many more. The chart also allows you to draw on the chart using the tools within the TradingView charts. More information on how to use TradingView charts can be found on the TradingView Wiki. Click on Depth button to switch to Depth View. Market depth is the market's ability to sustain relatively large market orders without impacting the price of the security. Market depth considers the overall level and breadth of open orders and usually refers to trading within individual trading pairs. The number of levels can be zoomed in and out. The key indicator of market depth is the spread. The spread is the gap between the bid and the ask prices. If the bid price for a stock is $19 and the ask price for the same stock is $20, then the spread for the stock in question is 1 divided by the lowest ask price) to yield a bid-ask spread of 5% ( 1 divided by the lowest ask price) to yield a bid-ask spread of 5% ( 1 / $20 x 100). Market with thinner spread is much liquid than others. Trade history and Orderbook The order book shows a list of open orders on the exchange. The top half is the asking side of the order book, where you will see sell orders. The bottom half is the bidding side of the order book where you can see the buy orders for that trading pair. You can switch to different display mode: buy order only or sell order only to see more levels. You can see the trading history from all users that have occurred on the trading pair that you currently have selected. The color of trades indicates taker/maker information. * Green: buyer is taker * Red: Seller is taker Your Trading Activities In the bottom left-hand side of the interface, you can locate Open Orders, Order History, Trade History, and Balances. - Open Orders: This section shows which orders are not filled in their entirety and are still currently open. You can view all of the orders on the blockchain by looking at their TxHash. - Order History: This section shows the orders you have placed, filled, unfilled or canceled. You can view all of the orders on the blockchain by looking at their TxHash. - Trade History: This section shows your executed trades on the exchange. - Balances: This section displays the current balance of your Genesys Chain Wallet. Order Form GSYS DEX currently only supports Limit orders. The Limit order section allows you to define the bid/ask price and the quantity you wish to trade. Please note that all order\u2019s parameters\u2019 constrains: * Price: Order price must be changed by multiple of tick size. Tick size stands for the smallest unit on price change * Quantity: Order quantity must be multiple of lot size. Lot size stands for the smallest quantity change * Timeinforce: It is Good Till Expire (GTE). The order would stay effective until expire time. The order may expire in the UTC midnight after more than 259, 200 blocks, which is 72 hours in terms of blocking time.","title":"GSYS DEX Trading Interface"},{"location":"guides/trading-interface.html#gsys-dex-trading-interface","text":"GSYS DEX trading page is designed to provide a user-friendly trading interface to everyone. To get started, go to the trading page first at https://www.genesys.network/trade. The trading page is composed of the following part: Tradig Pairs info TradingView Chart Trade history and orderbook Your Trading Activities Order Form Trading Video on Youtube","title":"GSYS DEX Trading Interface"},{"location":"guides/trading-interface.html#trading-pairs-info","text":"At the left-right part of the trading page, there is the section of \u201cTrading Pairs\u201d. The trading pairs are categorized into four markets: - GSYS - BTC - ALT - FIATS Click on tabs to switch between markets. Start Icon will show your favorite trading pairs. You can click at the star icon to add this trading pair to your list. Trading pairs can be ordered by two \u201cVolume\u201d or \u201cPrice Change\u201d. The list is in descending order by default. You can also change to ascending by clicking the header.","title":"Trading Pairs Info"},{"location":"guides/trading-interface.html#trading-view-and-market-depth","text":"At the center of the trading page, there is the TradingView chart. The TradingView displays information about your selected trading pair. The chart allows you to display indicators such as the RSI, moving average, Bollinger Bands and many more. The chart also allows you to draw on the chart using the tools within the TradingView charts. More information on how to use TradingView charts can be found on the TradingView Wiki. Click on Depth button to switch to Depth View. Market depth is the market's ability to sustain relatively large market orders without impacting the price of the security. Market depth considers the overall level and breadth of open orders and usually refers to trading within individual trading pairs. The number of levels can be zoomed in and out. The key indicator of market depth is the spread. The spread is the gap between the bid and the ask prices. If the bid price for a stock is $19 and the ask price for the same stock is $20, then the spread for the stock in question is 1 divided by the lowest ask price) to yield a bid-ask spread of 5% ( 1 divided by the lowest ask price) to yield a bid-ask spread of 5% ( 1 / $20 x 100). Market with thinner spread is much liquid than others.","title":"Trading View and Market Depth"},{"location":"guides/trading-interface.html#trade-history-and-orderbook","text":"The order book shows a list of open orders on the exchange. The top half is the asking side of the order book, where you will see sell orders. The bottom half is the bidding side of the order book where you can see the buy orders for that trading pair. You can switch to different display mode: buy order only or sell order only to see more levels. You can see the trading history from all users that have occurred on the trading pair that you currently have selected. The color of trades indicates taker/maker information. * Green: buyer is taker * Red: Seller is taker","title":"Trade history and Orderbook"},{"location":"guides/trading-interface.html#your-trading-activities","text":"In the bottom left-hand side of the interface, you can locate Open Orders, Order History, Trade History, and Balances. - Open Orders: This section shows which orders are not filled in their entirety and are still currently open. You can view all of the orders on the blockchain by looking at their TxHash. - Order History: This section shows the orders you have placed, filled, unfilled or canceled. You can view all of the orders on the blockchain by looking at their TxHash. - Trade History: This section shows your executed trades on the exchange. - Balances: This section displays the current balance of your Genesys Chain Wallet.","title":"Your Trading Activities"},{"location":"guides/trading-interface.html#order-form","text":"GSYS DEX currently only supports Limit orders. The Limit order section allows you to define the bid/ask price and the quantity you wish to trade. Please note that all order\u2019s parameters\u2019 constrains: * Price: Order price must be changed by multiple of tick size. Tick size stands for the smallest unit on price change * Quantity: Order quantity must be multiple of lot size. Lot size stands for the smallest quantity change * Timeinforce: It is Good Till Expire (GTE). The order would stay effective until expire time. The order may expire in the UTC midnight after more than 259, 200 blocks, which is 72 hours in terms of blocking time.","title":"Order Form"},{"location":"guides/concepts/BEP8.html","text":"Introduction Currently, the cost to get a BEP2 token listed on GSYS DEX is about 1500GSYS, which is a big barrier to many small, promising projects. As explained in BEP8 ,the idea of BEP8 Tokens is raised to accommodate the small or micro projects, intellectual properties, and other small token economies to build a more comprehensive venue for token trading. Based on the limitation usage of the network, the cost of issuing and listing of such BEP8 tokens are minimized to a different magnitude. Besides, any BEP8 token issuer can choose to directly list against GSYS and BUSD without the voting process of validators. Stablecoin pairs of BEP8 will provide a UX advantage and make any two BEP82 tokens exchangeable. Similar to SME board in the traditional stock markets, BEP8 tokens markets will increase the liquidity of utility tokens of startups or Intellectual Property (IP) tokens by removing the capital requirements for listing. One good example is the open-source license model. A software developer can issue a BEP8 token and link his work to it. This token will be used to cover licensing fees for his work in the future. Token Management Issue Issue is a transaction used to create a new asset. Anyone can issue a new token with fee paid. After issuing, the token would appear in the issuer's account as free balance. An issuance transaction contains: Symbol: The length of the string for representing this asset is between 3 and 8 alphanumeric characters and is case insensitive. The symbol will have a suffix autogenerated by the algorithm: the first 3 bytes of the issue transaction hash, plus letter \u201cM\u201d. TokenURI: Optional field. A distinct Uniform Resource Identifier (URI) for the token. The URI may point to a JSON file that conforms to the \"Mini-BEP2 Metadata JSON Schema\". The schema is also optional. TokenType: 1 for tiny token and 2 for Mini token . Total supply range of tiny token is [1-10K] and mini-token is [1, 1 milllion]. Mini-token will charge more than tiny-token for issue. TotalSupply: The total supply for this token can have a maximum of 8 digits of decimal and is boosted by 1e8 in order to store as int64. The amount before boosting should not exceed upper bound of supply range. Owner: The initial issuer of this token, the GSYS balance of issuer should be more than the fee for issuing tokens Mintable: Whether this token could be minted(increased) after the initial issuing, --mintable means the token can be inflationary. Commands Example on mainnet : ./eth-cli token issue-tiny --home $home -s $symbol --token-name $token_name -n 10000 --mintable --from $from --token-uri http://www.example.com --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node ./eth-cli token issue-mini --home $home -s $symbol --token-name $token_name -n 1000000 --mintable --from $from --token-uri http://www.example.com --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Transfer BEP8 Transfer type is the same as BEP2. The difference from BEP2 transfer is that the Mini-BEP2 transfer amount should be larger than or equal to 1, unless the sender sends the total amount of the free Mini-BEP2 token in his account. Commands Example on mainnet : ./eth-cli send --from $from -key-alias --to to-address --amount 200000000 :mini-token-symbol --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --json Freeze The transaction type, message structure and transaction process are the same as BEP2, except that the amount should be larger than or equal to 1, or equal to the free account balance. Commands Example on mainnet : ./eth-cli token freeze --amount 200000000 --symbol $mini -token-symbol --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Unfreeze The transaction type, message structure and transaction process are the same as BEP2 Tokens, except that the amount should be larger than or equal to 1, or equal to the frozen account balance. Commands Example on mainnet : ./eth-cli token unfreeze --amount 200000000 --symbol $mini -token-symbol --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Mint The transaction type, message structure and transaction process are the same as BEP2 Tokens, except that the amount should be larger than or equal to 1. Commands Example on mainnet : ./eth-cli token mint --amount 10000000000 --symbol $mini -token-symbol --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Burn The transaction type, message structure and transaction process are the same as BEP2 Tokens. The difference from BEP2 burn is that the Mini-BEP2 burn amount should be larger than or equal to 1, or equal to the free account balance. Commands Example on mainnet : ./eth-cli token burn --amount 100000000000 --symbol $mini -token-symbol --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Set Token URI The SetURI transaction is to change the value of TokenURI . Only token issuer can send this transaction. The URI may point to a JSON file that conforms to the \"Mini-BEP2 Metadata JSON Schema\". { \"name\" : \"Mini Token Metadata\" , \"description\" : \"Metadata description for the Mini Token\" , \"external_url\" : \"https://example.com/token\" , \"image\" : \"https://example.com/token/1.png\" , \"attributes\" : [ { \"name\" : \"custom field\" , \"value\" : \"custom value\" }, ... ] } Commands Example on mainnet : ./eth-cli token set-uri-mini --symbol $mini -token-symbol --token-uri http://www.efg.com --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node List BEP8 Tokens on GSYS DEX The listing process is different from BEP2 token list. BEP8 token issuer can list the Mini-BEP2 token without the agreement of Genesys Chain validators. The BEP8 token can only be listed against GSYS or BUSD and they cannot be listed as a quote symbol. The following parameters are required for the transaction: Field Type Description base-asset-symbol string the Mini BEP2 token to list quote-asset-symbol string only support GSYS and BUSD as quote asset init-price int64 the initial price for your asset, it is boosted by 1e8 from Bech32_address this address should be the issuer of base asset Commands ./eth-cli dex list-mini -s = $mini -token-symbol --quote-asset-symbol = GSYS --init-price = 1000000000 --from = alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node BEP8 Token Trading Pair Matching The number of BEP8 trading pairs could be much bigger than BEP2 pairs due to the cheap issue/listing fee. As they are designed to use limited network resource, GSYS DEX match engine will only allocate a fixed resource on matching the BEP8 pairs. Unlike BEP2 token, BEP8 trading pairs are not matched every block, but they are guaranteed to be matched at least once in every 16 blocks. Place Order The minimum amount of the Mini-BEP2 token should be larger than or equal to 1 , which is presented as 1e8 with the 8 digit decimal rule internally. The only exceptional case is that the user sells the total amount of the free BEP8 token in his account Delist Delist a trading pair of Mini-BEP2 token is the same as BEP2 delist . It needs the agreement of Genesys Chain validators. Fee Table for Testnet API URL: https://testnet-dex.genesys.network/api/v1/fees?format=amino Transaction Type Pay in GSYS TinyIssueFee 2 MiniIssueFee 3 SetUri 0.000375 List BEP8 8","title":"BEP8"},{"location":"guides/concepts/BEP8.html#introduction","text":"Currently, the cost to get a BEP2 token listed on GSYS DEX is about 1500GSYS, which is a big barrier to many small, promising projects. As explained in BEP8 ,the idea of BEP8 Tokens is raised to accommodate the small or micro projects, intellectual properties, and other small token economies to build a more comprehensive venue for token trading. Based on the limitation usage of the network, the cost of issuing and listing of such BEP8 tokens are minimized to a different magnitude. Besides, any BEP8 token issuer can choose to directly list against GSYS and BUSD without the voting process of validators. Stablecoin pairs of BEP8 will provide a UX advantage and make any two BEP82 tokens exchangeable. Similar to SME board in the traditional stock markets, BEP8 tokens markets will increase the liquidity of utility tokens of startups or Intellectual Property (IP) tokens by removing the capital requirements for listing. One good example is the open-source license model. A software developer can issue a BEP8 token and link his work to it. This token will be used to cover licensing fees for his work in the future.","title":"Introduction"},{"location":"guides/concepts/BEP8.html#token-management","text":"","title":"Token Management"},{"location":"guides/concepts/BEP8.html#issue","text":"Issue is a transaction used to create a new asset. Anyone can issue a new token with fee paid. After issuing, the token would appear in the issuer's account as free balance. An issuance transaction contains: Symbol: The length of the string for representing this asset is between 3 and 8 alphanumeric characters and is case insensitive. The symbol will have a suffix autogenerated by the algorithm: the first 3 bytes of the issue transaction hash, plus letter \u201cM\u201d. TokenURI: Optional field. A distinct Uniform Resource Identifier (URI) for the token. The URI may point to a JSON file that conforms to the \"Mini-BEP2 Metadata JSON Schema\". The schema is also optional. TokenType: 1 for tiny token and 2 for Mini token . Total supply range of tiny token is [1-10K] and mini-token is [1, 1 milllion]. Mini-token will charge more than tiny-token for issue. TotalSupply: The total supply for this token can have a maximum of 8 digits of decimal and is boosted by 1e8 in order to store as int64. The amount before boosting should not exceed upper bound of supply range. Owner: The initial issuer of this token, the GSYS balance of issuer should be more than the fee for issuing tokens Mintable: Whether this token could be minted(increased) after the initial issuing, --mintable means the token can be inflationary.","title":"Issue"},{"location":"guides/concepts/BEP8.html#commands","text":"Example on mainnet : ./eth-cli token issue-tiny --home $home -s $symbol --token-name $token_name -n 10000 --mintable --from $from --token-uri http://www.example.com --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node ./eth-cli token issue-mini --home $home -s $symbol --token-name $token_name -n 1000000 --mintable --from $from --token-uri http://www.example.com --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node","title":"Commands"},{"location":"guides/concepts/BEP8.html#transfer","text":"BEP8 Transfer type is the same as BEP2. The difference from BEP2 transfer is that the Mini-BEP2 transfer amount should be larger than or equal to 1, unless the sender sends the total amount of the free Mini-BEP2 token in his account.","title":"Transfer"},{"location":"guides/concepts/BEP8.html#commands_1","text":"Example on mainnet : ./eth-cli send --from $from -key-alias --to to-address --amount 200000000 :mini-token-symbol --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --json","title":"Commands"},{"location":"guides/concepts/BEP8.html#freeze","text":"The transaction type, message structure and transaction process are the same as BEP2, except that the amount should be larger than or equal to 1, or equal to the free account balance.","title":"Freeze"},{"location":"guides/concepts/BEP8.html#commands_2","text":"Example on mainnet : ./eth-cli token freeze --amount 200000000 --symbol $mini -token-symbol --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node","title":"Commands"},{"location":"guides/concepts/BEP8.html#unfreeze","text":"The transaction type, message structure and transaction process are the same as BEP2 Tokens, except that the amount should be larger than or equal to 1, or equal to the frozen account balance.","title":"Unfreeze"},{"location":"guides/concepts/BEP8.html#commands_3","text":"Example on mainnet : ./eth-cli token unfreeze --amount 200000000 --symbol $mini -token-symbol --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node","title":"Commands"},{"location":"guides/concepts/BEP8.html#mint","text":"The transaction type, message structure and transaction process are the same as BEP2 Tokens, except that the amount should be larger than or equal to 1.","title":"Mint"},{"location":"guides/concepts/BEP8.html#commands_4","text":"Example on mainnet : ./eth-cli token mint --amount 10000000000 --symbol $mini -token-symbol --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node","title":"Commands"},{"location":"guides/concepts/BEP8.html#burn","text":"The transaction type, message structure and transaction process are the same as BEP2 Tokens. The difference from BEP2 burn is that the Mini-BEP2 burn amount should be larger than or equal to 1, or equal to the free account balance.","title":"Burn"},{"location":"guides/concepts/BEP8.html#commands_5","text":"Example on mainnet : ./eth-cli token burn --amount 100000000000 --symbol $mini -token-symbol --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node","title":"Commands"},{"location":"guides/concepts/BEP8.html#set-token-uri","text":"The SetURI transaction is to change the value of TokenURI . Only token issuer can send this transaction. The URI may point to a JSON file that conforms to the \"Mini-BEP2 Metadata JSON Schema\". { \"name\" : \"Mini Token Metadata\" , \"description\" : \"Metadata description for the Mini Token\" , \"external_url\" : \"https://example.com/token\" , \"image\" : \"https://example.com/token/1.png\" , \"attributes\" : [ { \"name\" : \"custom field\" , \"value\" : \"custom value\" }, ... ] }","title":"Set Token URI"},{"location":"guides/concepts/BEP8.html#commands_6","text":"Example on mainnet : ./eth-cli token set-uri-mini --symbol $mini -token-symbol --token-uri http://www.efg.com --from alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node","title":"Commands"},{"location":"guides/concepts/BEP8.html#list-bep8-tokens-on-gsys-dex","text":"The listing process is different from BEP2 token list. BEP8 token issuer can list the Mini-BEP2 token without the agreement of Genesys Chain validators. The BEP8 token can only be listed against GSYS or BUSD and they cannot be listed as a quote symbol. The following parameters are required for the transaction: Field Type Description base-asset-symbol string the Mini BEP2 token to list quote-asset-symbol string only support GSYS and BUSD as quote asset init-price int64 the initial price for your asset, it is boosted by 1e8 from Bech32_address this address should be the issuer of base asset","title":"List BEP8 Tokens on GSYS DEX"},{"location":"guides/concepts/BEP8.html#commands_7","text":"./eth-cli dex list-mini -s = $mini -token-symbol --quote-asset-symbol = GSYS --init-price = 1000000000 --from = alice --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node","title":"Commands"},{"location":"guides/concepts/BEP8.html#bep8-token-trading-pair-matching","text":"The number of BEP8 trading pairs could be much bigger than BEP2 pairs due to the cheap issue/listing fee. As they are designed to use limited network resource, GSYS DEX match engine will only allocate a fixed resource on matching the BEP8 pairs. Unlike BEP2 token, BEP8 trading pairs are not matched every block, but they are guaranteed to be matched at least once in every 16 blocks.","title":"BEP8 Token Trading Pair Matching"},{"location":"guides/concepts/BEP8.html#place-order","text":"The minimum amount of the Mini-BEP2 token should be larger than or equal to 1 , which is presented as 1e8 with the 8 digit decimal rule internally. The only exceptional case is that the user sells the total amount of the free BEP8 token in his account","title":"Place Order"},{"location":"guides/concepts/BEP8.html#delist","text":"Delist a trading pair of Mini-BEP2 token is the same as BEP2 delist . It needs the agreement of Genesys Chain validators.","title":"Delist"},{"location":"guides/concepts/BEP8.html#fee-table-for-testnet","text":"API URL: https://testnet-dex.genesys.network/api/v1/fees?format=amino Transaction Type Pay in GSYS TinyIssueFee 2 MiniIssueFee 3 SetUri 0.000375 List BEP8 8","title":"Fee Table for Testnet"},{"location":"guides/concepts/BEP82.html","text":"BEP82 Note: this feature is only available in Testnet after Lagrange Upgrade. Introduction Before implementing BEP82, many token-related transactions, such as token listing, minting, burning, can only be proposed by the token owner. The owner of any BEP2/BEP8 token can not be changed once the token is issued on Genesys Chain. BEP82 introduced the changes related to the token owner who issued a token on Genesys Chain. It provides more convenience and flexibility for these transactions. Status This BEP is already implemented. Changes BEP82 introduce the following changes: Token issuers can renounce their ownership and promote others Allows token holders to burn their tokens New Transaction Type TransferOwnership transaction can transfer ownership of a specific token to another address, and only the original owner has the permission to send this transaction. Commands Example on mainnet : ./eth-cli token transfer-ownership --from $current -owner --symbol $symbol --new-owner $new -owner --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet : ./eth-cli token transfer-ownership --from $current -owner --symbol $symbol --new-owner $new -owner --chain-id GSYS-Chain-Nile --node = data-seed-pre-2-s1.genesys.network:80--trust-node Fees 0.01 GSYS will be charged on TransferOwnership transactions.","title":"BEP82"},{"location":"guides/concepts/BEP82.html#bep82","text":"Note: this feature is only available in Testnet after Lagrange Upgrade.","title":"BEP82"},{"location":"guides/concepts/BEP82.html#introduction","text":"Before implementing BEP82, many token-related transactions, such as token listing, minting, burning, can only be proposed by the token owner. The owner of any BEP2/BEP8 token can not be changed once the token is issued on Genesys Chain. BEP82 introduced the changes related to the token owner who issued a token on Genesys Chain. It provides more convenience and flexibility for these transactions.","title":"Introduction"},{"location":"guides/concepts/BEP82.html#status","text":"This BEP is already implemented.","title":"Status"},{"location":"guides/concepts/BEP82.html#changes","text":"BEP82 introduce the following changes: Token issuers can renounce their ownership and promote others Allows token holders to burn their tokens","title":"Changes"},{"location":"guides/concepts/BEP82.html#new-transaction-type","text":"TransferOwnership transaction can transfer ownership of a specific token to another address, and only the original owner has the permission to send this transaction.","title":"New Transaction Type"},{"location":"guides/concepts/BEP82.html#commands","text":"Example on mainnet : ./eth-cli token transfer-ownership --from $current -owner --symbol $symbol --new-owner $new -owner --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --trust-node Example on testnet : ./eth-cli token transfer-ownership --from $current -owner --symbol $symbol --new-owner $new -owner --chain-id GSYS-Chain-Nile --node = data-seed-pre-2-s1.genesys.network:80--trust-node","title":"Commands"},{"location":"guides/concepts/BEP82.html#fees","text":"0.01 GSYS will be charged on TransferOwnership transactions.","title":"Fees"},{"location":"guides/concepts/accounts.html","text":"Accounts Whenever a new address receives an asset, the corresponding transaction would create an Account for that address, which contains balances across all assets that are owned on this address. Account Balance The balance (the amount of tokens) of each asset is composed of 3 different parts: Available: the amount of tokens that can be transferred, and spent to swap (buy) other assets Locked: the amount of tokens that has been used in any outstanding orders. Once the order terminates (either filled, canceled or expired), the locked amount will decrease. Frozen: the amount of tokens that has been frozen via Freeze transactions. You can query the account info with the following command on mainnet: ./eth-cli account <your-address> --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --indent --trust-node Example output: Please note that the amount is boosted by e^8 for the decimal part. {\"type\":\"bnbchain/Account\",\"value\":{\"base\":{\"address\":\"tbnb1sylyjw032eajr9cyllp26n04300qzzre38qyv5\",\"coins\":[{\"denom\":\"000-0E1\",\"amount\":\"10530\"},{\"denom\":\"GSYS\",\"amount\":\"247349863800\"},{\"denom\":\"BTC.B-918\",\"amount\":\"113218800\"},{\"denom\":\"COSMOS-587\",\"amount\":\"50000101983748977\"},{\"denom\":\"EDU-DD0\",\"amount\":\"139885964\"},{\"denom\":\"MFH-9B5\",\"amount\":\"1258976083286\"},{\"denom\":\"NASC-137\",\"amount\":\"0\"},{\"denom\":\"PPC-00A\",\"amount\":\"205150260\"},{\"denom\":\"TGT-9FC\",\"amount\":\"33251102828\"},{\"denom\":\"UCX-CC8\",\"amount\":\"1398859649\"},{\"denom\":\"USDT.B-B7C\",\"amount\":\"140456966268\"},{\"denom\":\"YLC-D8B\",\"amount\":\"210572645\"},{\"denom\":\"ZZZ-21E\",\"amount\":\"13988596\"}],\"public_key\":{\"type\":\"tendermint/PubKeySecp256k1\",\"value\":\"AhOb3ZXecsIqwqKw+HhTscyi6K35xYpKaJx10yYwE0Qa\"},\"account_number\":\"406226\",\"sequence\":\"29\"},\"name\":\"\",\"frozen\":null,\"locked\":[{\"denom\":\"KOGE48-35D\",\"amount\":\"10000000000\"}]}} From the output you can see that this account account_number is 406226 and its sequence is 29. This is the important information about this account. Account and Sequence Number After Account is created, besides the balances, Account also contains: Account Number: an internal identifier for the account Sequence Number: an ever-changing integer. The Sequence Number is the way how Genesys Chain prevents Replay Attack (the idea is borrowed from Cosmos network, but varies a bit in handling). Every transaction should have a new Sequence Number increased by 1 from the current latest sequence number of the Account, and after this transaction is recorded on the block chain, the Sequence Number will be set to the same number as the one of latest transaction. This logic forces the client to be aware of the current Sequence Number, either by reading from the blockchain via API, or keep the counting locally by themselves. The recommended way is to keep counting locally and re-synchronize from the blockchain periodically.","title":"Accounts"},{"location":"guides/concepts/accounts.html#accounts","text":"Whenever a new address receives an asset, the corresponding transaction would create an Account for that address, which contains balances across all assets that are owned on this address.","title":"Accounts"},{"location":"guides/concepts/accounts.html#account-balance","text":"The balance (the amount of tokens) of each asset is composed of 3 different parts: Available: the amount of tokens that can be transferred, and spent to swap (buy) other assets Locked: the amount of tokens that has been used in any outstanding orders. Once the order terminates (either filled, canceled or expired), the locked amount will decrease. Frozen: the amount of tokens that has been frozen via Freeze transactions. You can query the account info with the following command on mainnet: ./eth-cli account <your-address> --chain-id GSYS-Chain-Tigris --node https://dataseed5.defibit.io:443 --indent --trust-node Example output: Please note that the amount is boosted by e^8 for the decimal part. {\"type\":\"bnbchain/Account\",\"value\":{\"base\":{\"address\":\"tbnb1sylyjw032eajr9cyllp26n04300qzzre38qyv5\",\"coins\":[{\"denom\":\"000-0E1\",\"amount\":\"10530\"},{\"denom\":\"GSYS\",\"amount\":\"247349863800\"},{\"denom\":\"BTC.B-918\",\"amount\":\"113218800\"},{\"denom\":\"COSMOS-587\",\"amount\":\"50000101983748977\"},{\"denom\":\"EDU-DD0\",\"amount\":\"139885964\"},{\"denom\":\"MFH-9B5\",\"amount\":\"1258976083286\"},{\"denom\":\"NASC-137\",\"amount\":\"0\"},{\"denom\":\"PPC-00A\",\"amount\":\"205150260\"},{\"denom\":\"TGT-9FC\",\"amount\":\"33251102828\"},{\"denom\":\"UCX-CC8\",\"amount\":\"1398859649\"},{\"denom\":\"USDT.B-B7C\",\"amount\":\"140456966268\"},{\"denom\":\"YLC-D8B\",\"amount\":\"210572645\"},{\"denom\":\"ZZZ-21E\",\"amount\":\"13988596\"}],\"public_key\":{\"type\":\"tendermint/PubKeySecp256k1\",\"value\":\"AhOb3ZXecsIqwqKw+HhTscyi6K35xYpKaJx10yYwE0Qa\"},\"account_number\":\"406226\",\"sequence\":\"29\"},\"name\":\"\",\"frozen\":null,\"locked\":[{\"denom\":\"KOGE48-35D\",\"amount\":\"10000000000\"}]}} From the output you can see that this account account_number is 406226 and its sequence is 29. This is the important information about this account.","title":"Account Balance"},{"location":"guides/concepts/accounts.html#account-and-sequence-number","text":"After Account is created, besides the balances, Account also contains: Account Number: an internal identifier for the account Sequence Number: an ever-changing integer. The Sequence Number is the way how Genesys Chain prevents Replay Attack (the idea is borrowed from Cosmos network, but varies a bit in handling). Every transaction should have a new Sequence Number increased by 1 from the current latest sequence number of the Account, and after this transaction is recorded on the block chain, the Sequence Number will be set to the same number as the one of latest transaction. This logic forces the client to be aware of the current Sequence Number, either by reading from the blockchain via API, or keep the counting locally by themselves. The recommended way is to keep counting locally and re-synchronize from the blockchain periodically.","title":"Account and Sequence Number"},{"location":"guides/concepts/architecture.html","text":"Architecture Consensus Details Genesys Chain is a peer-to-peer distributed system, connecting together multiple clients that reach consensus on their views of the \"state of the world\". Genesys Chain uses Tendermint BFT consensus and has a dedicated application layer that runs upon it. A simplified overview of the application's architecture might look something like this: +------------+-----------+ | RPC API | Web API | +------------------------+---------+ | Asset Management | Match Engine | +----------------------------------+ | Account Management | Governance |---------> crypto and blockchain governance +----------------------------------+ | State Caching and Persisence +-+ +----------------------------------+ | | Consensus Protocol | | +----------------------------------+ |-----> revised Tendermint | P2P Protocol | | +----------------------------------+ | | Networking | Database +-+ +----------------------------------+ For more information, please have a look at the Tendermint spec . Block Size Genesys Chain uses a similar block structure as Tendermint proposes, with a size limit of 1 megabyte. It is expected a block will be produced on a-few-of-seconds level among validators, and can include from 0 up to several thousands of transactions. Blockchain State Blockchain state stores the below information: account and balances fees token information trading pairs tick size and lot size governance information please note the transactions are not stored as chain state, because they are stored in blocks, while trades are not stored as state either, because they can be reproduced via balances and transactions. Cryptographic Design Account and Address For normal users, all the keys and addresses can be generated via GSYS Web Wallet . This default wallet would use a similar way to generate keys as Bitcoin, i.e. use 256 bits entropy to generate a 24-word mnemonic based on BIP39 , and then use the mnemonic and an empty passphrase to generate a seed; finally use the seed to generate a master key, and derive the private key using BIP32/BIP44 with HD prefix as \"44'/714'/\" , which is reserved at SLIP 44 . 714 comes from GSYS's birthday, July 14th. :) Keys Genesys Chain uses the same elliptic curve cryptography as the current Bitcoin implementation , i.e. secp256k1 . Its private key is 32 bytes while public key is 33 bytes. Address Addresses on Genesys Chain are 20 bytes and may be expressed as: Address = RIPEMD160(SHA256(compressed public key)) Typically, an address is encoded in the bech32 format which includes a checksum and human-readable prefix (HRP). However, it doesn't use the SegWit address format (because we do not have SegWit function anyway, so no witness program version etc.). A Genesys Chain address is therefore more similar to a Bitcoin Cash address , which does not include a SegWit program script. Address format pseudo-code: Address_Bech32 = HRP + '1' + bech32.encode(convert8BitsTo5Bits(RIPEMD160(SHA256(compressed public key)))) For Genesys Chain address, the prefix is bnb for production network, and tbnb for testnet. Signature Genesys Chain uses an ECDSA signature on curve secp256k1 against a SHA256 hash of the byte array of a JSON-encoded canonical representation of the transaction. For more information, please see this page .","title":"Architecture"},{"location":"guides/concepts/architecture.html#architecture","text":"","title":"Architecture"},{"location":"guides/concepts/architecture.html#consensus-details","text":"Genesys Chain is a peer-to-peer distributed system, connecting together multiple clients that reach consensus on their views of the \"state of the world\". Genesys Chain uses Tendermint BFT consensus and has a dedicated application layer that runs upon it. A simplified overview of the application's architecture might look something like this: +------------+-----------+ | RPC API | Web API | +------------------------+---------+ | Asset Management | Match Engine | +----------------------------------+ | Account Management | Governance |---------> crypto and blockchain governance +----------------------------------+ | State Caching and Persisence +-+ +----------------------------------+ | | Consensus Protocol | | +----------------------------------+ |-----> revised Tendermint | P2P Protocol | | +----------------------------------+ | | Networking | Database +-+ +----------------------------------+ For more information, please have a look at the Tendermint spec .","title":"Consensus Details"},{"location":"guides/concepts/architecture.html#block-size","text":"Genesys Chain uses a similar block structure as Tendermint proposes, with a size limit of 1 megabyte. It is expected a block will be produced on a-few-of-seconds level among validators, and can include from 0 up to several thousands of transactions.","title":"Block Size"},{"location":"guides/concepts/architecture.html#blockchain-state","text":"Blockchain state stores the below information: account and balances fees token information trading pairs tick size and lot size governance information please note the transactions are not stored as chain state, because they are stored in blocks, while trades are not stored as state either, because they can be reproduced via balances and transactions.","title":"Blockchain State"},{"location":"guides/concepts/architecture.html#cryptographic-design","text":"","title":"Cryptographic Design"},{"location":"guides/concepts/architecture.html#account-and-address","text":"For normal users, all the keys and addresses can be generated via GSYS Web Wallet . This default wallet would use a similar way to generate keys as Bitcoin, i.e. use 256 bits entropy to generate a 24-word mnemonic based on BIP39 , and then use the mnemonic and an empty passphrase to generate a seed; finally use the seed to generate a master key, and derive the private key using BIP32/BIP44 with HD prefix as \"44'/714'/\" , which is reserved at SLIP 44 . 714 comes from GSYS's birthday, July 14th. :)","title":"Account and Address"},{"location":"guides/concepts/architecture.html#keys","text":"Genesys Chain uses the same elliptic curve cryptography as the current Bitcoin implementation , i.e. secp256k1 . Its private key is 32 bytes while public key is 33 bytes.","title":"Keys"},{"location":"guides/concepts/architecture.html#address","text":"Addresses on Genesys Chain are 20 bytes and may be expressed as: Address = RIPEMD160(SHA256(compressed public key)) Typically, an address is encoded in the bech32 format which includes a checksum and human-readable prefix (HRP). However, it doesn't use the SegWit address format (because we do not have SegWit function anyway, so no witness program version etc.). A Genesys Chain address is therefore more similar to a Bitcoin Cash address , which does not include a SegWit program script. Address format pseudo-code: Address_Bech32 = HRP + '1' + bech32.encode(convert8BitsTo5Bits(RIPEMD160(SHA256(compressed public key)))) For Genesys Chain address, the prefix is bnb for production network, and tbnb for testnet.","title":"Address"},{"location":"guides/concepts/architecture.html#signature","text":"Genesys Chain uses an ECDSA signature on curve secp256k1 against a SHA256 hash of the byte array of a JSON-encoded canonical representation of the transaction. For more information, please see this page .","title":"Signature"},{"location":"guides/concepts/assets.html","text":"Assets Assets are stored as tokens on Genesys Chain, and the below management actions are available. All the assets are complied with BEP2 standard . BEP stands for Genesys Chain Evolution Proposal. Each BEP will be a proposal document providing information to the Genesys Chain/DEX community. The BEP should provide a concise technical specification of the feature or improvement and the rationale behind it. Each BEP proposer is responsible for building consensus within the community and documenting dissenting opinions. Each BEP has a unique index number. BEP2 Token Properties Source Address: Source Address is the owner of the issued token. Token Name: Token Name represents the long name of the token - e.g. \"MyToken\". Symbol: Symbol is the identifier of the newly issued token. Total Supply: Total supply will be the total number of issued tokens. Mintable: Mintable means whether this token can be minted in the future, which would increase the total supply of the token Symbol Convention: [Symbol][b]-[Suffix] Explanations: Suffix is the first 3 bytes of the issue transaction\u2019s hash, for example: BUSD-BD1 . It helps to remove the constraint of requiring unique token names. If this token pegs to an existing blockchain, there should be an additional suffix of \u201cB\u201d. Issue Process: Issuer signed an issue transaction and make it broadcasted to one of Genesys Chain nodes This Genesys Chain node will check this transaction. If there is no error, then this transaction will be broadcasted to other Genesys Chain nodes Issue transaction is committed on the blockchain by block proposer Validators will verify the constraints on total supply and symbol and deduct the fee from issuer\u2019s account New token\u2019s symbol is generated based on the transaction hash. It is added to the issuer\u2019s address and token info is saved on the Genesys Chain GSYS The Genesys, GSYS , is the native asset on Genesys Chain. There are 200MM Genesyss in total. There will be no mining. The existing coin burns and freezes will still be in effect on the new Genesys Chain blockchain. The exact number of Genesyss will be destroyed based on the same number of GSYS ERC20 tokens that have already been destroyed. Since Genesys Chain is live, all GSYS ERC20 tokens will be swapped for Genesys Chain coins. All users who hold GSYS ERC20 tokens can deposit them to GSYS.com, and upon withdrawal, the new Genesys Chain native coins will be sent to their new wallets.","title":"Assets"},{"location":"guides/concepts/assets.html#assets","text":"Assets are stored as tokens on Genesys Chain, and the below management actions are available. All the assets are complied with BEP2 standard . BEP stands for Genesys Chain Evolution Proposal. Each BEP will be a proposal document providing information to the Genesys Chain/DEX community. The BEP should provide a concise technical specification of the feature or improvement and the rationale behind it. Each BEP proposer is responsible for building consensus within the community and documenting dissenting opinions. Each BEP has a unique index number.","title":"Assets"},{"location":"guides/concepts/assets.html#bep2-token-properties","text":"Source Address: Source Address is the owner of the issued token. Token Name: Token Name represents the long name of the token - e.g. \"MyToken\". Symbol: Symbol is the identifier of the newly issued token. Total Supply: Total supply will be the total number of issued tokens. Mintable: Mintable means whether this token can be minted in the future, which would increase the total supply of the token","title":"BEP2 Token Properties"},{"location":"guides/concepts/assets.html#symbol-convention","text":"[Symbol][b]-[Suffix] Explanations: Suffix is the first 3 bytes of the issue transaction\u2019s hash, for example: BUSD-BD1 . It helps to remove the constraint of requiring unique token names. If this token pegs to an existing blockchain, there should be an additional suffix of \u201cB\u201d.","title":"Symbol Convention:"},{"location":"guides/concepts/assets.html#issue-process","text":"Issuer signed an issue transaction and make it broadcasted to one of Genesys Chain nodes This Genesys Chain node will check this transaction. If there is no error, then this transaction will be broadcasted to other Genesys Chain nodes Issue transaction is committed on the blockchain by block proposer Validators will verify the constraints on total supply and symbol and deduct the fee from issuer\u2019s account New token\u2019s symbol is generated based on the transaction hash. It is added to the issuer\u2019s address and token info is saved on the Genesys Chain","title":"Issue Process:"},{"location":"guides/concepts/assets.html#gsys","text":"The Genesys, GSYS , is the native asset on Genesys Chain. There are 200MM Genesyss in total. There will be no mining. The existing coin burns and freezes will still be in effect on the new Genesys Chain blockchain. The exact number of Genesyss will be destroyed based on the same number of GSYS ERC20 tokens that have already been destroyed. Since Genesys Chain is live, all GSYS ERC20 tokens will be swapped for Genesys Chain coins. All users who hold GSYS ERC20 tokens can deposit them to GSYS.com, and upon withdrawal, the new Genesys Chain native coins will be sent to their new wallets.","title":"GSYS"},{"location":"guides/concepts/atomic-swaps.html","text":"Cross-chain Atomic Swaps Atomic Swap The problem of an atomic swap is one where (at least) two parties, Alice and Bob, own coins, and want to exchange them without having to trust a third party (centralized exchange). A non-atomic trivial solution would have Alice send her coins to Bob, and then have Bob send other coins to Alice - but Bob has the option of going back on his end of the bargain and simply not following through with the protocol, ending up with both sets of coins. Atomic swaps can be used for trading between BEP2 tokens, or for trading crosss different blockchains. Hash Timer Locked Contract HGSYS has been used for Atomic Swap and cross payment channel for a few years on Bitcoin and its variant blockchains, and also Ethereum. This BEP defines native transactions to support HGSYS on Genesys Chain, and also proposes the standard infrastructure and procedure to use HGSYS for inter-chain atomic swap to easily create and use pegged token, which is called Atomic Peg . HGSYS on Genesys Chain As explained in BEP3 , Hash Timer Locked Contract(HGSYS) has been used for Atomic Swap and cross payment channels between different blockchains. BEP3 defines native transactions to support HGSYS on Genesys Chain and also proposes the standard infrastructure and procedure to use HGSYS for inter-chain atomic swap to easily create and use pegged token. During the swap process, the related fund will be locked to a purely-code-controlled escrow account. A purely-code-controlled escrow account is a kind of account which is derived from a hard-coded string in shree chain protocol. This kind of account has no its own private key and it's only controled by code in protocol. The code for calculating escrow account is the same as how it's done in cosmos-sdk : AtomicSwapCoinsAccAddr = sdk.AccAddress(crypto.AddressHash([]byte(\"Genesys ChainAtomicSwapCoins\"))) The account for mainnet is: bnb1wxeplyw7x8aahy93w96yhwm7xcq3ke4f8ge93u and the account for testnet is: tbnb1wxeplyw7x8aahy93w96yhwm7xcq3ke4ffasp3d . Once the swap is claimed or refunded, the fund will be transfered from the purely-code-controlled escrow account to client accounts. Hash Timer Locked Transfer Hash Timer Locked Transfer (HTLT) is a new transaction type on Genesys Chain, to serve as HGSYS in the first step of Atomic Swap, Parameters Name Type Description Optional From Address Sender address, where the asset is from No recipient-addr Address Receiver address, where the asset is to, if the proper condition meets. No recipient-other-chain bytes a byte array, maximum 32 bytes, in any proper encoding. leave it empty for single chain swap Yes sender-other-chain bytes a byte array, maximum 32 bytes, in any proper encoding. leave it empty for single chain swap Yes RandomNumberHash 32 bytes hash of a random number and timestamp, based on SHA256. If left out, a random value will be generated True Timestamp int64 Supposed to be the time of sending transaction, counted by second. It should be identical to the one in swap contract. If left out, current timestamp will be used. No OutAmount Coins similar to the Coins in the original Transfer defined in BEP2, assets to swap out No ExpectedIncome string Expected income from swap counter party, example: \"100:GSYS\" or \"100:GSYS,10000:BTCB-1DE\" The amount needs to be bumped by e^8 No HeightSpan int64 number of blocks to wait before the asset may be returned to From if not claimed via Random. The number must be larger than or equal to 360 (>2 minutes), and smaller than 518400 (< 48 hours) No CrossChain bool Specify if the HTLT is for cross chain atomic swap True, the default value is False Outputs Name Type Description Random number 32 bytes Timestamp int64 Random number hash 32 bytes Swap ID 32 bytes Examples Swap between BEP2 tokens On testnet : Command line ./eth-cli token HTLT --recipient-addr <recipient-addr> --amount 100 :GSYS --expected-income <expectedIncome> --height-span <heightSpan> --from <from-addr> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const recipient = \"tbnb1prrujx8kkukrcrppklggadhuvegfnx8pemsq77\" // recipient address const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" // 32 bytes random number const timestamp = Math . floor ( Date . now () / 1000 ) // take the current timestamp const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ) const amount = [{ denom : \"GSYS\" , amount : 100 }] const expectedIncome = \"100:GSYS\" // expected income const heightSpan = 400 // height span const res = client . swap . HTLT ( from , recipient , \"\" , \"\" , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , false ) Example output: Please take a note of returned swapID : Random number: 927c1ac33100bdbb001de19c626a05a7c3c11304fc825f5eabb22e741507711b Timestamp: 1568792486 Random number hash: 5768702259ee55983378d7b8207890c666648264524b9dada551386f832ba6b1 Password to sign with 'guest': Committed at block 39984169 ( tx hash: B5A3DD92A40E98745BBE9F608944FE5511B81071B34E9947A754A04A5F378A85, response: { Code:0 Data:[77 137 139 200 85 141 170 77 129 116 134 215 169 59 119 178 200 47 206 194 18 58 191 74 30 183 210 82 18 55 236 205] Log:Msg 0: swapID: 4d898bc8558daa4d817486d7a93b77b2c82fcec2123abf4a1eb7d2521237eccd Info: GasWanted:0 GasUsed:0 ... ) Besides, the Data field in the committed result is the byte array of swapID : Data:[77 137 139 200 85 141 170 77 129 116 134 215 169 59 119 178 200 47 206 194 18 58 191 74 30 183 210 82 18 55 236 205] swapID: 4d898bc8558daa4d817486d7a93b77b2c82fcec2123abf4a1eb7d2521237eccd Swap from Genesys Chain to Ethereum Clients send HTLT on Genesys Chain on testnet : Command line: ./eth-cli token HTLT --from <from-addr> --chain-id GSYS-Chain-Ganges --height-span <heightSpan> --amount <amount> --expected-income <expectedIncome> --recipient-addr <deputy-bep2-addr> --recipient-other-chain <client ethereum address> --cross-chain --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const recipient = \"tbnb1prrujx8kkukrcrppklggadhuvegfnx8pemsq77\" // recipient address const recipientOtherChain = \"0x37B8516a0F88E65D677229b402ec6C1e0E333004\" //client ethereum address const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" // 32 bytes random number const timestamp = Math . floor ( Date . now () / 1000 ) // take the current timestamp const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ) const amount = [{ denom : \"GSYS\" , amount : 100 }] // swap out token amount const expectedIncome = \"100:GSYS\" // expected income const heightSpan = 400 // height span const res = client . swap . HTLT ( from , recipient , recipientOtherChain , \"\" , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , true ) Swap from Ethereum to Genesys Chain Note: Once cross-chain is true, --recipient-other-chain must not be empty Deputy send HTLT on Genesys Chain on testnet : Command line: ./eth-cli token HTLT --from <from-addr> --chain-id GSYS-Chain-Ganges --height-span <heightSpan> --amount <amount> --expected-income <expectedIncome> --recipient-other-chain <deputy ethereum address> --sender-other-chain <client ethereum address> --recipient-addr <client bep2 address> --cross-chain --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const recipient = \"tbnb1prrujx8kkukrcrppklggadhuvegfnx8pemsq77\" // recipient address const recipientOtherChain = \"0xfA5E36a04EeF3152092099F352DDbe88953bB540\" //client ethereum address const senderOtherChain = \"0x37B8516a0F88E65D677229b402ec6C1e0E333004\" //client ethereum address const randomNumberHash = \"6632eda86c4f19190c8a986e188526eee865e1ce2758ba59c8bf45e20ffa3bb5\" //deputy get this value from the event log of swap contract const timestamp = 1571383800 //deputy get this value from the event log of swap contract const amount = [{ denom : \"GSYS\" , amount : 100 }] // swap out token amount const expectedIncome = \"100:GSYS\" // expected income const heightSpan = 400 // height span const res = client . swap . HTLT ( from , recipient , recipientOtherChain , senderOtherChain , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , true ) Deposit HTLT Deposit Hash Timer Locked Transfer is to lock new BEP2 asset to an existed HTLT which is for single chain atomic swap. Parameters Name Type Description Optional From Address Sender address, where the assets are from No SwapID 32 bytes ID of previously created swap, hex encoding No Amount Coins The swapped out amount BEP2 tokens, example: \"100:GSYS\" or \"100:GSYS,10000:BTCB-1DE\" No Examples On testnet: Command line: ./eth-cli token deposit --swap-id <swapID> --amount 10000 :TEST-599 --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const swapID = \"61daf59e977c5f718f5aaedeaf69ccbea1c376db5274a84bca88848696164ffe\" // the ID of an existing swap const amount = [{ denom : \"TEST-599\" , amount : 10000 }] const res = client . swap . depositHTLT ( from , swapID , amount ) Example output Committed at block 39984686 (tx hash: AA118F7CFCB3FFF86EF5EED8D2B9ADEAC5D9F242497910DAA232BDE5F6A84C1E, response: {Code:0 Data:[] Log:Msg 0: Info: GasWanted:0 GasUsed:0 Tags:[{Key:[115 101 110 100 101 114] Value:[116 98 110 98 49 110 107 120 57 57 52 113 118 113 109 113 103 107 53 55 118 103 117 113 104 54 122 106 108 97 99 113 122 120 100 107 117 101 53 122 106 121 120] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[114 101 99 105 112 105 101 110 116] Value:[116 98 110 98 49 119 120 101 112 108 121 119 55 120 56 97 97 104 121 57 51 119 57 54 121 104 119 109 55 120 99 113 51 107 101 52 102 102 97 115 112 51 100] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[97 99 116 105 111 110] Value:[100 101 112 111 115 105 116 72 84 76 84] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] Codespace: XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}) After the deposit, you may observe that the balance of sender is decreased. The amount in deposit transaction must be positive. Besides, you can query the swap by swapID and the in_amount must equal to the amount that you balance decreased. Claim HTLT Claim Hash Timer Locked Transfer is to claim the locked asset by showing the random number value that matches the hash. Each HTLT locked asset is guaranteed to be release once. Parameters Name Type Description Optional From Address Sender address No SwapID 32 bytes ID of previously created swap, hex encoding No RandomNumber 32 bytes The random number to unlock the locked hash, 32 bytes, hex encoding No Examples On testnet: Command line: ./eth-cli token claim --swap-id <swapID> --random-number <random-number> --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const swapID = \"61daf59e977c5f718f5aaedeaf69ccbea1c376db5274a84bca88848696164ffe\" // the ID of an existing swap const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" // the random number generated in htlt const res = client . swap . claimHTLT ( from , swapID , randomNumber ) Example output: Committed at block 39984971 (tx hash: 15B8625E0247DE54700D3C5C110BE0CE279D33CC13A73845F3E0305758A40902, response: {Code:0 Data:[] Log:Msg 0: Info: GasWanted:0 GasUsed:0 Tags:[{Key:[115 101 110 100 101 114] Value:[116 98 110 98 49 119 120 101 112 108 121 119 55 120 56 97 97 104 121 57 51 119 57 54 121 104 119 109 55 120 99 113 51 107 101 52 102 102 97 115 112 51 100] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[114 101 99 105 112 105 101 110 116] Value:[116 98 110 98 49 110 107 120 57 57 52 113 118 113 109 113 103 107 53 55 118 103 117 113 104 54 122 106 108 97 99 113 122 120 100 107 117 101 53 122 106 121 120] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[115 101 110 100 101 114] Value:[116 98 110 98 49 119 120 101 112 108 121 119 55 120 56 97 97 104 121 57 51 119 57 54 121 104 119 109 55 120 99 113 51 107 101 52 102 102 97 115 112 51 100] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[114 101 99 105 112 105 101 110 116] Value:[116 98 110 98 49 103 57 114 122 99 48 101 50 106 102 56 101 102 51 113 112 57 97 120 56 104 48 112 109 112 109 118 106 122 119 109 116 113 52 106 120 102 114] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[97 99 116 105 111 110] Value:[99 108 97 105 109 72 84 76 84] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] Codespace: XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}) Refund HTLT Refund Hash Timer Locked Transfer is to refund the locked asset after timelock is expired. Parameters Name Type Description Optional From Address Sender address No SwapID 32 bytes ID of previously created swap, hex encoding No Examples On testnet: Command line: ./eth-cli token refund --swap-id <swapID> --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const swapID = \"61daf59e977c5f718f5aaedeaf69ccbea1c376db5274a84bca88848696164ffe\" // the ID of an existing swap const res = client . swap . refundHTLT ( from , swapID , randomNumber ) Common error: Already complete ERROR: { \"codespace\" :8, \"code\" :12, \"abci_code\" :524300, \"message\" : \"Expected swap status is Open, actually it is Completed\" } Not expired ERROR : { \"codespace\" : 8 , \"code\" : 8 , \"abci_code\" : 524296 , \"message\" : \"Current block height is 40003412, the expire height (40013236) is still not reached\" } Query Atomic Swap Query atomic swap allows you to search swap information by swapID Parameters Name Type Description Optional SwapID 32 bytes ID of previously created swap, hex encoding No Examples On testnet: ./eth-cli token query-swap --swap-id <swapID> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Expected output { \"from\" : \"tbnb1g9rzc0e2jf8ef3qp9ax8h0pmpmvjzwmtq4jxfr\" , \"to\" : \"tbnb1nkx994qvqmqgk57vguqh6zjlacqzxdkue5zjyx\" , \"out_amount\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"100\" } ], \"in_amount\" : [ { \"denom\" : \"TEST-599\" , \"amount\" : \"10000\" } ], \"expected_income\" : \"10000:TEST-599\" , \"recipient_other_chain\" : \"\" , \"random_number_hash\" : \"5768702259ee55983378d7b8207890c666648264524b9dada551386f832ba6b1\" , \"random_number\" : \"927c1ac33100bdbb001de19c626a05a7c3c11304fc825f5eabb22e741507711b\" , \"timestamp\" : \"1568792486\" , \"cross_chain\" : false , \"expire_height\" : \"39994169\" , \"index\" : \"53\" , \"closed_time\" : \"1568792927\" , \"status\" : \"Completed\" } Query Atomic Swap ID By Recipient Query atomic swap ID allows you to search swap history of an recipient. As this is a heavy query interface, some public nodes might close this query interface. Parameters Name Type Description Optional recipient-addr Address Swap recipient address No Examples On testnet: ./eth-cli token query-swapIDs-by-recipient --recipient-addr <address> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Example output: [ \"4d898bc8558daa4d817486d7a93b77b2c82fcec2123abf4a1eb7d2521237eccd\", \"e7cc2e2eb025cc4617ff0bb84fcffc973d7ba34f15dbc51383fe3543ff143e9c\" ] Query Atomic Swap ID By Creator Query atomic swap ID allows you to search swap history of an initiator. As this is a heavy query interface, some public nodes might close this query interface. Parameters Name Type Description Optional creator-addr Address Swap creator address No Examples On testnet: ./eth-cli token query-swapIDs-by-creator --creator-addr <address> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Example output: [ \"7341d4ea0519af90d98f60fee45fdc7e385621875ea982bc8caf1fd7a49af8c3\", \"290664c1e8123966d8f9050fdc9d93e94b0e51b36e2e2a6978e492d3796423f1\", \"b260dad3cf63e558fe102a050afbe52d5dd2e30c7db76da33d02ce5f85d07fcf\", \"2b532bf9171c4d33d80fc4a8d6603581a86345b41552337482224d8476fcf5f7\", \"20d22bbfa579520f0ba79cd176fb2b06aa8dbe5b0a6ba8c9b761129f6a42a94c\" ] Fees Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related HTLT N/A 0.000375 GSYS Y depositHTLT N/A 0.000375 GSYS Y claimHTLT N/A 0.000375 GSYS Y refundHTLT N/A 0.000375 GSYS Y Workflows Preparations Deploy smart-contract which supports Atomic Peg Swap (APS), there is already one example for Ethereum Deploy deputy process for handling swap activities by token owners, there is an existing open-source solution here: https://github.com/githubusername/githubrepo/bep3-deputy Issue and transfer enough tokens Testnet Deployment ERC20 contract has been deployed here: https://ropsten.etherscan.io/address/0xd93395b2771914e1679155f3ea58c41d89d96098 Token Symbol: PPC SmartContract has been deployed here: https://ropsten.etherscan.io/address/0x12dcbf79be178479870a473a99d91f535ed960ad Its corresponding address on testnet is: tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr on Genesys Chain and 0xD93395B2771914E1679155F3EA58C41d89D96098 on Ethereum testnet Swap Tokens from Ethereum to Genesys Chain 1. Approve Swap Transaction Go to this page and approve some amount of tokens. Function: Approve Prameters: _spender: address of smartcontract, which is 0x12DCBf79BE178479870A473A99d91f535ed960AD _value: approved amount, should be bumped by e^10 Note: Please approve more than 1token. In the following example, 100 PPC token was approved: Example of approve 100 PPC on ropsten testnet 2. Call HTLT function From Ethereum Go to smartcontract and call HTLT function Function: htlt Prameters: _randomNumberHash: SHA256(randomNumber||timestamp), randomNumber is 32-length random byte array _timestamp: it should be about 10 mins span around current timestamp _heightSpan: it's a customized filed for deputy operator. it should be more than 200 for this deputy. _recipientAddr: deputy address on Ethereum, it's 0x1C002969Fe201975eD8F054916b071672326858e for this one _bep2SenderAddr: omit this field with 0x0 _bep2RecipientAddr: Decode your testnet address from bech32 encoded to hex, for example: 0xc41f2a85e1d3629637de1222017dce46c6c8e4b9 _outAmount: approved amount, should be bumped by e^10 _bep2Amount: _outAmount * exchange rate, the default rate is 1 Example of htlt transaction 3. Deputy Call HTLT on Genesys Chain Then, Deputy will send HTLT transaction here 4. Claim HTLT on Genesys Chain Get the swapID on Genesys Chain ./eth-cli token query-swapIDs-by-recipient --recipient-addr tbnb1cs0j4p0p6d3fvd77zg3qzlwwgmrv3e9e63423w --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 [ \"12aacc3bdc2cef97e8e45cc9b409796df57904a4e9c76863ad8420ff75f13128\" ] You can also get swapID by calculateSwapID in javascript-sdk . It requires three parameters: Name Type Description Example randomNumberHash string randomNumberHash in client HTLT transaction on Ethereum 5a3728a8f4ecb8b4cb0b983a9441b7d69f95229c4aa531e6e3827d7c19beac82 sender string deputy bep2 address tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr senderOtherChain string client ethereum address 0x133d144f52705ceb3f5801b63b9ebccf4102f5ed Query the swap by swapID { \"from\": \"tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr\", \"to\": \"tbnb1cs0j4p0p6d3fvd77zg3qzlwwgmrv3e9e63423w\", \"out_amount\": [ { \"denom\": \"PPC-00A\", \"amount\": \"9999999000\" } ], \"in_amount\": null, \"expected_income\": \"\", \"recipient_other_chain\": \"0x1C002969Fe201975eD8F054916b071672326858e\", \"random_number_hash\": \"5a3728a8f4ecb8b4cb0b983a9441b7d69f95229c4aa531e6e3827d7c19beac82\", \"random_number\": \"\", \"timestamp\": \"1569497984\", \"cross_chain\": true, \"expire_height\": \"41380567\", \"index\": \"1947\", \"closed_time\": \"\", \"status\": \"Open\" } Verify parameters in the swap: random_number_hash must equal to the randomNumberHash in client HTLT transaction on ethereum to must equals to client wallet address timestamp must equal to the timestamp in client HTLT transaction on ethereum out_amount should be reasonable. Please note that the decimals of bep2 tokens is 8, the out_amount should be something around 10000000000:PPC, deputy will deduct some fees. expire_height must not be passed and should be enough for send claim transaction Send claim transaction on Genesys Chain ./eth-cli token claim --swap-id 12aacc3bdc2cef97e8e45cc9b409796df57904a4e9c76863ad8420ff75f13128 --random-number <random-number> --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Example of claim tx on testnet 5. Deputy Claim ERC20 Token Deputy will claim ERC20 tokens afterwards with claim transaction 6. Demo for Client APP: swap erc20 to bep2 This is a javascript implementation for client app to swap PPC to PPC-00A with deputy. const erc20ContractAddr = \"0xd93395b2771914e1679155f3ea58c41d89d96098\" const swapContractAddr = \"0x12DCBf79BE178479870A473A99d91f535ed960AD\" const deputyEthWalletAddr = \"0x1C002969Fe201975eD8F054916b071672326858e\" const deputyGSYSWalletAddr = \"tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr\" const clientEthWalletAddr = \"0xfA5E36a04EeF3152092099F352DDbe88953bB540\" const clientEthWalletKey = new Buffer ( \"89A0F0E0732ACAA7AD37C9E6D7A9798ECCE6940C63FF0290A58B1C1C1697486A\" , \"hex\" ) const clientBnbWalletAddr = \"tbnb17vwyu8npjj5pywh3keq2lm7d4v76n434pwd8av\" const clientBnbWalletMnemonic = \"lawsuit margin siege phrase fabric matrix like picnic day thrive correct velvet stool type broom upon flee fee ten senior install wrestle soap sick\" const web3 = new Web3 ( new Web3 . providers . HttpProvider ( \"https://ropsten.infura.io/v3/1c5b38a27f92410cb5feb13b6efb2e14\" )) const bnbClient = new BncClient ( \"https://testnet-dex.genesys.network\" ) await bnbClient . initChain () bnbClient . setPrivateKey ( crypto . getPrivateKeyFromMnemonic ( clientBnbWalletMnemonic )) bnbClient . useDefaultSigningDelegate () bnbClient . useDefaultBroadcastDelegate () const bnbRPC = new rpcClient ( \"https://seed-pre-s3.genesys.network\" , \"testnet\" ) const erc20Contract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"name\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"approve\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_evilUser\" , \"type\" : \"address\" }], \"name\" : \"addBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"totalSupply\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_from\" , \"type\" : \"address\" },{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transferFrom\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"decimals\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_addedValue\" , \"type\" : \"uint256\" }], \"name\" : \"increaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"unpause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"isPauser\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_maker\" , \"type\" : \"address\" }], \"name\" : \"getBlackListStatus\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"paused\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renouncePauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"who\" , \"type\" : \"address\" }], \"name\" : \"balanceOf\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renounceOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"addPauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"pause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"owner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"isOwner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"symbol\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_subtractedValue\" , \"type\" : \"uint256\" }], \"name\" : \"decreaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transfer\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"issue\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"redeem\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_owner\" , \"type\" : \"address\" },{ \"name\" : \"_spender\" , \"type\" : \"address\" }], \"name\" : \"allowance\" , \"outputs\" : [{ \"name\" : \"remaining\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"name\" : \"isBlackListed\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_clearedUser\" , \"type\" : \"address\" }], \"name\" : \"removeBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"transferOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_blackListedUser\" , \"type\" : \"address\" }], \"name\" : \"destroyBlackFunds\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_initialSupply\" , \"type\" : \"uint256\" },{ \"name\" : \"_name\" , \"type\" : \"string\" },{ \"name\" : \"_symbol\" , \"type\" : \"string\" },{ \"name\" : \"_decimals\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Issue\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Redeem\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_blackListedUser\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"_balance\" , \"type\" : \"uint256\" }], \"name\" : \"DestroyedBlackFunds\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"AddedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"RemovedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Paused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Unpaused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"from\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"to\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Transfer\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"owner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"spender\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Approval\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"previousOwner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"OwnershipTransferred\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserAdded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserRemoved\" , \"type\" : \"event\" }], erc20ContractAddr ) const swapContract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"ERC20ContractAddr\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"isSwapExist\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refund\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_swapSender\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" }], \"name\" : \"calSwapID\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bytes32\" }], \"payable\" : false , \"stateMutability\" : \"pure\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"claim\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_heightSpan\" , \"type\" : \"uint256\" },{ \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_bep2RecipientAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"htlt\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"claimable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refundable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"queryOpenSwap\" , \"outputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_sender\" , \"type\" : \"address\" },{ \"name\" : \"_recipient\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_erc20Contract\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"indexed\" : false , \"name\" : \"_bep2Addr\" , \"type\" : \"bytes20\" },{ \"indexed\" : false , \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"HTLT\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" }], \"name\" : \"Refunded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"Claimed\" , \"type\" : \"event\" }], swapContractAddr ) //-------------------------------------------- //Step1 approve erc20 to swap contract address //-------------------------------------------- const approveData = erc20Contract . methods . increaseAllowance ( swapContractAddr , 10000000000 ). encodeABI () let nonce = await web3 . eth . getTransactionCount ( clientEthWalletAddr , 'pending' ) let gasPrice = await web3 . eth . getGasPrice () let gasLimit = 3000000 let rawTx = { nonce : web3 . utils . toHex ( nonce ), gasPrice : web3 . utils . toHex ( gasPrice ), gasLimit : web3 . utils . toHex ( gasLimit ), to : erc20ContractAddr , value : '0x00' , data : approveData } var ethereumjs = require ( 'ethereumjs-tx' ) var signTx = new ethereumjs ( rawTx ) signTx . sign ( clientEthWalletKey ) var serializedTx = signTx . serialize (); web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' )). on ( 'receipt' , console . log ) await wait ( 20000 ) //---------------------------------------------------------------------------- //Step2 call swap contract to send htlt transaction on Ethereum //---------------------------------------------------------------------------- const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" const timestamp = Math . floor ( Date . now () / 1000 ) const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ). toString ( \"hex\" ) const heightSpan = 1000 const hexEncodingClientGSYSaddr = '0x' + crypto . decodeAddress ( clientBnbWalletAddr ). toString ( \"hex\" ) const amount = 10000000000 // 10000000000:PPC\uff0c decimal is 10 const expectedIncome = 99999000 //\"99999000:PPC-00A\", decimal is 8, deputy will deduct swap fee, the swap fee is 1000:PPC-00A const htltData = swapContract . methods . htlt ( \"0x\" + randomNumberHash , timestamp , heightSpan , deputyEthWalletAddr , \"0x0\" , hexEncodingClientGSYSaddr , amount , expectedIncome ). encodeABI () nonce = await web3 . eth . getTransactionCount ( clientEthWalletAddr , 'pending' ) gasPrice = await web3 . eth . getGasPrice () gasLimit = 3000000 rawTx = { nonce : web3 . utils . toHex ( nonce ), gasPrice : web3 . utils . toHex ( gasPrice ), gasLimit : web3 . utils . toHex ( gasLimit ), to : swapContractAddr , value : '0x00' , data : htltData } ethereumjs = require ( 'ethereumjs-tx' ) signTx = new ethereumjs ( rawTx ) signTx . sign ( clientEthWalletKey ) serializedTx = signTx . serialize (); web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' )). on ( 'receipt' , console . log ) await wait ( 20000 ) //---------------------------------------------------------------------------- //Step3 query swap created by deputy on Genesys Chain and verify swap parameters //---------------------------------------------------------------------------- const swapID = calculateSwapID ( randomNumberHash . replace ( \"0x\" , \"\" ), deputyGSYSWalletAddr , clientEthWalletAddr ). toString () console . log ( swapID ) let atomicSwapList = await bnbClient . getSwapByRecipient ( clientBnbWalletAddr , 1000 , 0 ) while ( atomicSwapList . result . atomicSwaps [ 0 ]. swapId != swapID ) { console . log ( \"Waiting for the atomic swap created by deputy\" ) await wait ( 5000 ) atomicSwapList = await bnbClient . getSwapByRecipient ( clientBnbWalletAddr , 1000 , 0 ) } const atomicSwap = await bnbClient . getSwapByID ( swapID ) console . log ( atomicSwap ) const status = await bnbRPC . status () expect ( atomicSwap . result . toAddr ). toBe ( clientBnbWalletAddr ) expect ( atomicSwap . result . randomNumberHash ). toBe ( randomNumberHash . replace ( \"0x\" , \"\" )) expect ( atomicSwap . result . timestamp ). toBe ( timestamp ) expect ( atomicSwap . result . outAmount ). toBe ( \"99999000:PPC-00A\" ) expect ( Number ( atomicSwap . result . expireHeight )). toBeGreaterThan ( Number ( status . sync_info . latest_block_height ) + 100 ) //---------------------------------------------------------------------------- //Step4 claim on Genesys Chain //---------------------------------------------------------------------------- const res = await bnbClient . swap . claimHTLT ( clientBnbWalletAddr , swapID , randomNumber ) console . log ( res ) //---------------------------------------------------------------------------- //If step3 or step4 are failed and the expire height on Ethereum is passed, try to call refund method on Ethereum //---------------------------------------------------------------------------- Swap Tokens from Genesys Chain to Ethereum 1. Send HTLT Transaction from Genesys Chain Please read this section to generate a valid HTLT transaction. Please write down the randomNumber and randomNumberHash . ./eth-cli token HTLT --from atomic --recipient-addr tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr --chain-id GSYS-Chain-Ganges --height-span 10000 --amount 9900000000:PPC-00A --expected-income 9900000000:PPC --recipient-other-chain 0x133D144F52705cEb3f5801B63b9EBcCF4102f5Ed --cross-chain --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Random number: 4811959406ea3e69721d944d308880ec41323b7f89e51a78df3693348779315e Timestamp: 1569578936 Random number hash: b03f256c9efdb97b9815faa1417e1da4cca7672e0bb26e4e7d9bfc82d0f1f15e Committed at block 634510 ( tx hash: 9DEF124E12DE123BA1CC75AA6E68F20CC48EBBE9D7693CE4D0416267C6C0F159, response: { Code:0 Data:[229 50 241 60 76 91 112 146 93 68 100 222 83 84 180 133 181 151 241 174 93 125 132 82 245 198 5 66 0 123 32 113] Log:Msg 0: swapID: f85dd907df0a5897927b949c0f9e2563d453ba698ff9941fed1ce91f8057afc2 ... ) Note: the swap amount must be positive. Please write down the random number , random number hash , swapID and timestamp for next steps. Example is here Then, you can query the the swap by SwapID : ./eth-cli token query-swap --swap-id f85dd907df0a5897927b949c0f9e2563d453ba698ff9941fed1ce91f8057afc2 --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 You can use this swapID for refund if the deputy doesn't send htlt transaction on ethereum with proper parameters. 2. Deputy Approve Tokens You should see that Deputy has approve enough amount of tokens for atomic swap. 3. Deputy Send HTLT on Ethereum You should see that Deputy has sent the htlt transaction afterwards To get the swapID on Ethereum, you can check this page 0xd3bacf63906af5459ead39f27cae189e2f3e76fda34523714a4c61d76c79ee4e is the swapID on Ethereum. 4. Claim ERC20 Tokens on Ethereum You should see that Deputy has already approved enough tokens and In its event log , you should see the swapID . Before calling claim function on ethereum, clients should verify the parameters in the HTLT event. _randomNumberHash must equal to the randomNumberHash in client HTLT transaction on Genesys Chain _recipientAddr must equal to client ethereum wallet address _timestamp must equal to the timestamp in client HTLT transaction on Genesys Chain _outAmount should be reasonable. Please note that the decimals erc20 contract and deputy will deduct some fees. _expireHeight must not be passed and should be enough for send claim transaction Then, you can call the claim function: Function: claim Prameters: _swapID: this is get from event, you can also calculate it from calSwapID function in the contract. calSwapID(randomNumberHash, {deputy ethereum address}, {hex encoding client shree address}) _randomNumber: reveal your randomNumber Example is here 5. Deputy Claim on Genesys Chain Claim HTLT transaction from Deputy is sent afterwards: 6. Demo for Client APP: swap bep2 to erc20 This is a javascript implementation for client app to swap PPC-00A to PPC with deputy. const erc20ContractAddr = \"0xd93395b2771914e1679155f3ea58c41d89d96098\" const swapContractAddr = \"0x12DCBf79BE178479870A473A99d91f535ed960AD\" const deputyEthWalletAddr = \"0x1C002969Fe201975eD8F054916b071672326858e\" const deputyGSYSWalletAddr = \"tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr\" const clientEthWalletAddr = \"0xfA5E36a04EeF3152092099F352DDbe88953bB540\" const clientEthWalletKey = new Buffer ( \"89A0F0E0732ACAA7AD37C9E6D7A9798ECCE6940C63FF0290A58B1C1C1697486A\" , \"hex\" ) const clientBnbWalletAddr = \"tbnb17vwyu8npjj5pywh3keq2lm7d4v76n434pwd8av\" const clientBnbWalletMnemonic = \"lawsuit margin siege phrase fabric matrix like picnic day thrive correct velvet stool type broom upon flee fee ten senior install wrestle soap sick\" const web3 = new Web3 ( new Web3 . providers . HttpProvider ( \"https://ropsten.infura.io/v3/1c5b38a27f92410cb5feb13b6efb2e14\" )) const bnbClient = new BncClient ( \"https://testnet-dex.genesys.network\" ) await bnbClient . initChain () bnbClient . setPrivateKey ( crypto . getPrivateKeyFromMnemonic ( clientBnbWalletMnemonic )) bnbClient . useDefaultSigningDelegate () bnbClient . useDefaultBroadcastDelegate () const bnbRPC = new rpcClient ( \"https://seed-pre-s3.genesys.network\" , \"testnet\" ) const erc20Contract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"name\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"approve\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_evilUser\" , \"type\" : \"address\" }], \"name\" : \"addBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"totalSupply\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_from\" , \"type\" : \"address\" },{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transferFrom\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"decimals\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_addedValue\" , \"type\" : \"uint256\" }], \"name\" : \"increaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"unpause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"isPauser\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_maker\" , \"type\" : \"address\" }], \"name\" : \"getBlackListStatus\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"paused\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renouncePauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"who\" , \"type\" : \"address\" }], \"name\" : \"balanceOf\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renounceOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"addPauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"pause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"owner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"isOwner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"symbol\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_subtractedValue\" , \"type\" : \"uint256\" }], \"name\" : \"decreaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transfer\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"issue\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"redeem\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_owner\" , \"type\" : \"address\" },{ \"name\" : \"_spender\" , \"type\" : \"address\" }], \"name\" : \"allowance\" , \"outputs\" : [{ \"name\" : \"remaining\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"name\" : \"isBlackListed\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_clearedUser\" , \"type\" : \"address\" }], \"name\" : \"removeBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"transferOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_blackListedUser\" , \"type\" : \"address\" }], \"name\" : \"destroyBlackFunds\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_initialSupply\" , \"type\" : \"uint256\" },{ \"name\" : \"_name\" , \"type\" : \"string\" },{ \"name\" : \"_symbol\" , \"type\" : \"string\" },{ \"name\" : \"_decimals\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Issue\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Redeem\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_blackListedUser\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"_balance\" , \"type\" : \"uint256\" }], \"name\" : \"DestroyedBlackFunds\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"AddedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"RemovedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Paused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Unpaused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"from\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"to\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Transfer\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"owner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"spender\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Approval\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"previousOwner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"OwnershipTransferred\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserAdded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserRemoved\" , \"type\" : \"event\" }], erc20ContractAddr ) const swapContract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"ERC20ContractAddr\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"isSwapExist\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refund\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_swapSender\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" }], \"name\" : \"calSwapID\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bytes32\" }], \"payable\" : false , \"stateMutability\" : \"pure\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"claim\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_heightSpan\" , \"type\" : \"uint256\" },{ \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_bep2RecipientAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"htlt\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"claimable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refundable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"queryOpenSwap\" , \"outputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_sender\" , \"type\" : \"address\" },{ \"name\" : \"_recipient\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_erc20Contract\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"indexed\" : false , \"name\" : \"_bep2Addr\" , \"type\" : \"bytes20\" },{ \"indexed\" : false , \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"HTLT\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" }], \"name\" : \"Refunded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"Claimed\" , \"type\" : \"event\" }], swapContractAddr ) //-------------------------------------------- //Step1 send htlt on Genesys Chain //-------------------------------------------- const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" const timestamp = Math . floor ( Date . now () / 1000 ) const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ). toString ( \"hex\" ) const heightSpan = 10000 const amount = [{ denom : \"PPC-00A\" , amount : 100000000 }] const expectedIncome = \"9999990000:PPC\" //\"9999990000:PPC\", decimal is 10, deputy will deduct swap fee, the swap fee is 10000:PPC bnbClient . swap . HTLT ( clientBnbWalletAddr , deputyGSYSWalletAddr , clientEthWalletAddr , \"\" , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , true ) await wait ( 1000 ) //---------------------------------------------------------------------------- //Step2 query swap created by deputy on Ethereum and verify swap parameters //---------------------------------------------------------------------------- const hexEncodingClientGSYSaddr = '0x' + crypto . decodeAddress ( clientBnbWalletAddr ). toString ( \"hex\" ) const swapID = await swapContract . methods . calSwapID ( \"0x\" + randomNumberHash , deputyEthWalletAddr , hexEncodingClientGSYSaddr ). call () console . log ( swapID ) let openSwap = await swapContract . methods . queryOpenSwap ( swapID ). call () while ( openSwap . _randomNumberHash == '0x0000000000000000000000000000000000000000000000000000000000000000' ) { console . log ( \"Waiting for the atomic swap created by deputy\" ) await wait ( 5000 ) openSwap = await swapContract . methods . queryOpenSwap ( swapID ). call () } let ethBlock = await web3 . eth . getBlock ( 'latest' ) let ethLatestHeight = ethBlock . number expect ( openSwap . _randomNumberHash ). toBe ( \"0x\" + randomNumberHash ) expect ( Number ( openSwap . _timestamp )). toBe ( timestamp ) expect ( Number ( openSwap . _outAmount )). toBe ( 9999990000 ) expect ( openSwap . _recipient ). toBe ( clientEthWalletAddr ) expect ( Number ( openSwap . _expireHeight )). toBeGreaterThan ( Number ( ethLatestHeight ) + 20 ) //---------------------------------------------------------------------------- //Step3 claim on Ethereum //---------------------------------------------------------------------------- const claimData = swapContract . methods . claim ( swapID , \"0x\" + randomNumber ). encodeABI () let nonce = await web3 . eth . getTransactionCount ( clientEthWalletAddr , 'pending' ) let gasPrice = await web3 . eth . getGasPrice () let gasLimit = 3000000 let rawTx = { nonce : web3 . utils . toHex ( nonce ), gasPrice : web3 . utils . toHex ( gasPrice ), gasLimit : web3 . utils . toHex ( gasLimit ), to : swapContractAddr , value : '0x00' , data : claimData } var ethereumjs = require ( 'ethereumjs-tx' ) var signTx = new ethereumjs ( rawTx ) signTx . sign ( clientEthWalletKey ) var serializedTx = signTx . serialize (); web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' )). on ( 'receipt' , console . log ) await wait ( 20000 ) //---------------------------------------------------------------------------- //If step2 or step3 are failed and the expire height on Genesys Chain is passed, try to send refundHTLT transaction on Genesys Chain //---------------------------------------------------------------------------- Swap between Several BEP2 tokens Swap between Several BEP2 tokens fails","title":"Cross-chain Atomic Swaps"},{"location":"guides/concepts/atomic-swaps.html#cross-chain-atomic-swaps","text":"","title":"Cross-chain Atomic Swaps"},{"location":"guides/concepts/atomic-swaps.html#atomic-swap","text":"The problem of an atomic swap is one where (at least) two parties, Alice and Bob, own coins, and want to exchange them without having to trust a third party (centralized exchange). A non-atomic trivial solution would have Alice send her coins to Bob, and then have Bob send other coins to Alice - but Bob has the option of going back on his end of the bargain and simply not following through with the protocol, ending up with both sets of coins. Atomic swaps can be used for trading between BEP2 tokens, or for trading crosss different blockchains.","title":"Atomic Swap"},{"location":"guides/concepts/atomic-swaps.html#hash-timer-locked-contract","text":"HGSYS has been used for Atomic Swap and cross payment channel for a few years on Bitcoin and its variant blockchains, and also Ethereum. This BEP defines native transactions to support HGSYS on Genesys Chain, and also proposes the standard infrastructure and procedure to use HGSYS for inter-chain atomic swap to easily create and use pegged token, which is called Atomic Peg .","title":"Hash Timer Locked Contract"},{"location":"guides/concepts/atomic-swaps.html#hgsys-on-genesys-chain","text":"As explained in BEP3 , Hash Timer Locked Contract(HGSYS) has been used for Atomic Swap and cross payment channels between different blockchains. BEP3 defines native transactions to support HGSYS on Genesys Chain and also proposes the standard infrastructure and procedure to use HGSYS for inter-chain atomic swap to easily create and use pegged token. During the swap process, the related fund will be locked to a purely-code-controlled escrow account. A purely-code-controlled escrow account is a kind of account which is derived from a hard-coded string in shree chain protocol. This kind of account has no its own private key and it's only controled by code in protocol. The code for calculating escrow account is the same as how it's done in cosmos-sdk : AtomicSwapCoinsAccAddr = sdk.AccAddress(crypto.AddressHash([]byte(\"Genesys ChainAtomicSwapCoins\"))) The account for mainnet is: bnb1wxeplyw7x8aahy93w96yhwm7xcq3ke4f8ge93u and the account for testnet is: tbnb1wxeplyw7x8aahy93w96yhwm7xcq3ke4ffasp3d . Once the swap is claimed or refunded, the fund will be transfered from the purely-code-controlled escrow account to client accounts.","title":"HGSYS on Genesys Chain"},{"location":"guides/concepts/atomic-swaps.html#hash-timer-locked-transfer","text":"Hash Timer Locked Transfer (HTLT) is a new transaction type on Genesys Chain, to serve as HGSYS in the first step of Atomic Swap,","title":"Hash Timer Locked Transfer"},{"location":"guides/concepts/atomic-swaps.html#parameters","text":"Name Type Description Optional From Address Sender address, where the asset is from No recipient-addr Address Receiver address, where the asset is to, if the proper condition meets. No recipient-other-chain bytes a byte array, maximum 32 bytes, in any proper encoding. leave it empty for single chain swap Yes sender-other-chain bytes a byte array, maximum 32 bytes, in any proper encoding. leave it empty for single chain swap Yes RandomNumberHash 32 bytes hash of a random number and timestamp, based on SHA256. If left out, a random value will be generated True Timestamp int64 Supposed to be the time of sending transaction, counted by second. It should be identical to the one in swap contract. If left out, current timestamp will be used. No OutAmount Coins similar to the Coins in the original Transfer defined in BEP2, assets to swap out No ExpectedIncome string Expected income from swap counter party, example: \"100:GSYS\" or \"100:GSYS,10000:BTCB-1DE\" The amount needs to be bumped by e^8 No HeightSpan int64 number of blocks to wait before the asset may be returned to From if not claimed via Random. The number must be larger than or equal to 360 (>2 minutes), and smaller than 518400 (< 48 hours) No CrossChain bool Specify if the HTLT is for cross chain atomic swap True, the default value is False","title":"Parameters"},{"location":"guides/concepts/atomic-swaps.html#outputs","text":"Name Type Description Random number 32 bytes Timestamp int64 Random number hash 32 bytes Swap ID 32 bytes","title":"Outputs"},{"location":"guides/concepts/atomic-swaps.html#examples","text":"Swap between BEP2 tokens On testnet : Command line ./eth-cli token HTLT --recipient-addr <recipient-addr> --amount 100 :GSYS --expected-income <expectedIncome> --height-span <heightSpan> --from <from-addr> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const recipient = \"tbnb1prrujx8kkukrcrppklggadhuvegfnx8pemsq77\" // recipient address const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" // 32 bytes random number const timestamp = Math . floor ( Date . now () / 1000 ) // take the current timestamp const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ) const amount = [{ denom : \"GSYS\" , amount : 100 }] const expectedIncome = \"100:GSYS\" // expected income const heightSpan = 400 // height span const res = client . swap . HTLT ( from , recipient , \"\" , \"\" , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , false ) Example output: Please take a note of returned swapID : Random number: 927c1ac33100bdbb001de19c626a05a7c3c11304fc825f5eabb22e741507711b Timestamp: 1568792486 Random number hash: 5768702259ee55983378d7b8207890c666648264524b9dada551386f832ba6b1 Password to sign with 'guest': Committed at block 39984169 ( tx hash: B5A3DD92A40E98745BBE9F608944FE5511B81071B34E9947A754A04A5F378A85, response: { Code:0 Data:[77 137 139 200 85 141 170 77 129 116 134 215 169 59 119 178 200 47 206 194 18 58 191 74 30 183 210 82 18 55 236 205] Log:Msg 0: swapID: 4d898bc8558daa4d817486d7a93b77b2c82fcec2123abf4a1eb7d2521237eccd Info: GasWanted:0 GasUsed:0 ... ) Besides, the Data field in the committed result is the byte array of swapID : Data:[77 137 139 200 85 141 170 77 129 116 134 215 169 59 119 178 200 47 206 194 18 58 191 74 30 183 210 82 18 55 236 205] swapID: 4d898bc8558daa4d817486d7a93b77b2c82fcec2123abf4a1eb7d2521237eccd Swap from Genesys Chain to Ethereum Clients send HTLT on Genesys Chain on testnet : Command line: ./eth-cli token HTLT --from <from-addr> --chain-id GSYS-Chain-Ganges --height-span <heightSpan> --amount <amount> --expected-income <expectedIncome> --recipient-addr <deputy-bep2-addr> --recipient-other-chain <client ethereum address> --cross-chain --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const recipient = \"tbnb1prrujx8kkukrcrppklggadhuvegfnx8pemsq77\" // recipient address const recipientOtherChain = \"0x37B8516a0F88E65D677229b402ec6C1e0E333004\" //client ethereum address const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" // 32 bytes random number const timestamp = Math . floor ( Date . now () / 1000 ) // take the current timestamp const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ) const amount = [{ denom : \"GSYS\" , amount : 100 }] // swap out token amount const expectedIncome = \"100:GSYS\" // expected income const heightSpan = 400 // height span const res = client . swap . HTLT ( from , recipient , recipientOtherChain , \"\" , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , true ) Swap from Ethereum to Genesys Chain Note: Once cross-chain is true, --recipient-other-chain must not be empty Deputy send HTLT on Genesys Chain on testnet : Command line: ./eth-cli token HTLT --from <from-addr> --chain-id GSYS-Chain-Ganges --height-span <heightSpan> --amount <amount> --expected-income <expectedIncome> --recipient-other-chain <deputy ethereum address> --sender-other-chain <client ethereum address> --recipient-addr <client bep2 address> --cross-chain --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const recipient = \"tbnb1prrujx8kkukrcrppklggadhuvegfnx8pemsq77\" // recipient address const recipientOtherChain = \"0xfA5E36a04EeF3152092099F352DDbe88953bB540\" //client ethereum address const senderOtherChain = \"0x37B8516a0F88E65D677229b402ec6C1e0E333004\" //client ethereum address const randomNumberHash = \"6632eda86c4f19190c8a986e188526eee865e1ce2758ba59c8bf45e20ffa3bb5\" //deputy get this value from the event log of swap contract const timestamp = 1571383800 //deputy get this value from the event log of swap contract const amount = [{ denom : \"GSYS\" , amount : 100 }] // swap out token amount const expectedIncome = \"100:GSYS\" // expected income const heightSpan = 400 // height span const res = client . swap . HTLT ( from , recipient , recipientOtherChain , senderOtherChain , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , true )","title":"Examples"},{"location":"guides/concepts/atomic-swaps.html#deposit-htlt","text":"Deposit Hash Timer Locked Transfer is to lock new BEP2 asset to an existed HTLT which is for single chain atomic swap.","title":"Deposit HTLT"},{"location":"guides/concepts/atomic-swaps.html#parameters_1","text":"Name Type Description Optional From Address Sender address, where the assets are from No SwapID 32 bytes ID of previously created swap, hex encoding No Amount Coins The swapped out amount BEP2 tokens, example: \"100:GSYS\" or \"100:GSYS,10000:BTCB-1DE\" No","title":"Parameters"},{"location":"guides/concepts/atomic-swaps.html#examples_1","text":"On testnet: Command line: ./eth-cli token deposit --swap-id <swapID> --amount 10000 :TEST-599 --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const from = \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" // sender address const swapID = \"61daf59e977c5f718f5aaedeaf69ccbea1c376db5274a84bca88848696164ffe\" // the ID of an existing swap const amount = [{ denom : \"TEST-599\" , amount : 10000 }] const res = client . swap . depositHTLT ( from , swapID , amount ) Example output Committed at block 39984686 (tx hash: AA118F7CFCB3FFF86EF5EED8D2B9ADEAC5D9F242497910DAA232BDE5F6A84C1E, response: {Code:0 Data:[] Log:Msg 0: Info: GasWanted:0 GasUsed:0 Tags:[{Key:[115 101 110 100 101 114] Value:[116 98 110 98 49 110 107 120 57 57 52 113 118 113 109 113 103 107 53 55 118 103 117 113 104 54 122 106 108 97 99 113 122 120 100 107 117 101 53 122 106 121 120] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[114 101 99 105 112 105 101 110 116] Value:[116 98 110 98 49 119 120 101 112 108 121 119 55 120 56 97 97 104 121 57 51 119 57 54 121 104 119 109 55 120 99 113 51 107 101 52 102 102 97 115 112 51 100] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[97 99 116 105 111 110] Value:[100 101 112 111 115 105 116 72 84 76 84] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] Codespace: XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}) After the deposit, you may observe that the balance of sender is decreased. The amount in deposit transaction must be positive. Besides, you can query the swap by swapID and the in_amount must equal to the amount that you balance decreased.","title":"Examples"},{"location":"guides/concepts/atomic-swaps.html#claim-htlt","text":"Claim Hash Timer Locked Transfer is to claim the locked asset by showing the random number value that matches the hash. Each HTLT locked asset is guaranteed to be release once.","title":"Claim HTLT"},{"location":"guides/concepts/atomic-swaps.html#parameters_2","text":"Name Type Description Optional From Address Sender address No SwapID 32 bytes ID of previously created swap, hex encoding No RandomNumber 32 bytes The random number to unlock the locked hash, 32 bytes, hex encoding No","title":"Parameters"},{"location":"guides/concepts/atomic-swaps.html#examples_2","text":"On testnet: Command line: ./eth-cli token claim --swap-id <swapID> --random-number <random-number> --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const swapID = \"61daf59e977c5f718f5aaedeaf69ccbea1c376db5274a84bca88848696164ffe\" // the ID of an existing swap const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" // the random number generated in htlt const res = client . swap . claimHTLT ( from , swapID , randomNumber ) Example output: Committed at block 39984971 (tx hash: 15B8625E0247DE54700D3C5C110BE0CE279D33CC13A73845F3E0305758A40902, response: {Code:0 Data:[] Log:Msg 0: Info: GasWanted:0 GasUsed:0 Tags:[{Key:[115 101 110 100 101 114] Value:[116 98 110 98 49 119 120 101 112 108 121 119 55 120 56 97 97 104 121 57 51 119 57 54 121 104 119 109 55 120 99 113 51 107 101 52 102 102 97 115 112 51 100] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[114 101 99 105 112 105 101 110 116] Value:[116 98 110 98 49 110 107 120 57 57 52 113 118 113 109 113 103 107 53 55 118 103 117 113 104 54 122 106 108 97 99 113 122 120 100 107 117 101 53 122 106 121 120] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[115 101 110 100 101 114] Value:[116 98 110 98 49 119 120 101 112 108 121 119 55 120 56 97 97 104 121 57 51 119 57 54 121 104 119 109 55 120 99 113 51 107 101 52 102 102 97 115 112 51 100] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[114 101 99 105 112 105 101 110 116] Value:[116 98 110 98 49 103 57 114 122 99 48 101 50 106 102 56 101 102 51 113 112 57 97 120 56 104 48 112 109 112 109 118 106 122 119 109 116 113 52 106 120 102 114] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0} {Key:[97 99 116 105 111 110] Value:[99 108 97 105 109 72 84 76 84] XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0}] Codespace: XXX_NoUnkeyedLiteral:{} XXX_unrecognized:[] XXX_sizecache:0})","title":"Examples"},{"location":"guides/concepts/atomic-swaps.html#refund-htlt","text":"Refund Hash Timer Locked Transfer is to refund the locked asset after timelock is expired.","title":"Refund HTLT"},{"location":"guides/concepts/atomic-swaps.html#parameters_3","text":"Name Type Description Optional From Address Sender address No SwapID 32 bytes ID of previously created swap, hex encoding No","title":"Parameters"},{"location":"guides/concepts/atomic-swaps.html#examples_3","text":"On testnet: Command line: ./eth-cli token refund --swap-id <swapID> --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Javascript: const client = new BncClient ( \"https://testnet-dex.genesys.network\" ) const privateKey = crypto . getPrivateKeyFromMnemonic ( mnemonic ) client . setPrivateKey ( privateKey ) const swapID = \"61daf59e977c5f718f5aaedeaf69ccbea1c376db5274a84bca88848696164ffe\" // the ID of an existing swap const res = client . swap . refundHTLT ( from , swapID , randomNumber ) Common error: Already complete ERROR: { \"codespace\" :8, \"code\" :12, \"abci_code\" :524300, \"message\" : \"Expected swap status is Open, actually it is Completed\" } Not expired ERROR : { \"codespace\" : 8 , \"code\" : 8 , \"abci_code\" : 524296 , \"message\" : \"Current block height is 40003412, the expire height (40013236) is still not reached\" }","title":"Examples"},{"location":"guides/concepts/atomic-swaps.html#query-atomic-swap","text":"Query atomic swap allows you to search swap information by swapID","title":"Query Atomic Swap"},{"location":"guides/concepts/atomic-swaps.html#parameters_4","text":"Name Type Description Optional SwapID 32 bytes ID of previously created swap, hex encoding No","title":"Parameters"},{"location":"guides/concepts/atomic-swaps.html#examples_4","text":"On testnet: ./eth-cli token query-swap --swap-id <swapID> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Expected output { \"from\" : \"tbnb1g9rzc0e2jf8ef3qp9ax8h0pmpmvjzwmtq4jxfr\" , \"to\" : \"tbnb1nkx994qvqmqgk57vguqh6zjlacqzxdkue5zjyx\" , \"out_amount\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"100\" } ], \"in_amount\" : [ { \"denom\" : \"TEST-599\" , \"amount\" : \"10000\" } ], \"expected_income\" : \"10000:TEST-599\" , \"recipient_other_chain\" : \"\" , \"random_number_hash\" : \"5768702259ee55983378d7b8207890c666648264524b9dada551386f832ba6b1\" , \"random_number\" : \"927c1ac33100bdbb001de19c626a05a7c3c11304fc825f5eabb22e741507711b\" , \"timestamp\" : \"1568792486\" , \"cross_chain\" : false , \"expire_height\" : \"39994169\" , \"index\" : \"53\" , \"closed_time\" : \"1568792927\" , \"status\" : \"Completed\" }","title":"Examples"},{"location":"guides/concepts/atomic-swaps.html#query-atomic-swap-id-by-recipient","text":"Query atomic swap ID allows you to search swap history of an recipient. As this is a heavy query interface, some public nodes might close this query interface.","title":"Query Atomic Swap ID By Recipient"},{"location":"guides/concepts/atomic-swaps.html#parameters_5","text":"Name Type Description Optional recipient-addr Address Swap recipient address No","title":"Parameters"},{"location":"guides/concepts/atomic-swaps.html#examples_5","text":"On testnet: ./eth-cli token query-swapIDs-by-recipient --recipient-addr <address> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Example output: [ \"4d898bc8558daa4d817486d7a93b77b2c82fcec2123abf4a1eb7d2521237eccd\", \"e7cc2e2eb025cc4617ff0bb84fcffc973d7ba34f15dbc51383fe3543ff143e9c\" ]","title":"Examples"},{"location":"guides/concepts/atomic-swaps.html#query-atomic-swap-id-by-creator","text":"Query atomic swap ID allows you to search swap history of an initiator. As this is a heavy query interface, some public nodes might close this query interface.","title":"Query Atomic Swap ID By Creator"},{"location":"guides/concepts/atomic-swaps.html#parameters_6","text":"Name Type Description Optional creator-addr Address Swap creator address No","title":"Parameters"},{"location":"guides/concepts/atomic-swaps.html#examples_6","text":"On testnet: ./eth-cli token query-swapIDs-by-creator --creator-addr <address> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Example output: [ \"7341d4ea0519af90d98f60fee45fdc7e385621875ea982bc8caf1fd7a49af8c3\", \"290664c1e8123966d8f9050fdc9d93e94b0e51b36e2e2a6978e492d3796423f1\", \"b260dad3cf63e558fe102a050afbe52d5dd2e30c7db76da33d02ce5f85d07fcf\", \"2b532bf9171c4d33d80fc4a8d6603581a86345b41552337482224d8476fcf5f7\", \"20d22bbfa579520f0ba79cd176fb2b06aa8dbe5b0a6ba8c9b761129f6a42a94c\" ]","title":"Examples"},{"location":"guides/concepts/atomic-swaps.html#fees","text":"Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related HTLT N/A 0.000375 GSYS Y depositHTLT N/A 0.000375 GSYS Y claimHTLT N/A 0.000375 GSYS Y refundHTLT N/A 0.000375 GSYS Y","title":"Fees"},{"location":"guides/concepts/atomic-swaps.html#workflows","text":"","title":"Workflows"},{"location":"guides/concepts/atomic-swaps.html#preparations","text":"Deploy smart-contract which supports Atomic Peg Swap (APS), there is already one example for Ethereum Deploy deputy process for handling swap activities by token owners, there is an existing open-source solution here: https://github.com/githubusername/githubrepo/bep3-deputy Issue and transfer enough tokens","title":"Preparations"},{"location":"guides/concepts/atomic-swaps.html#testnet-deployment","text":"ERC20 contract has been deployed here: https://ropsten.etherscan.io/address/0xd93395b2771914e1679155f3ea58c41d89d96098 Token Symbol: PPC SmartContract has been deployed here: https://ropsten.etherscan.io/address/0x12dcbf79be178479870a473a99d91f535ed960ad Its corresponding address on testnet is: tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr on Genesys Chain and 0xD93395B2771914E1679155F3EA58C41d89D96098 on Ethereum testnet","title":"Testnet Deployment"},{"location":"guides/concepts/atomic-swaps.html#swap-tokens-from-ethereum-to-genesys-chain","text":"","title":"Swap Tokens from Ethereum to Genesys Chain"},{"location":"guides/concepts/atomic-swaps.html#1-approve-swap-transaction","text":"Go to this page and approve some amount of tokens. Function: Approve Prameters: _spender: address of smartcontract, which is 0x12DCBf79BE178479870A473A99d91f535ed960AD _value: approved amount, should be bumped by e^10 Note: Please approve more than 1token. In the following example, 100 PPC token was approved: Example of approve 100 PPC on ropsten testnet","title":"1.  Approve Swap Transaction"},{"location":"guides/concepts/atomic-swaps.html#2-call-htlt-function-from-ethereum","text":"Go to smartcontract and call HTLT function Function: htlt Prameters: _randomNumberHash: SHA256(randomNumber||timestamp), randomNumber is 32-length random byte array _timestamp: it should be about 10 mins span around current timestamp _heightSpan: it's a customized filed for deputy operator. it should be more than 200 for this deputy. _recipientAddr: deputy address on Ethereum, it's 0x1C002969Fe201975eD8F054916b071672326858e for this one _bep2SenderAddr: omit this field with 0x0 _bep2RecipientAddr: Decode your testnet address from bech32 encoded to hex, for example: 0xc41f2a85e1d3629637de1222017dce46c6c8e4b9 _outAmount: approved amount, should be bumped by e^10 _bep2Amount: _outAmount * exchange rate, the default rate is 1 Example of htlt transaction","title":"2. Call HTLT function From Ethereum"},{"location":"guides/concepts/atomic-swaps.html#3-deputy-call-htlt-on-genesys-chain","text":"Then, Deputy will send HTLT transaction here","title":"3. Deputy Call HTLT on Genesys Chain"},{"location":"guides/concepts/atomic-swaps.html#4-claim-htlt-on-genesys-chain","text":"Get the swapID on Genesys Chain ./eth-cli token query-swapIDs-by-recipient --recipient-addr tbnb1cs0j4p0p6d3fvd77zg3qzlwwgmrv3e9e63423w --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 [ \"12aacc3bdc2cef97e8e45cc9b409796df57904a4e9c76863ad8420ff75f13128\" ] You can also get swapID by calculateSwapID in javascript-sdk . It requires three parameters: Name Type Description Example randomNumberHash string randomNumberHash in client HTLT transaction on Ethereum 5a3728a8f4ecb8b4cb0b983a9441b7d69f95229c4aa531e6e3827d7c19beac82 sender string deputy bep2 address tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr senderOtherChain string client ethereum address 0x133d144f52705ceb3f5801b63b9ebccf4102f5ed Query the swap by swapID { \"from\": \"tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr\", \"to\": \"tbnb1cs0j4p0p6d3fvd77zg3qzlwwgmrv3e9e63423w\", \"out_amount\": [ { \"denom\": \"PPC-00A\", \"amount\": \"9999999000\" } ], \"in_amount\": null, \"expected_income\": \"\", \"recipient_other_chain\": \"0x1C002969Fe201975eD8F054916b071672326858e\", \"random_number_hash\": \"5a3728a8f4ecb8b4cb0b983a9441b7d69f95229c4aa531e6e3827d7c19beac82\", \"random_number\": \"\", \"timestamp\": \"1569497984\", \"cross_chain\": true, \"expire_height\": \"41380567\", \"index\": \"1947\", \"closed_time\": \"\", \"status\": \"Open\" } Verify parameters in the swap: random_number_hash must equal to the randomNumberHash in client HTLT transaction on ethereum to must equals to client wallet address timestamp must equal to the timestamp in client HTLT transaction on ethereum out_amount should be reasonable. Please note that the decimals of bep2 tokens is 8, the out_amount should be something around 10000000000:PPC, deputy will deduct some fees. expire_height must not be passed and should be enough for send claim transaction Send claim transaction on Genesys Chain ./eth-cli token claim --swap-id 12aacc3bdc2cef97e8e45cc9b409796df57904a4e9c76863ad8420ff75f13128 --random-number <random-number> --from <from-key> --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Example of claim tx on testnet","title":"4. Claim HTLT on Genesys Chain"},{"location":"guides/concepts/atomic-swaps.html#5-deputy-claim-erc20-token","text":"Deputy will claim ERC20 tokens afterwards with claim transaction","title":"5. Deputy Claim ERC20 Token"},{"location":"guides/concepts/atomic-swaps.html#6-demo-for-client-app-swap-erc20-to-bep2","text":"This is a javascript implementation for client app to swap PPC to PPC-00A with deputy. const erc20ContractAddr = \"0xd93395b2771914e1679155f3ea58c41d89d96098\" const swapContractAddr = \"0x12DCBf79BE178479870A473A99d91f535ed960AD\" const deputyEthWalletAddr = \"0x1C002969Fe201975eD8F054916b071672326858e\" const deputyGSYSWalletAddr = \"tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr\" const clientEthWalletAddr = \"0xfA5E36a04EeF3152092099F352DDbe88953bB540\" const clientEthWalletKey = new Buffer ( \"89A0F0E0732ACAA7AD37C9E6D7A9798ECCE6940C63FF0290A58B1C1C1697486A\" , \"hex\" ) const clientBnbWalletAddr = \"tbnb17vwyu8npjj5pywh3keq2lm7d4v76n434pwd8av\" const clientBnbWalletMnemonic = \"lawsuit margin siege phrase fabric matrix like picnic day thrive correct velvet stool type broom upon flee fee ten senior install wrestle soap sick\" const web3 = new Web3 ( new Web3 . providers . HttpProvider ( \"https://ropsten.infura.io/v3/1c5b38a27f92410cb5feb13b6efb2e14\" )) const bnbClient = new BncClient ( \"https://testnet-dex.genesys.network\" ) await bnbClient . initChain () bnbClient . setPrivateKey ( crypto . getPrivateKeyFromMnemonic ( clientBnbWalletMnemonic )) bnbClient . useDefaultSigningDelegate () bnbClient . useDefaultBroadcastDelegate () const bnbRPC = new rpcClient ( \"https://seed-pre-s3.genesys.network\" , \"testnet\" ) const erc20Contract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"name\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"approve\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_evilUser\" , \"type\" : \"address\" }], \"name\" : \"addBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"totalSupply\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_from\" , \"type\" : \"address\" },{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transferFrom\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"decimals\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_addedValue\" , \"type\" : \"uint256\" }], \"name\" : \"increaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"unpause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"isPauser\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_maker\" , \"type\" : \"address\" }], \"name\" : \"getBlackListStatus\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"paused\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renouncePauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"who\" , \"type\" : \"address\" }], \"name\" : \"balanceOf\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renounceOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"addPauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"pause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"owner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"isOwner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"symbol\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_subtractedValue\" , \"type\" : \"uint256\" }], \"name\" : \"decreaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transfer\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"issue\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"redeem\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_owner\" , \"type\" : \"address\" },{ \"name\" : \"_spender\" , \"type\" : \"address\" }], \"name\" : \"allowance\" , \"outputs\" : [{ \"name\" : \"remaining\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"name\" : \"isBlackListed\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_clearedUser\" , \"type\" : \"address\" }], \"name\" : \"removeBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"transferOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_blackListedUser\" , \"type\" : \"address\" }], \"name\" : \"destroyBlackFunds\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_initialSupply\" , \"type\" : \"uint256\" },{ \"name\" : \"_name\" , \"type\" : \"string\" },{ \"name\" : \"_symbol\" , \"type\" : \"string\" },{ \"name\" : \"_decimals\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Issue\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Redeem\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_blackListedUser\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"_balance\" , \"type\" : \"uint256\" }], \"name\" : \"DestroyedBlackFunds\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"AddedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"RemovedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Paused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Unpaused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"from\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"to\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Transfer\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"owner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"spender\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Approval\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"previousOwner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"OwnershipTransferred\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserAdded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserRemoved\" , \"type\" : \"event\" }], erc20ContractAddr ) const swapContract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"ERC20ContractAddr\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"isSwapExist\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refund\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_swapSender\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" }], \"name\" : \"calSwapID\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bytes32\" }], \"payable\" : false , \"stateMutability\" : \"pure\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"claim\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_heightSpan\" , \"type\" : \"uint256\" },{ \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_bep2RecipientAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"htlt\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"claimable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refundable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"queryOpenSwap\" , \"outputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_sender\" , \"type\" : \"address\" },{ \"name\" : \"_recipient\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_erc20Contract\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"indexed\" : false , \"name\" : \"_bep2Addr\" , \"type\" : \"bytes20\" },{ \"indexed\" : false , \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"HTLT\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" }], \"name\" : \"Refunded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"Claimed\" , \"type\" : \"event\" }], swapContractAddr ) //-------------------------------------------- //Step1 approve erc20 to swap contract address //-------------------------------------------- const approveData = erc20Contract . methods . increaseAllowance ( swapContractAddr , 10000000000 ). encodeABI () let nonce = await web3 . eth . getTransactionCount ( clientEthWalletAddr , 'pending' ) let gasPrice = await web3 . eth . getGasPrice () let gasLimit = 3000000 let rawTx = { nonce : web3 . utils . toHex ( nonce ), gasPrice : web3 . utils . toHex ( gasPrice ), gasLimit : web3 . utils . toHex ( gasLimit ), to : erc20ContractAddr , value : '0x00' , data : approveData } var ethereumjs = require ( 'ethereumjs-tx' ) var signTx = new ethereumjs ( rawTx ) signTx . sign ( clientEthWalletKey ) var serializedTx = signTx . serialize (); web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' )). on ( 'receipt' , console . log ) await wait ( 20000 ) //---------------------------------------------------------------------------- //Step2 call swap contract to send htlt transaction on Ethereum //---------------------------------------------------------------------------- const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" const timestamp = Math . floor ( Date . now () / 1000 ) const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ). toString ( \"hex\" ) const heightSpan = 1000 const hexEncodingClientGSYSaddr = '0x' + crypto . decodeAddress ( clientBnbWalletAddr ). toString ( \"hex\" ) const amount = 10000000000 // 10000000000:PPC\uff0c decimal is 10 const expectedIncome = 99999000 //\"99999000:PPC-00A\", decimal is 8, deputy will deduct swap fee, the swap fee is 1000:PPC-00A const htltData = swapContract . methods . htlt ( \"0x\" + randomNumberHash , timestamp , heightSpan , deputyEthWalletAddr , \"0x0\" , hexEncodingClientGSYSaddr , amount , expectedIncome ). encodeABI () nonce = await web3 . eth . getTransactionCount ( clientEthWalletAddr , 'pending' ) gasPrice = await web3 . eth . getGasPrice () gasLimit = 3000000 rawTx = { nonce : web3 . utils . toHex ( nonce ), gasPrice : web3 . utils . toHex ( gasPrice ), gasLimit : web3 . utils . toHex ( gasLimit ), to : swapContractAddr , value : '0x00' , data : htltData } ethereumjs = require ( 'ethereumjs-tx' ) signTx = new ethereumjs ( rawTx ) signTx . sign ( clientEthWalletKey ) serializedTx = signTx . serialize (); web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' )). on ( 'receipt' , console . log ) await wait ( 20000 ) //---------------------------------------------------------------------------- //Step3 query swap created by deputy on Genesys Chain and verify swap parameters //---------------------------------------------------------------------------- const swapID = calculateSwapID ( randomNumberHash . replace ( \"0x\" , \"\" ), deputyGSYSWalletAddr , clientEthWalletAddr ). toString () console . log ( swapID ) let atomicSwapList = await bnbClient . getSwapByRecipient ( clientBnbWalletAddr , 1000 , 0 ) while ( atomicSwapList . result . atomicSwaps [ 0 ]. swapId != swapID ) { console . log ( \"Waiting for the atomic swap created by deputy\" ) await wait ( 5000 ) atomicSwapList = await bnbClient . getSwapByRecipient ( clientBnbWalletAddr , 1000 , 0 ) } const atomicSwap = await bnbClient . getSwapByID ( swapID ) console . log ( atomicSwap ) const status = await bnbRPC . status () expect ( atomicSwap . result . toAddr ). toBe ( clientBnbWalletAddr ) expect ( atomicSwap . result . randomNumberHash ). toBe ( randomNumberHash . replace ( \"0x\" , \"\" )) expect ( atomicSwap . result . timestamp ). toBe ( timestamp ) expect ( atomicSwap . result . outAmount ). toBe ( \"99999000:PPC-00A\" ) expect ( Number ( atomicSwap . result . expireHeight )). toBeGreaterThan ( Number ( status . sync_info . latest_block_height ) + 100 ) //---------------------------------------------------------------------------- //Step4 claim on Genesys Chain //---------------------------------------------------------------------------- const res = await bnbClient . swap . claimHTLT ( clientBnbWalletAddr , swapID , randomNumber ) console . log ( res ) //---------------------------------------------------------------------------- //If step3 or step4 are failed and the expire height on Ethereum is passed, try to call refund method on Ethereum //----------------------------------------------------------------------------","title":"6. Demo for Client APP: swap erc20 to bep2"},{"location":"guides/concepts/atomic-swaps.html#swap-tokens-from-genesys-chain-to-ethereum","text":"","title":"Swap Tokens from Genesys Chain to Ethereum"},{"location":"guides/concepts/atomic-swaps.html#1-send-htlt-transaction-from-genesys-chain","text":"Please read this section to generate a valid HTLT transaction. Please write down the randomNumber and randomNumberHash . ./eth-cli token HTLT --from atomic --recipient-addr tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr --chain-id GSYS-Chain-Ganges --height-span 10000 --amount 9900000000:PPC-00A --expected-income 9900000000:PPC --recipient-other-chain 0x133D144F52705cEb3f5801B63b9EBcCF4102f5Ed --cross-chain --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 Random number: 4811959406ea3e69721d944d308880ec41323b7f89e51a78df3693348779315e Timestamp: 1569578936 Random number hash: b03f256c9efdb97b9815faa1417e1da4cca7672e0bb26e4e7d9bfc82d0f1f15e Committed at block 634510 ( tx hash: 9DEF124E12DE123BA1CC75AA6E68F20CC48EBBE9D7693CE4D0416267C6C0F159, response: { Code:0 Data:[229 50 241 60 76 91 112 146 93 68 100 222 83 84 180 133 181 151 241 174 93 125 132 82 245 198 5 66 0 123 32 113] Log:Msg 0: swapID: f85dd907df0a5897927b949c0f9e2563d453ba698ff9941fed1ce91f8057afc2 ... ) Note: the swap amount must be positive. Please write down the random number , random number hash , swapID and timestamp for next steps. Example is here Then, you can query the the swap by SwapID : ./eth-cli token query-swap --swap-id f85dd907df0a5897927b949c0f9e2563d453ba698ff9941fed1ce91f8057afc2 --chain-id GSYS-Chain-Ganges --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 You can use this swapID for refund if the deputy doesn't send htlt transaction on ethereum with proper parameters.","title":"1. Send HTLT Transaction from Genesys Chain"},{"location":"guides/concepts/atomic-swaps.html#2-deputy-approve-tokens","text":"You should see that Deputy has approve enough amount of tokens for atomic swap.","title":"2.  Deputy Approve Tokens"},{"location":"guides/concepts/atomic-swaps.html#3-deputy-send-htlt-on-ethereum","text":"You should see that Deputy has sent the htlt transaction afterwards To get the swapID on Ethereum, you can check this page 0xd3bacf63906af5459ead39f27cae189e2f3e76fda34523714a4c61d76c79ee4e is the swapID on Ethereum.","title":"3. Deputy Send HTLT on Ethereum"},{"location":"guides/concepts/atomic-swaps.html#4-claim-erc20-tokens-on-ethereum","text":"You should see that Deputy has already approved enough tokens and In its event log , you should see the swapID . Before calling claim function on ethereum, clients should verify the parameters in the HTLT event. _randomNumberHash must equal to the randomNumberHash in client HTLT transaction on Genesys Chain _recipientAddr must equal to client ethereum wallet address _timestamp must equal to the timestamp in client HTLT transaction on Genesys Chain _outAmount should be reasonable. Please note that the decimals erc20 contract and deputy will deduct some fees. _expireHeight must not be passed and should be enough for send claim transaction Then, you can call the claim function: Function: claim Prameters: _swapID: this is get from event, you can also calculate it from calSwapID function in the contract. calSwapID(randomNumberHash, {deputy ethereum address}, {hex encoding client shree address}) _randomNumber: reveal your randomNumber Example is here","title":"4. Claim ERC20 Tokens on Ethereum"},{"location":"guides/concepts/atomic-swaps.html#5-deputy-claim-on-genesys-chain","text":"Claim HTLT transaction from Deputy is sent afterwards:","title":"5. Deputy Claim on Genesys Chain"},{"location":"guides/concepts/atomic-swaps.html#6-demo-for-client-app-swap-bep2-to-erc20","text":"This is a javascript implementation for client app to swap PPC-00A to PPC with deputy. const erc20ContractAddr = \"0xd93395b2771914e1679155f3ea58c41d89d96098\" const swapContractAddr = \"0x12DCBf79BE178479870A473A99d91f535ed960AD\" const deputyEthWalletAddr = \"0x1C002969Fe201975eD8F054916b071672326858e\" const deputyGSYSWalletAddr = \"tbnb1pk45lc2k7lmf0pnfa59l0uhwrvpk8shsema7gr\" const clientEthWalletAddr = \"0xfA5E36a04EeF3152092099F352DDbe88953bB540\" const clientEthWalletKey = new Buffer ( \"89A0F0E0732ACAA7AD37C9E6D7A9798ECCE6940C63FF0290A58B1C1C1697486A\" , \"hex\" ) const clientBnbWalletAddr = \"tbnb17vwyu8npjj5pywh3keq2lm7d4v76n434pwd8av\" const clientBnbWalletMnemonic = \"lawsuit margin siege phrase fabric matrix like picnic day thrive correct velvet stool type broom upon flee fee ten senior install wrestle soap sick\" const web3 = new Web3 ( new Web3 . providers . HttpProvider ( \"https://ropsten.infura.io/v3/1c5b38a27f92410cb5feb13b6efb2e14\" )) const bnbClient = new BncClient ( \"https://testnet-dex.genesys.network\" ) await bnbClient . initChain () bnbClient . setPrivateKey ( crypto . getPrivateKeyFromMnemonic ( clientBnbWalletMnemonic )) bnbClient . useDefaultSigningDelegate () bnbClient . useDefaultBroadcastDelegate () const bnbRPC = new rpcClient ( \"https://seed-pre-s3.genesys.network\" , \"testnet\" ) const erc20Contract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"name\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"approve\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_evilUser\" , \"type\" : \"address\" }], \"name\" : \"addBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"totalSupply\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_from\" , \"type\" : \"address\" },{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transferFrom\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"decimals\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_addedValue\" , \"type\" : \"uint256\" }], \"name\" : \"increaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"unpause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"isPauser\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_maker\" , \"type\" : \"address\" }], \"name\" : \"getBlackListStatus\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"paused\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renouncePauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"who\" , \"type\" : \"address\" }], \"name\" : \"balanceOf\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"renounceOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"addPauser\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [], \"name\" : \"pause\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"owner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"isOwner\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [], \"name\" : \"symbol\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"string\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_spender\" , \"type\" : \"address\" },{ \"name\" : \"_subtractedValue\" , \"type\" : \"uint256\" }], \"name\" : \"decreaseAllowance\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_to\" , \"type\" : \"address\" },{ \"name\" : \"_value\" , \"type\" : \"uint256\" }], \"name\" : \"transfer\" , \"outputs\" : [{ \"name\" : \"success\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"issue\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"redeem\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_owner\" , \"type\" : \"address\" },{ \"name\" : \"_spender\" , \"type\" : \"address\" }], \"name\" : \"allowance\" , \"outputs\" : [{ \"name\" : \"remaining\" , \"type\" : \"uint256\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"name\" : \"isBlackListed\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_clearedUser\" , \"type\" : \"address\" }], \"name\" : \"removeBlackList\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"transferOwnership\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_blackListedUser\" , \"type\" : \"address\" }], \"name\" : \"destroyBlackFunds\" , \"outputs\" : [], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_initialSupply\" , \"type\" : \"uint256\" },{ \"name\" : \"_name\" , \"type\" : \"string\" },{ \"name\" : \"_symbol\" , \"type\" : \"string\" },{ \"name\" : \"_decimals\" , \"type\" : \"uint8\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Issue\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"amount\" , \"type\" : \"uint256\" }], \"name\" : \"Redeem\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_blackListedUser\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"_balance\" , \"type\" : \"uint256\" }], \"name\" : \"DestroyedBlackFunds\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"AddedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_user\" , \"type\" : \"address\" }], \"name\" : \"RemovedBlackList\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Paused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : false , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"Unpaused\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"from\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"to\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Transfer\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"owner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"spender\" , \"type\" : \"address\" },{ \"indexed\" : false , \"name\" : \"value\" , \"type\" : \"uint256\" }], \"name\" : \"Approval\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"previousOwner\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"newOwner\" , \"type\" : \"address\" }], \"name\" : \"OwnershipTransferred\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserAdded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"account\" , \"type\" : \"address\" }], \"name\" : \"PauserRemoved\" , \"type\" : \"event\" }], erc20ContractAddr ) const swapContract = new web3 . eth . Contract ([{ \"constant\" : true , \"inputs\" : [], \"name\" : \"ERC20ContractAddr\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"isSwapExist\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refund\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_swapSender\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" }], \"name\" : \"calSwapID\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bytes32\" }], \"payable\" : false , \"stateMutability\" : \"pure\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"claim\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : false , \"inputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_heightSpan\" , \"type\" : \"uint256\" },{ \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"name\" : \"_bep2SenderAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_bep2RecipientAddr\" , \"type\" : \"bytes20\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"htlt\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"claimable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"refundable\" , \"outputs\" : [{ \"name\" : \"\" , \"type\" : \"bool\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"constant\" : true , \"inputs\" : [{ \"name\" : \"_swapID\" , \"type\" : \"bytes32\" }], \"name\" : \"queryOpenSwap\" , \"outputs\" : [{ \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"name\" : \"_sender\" , \"type\" : \"address\" },{ \"name\" : \"_recipient\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"name\" : \"_erc20Contract\" , \"type\" : \"address\" }], \"payable\" : false , \"stateMutability\" : \"nonpayable\" , \"type\" : \"constructor\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_timestamp\" , \"type\" : \"uint64\" },{ \"indexed\" : false , \"name\" : \"_bep2Addr\" , \"type\" : \"bytes20\" },{ \"indexed\" : false , \"name\" : \"_expireHeight\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_outAmount\" , \"type\" : \"uint256\" },{ \"indexed\" : false , \"name\" : \"_bep2Amount\" , \"type\" : \"uint256\" }], \"name\" : \"HTLT\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" }], \"name\" : \"Refunded\" , \"type\" : \"event\" },{ \"anonymous\" : false , \"inputs\" : [{ \"indexed\" : true , \"name\" : \"_msgSender\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_recipientAddr\" , \"type\" : \"address\" },{ \"indexed\" : true , \"name\" : \"_swapID\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumberHash\" , \"type\" : \"bytes32\" },{ \"indexed\" : false , \"name\" : \"_randomNumber\" , \"type\" : \"bytes32\" }], \"name\" : \"Claimed\" , \"type\" : \"event\" }], swapContractAddr ) //-------------------------------------------- //Step1 send htlt on Genesys Chain //-------------------------------------------- const randomNumber = \"e8eae926261ab77d018202434791a335249b470246a7b02e28c3b2fb6ffad8f3\" const timestamp = Math . floor ( Date . now () / 1000 ) const randomNumberHash = calculateRandomNumberHash ( randomNumber , timestamp ). toString ( \"hex\" ) const heightSpan = 10000 const amount = [{ denom : \"PPC-00A\" , amount : 100000000 }] const expectedIncome = \"9999990000:PPC\" //\"9999990000:PPC\", decimal is 10, deputy will deduct swap fee, the swap fee is 10000:PPC bnbClient . swap . HTLT ( clientBnbWalletAddr , deputyGSYSWalletAddr , clientEthWalletAddr , \"\" , randomNumberHash , timestamp , amount , expectedIncome , heightSpan , true ) await wait ( 1000 ) //---------------------------------------------------------------------------- //Step2 query swap created by deputy on Ethereum and verify swap parameters //---------------------------------------------------------------------------- const hexEncodingClientGSYSaddr = '0x' + crypto . decodeAddress ( clientBnbWalletAddr ). toString ( \"hex\" ) const swapID = await swapContract . methods . calSwapID ( \"0x\" + randomNumberHash , deputyEthWalletAddr , hexEncodingClientGSYSaddr ). call () console . log ( swapID ) let openSwap = await swapContract . methods . queryOpenSwap ( swapID ). call () while ( openSwap . _randomNumberHash == '0x0000000000000000000000000000000000000000000000000000000000000000' ) { console . log ( \"Waiting for the atomic swap created by deputy\" ) await wait ( 5000 ) openSwap = await swapContract . methods . queryOpenSwap ( swapID ). call () } let ethBlock = await web3 . eth . getBlock ( 'latest' ) let ethLatestHeight = ethBlock . number expect ( openSwap . _randomNumberHash ). toBe ( \"0x\" + randomNumberHash ) expect ( Number ( openSwap . _timestamp )). toBe ( timestamp ) expect ( Number ( openSwap . _outAmount )). toBe ( 9999990000 ) expect ( openSwap . _recipient ). toBe ( clientEthWalletAddr ) expect ( Number ( openSwap . _expireHeight )). toBeGreaterThan ( Number ( ethLatestHeight ) + 20 ) //---------------------------------------------------------------------------- //Step3 claim on Ethereum //---------------------------------------------------------------------------- const claimData = swapContract . methods . claim ( swapID , \"0x\" + randomNumber ). encodeABI () let nonce = await web3 . eth . getTransactionCount ( clientEthWalletAddr , 'pending' ) let gasPrice = await web3 . eth . getGasPrice () let gasLimit = 3000000 let rawTx = { nonce : web3 . utils . toHex ( nonce ), gasPrice : web3 . utils . toHex ( gasPrice ), gasLimit : web3 . utils . toHex ( gasLimit ), to : swapContractAddr , value : '0x00' , data : claimData } var ethereumjs = require ( 'ethereumjs-tx' ) var signTx = new ethereumjs ( rawTx ) signTx . sign ( clientEthWalletKey ) var serializedTx = signTx . serialize (); web3 . eth . sendSignedTransaction ( '0x' + serializedTx . toString ( 'hex' )). on ( 'receipt' , console . log ) await wait ( 20000 ) //---------------------------------------------------------------------------- //If step2 or step3 are failed and the expire height on Genesys Chain is passed, try to send refundHTLT transaction on Genesys Chain //----------------------------------------------------------------------------","title":"6. Demo for Client APP: swap bep2 to erc20"},{"location":"guides/concepts/atomic-swaps.html#swap-between-several-bep2-tokens","text":"","title":"Swap between Several BEP2 tokens"},{"location":"guides/concepts/atomic-swaps.html#swap-between-several-bep2-tokens-fails","text":"","title":"Swap between Several BEP2 tokens fails"},{"location":"guides/concepts/bc-bridge.html","text":"BC <-> GSYS Token Bridge Note Please note that BC <-> GSYS Token Bridge is a module of Genesys Chain fullnode to facilitate cross-chain transfer between Genesys Chain and Genesys Chain, while GSYS Bridge , a bridge service providing access to inter-blockchain liquidity for Genesys Chain, Genesys Chain decentralized applications, and bring valuable assets to Genesys Chain ecosystems. What is BC <-> GSYS bridge BC <-> GSYS token bridge for self transfers of BEP2 tokens to BLUE20 (ERC20 representation). The BC <-> GSYS bridge connects two chains (BC and TC). When a user deposits BEP2 into the BC <-> GSYS bridge contract contract on BC they get the same amount of BLUE20 tokens on TC, and they can convert them back as well. A purely-code-controlled escrow account is a kind of account which is derived from a hard-coded string in shree chain protocol. This kind of account doesn't have its own private key and it's only controlled by code in protocol. The code for calculating escrow account is the same as how it's done in cosmos-sdk : AtomicSwapCoinsAccAddr = sdk.AccAddress(crypto.AddressHash([]byte(\"Genesys ChainPegAccount\"))) The account for mainnet is: bnb1v8vkkymvhe2sf7gd2092ujc6hweta38xadu2pj and the account for testnet is: tbnb1v8vkkymvhe2sf7gd2092ujc6hweta38xnc4wpr . Once the swap is claimed or refunded, the fund will be transferred from the purely-code-controlled escrow account to client accounts. Fee Table Transaction Type Pay in GSYS BC <-> GSYS Bridge Bind 0.01 Transfer Out 0.01 BC <-> GSYS Bridge Bind Relayer Fee 0.01 Transfer Out Relayer Fee 0.01 Commands Download Please download eth-cli binary from here Bind Parameters for BC <-> GSYS bridge bind parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from alice account name Yes --symbol DEF-0E9 chain-id of the side chain the validator belongs to Yes --amount 1000000000 amount of tokens to bind Yes --contract-address 0x6aade9709155a8386c63c1d2e5939525b960b4e7 contract address of token in smart chain Yes --contract-decimals 18 decimals of token in smart chain Yes --expire-time 1594715271 timestamp of bind expire time Yes For example Mainnet eth-cli bridge bind --symbol DEF-0F9 --amount 6000000000000000 --expire-time 1594715271 --contract-decimals 18 --from alice --chain-id GSYS-Chain-Tigris --contract-address 0x6aade9709155a8386c63c1d2e5939525b960b4e7 --home ~/home_cli Unbind Parameters for BC <-> GSYS bridge unbind parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from alice account name Yes --symbol DEF-0E9 chain-id of the side chain the validator belongs to Yes For example Mainnet eth-cli bridge unbind --symbol DEF-0F9 --from alice --chain-id GSYS-Chain-Tigris --home ~/home_cli Transfer out Parameters for BC <-> GSYS bridge transfer-out parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from alice account name Yes --to 0xf9f609f9f4309f191654aa1fd691a6be6aefa7ac receiver address in smart chain Yes --amount 1000000000:GSYS (10 GSYS) amount of token to transfer Yes --expire-time 1594715271 timestamp of transfer out expire time Yes For example Mainnet eth-cli bridge transfer-out --to 0xf9f609f9f4309f191654aa1fd691a6be6aefa7ac --expire-time 1594715271 --chain-id GSYS-Chain-Tigris --from alice --amount 100000000 :DEF-0F9 --home ~/home_cli","title":"BC <-> GSYS Token Bridge"},{"location":"guides/concepts/bc-bridge.html#bc-gsys-token-bridge","text":"Note Please note that BC <-> GSYS Token Bridge is a module of Genesys Chain fullnode to facilitate cross-chain transfer between Genesys Chain and Genesys Chain, while GSYS Bridge , a bridge service providing access to inter-blockchain liquidity for Genesys Chain, Genesys Chain decentralized applications, and bring valuable assets to Genesys Chain ecosystems.","title":"BC &lt;-&gt; GSYS Token Bridge"},{"location":"guides/concepts/bc-bridge.html#what-is-bc-gsys-bridge","text":"BC <-> GSYS token bridge for self transfers of BEP2 tokens to BLUE20 (ERC20 representation). The BC <-> GSYS bridge connects two chains (BC and TC). When a user deposits BEP2 into the BC <-> GSYS bridge contract contract on BC they get the same amount of BLUE20 tokens on TC, and they can convert them back as well. A purely-code-controlled escrow account is a kind of account which is derived from a hard-coded string in shree chain protocol. This kind of account doesn't have its own private key and it's only controlled by code in protocol. The code for calculating escrow account is the same as how it's done in cosmos-sdk : AtomicSwapCoinsAccAddr = sdk.AccAddress(crypto.AddressHash([]byte(\"Genesys ChainPegAccount\"))) The account for mainnet is: bnb1v8vkkymvhe2sf7gd2092ujc6hweta38xadu2pj and the account for testnet is: tbnb1v8vkkymvhe2sf7gd2092ujc6hweta38xnc4wpr . Once the swap is claimed or refunded, the fund will be transferred from the purely-code-controlled escrow account to client accounts.","title":"What is BC &lt;-&gt; GSYS  bridge"},{"location":"guides/concepts/bc-bridge.html#fee-table","text":"Transaction Type Pay in GSYS BC <-> GSYS Bridge Bind 0.01 Transfer Out 0.01 BC <-> GSYS Bridge Bind Relayer Fee 0.01 Transfer Out Relayer Fee 0.01","title":"Fee Table"},{"location":"guides/concepts/bc-bridge.html#commands","text":"","title":"Commands"},{"location":"guides/concepts/bc-bridge.html#download","text":"Please download eth-cli binary from here","title":"Download"},{"location":"guides/concepts/bc-bridge.html#bind","text":"","title":"Bind"},{"location":"guides/concepts/bc-bridge.html#parameters-for-bc-gsys-bridge-bind","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from alice account name Yes --symbol DEF-0E9 chain-id of the side chain the validator belongs to Yes --amount 1000000000 amount of tokens to bind Yes --contract-address 0x6aade9709155a8386c63c1d2e5939525b960b4e7 contract address of token in smart chain Yes --contract-decimals 18 decimals of token in smart chain Yes --expire-time 1594715271 timestamp of bind expire time Yes","title":"Parameters for BC &lt;-&gt; GSYS  bridge bind"},{"location":"guides/concepts/bc-bridge.html#for-example","text":"Mainnet eth-cli bridge bind --symbol DEF-0F9 --amount 6000000000000000 --expire-time 1594715271 --contract-decimals 18 --from alice --chain-id GSYS-Chain-Tigris --contract-address 0x6aade9709155a8386c63c1d2e5939525b960b4e7 --home ~/home_cli","title":"For example"},{"location":"guides/concepts/bc-bridge.html#unbind","text":"","title":"Unbind"},{"location":"guides/concepts/bc-bridge.html#parameters-for-bc-gsys-bridge-unbind","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from alice account name Yes --symbol DEF-0E9 chain-id of the side chain the validator belongs to Yes","title":"Parameters for BC &lt;-&gt; GSYS  bridge unbind"},{"location":"guides/concepts/bc-bridge.html#for-example_1","text":"Mainnet eth-cli bridge unbind --symbol DEF-0F9 --from alice --chain-id GSYS-Chain-Tigris --home ~/home_cli","title":"For example"},{"location":"guides/concepts/bc-bridge.html#transfer-out","text":"","title":"Transfer out"},{"location":"guides/concepts/bc-bridge.html#parameters-for-bc-gsys-bridge-transfer-out","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from alice account name Yes --to 0xf9f609f9f4309f191654aa1fd691a6be6aefa7ac receiver address in smart chain Yes --amount 1000000000:GSYS (10 GSYS) amount of token to transfer Yes --expire-time 1594715271 timestamp of transfer out expire time Yes","title":"Parameters for BC &lt;-&gt; GSYS bridge transfer-out"},{"location":"guides/concepts/bc-bridge.html#for-example_2","text":"Mainnet eth-cli bridge transfer-out --to 0xf9f609f9f4309f191654aa1fd691a6be6aefa7ac --expire-time 1594715271 --chain-id GSYS-Chain-Tigris --from alice --amount 100000000 :DEF-0F9 --home ~/home_cli","title":"For example"},{"location":"guides/concepts/bc-slashing.html","text":"Slashing Slashing Slashing is part of the on-chain governance, to ensure the malicious or negative behaviors are punished. GSYS slash can be submitted by anyone. The transaction submission requires slash evidence and cost fees but also brings a larger reward when it is successful. So far there are two slashable cases. Double Sign Anyone can submit a slash request on BC with the evidence of Double Sign of TC Evidence Validation Two block headers have same height and same parent block hash Two block headers are sealed by the same validator Two signatures of these two blocks must not be the same The time of these two blocks must be within the validity of the evidence, which is 24 hours If the evidence is valid: 1000GSYS would be slashed from the self-delegated GSYS of the validator If the self-delegator\u2019s stake amount on the validator is less than 1000GSYS, then the unbonding delegation balance would be slashed if it exists until totally 1000GSYS slashed from self-delegator of the validator. However, if all the slashed GSYS is less than 1000, all the remaining stake of the self-delegator will be slashed 100 of slashed GSYS would allocate to the submitter as a reward The rest of slashed GSYS will allocate to the custody addresses of which validators would take part in the next distribution. If no matched validators found, then the rest of slashed GSYS will allocate to validators on BC as block fee Set the validator \u2018jailed\u2019 with duration of 7 days, and remove it from validator set by an instance GSYS validator set update Cross-Chain update Inavailability There can be an internal smart contract responsible for recording the missed blocking metrics of each validator. If a validator missed more than 50 blocks in 24h, the blocking reward for validator will not be relayed to BC for distribution but shared with other better validators. If it missed more than 150 blocks in 24h, then this will be propagated back to BC where another Slashing will happen: 50GSYS would be slashed from the self-delegated GSYS of the validator If the self-delegator\u2019s stake amount on the validator is less than 50GSYS, then the unbonding delegation balance would be slashed if it exists until totally 50GSYS slashed from self-delegator of the validator. However, if all the slashed GSYS is less than 1000, all the remaining stake of the self-delegator will be slashed 10 of slashed GSYS would allocate to the validators on BC as block fee The rest of slashed GSYS will allocate to the custody addresses of which validators would take part in the next distribution. If no matched validators found, then the rest of slashed GSYS will allocate to validators on BC as block fee Set the validator \u2018jailed\u2019 with duration of 2 days, and remove it from validator set by an instance GSYS validator set update Cross-Chain update Unjail The malicious validators who are slashed by the previous cases will be set to jailed along with a duration setting as well due to the malicious or negative behaviors. We can set it to \u2018unjailed\u2019 by sending a side-unjail transaction if the validation passed. When your validator is unjailed on shree chain, it must wait for the next UTC 0:00 to join validatorsest again. Transaction Validation validator address must not be empty side chain id exists self-delegation of the validator exists and the tokens of it must be greater than the min-self-delegation setting by 20000GSYS the validator is in \u2018jailed\u2019 now already passed the duration set when \u2018jailed\u2019 happened Fee Table Transaction Type Pay in GSYS Unjail A Smart Chain Validator 1 Submit Byzaitine Behavior Evidence of A Smart Chain Validator 10 Commands Download Binary Please download eth-cli binary from here Submit GSYS evidence Slashing validators of GSYS for the malicious behavior of double-sign by submitting evidence consisting of two block headers with same height but signed by one signer Parameters for slashing nc-submit-evidence parameter name example comments required --chan-id GSYS-Chain-Tigris the chain id of shree chain Yes --from bnb19awsmku5ch689lp0rj0c6su7x0n5wxhjm65hdd Name or address of private key with which to sign Yes --evidence [{\"difficulty\":\"0x2\",\"extraData\":\"0xd98301...},{\"difficulty\":\"0x3\",\"extraData\":\"0xd64372...}] Evidence details, including two bsc block headers with json format Option --evidence-file /user/evidence.json File of evidence details, if evidence-file is not empty, --evidence will be ignored Option Examples Mainnet eth-cli slashing nc-submit-evidence --from = bnb19awsmku5ch689lp0rj0c6su7x0n5wxhjm65hdd --evidence =[{ \"parentHash\" : \"0x6116de25352c93149542e950162c7305f207bbc17b0eb725136b78c80aed79cc\" , \"sha3Uncles\" : \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\" , \"miner\" : \"0x0000000000000000000000000000000000000000\" , \"stateRoot\" : \"0xe7cb9d2fd449f7bd11126bff55266e7b74936f2f230e21d44d75c04b7780dfeb\" , \"transactionsRoot\" : \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"receiptsRoot\" : \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"logsBloom\" : \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"difficulty\" : \"0x20000\" , \"number\" : \"0x1\" , \"gasLimit\" : \"0x47e7c4\" , \"gasUsed\" : \"0x0\" , \"timestamp\" : \"0x5eb2a363\" , \"extraData\" : \"0x0000000000000000000000000000000000000000000000000000000000000000a2852203a9da8bb555ec98a78c66365437bb1dde6707a08032e9eb916a8a454e37a1fffeab272bcffc2fc1d82aee6f3124bbdc8ed884efcbadfb6ff862cf4c3801\" , \"mixHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"nonce\" : \"0x0000000000000000\" , \"hash\" : \"0xd977f1acfd035cf717193a9c3a2351cdccdc2ea0719aff871dade0e8daf8069d\" } , { \"parentHash\" : \"0x6116de25352c93149542e950162c7305f207bbc17b0eb725136b78c80aed79cc\" , \"sha3Uncles\" : \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\" , \"miner\" : \"0x0000000000000000000000000000000000000000\" , \"stateRoot\" : \"0xe7cb9d2fd449f7bd11126bff55266e7b74936f2f230e21d44d75c04b7780dfeb\" , \"transactionsRoot\" : \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"receiptsRoot\" : \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"logsBloom\" : \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"difficulty\" : \"0x20000\" , \"number\" : \"0x1\" , \"gasLimit\" : \"0x47e7c4\" , \"gasUsed\" : \"0x64\" , \"timestamp\" : \"0x5eb2a363\" , \"extraData\" : \"0x00000000000000000000000000000000000000000000000000000000000000005eab7a9bf40635d056ccab45ac0d8b4e99be4b4ed859e4246f651b95c0adaacc050760a0afc2d9383f821baab7f995cde07271f286c4805095b413e7ad69d9f401\" , \"mixHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"nonce\" : \"0x0000000000000000\" , \"hash\" : \"0x917c38a507c9807426fc9e3e9e8ded2db07c7f61070bd1c7b57b9df287e8f7b2\" }] --chain-id = test-chain-8d7sJz --home ~/home_cli Side chain Unjail Parameters for slashing side-unjail parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from bnb19awsmku5ch689lp0rj0c6su7x0n5wxhjm65hdd This address has to be the operator address of the validator to be unjailed. Name or address of private key with which to sign. Yes --side-chain-id TC-XXX chain-id of the side chain the validator belongs to Yes For example Mainnet eth-cli slashing side-unjail --from bnb19awsmku5ch689lp0rj0c6su7x0n5wxhjm65hdd --side-chain-id = bsc --chain-id = test-chain-8d7sJz --home ~/home_cli Query side chain Signing Info Parameters for slashing side-signing-info parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id TC-XXX chain-id of the side chain the validator belongs to Yes For example Mainnet eth-cli slashing side-signing-info 0x625448c3f21AB4636bBCef84Baaf8D6cCdE13c3F --side-chain-id = bsc --chain-id = test-chain-8d7sJz --home ~/home_cli Query side chain slash history Parameters for slashing side-slash-history [validator-sideConsAddr] parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --infraction-height 100 infraction height Yes --infraction-type DoubleSign infraction type, 'DoubleSign;Downtime' Yes --side-chain-id TC-XXX chain-id of the side chain the validator belongs to Yes For example Mainnet eth-cli slashing side-slash-history 0x625448c3f21AB4636bBCef84Baaf8D6cCdE13c3F --infraction-height 100 --infraction-type DoubleSign --side-chain-id = bsc --chain-id = test-chain-8d7sJz --home ~/home_cli Query side chain slash histories Parameters for slashing side-slash-histories parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --infraction-type DoubleSign infraction type, 'DoubleSign;Downtime' Option --side-chain-id TC-XXX chain-id of the side chain the validator belongs to Yes For example Mainnet eth-cli slashing side-slash-histories 0x625448c3f21AB4636bBCef84Baaf8D6cCdE13c3F --infraction-type DoubleSign --side-chain-id = bsc --chain-id = test-chain-8d7sJz --home ~/home_cli Query all side chain slash histories(for internal) Parameters for slashing side-all-slash-histories parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id TC-XXX chain-id of the side chain the validator belongs to Yes For example Mainnet eth-cli slashing side-all-slash-histories --side-chain-id = bsc --chain-id = test-chain-8d7sJz --home ~/home_cli","title":"Slashing"},{"location":"guides/concepts/bc-slashing.html#slashing","text":"","title":"Slashing"},{"location":"guides/concepts/bc-slashing.html#slashing_1","text":"Slashing is part of the on-chain governance, to ensure the malicious or negative behaviors are punished. GSYS slash can be submitted by anyone. The transaction submission requires slash evidence and cost fees but also brings a larger reward when it is successful. So far there are two slashable cases.","title":"Slashing"},{"location":"guides/concepts/bc-slashing.html#double-sign","text":"Anyone can submit a slash request on BC with the evidence of Double Sign of TC","title":"Double Sign"},{"location":"guides/concepts/bc-slashing.html#evidence-validation","text":"Two block headers have same height and same parent block hash Two block headers are sealed by the same validator Two signatures of these two blocks must not be the same The time of these two blocks must be within the validity of the evidence, which is 24 hours If the evidence is valid: 1000GSYS would be slashed from the self-delegated GSYS of the validator If the self-delegator\u2019s stake amount on the validator is less than 1000GSYS, then the unbonding delegation balance would be slashed if it exists until totally 1000GSYS slashed from self-delegator of the validator. However, if all the slashed GSYS is less than 1000, all the remaining stake of the self-delegator will be slashed 100 of slashed GSYS would allocate to the submitter as a reward The rest of slashed GSYS will allocate to the custody addresses of which validators would take part in the next distribution. If no matched validators found, then the rest of slashed GSYS will allocate to validators on BC as block fee Set the validator \u2018jailed\u2019 with duration of 7 days, and remove it from validator set by an instance GSYS validator set update Cross-Chain update","title":"Evidence Validation"},{"location":"guides/concepts/bc-slashing.html#inavailability","text":"There can be an internal smart contract responsible for recording the missed blocking metrics of each validator. If a validator missed more than 50 blocks in 24h, the blocking reward for validator will not be relayed to BC for distribution but shared with other better validators. If it missed more than 150 blocks in 24h, then this will be propagated back to BC where another Slashing will happen: 50GSYS would be slashed from the self-delegated GSYS of the validator If the self-delegator\u2019s stake amount on the validator is less than 50GSYS, then the unbonding delegation balance would be slashed if it exists until totally 50GSYS slashed from self-delegator of the validator. However, if all the slashed GSYS is less than 1000, all the remaining stake of the self-delegator will be slashed 10 of slashed GSYS would allocate to the validators on BC as block fee The rest of slashed GSYS will allocate to the custody addresses of which validators would take part in the next distribution. If no matched validators found, then the rest of slashed GSYS will allocate to validators on BC as block fee Set the validator \u2018jailed\u2019 with duration of 2 days, and remove it from validator set by an instance GSYS validator set update Cross-Chain update","title":"Inavailability"},{"location":"guides/concepts/bc-slashing.html#unjail","text":"The malicious validators who are slashed by the previous cases will be set to jailed along with a duration setting as well due to the malicious or negative behaviors. We can set it to \u2018unjailed\u2019 by sending a side-unjail transaction if the validation passed. When your validator is unjailed on shree chain, it must wait for the next UTC 0:00 to join validatorsest again.","title":"Unjail"},{"location":"guides/concepts/bc-slashing.html#transaction-validation","text":"validator address must not be empty side chain id exists self-delegation of the validator exists and the tokens of it must be greater than the min-self-delegation setting by 20000GSYS the validator is in \u2018jailed\u2019 now already passed the duration set when \u2018jailed\u2019 happened","title":"Transaction Validation"},{"location":"guides/concepts/bc-slashing.html#fee-table","text":"Transaction Type Pay in GSYS Unjail A Smart Chain Validator 1 Submit Byzaitine Behavior Evidence of A Smart Chain Validator 10","title":"Fee Table"},{"location":"guides/concepts/bc-slashing.html#commands","text":"","title":"Commands"},{"location":"guides/concepts/bc-slashing.html#download-binary","text":"Please download eth-cli binary from here","title":"Download Binary"},{"location":"guides/concepts/bc-slashing.html#submit-gsys-evidence","text":"Slashing validators of GSYS for the malicious behavior of double-sign by submitting evidence consisting of two block headers with same height but signed by one signer","title":"Submit GSYS evidence"},{"location":"guides/concepts/bc-slashing.html#parameters-for-slashing-nc-submit-evidence","text":"parameter name example comments required --chan-id GSYS-Chain-Tigris the chain id of shree chain Yes --from bnb19awsmku5ch689lp0rj0c6su7x0n5wxhjm65hdd Name or address of private key with which to sign Yes --evidence [{\"difficulty\":\"0x2\",\"extraData\":\"0xd98301...},{\"difficulty\":\"0x3\",\"extraData\":\"0xd64372...}] Evidence details, including two bsc block headers with json format Option --evidence-file /user/evidence.json File of evidence details, if evidence-file is not empty, --evidence will be ignored Option","title":"Parameters for  slashing nc-submit-evidence"},{"location":"guides/concepts/bc-slashing.html#examples","text":"Mainnet eth-cli slashing nc-submit-evidence --from = bnb19awsmku5ch689lp0rj0c6su7x0n5wxhjm65hdd --evidence =[{ \"parentHash\" : \"0x6116de25352c93149542e950162c7305f207bbc17b0eb725136b78c80aed79cc\" , \"sha3Uncles\" : \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\" , \"miner\" : \"0x0000000000000000000000000000000000000000\" , \"stateRoot\" : \"0xe7cb9d2fd449f7bd11126bff55266e7b74936f2f230e21d44d75c04b7780dfeb\" , \"transactionsRoot\" : \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"receiptsRoot\" : \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"logsBloom\" : \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"difficulty\" : \"0x20000\" , \"number\" : \"0x1\" , \"gasLimit\" : \"0x47e7c4\" , \"gasUsed\" : \"0x0\" , \"timestamp\" : \"0x5eb2a363\" , \"extraData\" : \"0x0000000000000000000000000000000000000000000000000000000000000000a2852203a9da8bb555ec98a78c66365437bb1dde6707a08032e9eb916a8a454e37a1fffeab272bcffc2fc1d82aee6f3124bbdc8ed884efcbadfb6ff862cf4c3801\" , \"mixHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"nonce\" : \"0x0000000000000000\" , \"hash\" : \"0xd977f1acfd035cf717193a9c3a2351cdccdc2ea0719aff871dade0e8daf8069d\" } , { \"parentHash\" : \"0x6116de25352c93149542e950162c7305f207bbc17b0eb725136b78c80aed79cc\" , \"sha3Uncles\" : \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\" , \"miner\" : \"0x0000000000000000000000000000000000000000\" , \"stateRoot\" : \"0xe7cb9d2fd449f7bd11126bff55266e7b74936f2f230e21d44d75c04b7780dfeb\" , \"transactionsRoot\" : \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"receiptsRoot\" : \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\" , \"logsBloom\" : \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"difficulty\" : \"0x20000\" , \"number\" : \"0x1\" , \"gasLimit\" : \"0x47e7c4\" , \"gasUsed\" : \"0x64\" , \"timestamp\" : \"0x5eb2a363\" , \"extraData\" : \"0x00000000000000000000000000000000000000000000000000000000000000005eab7a9bf40635d056ccab45ac0d8b4e99be4b4ed859e4246f651b95c0adaacc050760a0afc2d9383f821baab7f995cde07271f286c4805095b413e7ad69d9f401\" , \"mixHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"nonce\" : \"0x0000000000000000\" , \"hash\" : \"0x917c38a507c9807426fc9e3e9e8ded2db07c7f61070bd1c7b57b9df287e8f7b2\" }] --chain-id = test-chain-8d7sJz --home ~/home_cli","title":"Examples"},{"location":"guides/concepts/bc-slashing.html#side-chain-unjail","text":"","title":"Side chain Unjail"},{"location":"guides/concepts/bc-slashing.html#parameters-for-slashing-side-unjail","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from bnb19awsmku5ch689lp0rj0c6su7x0n5wxhjm65hdd This address has to be the operator address of the validator to be unjailed. Name or address of private key with which to sign. Yes --side-chain-id TC-XXX chain-id of the side chain the validator belongs to Yes","title":"Parameters for slashing side-unjail"},{"location":"guides/concepts/bc-slashing.html#for-example","text":"Mainnet eth-cli slashing side-unjail --from bnb19awsmku5ch689lp0rj0c6su7x0n5wxhjm65hdd --side-chain-id = bsc --chain-id = test-chain-8d7sJz --home ~/home_cli","title":"For example"},{"location":"guides/concepts/bc-slashing.html#query-side-chain-signing-info","text":"","title":"Query side chain Signing Info"},{"location":"guides/concepts/bc-slashing.html#parameters-for-slashing-side-signing-info","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id TC-XXX chain-id of the side chain the validator belongs to Yes","title":"Parameters for slashing side-signing-info"},{"location":"guides/concepts/bc-slashing.html#for-example_1","text":"Mainnet eth-cli slashing side-signing-info 0x625448c3f21AB4636bBCef84Baaf8D6cCdE13c3F --side-chain-id = bsc --chain-id = test-chain-8d7sJz --home ~/home_cli","title":"For example"},{"location":"guides/concepts/bc-slashing.html#query-side-chain-slash-history","text":"","title":"Query side chain slash history"},{"location":"guides/concepts/bc-slashing.html#parameters-for-slashing-side-slash-history-validator-sideconsaddr","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --infraction-height 100 infraction height Yes --infraction-type DoubleSign infraction type, 'DoubleSign;Downtime' Yes --side-chain-id TC-XXX chain-id of the side chain the validator belongs to Yes","title":"Parameters for slashing side-slash-history [validator-sideConsAddr]"},{"location":"guides/concepts/bc-slashing.html#for-example_2","text":"Mainnet eth-cli slashing side-slash-history 0x625448c3f21AB4636bBCef84Baaf8D6cCdE13c3F --infraction-height 100 --infraction-type DoubleSign --side-chain-id = bsc --chain-id = test-chain-8d7sJz --home ~/home_cli","title":"For example"},{"location":"guides/concepts/bc-slashing.html#query-side-chain-slash-histories","text":"","title":"Query side chain slash histories"},{"location":"guides/concepts/bc-slashing.html#parameters-for-slashing-side-slash-histories","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --infraction-type DoubleSign infraction type, 'DoubleSign;Downtime' Option --side-chain-id TC-XXX chain-id of the side chain the validator belongs to Yes","title":"Parameters for slashing side-slash-histories"},{"location":"guides/concepts/bc-slashing.html#for-example_3","text":"Mainnet eth-cli slashing side-slash-histories 0x625448c3f21AB4636bBCef84Baaf8D6cCdE13c3F --infraction-type DoubleSign --side-chain-id = bsc --chain-id = test-chain-8d7sJz --home ~/home_cli","title":"For example"},{"location":"guides/concepts/bc-slashing.html#query-all-side-chain-slash-historiesfor-internal","text":"","title":"Query all side chain slash histories(for internal)"},{"location":"guides/concepts/bc-slashing.html#parameters-for-slashing-side-all-slash-histories","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id TC-XXX chain-id of the side chain the validator belongs to Yes","title":"Parameters for slashing side-all-slash-histories"},{"location":"guides/concepts/bc-slashing.html#for-example_4","text":"Mainnet eth-cli slashing side-all-slash-histories --side-chain-id = bsc --chain-id = test-chain-8d7sJz --home ~/home_cli","title":"For example"},{"location":"guides/concepts/bc-staking.html","text":"Staking PoSA Consensus of Genesys Chain Genesys Chain is an innovative solution to bring programmability and interoperability to Genesys Chain . Genesys Chain relies on a system of 21 validators with Proof of Staked Authority (PoSA) consensus that can support short block time and lower fees. The most bonded validator candidates of staking will become validators and produce blocks. The double-sign detection and other slashing logic guarantee security, stability, and chain finality. Staking on Genesys Chain Ideally, Genesys Chain should build such staking and reward logic into the blockchain, and automatically distribute rewards as the blocking happens. Cosmos Hub , who also build on top of Tendermint consensus like Genesys Chain, works in this way. However, as GSYS wants to remain compatible with Ethereum as much as possible. On the other side, Genesys Chain already has a staking module and could be extended to support both BC and TC. In this way, all the staking related operations are recorded in BC. Once there are any changes about TC's validator set or voting power, the new message will be transferred to GSYS through cross-chain communication. Staking Economics The staking token is GSYS , as it is a native token on both blockchains anyway The staking, i.e. token bond and delegation actions and records for TC, happens on BC. The GSYS validator set is determined by its staking and delegation logic, via a staking module built on BC for TC, and propagated every day UTC 00:00 from BC to GSYS via Cross-Chain communication. The reward distribution happens on BC around every day UTC 00:00 after. Ranking Algorithm Validators are ranked by their power and operator address. The more its delegation tokens, the higher ranking is. If two validators get the same amount of delegated tokens, validator with smaller address bytes has higher ranking. Reward Distrubution Since GSYS uses PoSA as its consensus engine, all the delegators of validators can receive some share of the validators\u2019 reward. However, the rewards(fees) are collected on GSYS while the staking info is stored on BC. So the main idea is we transfer all the rewards from GSYS to BC once every day and execute the distribution on BC. Main Workflow: ValidatorSet is updated in BreatheBlock, the frequency is once a day. let\u2019s assume it happens on day N. The info of validator set changes of day N would be transmitted to NCthrough interchain communication. The validator set contract on GSYS would receive and update the new validatorset. After that, it would trigger several interchain transfer to transfer the fees that every previous validators collected in this period to their addresses on BC. we can see that fees belongs to the validators of day N-1. To make some room for the error handling, we distribute the fees of day N-1 in the next breathe block (day N+1). Details even if validator set or any their voting powers are not changed on that day, we still transmit the validator set info to TC. the validator set contract maintains the history of the fees that every validators collected after the previous period(We define the period as the time between two contract calls of validator set changes). The actual fees are collected on the contract address. the interchain transfer to send fees from the contract address to each validator\u2019s distribution address on BC. Note the distribution address is auto generated on BC when handling the create-validator tx, so no private key is corresponded to that address and no one except the distribution module can move the tokens on that address. This address is displayed as Distribution Addr in validator info. Validator Fee Address: tbnb15mgzha93ny878kuvjl0pnqmjygwccdadpw5dxf Operator Address: bva15mgzha93ny878kuvjl0pnqmjygwccdad08uecu Validator Consensus Pubkey: Jailed: false Status: Bonded Tokens: 5000000000000 Delegator Shares: 5000000000000 Description: { Elbrus \"\" www.genesys.network This is Elbrus org on chapel network. } Bond Height: 74158 Unbonding Height: 0 Minimum Unbonding Time: 1970 -01-01 00 :00:00 +0000 UTC Commission: { rate: 75000000 , maxRate: 90000000 , maxChangeRate: 3000000 , updateTime: 2020 -05-22 12 :24:19.478568234 +0000 UTC } Distribution Addr: tbnb1srkkfjk8qctvvy4s3cllhpnkz9679jphr30t2c Side Chain Id: chapel Consensus Addr on Side Chain: 0xF474Cf03ccEfF28aBc65C9cbaE594F725c80e12d Fee Addr on Side Chain: 0xe61a183325A18a173319dD8E19c8d069459E2175 we have a lower limit of the value of interchain transfer, at least the value can cover the transfer fee. Also, interchain transfer will only allow max 8 decimals for the amount. The tiny left part would be kept in the contract or put into the system reward pool. the reward: (totalfees * (1-commissionRate)) would be distributed in proportion to the delegations, the left part would be sent to the validator fee address. Error handling: if the cross-chain transfer failed, the tokens would be sent back to a specified address(i.e. the SideFeeAddr in the store section, validators can change this address via the EditValidator tx). After that, validators can manually deposit the tokens to its own DistributionAddr on BC via Transfer tx. We do not force the validator to do so, but it\u2019s an indicator that can help delegators choose validators. Fee Table Transaction Type Pay in GSYS Create A New Smart Chain Validator 10 Edit Smart Chain Validator Information 1 Delegate Smart Chain Validator 0.001 Redelegate Smart Chain Validator 0.003 Undelegate Smart Chain Validator 0.002 Commands Download Mainnet Please download eth-cli binary from here Testnet Please download eth-cli binary from here Create GSYS Validator Parameters for nc-create-validator parameter name example comment required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from bnb1xxx/tbnb1xxx address of private key with which to sign this tx, also be used as the validator operator address Yes --address-delegator bnb1xxx/tbnb1xxx optional, bech32 address of the self-delegator. if not provided, --from address will be used as self-delegator. No --amount 2000000000000:GSYS (means 20000 GSYS) self-delegation amount, it has 8 decimal places Yes --moniker myval1 validator name Yes --identity xxx optional identity signature (ex. UPort or Keybase) No --website www.example.com optional website No --details some details optional details No --commission-rate 80000000(that means 0.8 or 80%) The initial commission rate percentage, it has 8 decimal places. Yes --commission-max-rate 95000000 (0.95 or 95%) The maximum commission rate percentage, it has 8 decimal places. You can not update this rate. Yes --commission-max-change-rate 3000000 (0.03 or 3%) The maximum commission change rate percentage (per day). You can not update this rate. Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes --side-cons-addr 0x1234abcd consensus address of the validator on side chain, please use hex format prefixed with 0x Yes --side-fee-addr 0xabcd1234 address that validator collects fee rewards on side chain, please use hex format prefixed with 0x. Yes --home /path/to/cli_home home directory of eth-cli data and config, default to \u201c~/.eth-cli\u201d No Some address parameters we need to highlight here: Field Name Usage DelegatorAddr Self delegator address. For BC, this address also used to collect fees. ValidatorAddr validator operator\u2019s address, used in governance ops like voting. SideConsAddr block producer\u2019s address on side chain, i.e. consensus address. BC has another parameter named PubKey , here SideConsAddr replaced that for TC. Only GSYS validators need this parameter. SideFeeAddr fees are collected in this address on TC, Only GSYS validators need this parameter. Due to different token units, there are some GSYS left as dust when sending block rewards from Genesys Chain to Genesys Chain. Those GSYS will be sent to fee address. Examples If you want to create a validator with the same operator address and self-delegator address, you only need one signature for this transaction. Mainnet ## mainnet eth-cli staking nc-create-validator --chain-id GSYS-Chain-Tigris --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --amount 1000000000000 :GSYS --moniker bsc_v1 --identity \"xxx\" --website \"[www.example.](http://www.genesys.network)com\" --details \"bsc validator node 1\" --commission-rate 80000000 --commission-max-rate 95000000 --commission-max-change-rate 3000000 --side-chain-id bsc --side-cons-addr 0x9B24Ee0BfBf708b541fB65b6087D6e991a0D11A8 --side-fee-addr 0x5885d2A27Bd4c6D111B83Bc3fC359eD951E8E6F8 --home ~/home_cli ## testnet eth-cli staking nc-create-validator --chain-id GSYS-Chain-Ganges --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --amount 2000000000000 :GSYS --moniker bsc_v1 --identity \"xxx\" --website \"[www.example.](http://www.genesys.network)com\" --details \"bsc validator node 1\" --commission-rate 80000000 --commission-max-rate 95000000 --commission-max-change-rate 3000000 --side-chain-id chapel --side-cons-addr 0x9B24Ee0BfBf708b541fB65b6087D6e991a0D11A8 --side-fee-addr 0x5885d2A27Bd4c6D111B83Bc3fC359eD951E8E6F8 --home ~/home_cli Testnet ## mainnet eth-cli staking nc-create-validator --chain-id GSYS-Chain-Tigris --from tbnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --amount 2000000000000 :GSYS --moniker bsc_v1 --identity \"xxx\" --website \"[www.example.](http://www.genesys.network)com\" --details \"bsc validator node 1\" --commission-rate 80000000 --commission-max-rate 95000000 --commission-max-change-rate 3000000 --side-chain-id bsc --side-cons-addr 0x9B24Ee0BfBf708b541fB65b6087D6e991a0D11A8 --side-fee-addr 0x5885d2A27Bd4c6D111B83Bc3fC359eD951E8E6F8 --home ~/home_cli ## testnet eth-cli staking nc-create-validator --chain-id GSYS-Chain-Ganges --from tbnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --amount 2000000000000 :GSYS --moniker bsc_v1 --identity \"xxx\" --website \"[www.example.](http://www.genesys.network)com\" --details \"bsc validator node 1\" --commission-rate 80000000 --commission-max-rate 95000000 --commission-max-change-rate 3000000 --side-chain-id chapel --side-cons-addr 0x9B24Ee0BfBf708b541fB65b6087D6e991a0D11A8 --side-fee-addr 0x5885d2A27Bd4c6D111B83Bc3fC359eD951E8E6F8 --home ~/home_cli If you want a separated self-delegator address, both self-delegator and validator operator need to sign this transaction. Here we need to use another two commands to support multiple signatures. a. use the following commands appended with a parameter \u201c --generate-only \u201d and save the result to a json file which would be used to be signed. ## mainnet eth-cli staking nc-create-validator --chain-id GSYS-Chain-Tigris --from { validator-operator-address } --address-delegator { delegator-address } --amount 5000000000000 :GSYS --moniker bsc_v1 --identity \"xxx\" --website \"www.example.com\" --details \"bsc validator node 1\" --commission-rate 80000000 --commission-max-rate 95000000 --commission-max-change-rate 3000000 --side-chain-id bsc --side-cons-addr 0x9B24Ee0BfBf708b541fB65b6087D6e991a0D11A8 --side-fee-addr 0x5885d2A27Bd4c6D111B83Bc3fC359eD951E8E6F8 --home ~/home_cli --generate-only > unsigned.json ## testnet eth-cli staking nc-create-validator --chain-id GSYS-Chain-Ganges --from { validator-operator-address } --address-delegator { delegator-address } --amount 5000000000000 :GSYS --moniker bsc_v1 --identity \"xxx\" --website \"www.example.com\" --details \"bsc validator node 1\" --commission-rate 80000000 --commission-max-rate 95000000 --commission-max-change-rate 3000000 --side-chain-id chapel --side-cons-addr 0x9B24Ee0BfBf708b541fB65b6087D6e991a0D11A8 --side-fee-addr 0x5885d2A27Bd4c6D111B83Bc3fC359eD951E8E6F8 --home ~/home_cli --generate-only > unsigned.json b. both validator operator(--from) and self-delegator(--address-delegator) use \u201c eth-cli sign \u201d command to sign the file from a). Delegator address need to sign unsigned.json first Online Mode ## mainnet ./eth-cli sign unsigned.json --from { delegator-address } --node dataseed4.genesys.network:80 --chain-id GSYS-Chain-Tigris >> delegator-signed.json ## testnet ./eth-cli sign unsigned.json --from { delegator-address } --node data-seed-pre-0-s3.genesys.network:80 --chain-id GSYS-Chain-Ganges >> delegator-signed.json Offline Mode ## mainnet ./eth-cli sign unsigned.json --account-number <delegator-account-number> --sequence <address-sequence> --chain-id GSYS-Chain-Tigris --offline --name { delegator-address } >> delegator-signed.json ## testnet ./eth-cli sign unsigned.json --account-number <delegator-account-number> --sequence <address-sequence> --chain-id GSYS-Chain-Ganges --offline --name { delegator-address } >> delegator-signed.json Then, validator operator addres will sign it later. Online Mode ## mainnet ./eth-cli sign delegator-signed.json --from { validator-address } --node dataseed4.genesys.network:80 --chain-id GSYS-Chain-Tigris >> both-signed.json ## testnet ./eth-cli sign delegator-signed.json --from { validator-address } --node data-seed-pre-0-s3.genesys.network:80 --chain-id GSYS-Chain-Ganges >> both-signed.json Offline Mode ## mainnet ./eth-cli sign delegator-signed.json --account-number <validator-account-number> --sequence <address-sequence> --chain-id GSYS-Chain-Tigris --offline --name { validator-address } >> both-signed.json ## testnet ./eth-cli sign delegator-signed.json --account-number <validator-account-number> --sequence <address-sequence> --chain-id GSYS-Chain-Ganges --offline --name { validator-address } >> both-signed.json c. use \u201c eth-cli broadcast \u201d to send the transaction from above to the blockchain nodes. ## mainnet ./eth-cli broadcast both-signed.json --node dataseed4.genesys.network:80 --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli broadcast both-signed.json --node data-seed-pre-0-s3.genesys.network:80 --chain-id GSYS-Chain-Ganges Verify your transaction in mainnet-explorer or testnet-explorer Edit GSYS Validator Parameters for nc-edit-validator parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from bnb1xxx/tbnb1xxx address of private key with which to sign this tx, that also indicate the validator that you want to edit. Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes --moniker myval1 validator name (default \"[do-not-modify]\") No --identity xxx optional identity signature (ex. UPort or Keybase) (default \"[do-not-modify]\") No --website www.example.com optional website (default \"[do-not-modify]\") No --details some details optional details (default \"[do-not-modify]\") No --commission-rate 80000000(that means 0.8 or 80%) The new commission rate percentage No --side-fee-addr 0xabcd1234 address that validator collects fee rewards on side chain, please use hex format prefixed with 0x. No Examples Mainnet eth-cli staking nc-edit-validator --chain-id GSYS-Chain-Tigris --side-chain-id bsc --moniker bsc_v1_new --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --home ~/home_cli Testnet eth-cli staking nc-edit-validator --chain-id GSYS-Chain-Ganges --side-chain-id chapel --moniker bsc_v1_new --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --home ~/home_cli Delegate GSYS Parameters for staking nc-delegate parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from bnb1xxx/tbnb1xxx address of private key with which to sign this tx, that is also the delegator address Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes --validator bva1xxx bech32 address of the validator, starts with \u201cbva\u201d Yes --amount 1000000000:GSYS (10 GSYS) delegation amount, it has 8 decimal places Yes Examples ## mainnet eth-cli staking nc-delegate --chain-id GSYS-Chain-Tigris --side-chain-id bsc --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --validator bva1tfh30c67mkzfz06as2hk0756mgdx8mgypqldvm --amount 1000000000 :GSYS --home ~/home_cli ## testnet eth-cli staking nc-delegate --chain-id GSYS-Chain-Ganges --side-chain-id chapel --from tbnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --validator bva1tfh30c67mkzfz06as2hk0756mgdx8mgypqldvm --amount 1000000000 :GSYS --home ~/home_cli Redelegate GSYS Parameters for staking nc-redelegate parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from bnb1xxx/tbnb1xxx address of private key with which to sign this tx, that is also the delegator address Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes --addr-validator-source bva1xxx bech32 address of the source validator, starts with \u201cbva\u201d Yes --addr-validator-dest bva1yyy bech32 address of the destination validator, starts with \u201cbva\u201d Yes --amount 1000000000:GSYS (10 GSYS) delegation amount, it has 8 decimal places Yes Examples Mainnet eth-cli staking nc-redelegate --chain-id GSYS-Chain-Tigris --side-chain-id bsc --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --addr-validator-source bva1tfh30c67mkzfz06as2hk0756mgdx8mgypqldvm --addr-validator-dest bva1jam9wn8drs97mskmwg7jwm09kuy5yjumvvx6r2 --amount1000000000:GSYS --home ~/home_cli Testnet eth-cli staking nc-redelegate --chain-id GSYS-Chain-Ganges --side-chain-id chapel --from tbnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --addr-validator-source bva1tfh30c67mkzfz06as2hk0756mgdx8mgypqldvm --addr-validator-dest bva1jam9wn8drs97mskmwg7jwm09kuy5yjumvvx6r2 --amount1000000000:GSYS --home ~/home_cli Undelegate GSYS Parameters for staking nc-unbond parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from bnb1xxx/tbnb1xxx address of private key with which to sign this tx, that is also the delegator address Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes --validator bva1xxx bech32 address of the validator, starts with \u201cbva\u201d Yes --amount 1000000000:GSYS (10 GSYS) delegation amount, it has 8 decimal places Yes Examples Mainnet eth-cli staking nc-unbond --chain-id GSYS-Chain-Ganges --side-chain-id chapel --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --validator bva1tfh30c67mkzfz06as2hk0756mgdx8mgypqldvm --amount 1000000000 :GSYS --home ~/home_cli Query side chain vaildator by operator Parameters for staking side-validator parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes Examples Mainnet eth-cli staking side-validator bva1hz5sg3u0v4gq2veyw5355z7qx6y7uuqhcuzf3f --side-chain-id bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli Query side chain delegation by delegator and operator Parameters for staking side-delegation parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes Examples Mainnet eth-cli staking side-delegation bnb1hz5sg3u0v4gq2veyw5355z7qx6y7uuqhcqre0d bva1hz5sg3u0v4gq2veyw5355z7qx6y7uuqhcuzf3f --chain-id = GSYS-Chain-Tigris --side-chain-id bsc --home ~/home_cli Query side chain delegations by delegator Parameters for staking side-delegations parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes Examples Mainnet eth-cli staking side-delegations bnb1hz5sg3u0v4gq2veyw5355z7qx6y7uuqhcqre0d --side-chain-id bsc --node = 0 .0.0.0:26657 --chain-id = GSYS-Chain-Tigris --trust-node Query side chain unbonding delegation Parameters for staking side-unbonding-delegation Usage: eth-cli staking side-unbonding-delegation [ delegator-addr ] [ operator-addr ] [ flags ] parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id bsc/chapel chain-id of the side chain the validator belongs to Yes For example eth-cli staking side-unbonding-delegation bnb1rtzy6szuyzcj4amfn6uarvne8a5epxrdklwhhj bva12hlquylu78cjylk5zshxpdj6hf3t0tahqmr98n --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli Query side chain unbonding delegations by delegator Parameters for staking side-unbonding-delegations Usage: eth-cli staking side-unbonding-delegations [ delegator-addr ] [ flags ] parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes For example eth-cli staking side-unbonding-delegations bnb1rtzy6szuyzcj4amfn6uarvne8a5epxrdklwhhj --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli Query side chain unbonding delegations by validator Parameters for staking side-val-unbonding-delegations Usage: eth-cli staking side-val-unbonding-delegation [ operator-addr ] [ flags ] parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id bsc/chapel chain-id of the side chain the validator belongs to Yes For example eth-cli staking side-val-unbonding-delegations bva12hlquylu78cjylk5zshxpdj6hf3t0tahqmr98n --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli Query side chain re-delegation Parameters for staking side-redelegation Usage: eth-cli staking side-redelegation [ delegator-addr ] [ src-operator-addr ] [ dst-operator-addr ] [ flags ] parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id bsc/chapel chain-id of the side chain the validator belongs to Yes For example eth-cli staking side-redelegation bnb1rtzy6szuyzcj4amfn6uarvne8a5epxrdklwhhj bva12hlquylu78cjylk5zshxpdj6hf3t0tahqmr98n bva1hz5sg3u0v4gq2veyw5355z7qx6y7uuqhcuzf3f --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli Query side chain re-delegations by delegator Parameters for staking side-redelegations Usage: eth-cli staking side-redelegations [ delegator-addr ] [ flags ] parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id bsc/chapel chain-id of the side chain the validator belongs to Yes For example eth-cli staking side-redelegations bnb1rtzy6szuyzcj4amfn6uarvne8a5epxrdklwhhj --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli Query side chain re-delegations by validator Parameters for staking side-val-redelegations Usage: eth-cli staking side-val-redelegations [ operator-addr ] [ flags ] | parameter name | example | comments | required | | ------------------- | ----------------- | --------------------------------------------------- | ------------ | | --chan-id | GSYS-Chain-XXX | the chain id of shree chain | Yes | | --side-chain-id | bsc/chapel | chain-id of the side chain the validator belongs to | Yes | For example eth-cli staking side-val-redelegations bva12hlquylu78cjylk5zshxpdj6hf3t0tahqmr98n --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli Query side chain staking pool Parameters for staking side-pool parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id bsc/chapel chain-id of the side chain the validator belongs to Yes For example eth-cli staking side-pool --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli Query side chain top validators Parameters for staking side-top-validators parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes --top 10 number of validators to be returned. set as maximum number of validators by default Option For example eth-cli staking side-top-validators --top 10 --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli Query side chain validators count Parameters for staking side-validators-count parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes --jail-involved true if true, meaning that the jailed validators will be involved to count Option For example eth-cli staking side-validators-count --jail-involved --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli","title":"Staking"},{"location":"guides/concepts/bc-staking.html#staking","text":"","title":"Staking"},{"location":"guides/concepts/bc-staking.html#posa-consensus-of-genesys-chain","text":"Genesys Chain is an innovative solution to bring programmability and interoperability to Genesys Chain . Genesys Chain relies on a system of 21 validators with Proof of Staked Authority (PoSA) consensus that can support short block time and lower fees. The most bonded validator candidates of staking will become validators and produce blocks. The double-sign detection and other slashing logic guarantee security, stability, and chain finality.","title":"PoSA Consensus of Genesys Chain"},{"location":"guides/concepts/bc-staking.html#staking-on-genesys-chain","text":"Ideally, Genesys Chain should build such staking and reward logic into the blockchain, and automatically distribute rewards as the blocking happens. Cosmos Hub , who also build on top of Tendermint consensus like Genesys Chain, works in this way. However, as GSYS wants to remain compatible with Ethereum as much as possible. On the other side, Genesys Chain already has a staking module and could be extended to support both BC and TC. In this way, all the staking related operations are recorded in BC. Once there are any changes about TC's validator set or voting power, the new message will be transferred to GSYS through cross-chain communication.","title":"Staking on Genesys Chain"},{"location":"guides/concepts/bc-staking.html#staking-economics","text":"The staking token is GSYS , as it is a native token on both blockchains anyway The staking, i.e. token bond and delegation actions and records for TC, happens on BC. The GSYS validator set is determined by its staking and delegation logic, via a staking module built on BC for TC, and propagated every day UTC 00:00 from BC to GSYS via Cross-Chain communication. The reward distribution happens on BC around every day UTC 00:00 after.","title":"Staking Economics"},{"location":"guides/concepts/bc-staking.html#ranking-algorithm","text":"Validators are ranked by their power and operator address. The more its delegation tokens, the higher ranking is. If two validators get the same amount of delegated tokens, validator with smaller address bytes has higher ranking.","title":"Ranking Algorithm"},{"location":"guides/concepts/bc-staking.html#reward-distrubution","text":"Since GSYS uses PoSA as its consensus engine, all the delegators of validators can receive some share of the validators\u2019 reward. However, the rewards(fees) are collected on GSYS while the staking info is stored on BC. So the main idea is we transfer all the rewards from GSYS to BC once every day and execute the distribution on BC.","title":"Reward Distrubution"},{"location":"guides/concepts/bc-staking.html#main-workflow","text":"ValidatorSet is updated in BreatheBlock, the frequency is once a day. let\u2019s assume it happens on day N. The info of validator set changes of day N would be transmitted to NCthrough interchain communication. The validator set contract on GSYS would receive and update the new validatorset. After that, it would trigger several interchain transfer to transfer the fees that every previous validators collected in this period to their addresses on BC. we can see that fees belongs to the validators of day N-1. To make some room for the error handling, we distribute the fees of day N-1 in the next breathe block (day N+1).","title":"Main Workflow:"},{"location":"guides/concepts/bc-staking.html#details","text":"even if validator set or any their voting powers are not changed on that day, we still transmit the validator set info to TC. the validator set contract maintains the history of the fees that every validators collected after the previous period(We define the period as the time between two contract calls of validator set changes). The actual fees are collected on the contract address. the interchain transfer to send fees from the contract address to each validator\u2019s distribution address on BC. Note the distribution address is auto generated on BC when handling the create-validator tx, so no private key is corresponded to that address and no one except the distribution module can move the tokens on that address. This address is displayed as Distribution Addr in validator info. Validator Fee Address: tbnb15mgzha93ny878kuvjl0pnqmjygwccdadpw5dxf Operator Address: bva15mgzha93ny878kuvjl0pnqmjygwccdad08uecu Validator Consensus Pubkey: Jailed: false Status: Bonded Tokens: 5000000000000 Delegator Shares: 5000000000000 Description: { Elbrus \"\" www.genesys.network This is Elbrus org on chapel network. } Bond Height: 74158 Unbonding Height: 0 Minimum Unbonding Time: 1970 -01-01 00 :00:00 +0000 UTC Commission: { rate: 75000000 , maxRate: 90000000 , maxChangeRate: 3000000 , updateTime: 2020 -05-22 12 :24:19.478568234 +0000 UTC } Distribution Addr: tbnb1srkkfjk8qctvvy4s3cllhpnkz9679jphr30t2c Side Chain Id: chapel Consensus Addr on Side Chain: 0xF474Cf03ccEfF28aBc65C9cbaE594F725c80e12d Fee Addr on Side Chain: 0xe61a183325A18a173319dD8E19c8d069459E2175 we have a lower limit of the value of interchain transfer, at least the value can cover the transfer fee. Also, interchain transfer will only allow max 8 decimals for the amount. The tiny left part would be kept in the contract or put into the system reward pool. the reward: (totalfees * (1-commissionRate)) would be distributed in proportion to the delegations, the left part would be sent to the validator fee address.","title":"Details"},{"location":"guides/concepts/bc-staking.html#error-handling","text":"if the cross-chain transfer failed, the tokens would be sent back to a specified address(i.e. the SideFeeAddr in the store section, validators can change this address via the EditValidator tx). After that, validators can manually deposit the tokens to its own DistributionAddr on BC via Transfer tx. We do not force the validator to do so, but it\u2019s an indicator that can help delegators choose validators.","title":"Error handling:"},{"location":"guides/concepts/bc-staking.html#fee-table","text":"Transaction Type Pay in GSYS Create A New Smart Chain Validator 10 Edit Smart Chain Validator Information 1 Delegate Smart Chain Validator 0.001 Redelegate Smart Chain Validator 0.003 Undelegate Smart Chain Validator 0.002","title":"Fee Table"},{"location":"guides/concepts/bc-staking.html#commands","text":"","title":"Commands"},{"location":"guides/concepts/bc-staking.html#download","text":"","title":"Download"},{"location":"guides/concepts/bc-staking.html#mainnet","text":"Please download eth-cli binary from here","title":"Mainnet"},{"location":"guides/concepts/bc-staking.html#testnet","text":"Please download eth-cli binary from here","title":"Testnet"},{"location":"guides/concepts/bc-staking.html#create-gsys-validator","text":"","title":"Create GSYS Validator"},{"location":"guides/concepts/bc-staking.html#parameters-for-nc-create-validator","text":"parameter name example comment required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from bnb1xxx/tbnb1xxx address of private key with which to sign this tx, also be used as the validator operator address Yes --address-delegator bnb1xxx/tbnb1xxx optional, bech32 address of the self-delegator. if not provided, --from address will be used as self-delegator. No --amount 2000000000000:GSYS (means 20000 GSYS) self-delegation amount, it has 8 decimal places Yes --moniker myval1 validator name Yes --identity xxx optional identity signature (ex. UPort or Keybase) No --website www.example.com optional website No --details some details optional details No --commission-rate 80000000(that means 0.8 or 80%) The initial commission rate percentage, it has 8 decimal places. Yes --commission-max-rate 95000000 (0.95 or 95%) The maximum commission rate percentage, it has 8 decimal places. You can not update this rate. Yes --commission-max-change-rate 3000000 (0.03 or 3%) The maximum commission change rate percentage (per day). You can not update this rate. Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes --side-cons-addr 0x1234abcd consensus address of the validator on side chain, please use hex format prefixed with 0x Yes --side-fee-addr 0xabcd1234 address that validator collects fee rewards on side chain, please use hex format prefixed with 0x. Yes --home /path/to/cli_home home directory of eth-cli data and config, default to \u201c~/.eth-cli\u201d No Some address parameters we need to highlight here: Field Name Usage DelegatorAddr Self delegator address. For BC, this address also used to collect fees. ValidatorAddr validator operator\u2019s address, used in governance ops like voting. SideConsAddr block producer\u2019s address on side chain, i.e. consensus address. BC has another parameter named PubKey , here SideConsAddr replaced that for TC. Only GSYS validators need this parameter. SideFeeAddr fees are collected in this address on TC, Only GSYS validators need this parameter. Due to different token units, there are some GSYS left as dust when sending block rewards from Genesys Chain to Genesys Chain. Those GSYS will be sent to fee address.","title":"Parameters for nc-create-validator"},{"location":"guides/concepts/bc-staking.html#examples","text":"If you want to create a validator with the same operator address and self-delegator address, you only need one signature for this transaction. Mainnet ## mainnet eth-cli staking nc-create-validator --chain-id GSYS-Chain-Tigris --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --amount 1000000000000 :GSYS --moniker bsc_v1 --identity \"xxx\" --website \"[www.example.](http://www.genesys.network)com\" --details \"bsc validator node 1\" --commission-rate 80000000 --commission-max-rate 95000000 --commission-max-change-rate 3000000 --side-chain-id bsc --side-cons-addr 0x9B24Ee0BfBf708b541fB65b6087D6e991a0D11A8 --side-fee-addr 0x5885d2A27Bd4c6D111B83Bc3fC359eD951E8E6F8 --home ~/home_cli ## testnet eth-cli staking nc-create-validator --chain-id GSYS-Chain-Ganges --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --amount 2000000000000 :GSYS --moniker bsc_v1 --identity \"xxx\" --website \"[www.example.](http://www.genesys.network)com\" --details \"bsc validator node 1\" --commission-rate 80000000 --commission-max-rate 95000000 --commission-max-change-rate 3000000 --side-chain-id chapel --side-cons-addr 0x9B24Ee0BfBf708b541fB65b6087D6e991a0D11A8 --side-fee-addr 0x5885d2A27Bd4c6D111B83Bc3fC359eD951E8E6F8 --home ~/home_cli Testnet ## mainnet eth-cli staking nc-create-validator --chain-id GSYS-Chain-Tigris --from tbnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --amount 2000000000000 :GSYS --moniker bsc_v1 --identity \"xxx\" --website \"[www.example.](http://www.genesys.network)com\" --details \"bsc validator node 1\" --commission-rate 80000000 --commission-max-rate 95000000 --commission-max-change-rate 3000000 --side-chain-id bsc --side-cons-addr 0x9B24Ee0BfBf708b541fB65b6087D6e991a0D11A8 --side-fee-addr 0x5885d2A27Bd4c6D111B83Bc3fC359eD951E8E6F8 --home ~/home_cli ## testnet eth-cli staking nc-create-validator --chain-id GSYS-Chain-Ganges --from tbnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --amount 2000000000000 :GSYS --moniker bsc_v1 --identity \"xxx\" --website \"[www.example.](http://www.genesys.network)com\" --details \"bsc validator node 1\" --commission-rate 80000000 --commission-max-rate 95000000 --commission-max-change-rate 3000000 --side-chain-id chapel --side-cons-addr 0x9B24Ee0BfBf708b541fB65b6087D6e991a0D11A8 --side-fee-addr 0x5885d2A27Bd4c6D111B83Bc3fC359eD951E8E6F8 --home ~/home_cli If you want a separated self-delegator address, both self-delegator and validator operator need to sign this transaction. Here we need to use another two commands to support multiple signatures. a. use the following commands appended with a parameter \u201c --generate-only \u201d and save the result to a json file which would be used to be signed. ## mainnet eth-cli staking nc-create-validator --chain-id GSYS-Chain-Tigris --from { validator-operator-address } --address-delegator { delegator-address } --amount 5000000000000 :GSYS --moniker bsc_v1 --identity \"xxx\" --website \"www.example.com\" --details \"bsc validator node 1\" --commission-rate 80000000 --commission-max-rate 95000000 --commission-max-change-rate 3000000 --side-chain-id bsc --side-cons-addr 0x9B24Ee0BfBf708b541fB65b6087D6e991a0D11A8 --side-fee-addr 0x5885d2A27Bd4c6D111B83Bc3fC359eD951E8E6F8 --home ~/home_cli --generate-only > unsigned.json ## testnet eth-cli staking nc-create-validator --chain-id GSYS-Chain-Ganges --from { validator-operator-address } --address-delegator { delegator-address } --amount 5000000000000 :GSYS --moniker bsc_v1 --identity \"xxx\" --website \"www.example.com\" --details \"bsc validator node 1\" --commission-rate 80000000 --commission-max-rate 95000000 --commission-max-change-rate 3000000 --side-chain-id chapel --side-cons-addr 0x9B24Ee0BfBf708b541fB65b6087D6e991a0D11A8 --side-fee-addr 0x5885d2A27Bd4c6D111B83Bc3fC359eD951E8E6F8 --home ~/home_cli --generate-only > unsigned.json b. both validator operator(--from) and self-delegator(--address-delegator) use \u201c eth-cli sign \u201d command to sign the file from a). Delegator address need to sign unsigned.json first Online Mode ## mainnet ./eth-cli sign unsigned.json --from { delegator-address } --node dataseed4.genesys.network:80 --chain-id GSYS-Chain-Tigris >> delegator-signed.json ## testnet ./eth-cli sign unsigned.json --from { delegator-address } --node data-seed-pre-0-s3.genesys.network:80 --chain-id GSYS-Chain-Ganges >> delegator-signed.json Offline Mode ## mainnet ./eth-cli sign unsigned.json --account-number <delegator-account-number> --sequence <address-sequence> --chain-id GSYS-Chain-Tigris --offline --name { delegator-address } >> delegator-signed.json ## testnet ./eth-cli sign unsigned.json --account-number <delegator-account-number> --sequence <address-sequence> --chain-id GSYS-Chain-Ganges --offline --name { delegator-address } >> delegator-signed.json Then, validator operator addres will sign it later. Online Mode ## mainnet ./eth-cli sign delegator-signed.json --from { validator-address } --node dataseed4.genesys.network:80 --chain-id GSYS-Chain-Tigris >> both-signed.json ## testnet ./eth-cli sign delegator-signed.json --from { validator-address } --node data-seed-pre-0-s3.genesys.network:80 --chain-id GSYS-Chain-Ganges >> both-signed.json Offline Mode ## mainnet ./eth-cli sign delegator-signed.json --account-number <validator-account-number> --sequence <address-sequence> --chain-id GSYS-Chain-Tigris --offline --name { validator-address } >> both-signed.json ## testnet ./eth-cli sign delegator-signed.json --account-number <validator-account-number> --sequence <address-sequence> --chain-id GSYS-Chain-Ganges --offline --name { validator-address } >> both-signed.json c. use \u201c eth-cli broadcast \u201d to send the transaction from above to the blockchain nodes. ## mainnet ./eth-cli broadcast both-signed.json --node dataseed4.genesys.network:80 --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli broadcast both-signed.json --node data-seed-pre-0-s3.genesys.network:80 --chain-id GSYS-Chain-Ganges Verify your transaction in mainnet-explorer or testnet-explorer","title":"Examples"},{"location":"guides/concepts/bc-staking.html#edit-gsys-validator","text":"","title":"Edit GSYS Validator"},{"location":"guides/concepts/bc-staking.html#parameters-for-nc-edit-validator","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from bnb1xxx/tbnb1xxx address of private key with which to sign this tx, that also indicate the validator that you want to edit. Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes --moniker myval1 validator name (default \"[do-not-modify]\") No --identity xxx optional identity signature (ex. UPort or Keybase) (default \"[do-not-modify]\") No --website www.example.com optional website (default \"[do-not-modify]\") No --details some details optional details (default \"[do-not-modify]\") No --commission-rate 80000000(that means 0.8 or 80%) The new commission rate percentage No --side-fee-addr 0xabcd1234 address that validator collects fee rewards on side chain, please use hex format prefixed with 0x. No","title":"Parameters for nc-edit-validator"},{"location":"guides/concepts/bc-staking.html#examples_1","text":"Mainnet eth-cli staking nc-edit-validator --chain-id GSYS-Chain-Tigris --side-chain-id bsc --moniker bsc_v1_new --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --home ~/home_cli Testnet eth-cli staking nc-edit-validator --chain-id GSYS-Chain-Ganges --side-chain-id chapel --moniker bsc_v1_new --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --home ~/home_cli","title":"Examples"},{"location":"guides/concepts/bc-staking.html#delegate-gsys","text":"","title":"Delegate GSYS"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-nc-delegate","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from bnb1xxx/tbnb1xxx address of private key with which to sign this tx, that is also the delegator address Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes --validator bva1xxx bech32 address of the validator, starts with \u201cbva\u201d Yes --amount 1000000000:GSYS (10 GSYS) delegation amount, it has 8 decimal places Yes","title":"Parameters for staking nc-delegate"},{"location":"guides/concepts/bc-staking.html#examples_2","text":"## mainnet eth-cli staking nc-delegate --chain-id GSYS-Chain-Tigris --side-chain-id bsc --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --validator bva1tfh30c67mkzfz06as2hk0756mgdx8mgypqldvm --amount 1000000000 :GSYS --home ~/home_cli ## testnet eth-cli staking nc-delegate --chain-id GSYS-Chain-Ganges --side-chain-id chapel --from tbnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --validator bva1tfh30c67mkzfz06as2hk0756mgdx8mgypqldvm --amount 1000000000 :GSYS --home ~/home_cli","title":"Examples"},{"location":"guides/concepts/bc-staking.html#redelegate-gsys","text":"","title":"Redelegate GSYS"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-nc-redelegate","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from bnb1xxx/tbnb1xxx address of private key with which to sign this tx, that is also the delegator address Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes --addr-validator-source bva1xxx bech32 address of the source validator, starts with \u201cbva\u201d Yes --addr-validator-dest bva1yyy bech32 address of the destination validator, starts with \u201cbva\u201d Yes --amount 1000000000:GSYS (10 GSYS) delegation amount, it has 8 decimal places Yes","title":"Parameters for staking nc-redelegate"},{"location":"guides/concepts/bc-staking.html#examples_3","text":"Mainnet eth-cli staking nc-redelegate --chain-id GSYS-Chain-Tigris --side-chain-id bsc --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --addr-validator-source bva1tfh30c67mkzfz06as2hk0756mgdx8mgypqldvm --addr-validator-dest bva1jam9wn8drs97mskmwg7jwm09kuy5yjumvvx6r2 --amount1000000000:GSYS --home ~/home_cli Testnet eth-cli staking nc-redelegate --chain-id GSYS-Chain-Ganges --side-chain-id chapel --from tbnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --addr-validator-source bva1tfh30c67mkzfz06as2hk0756mgdx8mgypqldvm --addr-validator-dest bva1jam9wn8drs97mskmwg7jwm09kuy5yjumvvx6r2 --amount1000000000:GSYS --home ~/home_cli","title":"Examples"},{"location":"guides/concepts/bc-staking.html#undelegate-gsys","text":"","title":"Undelegate GSYS"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-nc-unbond","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --from bnb1xxx/tbnb1xxx address of private key with which to sign this tx, that is also the delegator address Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes --validator bva1xxx bech32 address of the validator, starts with \u201cbva\u201d Yes --amount 1000000000:GSYS (10 GSYS) delegation amount, it has 8 decimal places Yes","title":"Parameters for staking nc-unbond"},{"location":"guides/concepts/bc-staking.html#examples_4","text":"Mainnet eth-cli staking nc-unbond --chain-id GSYS-Chain-Ganges --side-chain-id chapel --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --validator bva1tfh30c67mkzfz06as2hk0756mgdx8mgypqldvm --amount 1000000000 :GSYS --home ~/home_cli","title":"Examples"},{"location":"guides/concepts/bc-staking.html#query-side-chain-vaildator-by-operator","text":"","title":"Query side chain vaildator by operator"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-side-validator","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes","title":"Parameters for staking side-validator"},{"location":"guides/concepts/bc-staking.html#examples_5","text":"Mainnet eth-cli staking side-validator bva1hz5sg3u0v4gq2veyw5355z7qx6y7uuqhcuzf3f --side-chain-id bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli","title":"Examples"},{"location":"guides/concepts/bc-staking.html#query-side-chain-delegation-by-delegator-and-operator","text":"","title":"Query side chain delegation by delegator and operator"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-side-delegation","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes","title":"Parameters for staking side-delegation"},{"location":"guides/concepts/bc-staking.html#examples_6","text":"Mainnet eth-cli staking side-delegation bnb1hz5sg3u0v4gq2veyw5355z7qx6y7uuqhcqre0d bva1hz5sg3u0v4gq2veyw5355z7qx6y7uuqhcuzf3f --chain-id = GSYS-Chain-Tigris --side-chain-id bsc --home ~/home_cli","title":"Examples"},{"location":"guides/concepts/bc-staking.html#query-side-chain-delegations-by-delegator","text":"","title":"Query side chain delegations by delegator"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-side-delegations","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes","title":"Parameters for staking side-delegations"},{"location":"guides/concepts/bc-staking.html#examples_7","text":"Mainnet eth-cli staking side-delegations bnb1hz5sg3u0v4gq2veyw5355z7qx6y7uuqhcqre0d --side-chain-id bsc --node = 0 .0.0.0:26657 --chain-id = GSYS-Chain-Tigris --trust-node","title":"Examples"},{"location":"guides/concepts/bc-staking.html#query-side-chain-unbonding-delegation","text":"","title":"Query side chain unbonding delegation"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-side-unbonding-delegation","text":"Usage: eth-cli staking side-unbonding-delegation [ delegator-addr ] [ operator-addr ] [ flags ] parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id bsc/chapel chain-id of the side chain the validator belongs to Yes For example eth-cli staking side-unbonding-delegation bnb1rtzy6szuyzcj4amfn6uarvne8a5epxrdklwhhj bva12hlquylu78cjylk5zshxpdj6hf3t0tahqmr98n --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli","title":"Parameters for staking side-unbonding-delegation"},{"location":"guides/concepts/bc-staking.html#query-side-chain-unbonding-delegations-by-delegator","text":"","title":"Query side chain unbonding delegations by delegator"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-side-unbonding-delegations","text":"Usage: eth-cli staking side-unbonding-delegations [ delegator-addr ] [ flags ] parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes For example eth-cli staking side-unbonding-delegations bnb1rtzy6szuyzcj4amfn6uarvne8a5epxrdklwhhj --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli","title":"Parameters for staking side-unbonding-delegations"},{"location":"guides/concepts/bc-staking.html#query-side-chain-unbonding-delegations-by-validator","text":"","title":"Query side chain unbonding delegations by validator"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-side-val-unbonding-delegations","text":"Usage: eth-cli staking side-val-unbonding-delegation [ operator-addr ] [ flags ] parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id bsc/chapel chain-id of the side chain the validator belongs to Yes For example eth-cli staking side-val-unbonding-delegations bva12hlquylu78cjylk5zshxpdj6hf3t0tahqmr98n --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli","title":"Parameters for staking side-val-unbonding-delegations"},{"location":"guides/concepts/bc-staking.html#query-side-chain-re-delegation","text":"","title":"Query side chain re-delegation"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-side-redelegation","text":"Usage: eth-cli staking side-redelegation [ delegator-addr ] [ src-operator-addr ] [ dst-operator-addr ] [ flags ] parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id bsc/chapel chain-id of the side chain the validator belongs to Yes For example eth-cli staking side-redelegation bnb1rtzy6szuyzcj4amfn6uarvne8a5epxrdklwhhj bva12hlquylu78cjylk5zshxpdj6hf3t0tahqmr98n bva1hz5sg3u0v4gq2veyw5355z7qx6y7uuqhcuzf3f --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli","title":"Parameters for staking side-redelegation"},{"location":"guides/concepts/bc-staking.html#query-side-chain-re-delegations-by-delegator","text":"","title":"Query side chain re-delegations by delegator"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-side-redelegations","text":"Usage: eth-cli staking side-redelegations [ delegator-addr ] [ flags ] parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id bsc/chapel chain-id of the side chain the validator belongs to Yes For example eth-cli staking side-redelegations bnb1rtzy6szuyzcj4amfn6uarvne8a5epxrdklwhhj --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli","title":"Parameters for staking side-redelegations"},{"location":"guides/concepts/bc-staking.html#query-side-chain-re-delegations-by-validator","text":"","title":"Query side chain re-delegations by validator"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-side-val-redelegations","text":"Usage: eth-cli staking side-val-redelegations [ operator-addr ] [ flags ] | parameter name | example | comments | required | | ------------------- | ----------------- | --------------------------------------------------- | ------------ | | --chan-id | GSYS-Chain-XXX | the chain id of shree chain | Yes | | --side-chain-id | bsc/chapel | chain-id of the side chain the validator belongs to | Yes | For example eth-cli staking side-val-redelegations bva12hlquylu78cjylk5zshxpdj6hf3t0tahqmr98n --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli","title":"Parameters for staking side-val-redelegations"},{"location":"guides/concepts/bc-staking.html#query-side-chain-staking-pool","text":"","title":"Query side chain staking pool"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-side-pool","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id bsc/chapel chain-id of the side chain the validator belongs to Yes For example eth-cli staking side-pool --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli","title":"Parameters for staking side-pool"},{"location":"guides/concepts/bc-staking.html#query-side-chain-top-validators","text":"","title":"Query side chain top validators"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-side-top-validators","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes --top 10 number of validators to be returned. set as maximum number of validators by default Option For example eth-cli staking side-top-validators --top 10 --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli","title":"Parameters for  staking side-top-validators"},{"location":"guides/concepts/bc-staking.html#query-side-chain-validators-count","text":"","title":"Query side chain validators count"},{"location":"guides/concepts/bc-staking.html#parameters-for-staking-side-validators-count","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel chain-id of the side chain the validator belongs to Yes --jail-involved true if true, meaning that the jailed validators will be involved to count Option For example eth-cli staking side-validators-count --jail-involved --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris --home ~/home_cli","title":"Parameters for staking side-validators-count"},{"location":"guides/concepts/fees.html","text":"GSYS is the native token on Genesys Chain, thus users are charged GSYS for sending transactions. Trading Fees on DEX Trading fees are subject to complex logic that may mean that individual trades are not charged exactly by the rates below, but between them instead; this is due to the block-based matching engine in use on the DEX. The current fee for trades, applied on the settled amounts, is as follows: Transaction Type Pay in non-GSYS Asset Pay in GSYS Trade 0.1% 0.05% Trading fee can be queried at here . It's under the \"params/DexFeeParam/\". \"FeeRate\" and \"FeeRateNative\" are both under unit of 10^-6. Fix Fee Table The difference between Genesys Chain and Ethereum is that there is no notion of gas . As a result, fees for the rest transactions are fixed. The details are showned in the table below: Current Fees Table on Mainnet Fees are variable and may change over time as governance proposals are proposed and voted on. The current fees table for Mainnet as of 2021-03-21 is as follows: Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related New Order 0 0 Y Cancel (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y Order Expire (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y IOC (No Fill) Equivalent 0.00025 GSYS 0.000005 GSYS Y Transfer N/A 0.000075 GSYS N crossTransferOut N/A 0.000075 GSYS N Multi-send N/A 0.00006 GSYS N Issue Asset N/A 10 GSYS Mint Asset N/A 0.002 GSYS N Transfer ownership N/A 0.002 GSYS N Burn Asset N/A 0.002 GSYS N Freeze/Unfreeze Asset N/A 0.001 GSYS N Lock/unlock/relock Asset N/A 0.002 GSYS N List Asset N/A 200 GSYS N Submit Proposal N/A 1 GSYS N Deposit N/A 0.000125 GSYS N Enable Memo Check N/A 0.2 GSYS N Disable Memo Check N/A 0.2 GSYS N HTLT N/A 0.000075 GSYS N depositHTLT N/A 0.000075 GSYS N claimHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N TinyIssueFee N/A 0.4 GSYS N MiniIssueFee N/A 0.6 GSYS N SetTokenUri N/A 0.000075 GSYS N List BEP8 Token N/A 1 GSYS N Create A New Smart Chain Validator N/A 2 GSYS N Edit Smart Chain Validator Information N/A 0.2 GSYS N Delegate Smart Chain Validator N/A 0.0002 GSYS N Redelegate Smart Chain Validator N/A 0.0006 GSYS N Undelegate Smart Chain Validator N/A 0.0004 GSYS N Unjail A Smart Chain Validator N/A 0.5 GSYS N Submit Byzaitine Behavior Evidence of A Smart Chain Validator N/A 0.5 GSYS N Submit Smart Chain Proposal N/A 1 GSYS N Smart Chain Proposal Deposit N/A 0.00025 GSYS N Smart Chain Proposal Vote N/A 0 GSYS N Cross transfer out relayer reward N/A 0.0004 GSYS N Current Fees Table on Testnet Fees are variable and may change over time as governance proposals are proposed and voted on. The current fees table for Testnet as of 2021-03-17 is as follows: Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related New Order 0 0 Y Cancel (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y Order Expire (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y IOC (No Fill) Equivalent 0.00025 GSYS 0.000005 GSYS Y Transfer N/A 0.000075 GSYS N crossTransferOut N/A 0.000075 GSYS N Multi-send N/A 0.00006 GSYS N Issue Asset N/A 10 GSYS Mint Asset N/A 0.002 GSYS N Transfer ownership N/A 0.002 GSYS N Burn Asset N/A 0.002 GSYS N Freeze/Unfreeze Asset N/A 0.001 GSYS N Lock/unlock/relock Asset N/A 0.002 GSYS N List Asset N/A 200 GSYS N Submit Proposal N/A 1 GSYS N Deposit N/A 0.000125 GSYS N Enable Memo Check N/A 0.2 GSYS N Disable Memo Check N/A 0.2 GSYS N HTLT N/A 0.000075 GSYS N depositHTLT N/A 0.000075 GSYS N claimHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N TinyIssueFee N/A 0.4 GSYS N MiniIssueFee N/A 0.6 GSYS N SetTokenUri N/A 0.000075 GSYS N List BEP8 Token N/A 1 GSYS N Create A New Smart Chain Validator N/A 2 GSYS N Edit Smart Chain Validator Information N/A 0.2 GSYS N Delegate Smart Chain Validator N/A 0.0002 GSYS N Redelegate Smart Chain Validator N/A 0.0006 GSYS N Undelegate Smart Chain Validator N/A 0.0004 GSYS N Unjail A Smart Chain Validator N/A 0.5 GSYS N Submit Byzaitine Behavior Evidence of A Smart Chain Validator N/A 0.5 GSYS N Submit Smart Chain Proposal N/A 1 GSYS N Smart Chain Proposal Deposit N/A 0.00025 GSYS N Smart Chain Proposal Vote N/A 0 GSYS N Cross transfer out relayer reward N/A 0.0004 GSYS N How to calculate multisend fee eth-cli offers you a multi-send command to transfer multiple tokens to multiple people. 20% discount is available for multi-send transactions. For now, multi-send transaction will send some tokens from one address to multiple output addresses. If the count of output address is bigger than the threshold, currently it's 2, then the total transaction fee is 0.001 GSYS per token per address. For example, if you send 3 ABC token,1 SAT token and 1 ABC to 3 different addresses. [ { \"to\" : \"bnb1g5p04snezgpky203fq6da9qyjsy2k9kzr5yuhl\" , \"amount\" : \"100000000:GSYS,100000000:ABC\" }, { \"to\" : \"bnb1l86xty0m55ryct9pnypz6chvtsmpyewmhrqwxw\" , \"amount\" : \"100000000:GSYS\" }, { \"to\" : \"bnb1l86xty0maxdgst9pnypz6chvtsmpydkjflfioe\" , \"amount\" : \"100000000:GSYS,100000000:SAT\" } ] You will pay on mainnet/testnet 0.0003 GSYS * 5 = 0.0015 GSYS How are rewards distributed between validators? you can use API to get the latest fee params. [ { msg_ t ype : \"submit_proposal\" , fee : 500000000 , fee _ f or : 1 }, { msg_ t ype : \"deposit\" , fee : 62500 , fee _ f or : 1 }, { msg_ t ype : \"vote\" , fee : 0 , fee _ f or : 3 }, { msg_ t ype : \"create_validator\" , fee : 1000000000 , fee _ f or : 1 }, { msg_ t ype : \"remove_validator\" , fee : 100000000 , fee _ f or : 1 }, { msg_ t ype : \"dexList\" , fee : 100000000000 , fee _ f or : 2 }, { msg_ t ype : \"orderNew\" , fee : 0 , fee _ f or : 3 }, { msg_ t ype : \"orderCancel\" , fee : 0 , fee _ f or : 3 }, { msg_ t ype : \"issueMsg\" , fee : 50000000000 , fee _ f or : 2 }, { msg_ t ype : \"mintMsg\" , fee : 500000000 , fee _ f or : 2 }, { msg_ t ype : \"tokensBurn\" , fee : 50000000 , fee _ f or : 1 }, { msg_ t ype : \"tokensFreeze\" , fee : 500000 , fee _ f or : 1 }, { f ixed_ fee _params : { msg_ t ype : \"send\" , fee : 37500 , fee _ f or : 1 }, mul t i_ transfer _ fee : 30000 , lower_limi t _as_mul t i : 2 }, { dex_ fee _ f ields : [ { fee _ na me : \"ExpireFee\" , fee _value : 25000 }, { fee _ na me : \"ExpireFeeNative\" , fee _value : 5000 }, { fee _ na me : \"CancelFee\" , fee _value : 25000 }, { fee _ na me : \"CancelFeeNative\" , fee _value : 5000 }, { fee _ na me : \"FeeRate\" , fee _value : 1000 }, { fee _ na me : \"FeeRateNative\" , fee _value : 400 }, { fee _ na me : \"IOCExpireFee\" , fee _value : 10000 }, { fee _ na me : \"IOCExpireFeeNative\" , fee _value : 2500 } ] }, { msg_ t ype : \"timeLock\" , fee : 1000000 , fee _ f or : 1 }, { msg_ t ype : \"timeUnlock\" , fee : 1000000 , fee _ f or : 1 }, { msg_ t ype : \"timeRelock\" , fee : 1000000 , fee _ f or : 1 }, { msg_ t ype : \"setAccountFlags\" , fee : 100000000 , fee _ f or : 1 }, { msg_ t ype : \"HTLT\" , fee : 37500 , fee _ f or : 1 }, { msg_ t ype : \"depositHTLT\" , fee : 37500 , fee _ f or : 1 }, { msg_ t ype : \"claimHTLT\" , fee : 37500 , fee _ f or : 1 }, { msg_ t ype : \"refundHTLT\" , fee : 37500 , fee _ f or : 1 } ] The fee_for parameter indicate the different distribution way: 1 means rewards is only for block proposer 2 means rewards are shared among all validators 3 means fee is free. How to query fees in every block The rewards for Genesys Chain validators are displayed in explorer. For example: in block 59947302 , validator bnb1tpagqqqx36gq09kzw4f5a3a9sk3tq54dpl5ldn get 0.00005 GSYS as rewards. If you have a fullnode running, you can also get the rewards details exported. To achieve this, you need to set publishBlockFee to be true in your app.toml . To receive rewards stream, there aretwo options publishKafka and publishLocal # Whether we want publish block fee changes publishBlockFee = true blockFeeTopic = \"accounts\" blockFeeKafka = \"127.0.0.1:9092\" # Global setting publicationChannelSize = \"10000\" publishKafka = false publishLocal = true The rewards history are saved under {fullnode home}/marketdata/marketdata.json . For example, Note: Quantities here are expressed without decimals, i.e. shifted by 10^8 { \"Height\" : 59947302 , \"Fee\" : \"GSYS:5000\" , \"Validators\" :[ \"bnb1tpagqqqx36gq09kzw4f5a3a9sk3tq54dpl5ldn\" ]} { \"Height\" : 59947303 , \"Fee\" : \"GSYS:5000\" , \"Validators\" :[ \"bnb1y888axmhzz6yjj464syfy68mkhzy9phlv8fzac\" ]} { \"Height\" : 59947304 , \"Fee\" : \"GSYS:5000\" , \"Validators\" :[ \"bnb19klje94mnu53wj7pmrk0zmtpwgr0uz8th0fcvw\" ]} { \"Height\" : 59947305 , \"Fee\" : \"GSYS:21364\" , \"Validators\" :[ \"bnb19hunw9ps8n9tkrp2j64jvheezgqmfc2eyrxd7a\" ]} { \"Height\" : 59947306 , \"Fee\" : \"\" , \"Validators\" :[]} ... { \"Height\" : 59947480 , \"Fee\" : \"BUSD-BD1:1486828;XRP-BF2:3311258\" , \"Validators\" :[ \"bnb19klje94mnu53wj7pmrk0zmtpwgr0uz8th0fcvw\" ]} ... Trading fees can be charged in different BEP2 tokens,","title":"Fees"},{"location":"guides/concepts/fees.html#trading-fees-on-dex","text":"Trading fees are subject to complex logic that may mean that individual trades are not charged exactly by the rates below, but between them instead; this is due to the block-based matching engine in use on the DEX. The current fee for trades, applied on the settled amounts, is as follows: Transaction Type Pay in non-GSYS Asset Pay in GSYS Trade 0.1% 0.05% Trading fee can be queried at here . It's under the \"params/DexFeeParam/\". \"FeeRate\" and \"FeeRateNative\" are both under unit of 10^-6.","title":"Trading Fees on DEX"},{"location":"guides/concepts/fees.html#fix-fee-table","text":"The difference between Genesys Chain and Ethereum is that there is no notion of gas . As a result, fees for the rest transactions are fixed. The details are showned in the table below:","title":"Fix Fee Table"},{"location":"guides/concepts/fees.html#current-fees-table-on-mainnet","text":"Fees are variable and may change over time as governance proposals are proposed and voted on. The current fees table for Mainnet as of 2021-03-21 is as follows: Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related New Order 0 0 Y Cancel (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y Order Expire (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y IOC (No Fill) Equivalent 0.00025 GSYS 0.000005 GSYS Y Transfer N/A 0.000075 GSYS N crossTransferOut N/A 0.000075 GSYS N Multi-send N/A 0.00006 GSYS N Issue Asset N/A 10 GSYS Mint Asset N/A 0.002 GSYS N Transfer ownership N/A 0.002 GSYS N Burn Asset N/A 0.002 GSYS N Freeze/Unfreeze Asset N/A 0.001 GSYS N Lock/unlock/relock Asset N/A 0.002 GSYS N List Asset N/A 200 GSYS N Submit Proposal N/A 1 GSYS N Deposit N/A 0.000125 GSYS N Enable Memo Check N/A 0.2 GSYS N Disable Memo Check N/A 0.2 GSYS N HTLT N/A 0.000075 GSYS N depositHTLT N/A 0.000075 GSYS N claimHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N TinyIssueFee N/A 0.4 GSYS N MiniIssueFee N/A 0.6 GSYS N SetTokenUri N/A 0.000075 GSYS N List BEP8 Token N/A 1 GSYS N Create A New Smart Chain Validator N/A 2 GSYS N Edit Smart Chain Validator Information N/A 0.2 GSYS N Delegate Smart Chain Validator N/A 0.0002 GSYS N Redelegate Smart Chain Validator N/A 0.0006 GSYS N Undelegate Smart Chain Validator N/A 0.0004 GSYS N Unjail A Smart Chain Validator N/A 0.5 GSYS N Submit Byzaitine Behavior Evidence of A Smart Chain Validator N/A 0.5 GSYS N Submit Smart Chain Proposal N/A 1 GSYS N Smart Chain Proposal Deposit N/A 0.00025 GSYS N Smart Chain Proposal Vote N/A 0 GSYS N Cross transfer out relayer reward N/A 0.0004 GSYS N","title":"Current Fees Table on Mainnet"},{"location":"guides/concepts/fees.html#current-fees-table-on-testnet","text":"Fees are variable and may change over time as governance proposals are proposed and voted on. The current fees table for Testnet as of 2021-03-17 is as follows: Transaction Type Pay in Non-GSYS Asset Pay in GSYS Exchange (DEX) Related New Order 0 0 Y Cancel (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y Order Expire (No Fill) Equivalent 0.00005 GSYS 0.00001 GSYS Y IOC (No Fill) Equivalent 0.00025 GSYS 0.000005 GSYS Y Transfer N/A 0.000075 GSYS N crossTransferOut N/A 0.000075 GSYS N Multi-send N/A 0.00006 GSYS N Issue Asset N/A 10 GSYS Mint Asset N/A 0.002 GSYS N Transfer ownership N/A 0.002 GSYS N Burn Asset N/A 0.002 GSYS N Freeze/Unfreeze Asset N/A 0.001 GSYS N Lock/unlock/relock Asset N/A 0.002 GSYS N List Asset N/A 200 GSYS N Submit Proposal N/A 1 GSYS N Deposit N/A 0.000125 GSYS N Enable Memo Check N/A 0.2 GSYS N Disable Memo Check N/A 0.2 GSYS N HTLT N/A 0.000075 GSYS N depositHTLT N/A 0.000075 GSYS N claimHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N refundHTLT N/A 0.000075 GSYS N TinyIssueFee N/A 0.4 GSYS N MiniIssueFee N/A 0.6 GSYS N SetTokenUri N/A 0.000075 GSYS N List BEP8 Token N/A 1 GSYS N Create A New Smart Chain Validator N/A 2 GSYS N Edit Smart Chain Validator Information N/A 0.2 GSYS N Delegate Smart Chain Validator N/A 0.0002 GSYS N Redelegate Smart Chain Validator N/A 0.0006 GSYS N Undelegate Smart Chain Validator N/A 0.0004 GSYS N Unjail A Smart Chain Validator N/A 0.5 GSYS N Submit Byzaitine Behavior Evidence of A Smart Chain Validator N/A 0.5 GSYS N Submit Smart Chain Proposal N/A 1 GSYS N Smart Chain Proposal Deposit N/A 0.00025 GSYS N Smart Chain Proposal Vote N/A 0 GSYS N Cross transfer out relayer reward N/A 0.0004 GSYS N","title":"Current Fees Table on Testnet"},{"location":"guides/concepts/fees.html#how-to-calculate-multisend-fee","text":"eth-cli offers you a multi-send command to transfer multiple tokens to multiple people. 20% discount is available for multi-send transactions. For now, multi-send transaction will send some tokens from one address to multiple output addresses. If the count of output address is bigger than the threshold, currently it's 2, then the total transaction fee is 0.001 GSYS per token per address. For example, if you send 3 ABC token,1 SAT token and 1 ABC to 3 different addresses. [ { \"to\" : \"bnb1g5p04snezgpky203fq6da9qyjsy2k9kzr5yuhl\" , \"amount\" : \"100000000:GSYS,100000000:ABC\" }, { \"to\" : \"bnb1l86xty0m55ryct9pnypz6chvtsmpyewmhrqwxw\" , \"amount\" : \"100000000:GSYS\" }, { \"to\" : \"bnb1l86xty0maxdgst9pnypz6chvtsmpydkjflfioe\" , \"amount\" : \"100000000:GSYS,100000000:SAT\" } ] You will pay on mainnet/testnet 0.0003 GSYS * 5 = 0.0015 GSYS","title":"How to calculate multisend fee"},{"location":"guides/concepts/fees.html#how-are-rewards-distributed-between-validators","text":"you can use API to get the latest fee params. [ { msg_ t ype : \"submit_proposal\" , fee : 500000000 , fee _ f or : 1 }, { msg_ t ype : \"deposit\" , fee : 62500 , fee _ f or : 1 }, { msg_ t ype : \"vote\" , fee : 0 , fee _ f or : 3 }, { msg_ t ype : \"create_validator\" , fee : 1000000000 , fee _ f or : 1 }, { msg_ t ype : \"remove_validator\" , fee : 100000000 , fee _ f or : 1 }, { msg_ t ype : \"dexList\" , fee : 100000000000 , fee _ f or : 2 }, { msg_ t ype : \"orderNew\" , fee : 0 , fee _ f or : 3 }, { msg_ t ype : \"orderCancel\" , fee : 0 , fee _ f or : 3 }, { msg_ t ype : \"issueMsg\" , fee : 50000000000 , fee _ f or : 2 }, { msg_ t ype : \"mintMsg\" , fee : 500000000 , fee _ f or : 2 }, { msg_ t ype : \"tokensBurn\" , fee : 50000000 , fee _ f or : 1 }, { msg_ t ype : \"tokensFreeze\" , fee : 500000 , fee _ f or : 1 }, { f ixed_ fee _params : { msg_ t ype : \"send\" , fee : 37500 , fee _ f or : 1 }, mul t i_ transfer _ fee : 30000 , lower_limi t _as_mul t i : 2 }, { dex_ fee _ f ields : [ { fee _ na me : \"ExpireFee\" , fee _value : 25000 }, { fee _ na me : \"ExpireFeeNative\" , fee _value : 5000 }, { fee _ na me : \"CancelFee\" , fee _value : 25000 }, { fee _ na me : \"CancelFeeNative\" , fee _value : 5000 }, { fee _ na me : \"FeeRate\" , fee _value : 1000 }, { fee _ na me : \"FeeRateNative\" , fee _value : 400 }, { fee _ na me : \"IOCExpireFee\" , fee _value : 10000 }, { fee _ na me : \"IOCExpireFeeNative\" , fee _value : 2500 } ] }, { msg_ t ype : \"timeLock\" , fee : 1000000 , fee _ f or : 1 }, { msg_ t ype : \"timeUnlock\" , fee : 1000000 , fee _ f or : 1 }, { msg_ t ype : \"timeRelock\" , fee : 1000000 , fee _ f or : 1 }, { msg_ t ype : \"setAccountFlags\" , fee : 100000000 , fee _ f or : 1 }, { msg_ t ype : \"HTLT\" , fee : 37500 , fee _ f or : 1 }, { msg_ t ype : \"depositHTLT\" , fee : 37500 , fee _ f or : 1 }, { msg_ t ype : \"claimHTLT\" , fee : 37500 , fee _ f or : 1 }, { msg_ t ype : \"refundHTLT\" , fee : 37500 , fee _ f or : 1 } ] The fee_for parameter indicate the different distribution way: 1 means rewards is only for block proposer 2 means rewards are shared among all validators 3 means fee is free.","title":"How are rewards distributed between validators?"},{"location":"guides/concepts/fees.html#how-to-query-fees-in-every-block","text":"The rewards for Genesys Chain validators are displayed in explorer. For example: in block 59947302 , validator bnb1tpagqqqx36gq09kzw4f5a3a9sk3tq54dpl5ldn get 0.00005 GSYS as rewards. If you have a fullnode running, you can also get the rewards details exported. To achieve this, you need to set publishBlockFee to be true in your app.toml . To receive rewards stream, there aretwo options publishKafka and publishLocal # Whether we want publish block fee changes publishBlockFee = true blockFeeTopic = \"accounts\" blockFeeKafka = \"127.0.0.1:9092\" # Global setting publicationChannelSize = \"10000\" publishKafka = false publishLocal = true The rewards history are saved under {fullnode home}/marketdata/marketdata.json . For example, Note: Quantities here are expressed without decimals, i.e. shifted by 10^8 { \"Height\" : 59947302 , \"Fee\" : \"GSYS:5000\" , \"Validators\" :[ \"bnb1tpagqqqx36gq09kzw4f5a3a9sk3tq54dpl5ldn\" ]} { \"Height\" : 59947303 , \"Fee\" : \"GSYS:5000\" , \"Validators\" :[ \"bnb1y888axmhzz6yjj464syfy68mkhzy9phlv8fzac\" ]} { \"Height\" : 59947304 , \"Fee\" : \"GSYS:5000\" , \"Validators\" :[ \"bnb19klje94mnu53wj7pmrk0zmtpwgr0uz8th0fcvw\" ]} { \"Height\" : 59947305 , \"Fee\" : \"GSYS:21364\" , \"Validators\" :[ \"bnb19hunw9ps8n9tkrp2j64jvheezgqmfc2eyrxd7a\" ]} { \"Height\" : 59947306 , \"Fee\" : \"\" , \"Validators\" :[]} ... { \"Height\" : 59947480 , \"Fee\" : \"BUSD-BD1:1486828;XRP-BF2:3311258\" , \"Validators\" :[ \"bnb19klje94mnu53wj7pmrk0zmtpwgr0uz8th0fcvw\" ]} ... Trading fees can be charged in different BEP2 tokens,","title":"How to query fees in every block"},{"location":"guides/concepts/genesis.html","text":"This document explains how the genesis file of the Genesys Chain mainnet is structured. It also explains how you can build a genesis file for your own testnet. Note that you can generate a default genesis file for your own testnet by running the following command: bnbchaind init --chain-id The genesis file is stored in ~/.bnbchaind/config/genesis.json . What is a Genesis File A genesis file is a JSON file which defines the initial state of your blockchain. It can be seen as height 0 of your blockchain. The first block, at height 1 , will reference the genesis file as its parent. The state defined in the genesis file contains all the necessary information, like initial token allocation, genesis time, default parameters, and more. Let us break down these information. Genesis Time and Chain_id The genesis_time is defined at the top of the genesis file. It is a UTC timestamps which specifies when the blockchain is due to start. At this time, genesis validators are supposed to come online and start participating in the consensus process. The blockchain starts when more than 2/3rd of the genesis validators (weighted by voting power) are online. \"genesis_time\": \"2019-04-18T05:59:26.228734998Z\" The chain_id is a unique identifier for your chain. It helps differentiate between different chains using the same version of the software. \"chain_id\": \"GSYS-Chain-Tigris\", Consensus Parameters Next, the genesis file defines consensus parameters. Consensus parameters regroup all the parameters that are related to the consensus layer, which is Tendermint in the case of Genesys Chain . Let us look at these parameters: block_size max_bytes : Maximum number of bytes per block is 1048576. max_gas : Gas limit per block. As gas is not used to calculate transaction fees at the moment. The limit. is set to -1 . evidence max_age : An evidence is a proof that a validator signed two different blocks at the same height (and round). This is an explicitly malicious behaviour that is punished at the state-machine level. The max_age defines the maximum number of blocks after which an evidence is not valid anymore. validator pub_key_types : Currently only ed25519 is accepted for validators. co nsensus _params : { block_size : { max_by tes : \"1048576\" , max_gas : \"-1\" }, evide n ce : { max_age : \"100000\" }, valida t or : { pub_key_ t ypes : [ \"ed25519\" ] } }, Application State The application state defines the initial state of the state-machine. Genesis Accounts In this section, initial allocation of tokens is defined. It is possible to add accounts manually by directly editing the genesis file, but it is also possible to edit the balance after genesis file is created. This command creates an item in the accounts list, under the app_state section. In this section, you can see the three different address of all 11 validators. [ { na me : \"Aconcagua\" , address : \"bnb1y888axmhzz6yjj464syfy68mkhzy9phlv8fzac\" , co nsensus _addr : \"\" }, { na me : \"Aconcagua\" , address : \"bnb1kdx4xkktr35j2mpxncvtsshswj5gq577me7lx4\" , co nsensus _addr : \"A71E5CD078B8C5C7B1AF88BCE84DD70B0557D93E\" }, Let us break down the list: The first address bnb1y888axmhzz6yjj464syfy68mkhzy9phlv8fzac . At genesis block, according to gentx info, same amount of staking tokens will be allocated to this address. It is also used to receive rewards after chain launched. The second address bnb1kdx4xkktr35j2mpxncvtsshswj5gq577me7lx4 is used for governance consensus_addr is used for signing new blocks Token The tokens module handles tokens. It contains the information of Genesys Chain native token GSYS name: \"Genesys Chain Native Token\", symbol: \"GSYS\", total_supply: \"20000000000000000\", owner: \"bnb1ultyhpw2p2ktvr68swz56570lgj2rdsadq3ym2\", mintable: false Staking The staking module handles the bulk of the Proof-of-Stake logic of the state-machine. This section should look like the following: stake: { pool: { loose_tokens: \"20000000000000000\", bonded_tokens: \"0\" }, params: { unbonding_time: \"604800000000000\", max_validators: 21, bond_denom: \"GSYS\" }, validators: null, bonds: null }, Let us break down the parameters: pool not_bonded_tokens : Defines the amount of tokens not bonded (i.e. delegated) in genesis. Generally, it equals the total supply of the staking token, it's shifted by 8 digits for representing decimals. bonded_tokens : Amount of bonded tokens in genesis. Generally 0 . params unbonding_time : Time in nanosecond it takes for tokens to complete unbonding. max_validators : Maximum number of active validators. bond_denom : Denomination of the staking token. validators : List of last known validators. Generally null in genesis (except if genesis was generated using a previous state). bonds : List of last known delegation. Generally null in genesis (except if genesis was generated using a previous state). Governance The gov module handles all governance-related transactions. The initial state of the gov section looks like the following: gov: { starting_proposalID: \"1\", deposit_params: { min_deposit: [ { denom: \"GSYS\", amount: \"100000000000\" } ], max_deposit_period: \"172800000000000\" }, tally_params: { quorum: \"50000000\", threshold: \"50000000\", veto: \"33400000\" } }, Let us break down the parameters: starting_proposal_id : This parameter defines the ID of the first proposal. Each proposal is identified by a unique ID. deposit_params min_deposit : The minimum deposit required for the proposal to enter Voting Period . max_deposit_period : The maximum period (in nanoseconds ) after which it is not possible to deposit on the proposal anymore. tally_params quorum : Minimum percentage of bonded staking tokens that needs to vote for the result to be valid. threshold : Minimum percentage of votes that need to be YES for the result to be valid. veto : Maximum percentage NO_WITH_VETO votes for the result to be valid. Genesis Transactions A gentx is a transaction that bonds staking token present in the genesis file under accounts to a validator, essentially creating a validator at genesis. The chain will start as soon as more than 2/3rds of the validators (weighted by voting power) that are the recipient of a valid gentx come online after genesis_time . A gentx can be added manually to the genesis file { type: \"auth/StdTx\", value: { msg: [ { type: \"cosmos-sdk/MsgCreateValidatorProposal\", value: { MsgCreateValidator: { Description: { moniker: \"Aconcagua\", identity: \"\", website: \"\", details: \"\" }, Commission: { rate: \"0\", max_rate: \"0\", max_change_rate: \"0\" }, delegator_address: \"bnb1y888axmhzz6yjj464syfy68mkhzy9phlv8fzac\", validator_address: \"bva1kdx4xkktr35j2mpxncvtsshswj5gq577m9l0c3\", pubkey: { type: \"tendermint/PubKeyEd25519\", value: \"Xj/NowvRnUXEtzaI2jXn2h/OfGhZssHyDtUgLSQUTj4=\" }, delegation: { denom: \"GSYS\", amount: \"1000000000000\" } }, proposal_id: \"0\" } } ], signatures: [ { pub_key: { type: \"tendermint/PubKeySecp256k1\", value: \"AoeLfC96urAqZtAxg7cCSXh/+tRxGMthLbvXFu/w9nO0\" }, signature: \"b0wYwS7fJcpg0TerEoH22T1CqcZMc3NHm0BusK/+LPMPtqHQuOkbIlPUM12r1iXJjKZhPM/ItFveKIo1oFtfUg==\", account_number: \"0\", sequence: \"0\" }, { pub_key: { type: \"tendermint/PubKeySecp256k1\", value: \"AreZUwAj6OlZI+xHZm66K4Nj5G/eNei768x77fdFz1fc\" }, signature: \"GefEmRyOFk5jGpIZnaGNAOubzPn+wedg62mf8m8yV5cWK7+SByBCcCTHQ+7kB+mkMjOR1AIuXC7Xfou5Q/QhgQ==\", account_number: \"0\", sequence: \"0\" } ], memo: \"\", source: \"0\", data: null } }, A gentx is just a signed message that validator signed to agree to be validators. Let us break down the parameters: Signature related info pub_key : pubkey is used for verifying signature signature : the signature from validator account_number : Unique identifier for the account. It is generated the first time a transaction including this account is included in a block. In gentx, they are all 0 sequence : This number is used to count the number of transactions sent by this account. It is incremented each time a transaction is included in a block, and used to prevent replay attacks. Initial value is 0. memo , source and data are all customized details regarding this transaction Delegation info moniker : the name of validator delegator_address : this is the address that is listed in app_state section validator_address : this is the validator pubkey in bech32 encoding with prefix of bva delegation: this is the delegation amount. It's shifted by 8 digits for representing decimals.","title":"Genesis File"},{"location":"guides/concepts/genesis.html#what-is-a-genesis-file","text":"A genesis file is a JSON file which defines the initial state of your blockchain. It can be seen as height 0 of your blockchain. The first block, at height 1 , will reference the genesis file as its parent. The state defined in the genesis file contains all the necessary information, like initial token allocation, genesis time, default parameters, and more. Let us break down these information.","title":"What is a Genesis File"},{"location":"guides/concepts/genesis.html#genesis-time-and-chain_id","text":"The genesis_time is defined at the top of the genesis file. It is a UTC timestamps which specifies when the blockchain is due to start. At this time, genesis validators are supposed to come online and start participating in the consensus process. The blockchain starts when more than 2/3rd of the genesis validators (weighted by voting power) are online. \"genesis_time\": \"2019-04-18T05:59:26.228734998Z\" The chain_id is a unique identifier for your chain. It helps differentiate between different chains using the same version of the software. \"chain_id\": \"GSYS-Chain-Tigris\",","title":"Genesis Time and Chain_id"},{"location":"guides/concepts/genesis.html#consensus-parameters","text":"Next, the genesis file defines consensus parameters. Consensus parameters regroup all the parameters that are related to the consensus layer, which is Tendermint in the case of Genesys Chain . Let us look at these parameters: block_size max_bytes : Maximum number of bytes per block is 1048576. max_gas : Gas limit per block. As gas is not used to calculate transaction fees at the moment. The limit. is set to -1 . evidence max_age : An evidence is a proof that a validator signed two different blocks at the same height (and round). This is an explicitly malicious behaviour that is punished at the state-machine level. The max_age defines the maximum number of blocks after which an evidence is not valid anymore. validator pub_key_types : Currently only ed25519 is accepted for validators. co nsensus _params : { block_size : { max_by tes : \"1048576\" , max_gas : \"-1\" }, evide n ce : { max_age : \"100000\" }, valida t or : { pub_key_ t ypes : [ \"ed25519\" ] } },","title":"Consensus Parameters"},{"location":"guides/concepts/genesis.html#application-state","text":"The application state defines the initial state of the state-machine.","title":"Application State"},{"location":"guides/concepts/genesis.html#genesis-accounts","text":"In this section, initial allocation of tokens is defined. It is possible to add accounts manually by directly editing the genesis file, but it is also possible to edit the balance after genesis file is created. This command creates an item in the accounts list, under the app_state section. In this section, you can see the three different address of all 11 validators. [ { na me : \"Aconcagua\" , address : \"bnb1y888axmhzz6yjj464syfy68mkhzy9phlv8fzac\" , co nsensus _addr : \"\" }, { na me : \"Aconcagua\" , address : \"bnb1kdx4xkktr35j2mpxncvtsshswj5gq577me7lx4\" , co nsensus _addr : \"A71E5CD078B8C5C7B1AF88BCE84DD70B0557D93E\" }, Let us break down the list: The first address bnb1y888axmhzz6yjj464syfy68mkhzy9phlv8fzac . At genesis block, according to gentx info, same amount of staking tokens will be allocated to this address. It is also used to receive rewards after chain launched. The second address bnb1kdx4xkktr35j2mpxncvtsshswj5gq577me7lx4 is used for governance consensus_addr is used for signing new blocks","title":"Genesis Accounts"},{"location":"guides/concepts/genesis.html#token","text":"The tokens module handles tokens. It contains the information of Genesys Chain native token GSYS name: \"Genesys Chain Native Token\", symbol: \"GSYS\", total_supply: \"20000000000000000\", owner: \"bnb1ultyhpw2p2ktvr68swz56570lgj2rdsadq3ym2\", mintable: false","title":"Token"},{"location":"guides/concepts/genesis.html#staking","text":"The staking module handles the bulk of the Proof-of-Stake logic of the state-machine. This section should look like the following: stake: { pool: { loose_tokens: \"20000000000000000\", bonded_tokens: \"0\" }, params: { unbonding_time: \"604800000000000\", max_validators: 21, bond_denom: \"GSYS\" }, validators: null, bonds: null }, Let us break down the parameters: pool not_bonded_tokens : Defines the amount of tokens not bonded (i.e. delegated) in genesis. Generally, it equals the total supply of the staking token, it's shifted by 8 digits for representing decimals. bonded_tokens : Amount of bonded tokens in genesis. Generally 0 . params unbonding_time : Time in nanosecond it takes for tokens to complete unbonding. max_validators : Maximum number of active validators. bond_denom : Denomination of the staking token. validators : List of last known validators. Generally null in genesis (except if genesis was generated using a previous state). bonds : List of last known delegation. Generally null in genesis (except if genesis was generated using a previous state).","title":"Staking"},{"location":"guides/concepts/genesis.html#governance","text":"The gov module handles all governance-related transactions. The initial state of the gov section looks like the following: gov: { starting_proposalID: \"1\", deposit_params: { min_deposit: [ { denom: \"GSYS\", amount: \"100000000000\" } ], max_deposit_period: \"172800000000000\" }, tally_params: { quorum: \"50000000\", threshold: \"50000000\", veto: \"33400000\" } }, Let us break down the parameters: starting_proposal_id : This parameter defines the ID of the first proposal. Each proposal is identified by a unique ID. deposit_params min_deposit : The minimum deposit required for the proposal to enter Voting Period . max_deposit_period : The maximum period (in nanoseconds ) after which it is not possible to deposit on the proposal anymore. tally_params quorum : Minimum percentage of bonded staking tokens that needs to vote for the result to be valid. threshold : Minimum percentage of votes that need to be YES for the result to be valid. veto : Maximum percentage NO_WITH_VETO votes for the result to be valid.","title":"Governance"},{"location":"guides/concepts/genesis.html#genesis-transactions","text":"A gentx is a transaction that bonds staking token present in the genesis file under accounts to a validator, essentially creating a validator at genesis. The chain will start as soon as more than 2/3rds of the validators (weighted by voting power) that are the recipient of a valid gentx come online after genesis_time . A gentx can be added manually to the genesis file { type: \"auth/StdTx\", value: { msg: [ { type: \"cosmos-sdk/MsgCreateValidatorProposal\", value: { MsgCreateValidator: { Description: { moniker: \"Aconcagua\", identity: \"\", website: \"\", details: \"\" }, Commission: { rate: \"0\", max_rate: \"0\", max_change_rate: \"0\" }, delegator_address: \"bnb1y888axmhzz6yjj464syfy68mkhzy9phlv8fzac\", validator_address: \"bva1kdx4xkktr35j2mpxncvtsshswj5gq577m9l0c3\", pubkey: { type: \"tendermint/PubKeyEd25519\", value: \"Xj/NowvRnUXEtzaI2jXn2h/OfGhZssHyDtUgLSQUTj4=\" }, delegation: { denom: \"GSYS\", amount: \"1000000000000\" } }, proposal_id: \"0\" } } ], signatures: [ { pub_key: { type: \"tendermint/PubKeySecp256k1\", value: \"AoeLfC96urAqZtAxg7cCSXh/+tRxGMthLbvXFu/w9nO0\" }, signature: \"b0wYwS7fJcpg0TerEoH22T1CqcZMc3NHm0BusK/+LPMPtqHQuOkbIlPUM12r1iXJjKZhPM/ItFveKIo1oFtfUg==\", account_number: \"0\", sequence: \"0\" }, { pub_key: { type: \"tendermint/PubKeySecp256k1\", value: \"AreZUwAj6OlZI+xHZm66K4Nj5G/eNei768x77fdFz1fc\" }, signature: \"GefEmRyOFk5jGpIZnaGNAOubzPn+wedg62mf8m8yV5cWK7+SByBCcCTHQ+7kB+mkMjOR1AIuXC7Xfou5Q/QhgQ==\", account_number: \"0\", sequence: \"0\" } ], memo: \"\", source: \"0\", data: null } }, A gentx is just a signed message that validator signed to agree to be validators. Let us break down the parameters: Signature related info pub_key : pubkey is used for verifying signature signature : the signature from validator account_number : Unique identifier for the account. It is generated the first time a transaction including this account is included in a block. In gentx, they are all 0 sequence : This number is used to count the number of transactions sent by this account. It is incremented each time a transaction is included in a block, and used to prevent replay attacks. Initial value is 0. memo , source and data are all customized details regarding this transaction Delegation info moniker : the name of validator delegator_address : this is the address that is listed in app_state section validator_address : this is the validator pubkey in bech32 encoding with prefix of bva delegation: this is the delegation amount. It's shifted by 8 digits for representing decimals.","title":"Genesis Transactions"},{"location":"guides/concepts/matching-engine.html","text":"GSYS DEX is the native marketplace on Genesys Chain, allowing you to exchange digital assets issued and listed on it. The matching happens within the blockchain nodes and all of the transactions are recorded on-chain, therefore forming a complete, auditable ledger of activity. ATTENTION: The match logic on DEX is quite different from normal centralized exchange. Please go over the trading and match spec below to get the best interests for your orders. Order Types GSYS DEX only accept LIMIT orders, which is adhering to SEC definitions of LIMIT orders TimeInForce: * GTE : Good Till Expire . Order would stay effective until expire time . Order may expire in the UTC midnight after more than 259 , 200 blocks , which is 72 hours in term of blocking time . * IOC : Immediate or Cancel . Orders would be executed as much as it can in the booking block round and then got canceled back if there is still quantity left . Match Logic GSYS DEX uses periodic auction to match all available orders. Maker/Taker concepts are introduced to enhance the current periodic auction match algorithm. The match is still executed only once in each block while the execution prices may vary for maker and taker orders. Anti-front-running Front-running means someone can get prior knowledge of transactions from other beneficial owners via technology or market advantage, so that they can influence the price beforehand and result in economic gain, which usually brings loss or cost to others. It is a daunting question asked to both centralized and other decentralized exchanges (DEX). Especially on some DEX, front-running actually happens quite often, e.g. via gas or timestamp manipulations, or slow matching. There are several design points in GSYS DEX that make front-running very difficult to execute.","title":"Matching Engine"},{"location":"guides/concepts/nc-gov.html","text":"Governance of TC There are many system parameters to control the behavior of the TC: All these parameters of GSYS system contracts should be flexible: slashing threshold, cross-chain transfer fees, relayer reward amount and so on. params of Staking/Slash/Oracle/IBC modules on BC All these parameters will be determined by GSYS Validator Set together through a proposal-vote process based on their staking. Such process will be carried on BC, and the new parameter values will be picked up by corresponding system contracts via cross-chain communication when needed. Fee Table Transaction Type Fee Fee For Submit Smart Chain Proposal 10 GSYSs Proposer Smart Chain Proposal Deposit 0.00125 GSYS Proposer Smart Chain Proposal Vote 1 GSYS Proposer Relayer reward 0.001 GSYS system reward pool Global Parameters min-deposit : The threshold for submitting a proposal on mainnet is 1000GSYS , and the threshold for submitting a proposal on testnet is 2000GSYS Commands Query side chain proposals parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --status passed filter proposals by proposal status, status: deposit_period/voting_period/passed/rejected No --voter bnb1h9ymecpakr8p8lhchtah2xxx7x4xq099umclqu filter by proposals voted on by voted No ## mainnet ./eth-cli gov query-proposals --side-chain-id bsc --trust-node --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli gov query-proposals --side-chain-id chapel --trust-node --chain-id GSYS-Chain-Ganges Query side chain proposal parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --proposal-id 1 proposalID of proposal being queried Yes ## mainnet ./eth-cli gov query-proposal --proposal-id 1 --side-chain-id bsc --trust-node --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli gov query-proposal --proposal-id 1 --side-chain-id chapel --trust-node --chain-id GSYS-Chain-Ganges Query side chain parameters parameter name example comments required --side-chain-id chapel the id of side chain, default is native chain Yes ## mainnet ./eth-cli params side-params --side-chain-id bsc --trust-node ## testnet ./eth-cli params side-params --side-chain-id chapel --trust-node Submit cross chain param change proposal. parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --deposit 200000000000:GSYS deposit of proposal Yes --from alice Name or address of private key with which to sign Yes --key felonyThreshold the parameter name on the side chain Yes --target 0x0000000000000000000000000000000000001001 the address of the contract on side chain Yes --title \"test csc change\" title of proposal Yes --value 0x000000000000000000000000000000000000000000000000000000000000001b the specified value of the parameter on side chain, should encoded in hex Yes --voting-period 604800 voting period in seconds (default 604800) No ## mainet ./eth-cli params submit-bscParam-change-proposal --key \"felonyThreshold\" --value \"0x000000000000000000000000000000000000000000000000000000000000001b\" --target 0x0000000000000000000000000000000000001001 --deposit 200000000000 :GSYS --voting-period 100 --side-chain-id bsc --title \"test csc change\" --from alice --trust-node --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli params submit-bscParam-change-proposal --key \"felonyThreshold\" --value \"0x000000000000000000000000000000000000000000000000000000000000001b\" --target 0x0000000000000000000000000000000000001001 --deposit 200000000000 :GSYS --voting-period 100 --side-chain-id chapel --title \"test csc change\" --from alice --trust-node --chain-id GSYS-Chain-Ganges Submit cross chain channel management proposal. parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --deposit 200000000000:GSYS deposit of proposal Yes --from alice Name or address of private key with which to sign Yes --channel-id 1 the the channel id that want to manage Yes --enable true enable the channel or not (default true) Yes --title \"test csc change\" title of proposal Yes --voting-period 604800 voting period in seconds (default 604800) No ## mainnet ./eth-cli side-chain submit-channel-manage-proposal --channel-id 2 --enable = true --deposit 200000000000 :GSYS --voting-period 100 --side-chain-id bsc --title \"test csc change\" --from alice --trust-node --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli side-chain submit-channel-manage-proposal --channel-id 2 --enable = true --deposit 200000000000 :GSYS --voting-period 100 --side-chain-id chapel --title \"test csc change\" --from alice --trust-node --chain-id GSYS-Chain-Ganges Submit side chain module param change proposal. parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --deposit 200000000000:GSYS deposit of proposal Yes --from alice Name or address of private key with which to sign Yes --title \"test csc change\" title of proposal Yes --sc-param-file param.json the file of Side Chain params (json format) Yes --voting-period 604800 voting period in seconds (default 604800) No ## mainnet ./eth-cli params submit-sc-change-proposal --sc-param-file param.json --deposit 200000000000 :GSYS --voting-period 100 --side-chain-id bsc --title \"test proposal\" --from delegator1 --trust-node --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli params submit-sc-change-proposal --sc-param-file param.json --deposit 200000000000 :GSYS --voting-period 100 --side-chain-id chapel --title \"test proposal\" --from delegator1 --trust-node --chain-id GSYS-Chain-Ganges Vote for side chain proposal parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --proposal-id 1 proposalID of proposal being queried Yes --option Yes vote option {yes, no, no_with_veto, abstain} Yes ## mainnet ./eth-cli gov vote --from alice --side-chain-id bsc --proposal-id 1 --option Yes --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli gov vote --from alice --side-chain-id chapel --proposal-id 1 --option Yes --chain-id GSYS-Chain-Ganges Deposit for side chain proposal parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --proposal-id 1 proposalID of proposal being queried Yes --deposit Yes amount of deposit Yes ## mainnet ./eth-cli gov deposit --from alice --side-chain-id bsc --proposal-id 1 --deposit 1000000000 :GSYS --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli gov deposit --from alice --side-chain-id chapel --proposal-id 1 --deposit 1000000000 :GSYS --chain-id GSYS-Chain-Ganges","title":"Governance of TC"},{"location":"guides/concepts/nc-gov.html#governance-of-tc","text":"There are many system parameters to control the behavior of the TC: All these parameters of GSYS system contracts should be flexible: slashing threshold, cross-chain transfer fees, relayer reward amount and so on. params of Staking/Slash/Oracle/IBC modules on BC All these parameters will be determined by GSYS Validator Set together through a proposal-vote process based on their staking. Such process will be carried on BC, and the new parameter values will be picked up by corresponding system contracts via cross-chain communication when needed.","title":"Governance of TC"},{"location":"guides/concepts/nc-gov.html#fee-table","text":"Transaction Type Fee Fee For Submit Smart Chain Proposal 10 GSYSs Proposer Smart Chain Proposal Deposit 0.00125 GSYS Proposer Smart Chain Proposal Vote 1 GSYS Proposer Relayer reward 0.001 GSYS system reward pool","title":"Fee Table"},{"location":"guides/concepts/nc-gov.html#global-parameters","text":"min-deposit : The threshold for submitting a proposal on mainnet is 1000GSYS , and the threshold for submitting a proposal on testnet is 2000GSYS","title":"Global Parameters"},{"location":"guides/concepts/nc-gov.html#commands","text":"","title":"Commands"},{"location":"guides/concepts/nc-gov.html#query-side-chain-proposals","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --status passed filter proposals by proposal status, status: deposit_period/voting_period/passed/rejected No --voter bnb1h9ymecpakr8p8lhchtah2xxx7x4xq099umclqu filter by proposals voted on by voted No ## mainnet ./eth-cli gov query-proposals --side-chain-id bsc --trust-node --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli gov query-proposals --side-chain-id chapel --trust-node --chain-id GSYS-Chain-Ganges","title":"Query side chain proposals"},{"location":"guides/concepts/nc-gov.html#query-side-chain-proposal","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --proposal-id 1 proposalID of proposal being queried Yes ## mainnet ./eth-cli gov query-proposal --proposal-id 1 --side-chain-id bsc --trust-node --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli gov query-proposal --proposal-id 1 --side-chain-id chapel --trust-node --chain-id GSYS-Chain-Ganges","title":"Query side chain proposal"},{"location":"guides/concepts/nc-gov.html#query-side-chain-parameters","text":"parameter name example comments required --side-chain-id chapel the id of side chain, default is native chain Yes ## mainnet ./eth-cli params side-params --side-chain-id bsc --trust-node ## testnet ./eth-cli params side-params --side-chain-id chapel --trust-node","title":"Query side chain parameters"},{"location":"guides/concepts/nc-gov.html#submit-cross-chain-param-change-proposal","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --deposit 200000000000:GSYS deposit of proposal Yes --from alice Name or address of private key with which to sign Yes --key felonyThreshold the parameter name on the side chain Yes --target 0x0000000000000000000000000000000000001001 the address of the contract on side chain Yes --title \"test csc change\" title of proposal Yes --value 0x000000000000000000000000000000000000000000000000000000000000001b the specified value of the parameter on side chain, should encoded in hex Yes --voting-period 604800 voting period in seconds (default 604800) No ## mainet ./eth-cli params submit-bscParam-change-proposal --key \"felonyThreshold\" --value \"0x000000000000000000000000000000000000000000000000000000000000001b\" --target 0x0000000000000000000000000000000000001001 --deposit 200000000000 :GSYS --voting-period 100 --side-chain-id bsc --title \"test csc change\" --from alice --trust-node --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli params submit-bscParam-change-proposal --key \"felonyThreshold\" --value \"0x000000000000000000000000000000000000000000000000000000000000001b\" --target 0x0000000000000000000000000000000000001001 --deposit 200000000000 :GSYS --voting-period 100 --side-chain-id chapel --title \"test csc change\" --from alice --trust-node --chain-id GSYS-Chain-Ganges","title":"Submit cross chain param change proposal."},{"location":"guides/concepts/nc-gov.html#submit-cross-chain-channel-management-proposal","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --deposit 200000000000:GSYS deposit of proposal Yes --from alice Name or address of private key with which to sign Yes --channel-id 1 the the channel id that want to manage Yes --enable true enable the channel or not (default true) Yes --title \"test csc change\" title of proposal Yes --voting-period 604800 voting period in seconds (default 604800) No ## mainnet ./eth-cli side-chain submit-channel-manage-proposal --channel-id 2 --enable = true --deposit 200000000000 :GSYS --voting-period 100 --side-chain-id bsc --title \"test csc change\" --from alice --trust-node --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli side-chain submit-channel-manage-proposal --channel-id 2 --enable = true --deposit 200000000000 :GSYS --voting-period 100 --side-chain-id chapel --title \"test csc change\" --from alice --trust-node --chain-id GSYS-Chain-Ganges","title":"Submit cross chain channel management proposal."},{"location":"guides/concepts/nc-gov.html#submit-side-chain-module-param-change-proposal","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --deposit 200000000000:GSYS deposit of proposal Yes --from alice Name or address of private key with which to sign Yes --title \"test csc change\" title of proposal Yes --sc-param-file param.json the file of Side Chain params (json format) Yes --voting-period 604800 voting period in seconds (default 604800) No ## mainnet ./eth-cli params submit-sc-change-proposal --sc-param-file param.json --deposit 200000000000 :GSYS --voting-period 100 --side-chain-id bsc --title \"test proposal\" --from delegator1 --trust-node --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli params submit-sc-change-proposal --sc-param-file param.json --deposit 200000000000 :GSYS --voting-period 100 --side-chain-id chapel --title \"test proposal\" --from delegator1 --trust-node --chain-id GSYS-Chain-Ganges","title":"Submit side chain module param change proposal."},{"location":"guides/concepts/nc-gov.html#vote-for-side-chain-proposal","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --proposal-id 1 proposalID of proposal being queried Yes --option Yes vote option {yes, no, no_with_veto, abstain} Yes ## mainnet ./eth-cli gov vote --from alice --side-chain-id bsc --proposal-id 1 --option Yes --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli gov vote --from alice --side-chain-id chapel --proposal-id 1 --option Yes --chain-id GSYS-Chain-Ganges","title":"Vote for side chain proposal"},{"location":"guides/concepts/nc-gov.html#deposit-for-side-chain-proposal","text":"parameter name example comments required --chan-id GSYS-Chain-XXX the chain id of shree chain Yes --side-chain-id chapel the id of side chain, default is native chain Yes --proposal-id 1 proposalID of proposal being queried Yes --deposit Yes amount of deposit Yes ## mainnet ./eth-cli gov deposit --from alice --side-chain-id bsc --proposal-id 1 --deposit 1000000000 :GSYS --chain-id GSYS-Chain-Tigris ## testnet ./eth-cli gov deposit --from alice --side-chain-id chapel --proposal-id 1 --deposit 1000000000 :GSYS --chain-id GSYS-Chain-Ganges","title":"Deposit for side chain proposal"},{"location":"guides/concepts/signature.html","text":"Signatures Signature is the evidence to prove the sender owns the transaction. It will be created from the actions outlined below: Compose a data structure. please note msgs , memo , source , data are the same as in the above payload . chain_id : a string, unique ID for the Chain, it stays the same for most time, but may vary as Genesys Chain evolves; account_number : a string for a 64-bit integer, an identifier number associated with the signing address sequence : a string for a a 64-bit integer, please check accounts memo : a string, a short sentence of remark for the transaction msgs : a byte array, json encoded transaction messages, please check the encoding doc. source : a string for a 64 bits integer, which is an identifier for transaction incoming tools data : byte array, reserved for future use Here is an example in go-sdk : golang // StdSignMsg def type StdSignMsg struct { ChainID string `json:\"chain_id\"` AccountNumber int64 `json:\"account_number\"` Sequence int64 `json:\"sequence\"` Msgs []msg.Msg `json:\"msgs\"` Memo string `json:\"memo\"` Source int64 `json:\"source\"` Data []byte `json:\"data\"` } Encode the above data structure in json, with ordered key, Specifically: Maps have their keys sorted lexicographically Structs keys are marshalled in the order defined in the struct Sign SHA256 of the encoded byte array, to create an ECDSA signature on curve Secp256k1 and serialize the R and S result into a 64-byte array. (both R and S are encoded into 32-byte big endian integers, and then R is put into the first 32 bytes and S are put into the last 32 bytes of the byte array. In order to break S 's malleability, S set to curve.Order() - S if S > curnve.Order()/2 .) The signature will be encoded together with transaction message and sent as payload to Genesys Chain node via RPC or http REST API, as described in the above section.","title":"Signatures"},{"location":"guides/concepts/signature.html#signatures","text":"Signature is the evidence to prove the sender owns the transaction. It will be created from the actions outlined below: Compose a data structure. please note msgs , memo , source , data are the same as in the above payload . chain_id : a string, unique ID for the Chain, it stays the same for most time, but may vary as Genesys Chain evolves; account_number : a string for a 64-bit integer, an identifier number associated with the signing address sequence : a string for a a 64-bit integer, please check accounts memo : a string, a short sentence of remark for the transaction msgs : a byte array, json encoded transaction messages, please check the encoding doc. source : a string for a 64 bits integer, which is an identifier for transaction incoming tools data : byte array, reserved for future use Here is an example in go-sdk : golang // StdSignMsg def type StdSignMsg struct { ChainID string `json:\"chain_id\"` AccountNumber int64 `json:\"account_number\"` Sequence int64 `json:\"sequence\"` Msgs []msg.Msg `json:\"msgs\"` Memo string `json:\"memo\"` Source int64 `json:\"source\"` Data []byte `json:\"data\"` } Encode the above data structure in json, with ordered key, Specifically: Maps have their keys sorted lexicographically Structs keys are marshalled in the order defined in the struct Sign SHA256 of the encoded byte array, to create an ECDSA signature on curve Secp256k1 and serialize the R and S result into a 64-byte array. (both R and S are encoded into 32-byte big endian integers, and then R is put into the first 32 bytes and S are put into the last 32 bytes of the byte array. In order to break S 's malleability, S set to curve.Order() - S if S > curnve.Order()/2 .) The signature will be encoded together with transaction message and sent as payload to Genesys Chain node via RPC or http REST API, as described in the above section.","title":"Signatures"},{"location":"guides/concepts/threshold-signature-scheme.html","text":"Threshold Signature Scheme Introduction Threshold Signature Scheme (TSS) is a cryptographic protocol for distributed key generation and signing. TSS allows constructing a signature that is distributed among different parties (for example three users), and each user receives a share of the private signing key. To sign a transaction, at least two of these three users need to join. For individuals, threshold signatures allow for two-factor security or splitting the ability to sign between two devices so that a single compromised device won\u2019t put the money at risk. For businesses, threshold signatures allow for the realization of access control policies that prevent both insiders and outsiders from stealing corporate funds. TSS technology allows us to replace all signing commands with distributed computations.The private key is no longer a single point of failure. Motivation A physical key must fit exactly into a keyhole to unlock a physical vault. But if this key is compromised or lost, the funds locked in the vault may no longer be safe. This simple approach of key management may make sense when a small sum is at stake. However, when the amount stored in the vault is large, it is wise to consider spreading the responsibility of key ownership between several trusted parties. Traditional MultiSig (multi-signature) is a more refined unlocking system that requires multiple independent keys to unlock the vault. MultiSig requires generating a larger private key and the vault has multiple locks - one for each key . More processing power is needed as participants have to sign additional signatures, which must then be checked individually by the network. This is not ideal, because a participant must leave traces showing exactly who signed and multiple parties must be online at the same time. With Threshold Signatures , all of the parties must forge the vault\u2019s lock together, in a modular way, where each party owns a share of the key. A TSS vault is indistinguishable from a regular vault and is hence universal, and it has the same privacy and verification cost of a regular vault. Even if only a subset of the keys is available, the vault may still be unlocked (this is known as meeting a threshold of participation). Combining TSS feature with Genesys Chain client will help users manage their funds in a much safer way. TSS will be offered in an independent binary, but it will have some impact on the existing functions of eth-cli/eth-cli . Implementation Many development resources have been poured into implementing TSS, a cryptographic protocol for distributed key generation and signing. TSS is now compatible and reusable for ECDSA-based blockchains, including Genesys Chain, Bitcoin, and Ethereum networks. We expect that members of the GSYS ecosystem and partner community can integrate this TSS library with their applications, such as wallets and custodians, and further develop this exciting new technology. With the support of the Genesys Chain community, we are happy to share the open-source code athttps://github.com/githubusername/githubrepo/tss-lib. Security Audit The implementation of a multi-party threshold ECDSA library is open source so it can be publicly audited by anyone. An independent third party auditors from Kudelski Security are hired to validate the security of the cryptography in TSS solution. The latest report in October by can be found here . Security checks are routinely and continuously planed for all parts of TSS lib implmentations and future audits will be reported to Genesys Chain community. Workflow Let\u2019s take a look at the major steps in TSS: Vault Initialization : the first step is for setting up tss parameters of each party. This will initialize the node's p2p listen address and setup a directory to save key. It's recommended that you should save your tss key in a different folder other than normal key info. Key Generation : the second step is also the most complex. We need to define the quorum policy: count of total parties (n) that holds secret shares and threshold (t) which means at least t + 1 parties need to take part in the signing process. We need to generate a key which will be public and used to verify future signatures. However, we also have to generate an individual secret for each party, which is called a secret share. The functions guarantee the same public key to all parties and a different secret share for each. In this way, we achieve: (1) privacy: no secret shares data is leaked between any parties, and (2) correctness: the public key is intact with secret share. They need to agree on the channel which they want to use for sending messages between each other. The channel will have its corresponding password. Both ID and password needs to be shared offline. Signing : this step involves a signature generation function. The input of each party will be its own secret share, created as output of the distributed key generation in the previous step. There is also public input known to all, which is the message to be signed. The output will be a digital signature, and the property of privacy ensures that no leakage of secret shares occurred during the computation. Verification : the verification algorithm remains as it is in the classical setting. To be compatible with single key signatures, Genesys Chain validator nodes can be able to verify the signature with the public key. The transaction will be no different from others. Vault Regroup : Regroup will reset secret share and configs between all parties.It's recommend to switch the configuration periodically, say once a month. If some party lost his key, it's also necessory to reset the distribution once some party lost their key. Regroup will generate new_n secret share with new_t threshold. At least old_t + 1 should participant Where can I download the GSYS TSS CLI? You can download tss client and Genesys Chain Commandline here: * Mainnet: https://github.com/githubusername/githubrepo/node-binary/tree/master/cli/prod/0.6.3 * Testnet: https://github.com/githubusername/githubrepo/node-binary/tree/master/cli/testnet/0.6.3 How to Use Warning : Please test your TSS setup before use this on mainnet. Please backup your eth-cli home before use this tool: cp -r ~/.eth-cli ~/.eth-cli_backup_tss (replace ~/.eth-cli with their eth-cli home) Please refer to this Example to help you understand the whole process Init tss init will create home directory of a new tss setup, generate p2p key pair. Here are the global transaction flags: Name Type Description Note vault_name string name of the vault of this party password string the password of the vault must be 32 bytes or more, the default value is 48 home string Path to config/route_table/node_key/tss_key files, configs in config file can be overridden by command line argument the default value is \"~/.tss\" Here are the flags for tss init : Name Type Description Note kdf.iterations uint32 The number of iterations (or passes) over the memory. the default value is 13 kdf.key_length uint32 Length of the generated key (or password hash) \"must be 32 bytes or more, the default value is 48\" kdf.memory uint32 The amount of memory used by the algorithm (in kibibytes) the default value is 65536 kdf.parallelism uint8 The number of threads (or lanes) used by the algorithm. the default value is 4 kdf.salt_length uint32 Length of the random salt. 16 bytes is recommended for password hashing. the default value is 16 moniker string moniker of current party p2p.listen string Adds a multiaddress to the listen list Describe tss describe will show config and address of a tss vault Here are the flags for tss describe : Name Type Description Note address_prefix string bech32 prefix of address (default \"bnb\") Example ./tss describe > please set vault of this party: [input vault name] > Password to sign with this vault: [input password] address of this vault: bnb1 config of this vault: { \"p2p\": { \"listen\": \"/ip4/0.0.0.0/tcp/59968\", \"bootstraps\": null, \"relays\": null, \"peer_addrs\": [ \"/ip4/127.0.0.1/tcp/59748\", \"/ip4/127.0.0.1/tcp/60022\" ], \"peers\": [ \"test3\", \"test2\" ], \"DefaultBootstap\": false }, \"Id\": \"\", \"Moniker\": \"tss1\", \"vault_name\": \"vault1\", \"Threshold\": 1, \"Parties\": 3, \"log_level\": \"info\", \"profile_addr\": \"\", \"Home\": \"~/.tss\" } Channel tss channel will generate a channel ID for bootstrapping. One party can generate a channel, then share the generated channel ID with others offline. Here are the flags for tss channel : Name Type Description Note channel_expire int expire time in minutes of this channel Default value is 30mins It's advised to refresh the channels regularly. Keygen This command will generated the private key and share the secret. Everyone needs to agree on the password of this private key. The lenght of password must be more than eight . Note: you need to make sure that all the parties are online. Here are the flags for tss keygen : Name Type Description Note address_prefix string prefix of bech32 address the default value is bnb channel_id string channel id for this session channel_password string password to this channel This password has to be set offline. And its length should be more than eight . p2p.peer_addrs []sting peer's multiplex addresses parties int total parities of this scheme threshold int threshold of this scheme, at least threshold + 1 parties need participant signing if you want to add the generated key files in the eth-cli home, you can copy it to the home folder: eth-cli keys add --tss -t tss --tss-home ~/.test1 --tss-vault third test1_third Regroup This command will generate new_n secret from the same private key, and it will be shared with new_t threshold. At least old_t + 1 should participante in signing Here are the flags for tss regroup : Name Type Description Note channel_password string channel password of this session channel_id string channel id of this session is_old string whether this party is old committee. If it is set to true, it will participant signing in regroup. There should be only t+1 parties set this to true for one regroup is_new_member string whether this party is new committee, for new party it will changed to true automatically. if an old party set this to true, its share will be replaced by one generated one new_parties int new total parties of regrouped scheme new_threshold int new threshold of regrouped scheme p2p.new_peer_addrs []sting unknown peer's multiple addresses parties int total parities of this scheme threshold int threshold of this scheme, at least threshold + 1 parties need participant signing Changes to eth-cli/eth-cli We added a new key type \u201ctss\u201d (just like the existing types: \u201clocal\u201d, \u201coffline\u201d, \u201cledger\u201d) to eth-cli which stands for tss secret share. To add a tss key into eth-cli\u2019s keystore: 1. Tss keygen command will automatically add generated secret share into default keystore (~/.eth-cli) with name \u201ctss_ _ \u201d 2. User can manually specify tss\u2019s home, vault_name and a customized eth-cli home like: eth-cli keys add --home ~/.customized_cli --tss -t tss --tss-home ~/.test1 --tss-vault \u201cdefault\u201d my_name All other commands (i.e. send token, place order, delete key etc.) of eth-cli should support tss type key. Example In this example, A, B and C are the parties who decided to share a private key together. They decided that any two of them can sign a transaction. To complete a TSS signing process, they need to follow the following steps: Step 1: Init TSS During this step, all parties from different machines have to initialite their P2P settings before generate the shared key. A B C command ./tss init ./tss init ./tss init Interactive input > please set moniker of this party: tss1 > please set vault of this party: vault1 > please set password of thisvault: [input password] > please input again: [input password] > please set moniker of this party: tss2 > please set vault of this party: vault1 > please set password of this vault: [input password] >please input again: [input password] > please set moniker of this party: tss3 > please set vault of this party:vault1 > please set password of this vault: [input password] > please input again: [input password] output Local party has been initialized under: ~/.tss/vault1 Local party has been initialized under: ~/.tss/vault1 Local party has been initialized under: ~/.tss/vault1 Files touched or generated ~/.tss/vault1/config.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/node_key Step 2: Generate Channel ID for bootstraping In this step, the parties will create a secrect communication channel between them. One of then will generate the channel ID and share with others. In this example, A will generate the channel ID. B and C will not have to do anything. A can also specify the length for this channel session and the default time is 30 mins. A B C command ./tss channel N/A N/A Interactive input > please set expire time in minutes, (default: 30): [input time] N/A N/A output channel id: 5185D3EF597 N/A N/A Step 3: Generate and Share Secret In this step, the private key will be generated and shared between these three parties. All the parties have to be online at the sme time. A B C command ./tss keygen --vault_name vault1 ./tss keygen --vault_name vault1 ./tss keygen --vault_name vault1 Interactive input > Password to sign with this vault: [enter password] > please set total parties(n): 3 > please set threshold(t), at least t + 1 parties need participant signing: 1 > please set channel id of this session [enter ID] > please input password (AGREED offline with peers) of this session: [enter password] > please input password of this tss vault: [enter password] >please input> Password to sign with this vault: [enter password] > please set total parties(n): 3 > please set threshold(t), at least t + 1 parties need participant signing: 1 > please set channel id of this session [enter ID] >please input password (AGREED offline with peers) of this session: [enter password] >please input password of this tss vault: [enter password] > Password to sign with this vault: [enter password] > please set total parties(n): 3 > please set threshold(t), at least t + 1 parties need participant signing: 1 > please set channel id of this session 3085D3EC76D > please input password (AGREED offline with peers) of this session: [enter password] Password of this tss vault: [enter password] output 18:00:09.777 INFO tss-lib: party {0,tss1}: keygen finished! party.go:11318:00:09.777 INFO tss: [tss1] received save data client.go:30418:00:09.777 INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp client.go:309Password of this tss vault:NAME: TYPE: ADDRESS: PUBKEY:tss_tss1_vault1 tss tbnb19277gzv934ayctxeg5k9zdwnx3j48u6tydjv9p bnbp1addwnpepqwazk6d3f6e3f5rjev6z0ufqxk8znq8z89ax2tgnwmzreaq8nu7sx2u4jcc 18:00:09.777 INFO : party {1,tss2}: keygen finished! party.go:11318:00:09.777 INFO tss: [tss2] received save data client.go:30418:00:09.777 INFO tss: [tss2] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp client.go:309Password of this tss vault:NAME: TYPE: ADDRESS: PUBKEY:tss_tss2_vault1 tss tbnb19277gzv934ayctxeg5k9zdwnx3j48u6tydjv9p bnbp1addwnpepqwazk6d3f6e3f5rjev6z0ufqxk8znq8z89ax2tgnwmzreaq8nu7sx2u4jcc 18:00:09.773 INFO tss-lib: party {2,tss3}: keygen finished! party.go:11318:00:09.773 INFO tss: [tss3] received save data client.go:30418:00:09.773 INFO tss: [tss3] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp client.go:309Password of this tss vault:NAME: TYPE: ADDRESS: PUBKEY:tss_tss3_vault1 tss tbnb19277gzv934ayctxeg5k9zdwnx3j48u6tydjv9p bnbp1addwnpepqwazk6d3f6e3f5rjev6z0ufqxk8znq8z89ax2tgnwmzreaq8nu7sx2u4jcc Files touched or generated ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json Step 4: Sign Transaction In this steo, A and B decided to sign a transaction together. Both A and B will try to broadcast the transaction and only one of them will succeed. A B C command eth-cli send --amount 1000000:GSYS --to tbnb1mh3w2kxmdmnvctt7t5nu7hhz9jnp422edqdw2d --from tss_tss1_vault1 --chain-id GSYS-Chain-Ganges --node https://data-seed-pre-0-s1.genesys.network:443 --trust-node eth-cli send --amount 1000000:GSYS --to tbnb1mh3w2kxmdmnvctt7t5nu7hhz9jnp422edqdw2d --from tss_tss2_vault1 --chain-id GSYS-Chain-Ganges --node https://data-seed-pre-0-s1.genesys.network:443 --trust-node NA Interactive input Password to sign with tss_tss1_vault1: [Enter password] > Channel id: 5185D3EF597 please input password (AGREED offline with peers) of this session: [Enter password] Password to sign with tss_tss2_vault1: [Enter password] > Channel id: 5185D3EF597 please input password (AGREED offline with peers) of this session: [Enter password] N/A output Committed at block 33600477 (tx hash: 4FB8096A93D545612A3B5DCE520622608C299C7742103A6BE34C444829BD83A5 ERROR: broadcast_tx_commit: Response error: RPC error -32603 - Internal error: Error on broadcastTxCommit: Tx already exists in cache N/A Files touched or generated N/A N/A N/A Step 5: Regroup Vault First, please generate a new channel for messaging: A B C command ./tss channel N/A N/A Interactive input > please set expire time in minutes, (default: 30): [input time] N/A N/A output channel id: 3415D3FBE00 N/A N/A Then, we can switch to the new channel for sending messages to each others. A B C command ./tss regroup ./tss regroup ./tss regroup Interactive input > please set vault of this party: vault1 > Password to sign with this vault: Password to sign with tss_tss1_vault1: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set new total parties(n): 3 > please set new threshold(t), at least t + 1 parties participant signing: 1 > Channel id: 3415D3FBE00 please input password (AGREED offline with peers) of this session: Password to sign with tss_tss1_vault1: [Enter password] > please set vault of this party: vault1 > Password to sign with this vault: Password to sign with tss_tss1_vault1: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set new total parties(n): 3 > please set new threshold(t), at least t + 1 parties participant signing: 1 > Channel id: 3415D3FBE00 please input password (AGREED offline with peers) of this session: Password to sign with tss_tss1_vault1: [Enter password] > please set vault of this party: vault1 > Password to sign with this vault: Password to sign with tss_tss1_vault1: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set new total parties(n): 3 > please set new threshold(t), at least t + 1 parties participant signing: 1 > Channel id: 3415D3FBE00 please input password (AGREED offline with peers) of this session: Password to sign with tss_tss1_vault1: [Enter password] output INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp Files touched or generated ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/node_key New committee having different t-n from old committee Change 1-3 into 2-4 scheme. old parties (A, B) join new committee new parties (D, E) are newly-joined D E command ./tss init --vault_name vault1 ./tss init --vault_name vault1 Interactive input > please set moniker of this party: tss4 > please set password for key share: [Enter password] > please intput again: [Enter password] > please set moniker of this party: tss4 > please set password for key share: [Enter password] > please intput again: [Enter password] output Local party has been initialized under: ~/.tss/vault1 Local party has been initialized under: ~/.tss/vault1 Regroup from 1-3 to 2-4, with 2 old parties (A and B) and 2 new parties (D and E) A (old&new committee) B (old&new committee) D (new committee) E (new committee) command ./tss regroup/ --vault_name vault1 ./tss regroup --vault_name vault1 ./tss regroup --vault_name vault1 ./tss regroup --vault_name vault1 Interactive input > please input password: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new commitee? [Y/n]: Y > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] > please input password: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties need participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] > please input password: [Enter password] > please set Old total parties(n): 3 > please set Old threshold(t), at least t + 1 parties need participant signing: 1 > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties need participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] > please input password: [Enter password] > please set Old total parties(n): 3 > please set Old threshold(t), at least t + 1 parties need participant signing: 1 > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties need participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] output Files touched or generated ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/payment/config.json ~/.tss/payment/pk.json ~/.tss/vault1/sk.json","title":"Threshold Signature Scheme"},{"location":"guides/concepts/threshold-signature-scheme.html#threshold-signature-scheme","text":"","title":"Threshold Signature Scheme"},{"location":"guides/concepts/threshold-signature-scheme.html#introduction","text":"Threshold Signature Scheme (TSS) is a cryptographic protocol for distributed key generation and signing. TSS allows constructing a signature that is distributed among different parties (for example three users), and each user receives a share of the private signing key. To sign a transaction, at least two of these three users need to join. For individuals, threshold signatures allow for two-factor security or splitting the ability to sign between two devices so that a single compromised device won\u2019t put the money at risk. For businesses, threshold signatures allow for the realization of access control policies that prevent both insiders and outsiders from stealing corporate funds. TSS technology allows us to replace all signing commands with distributed computations.The private key is no longer a single point of failure.","title":"Introduction"},{"location":"guides/concepts/threshold-signature-scheme.html#motivation","text":"A physical key must fit exactly into a keyhole to unlock a physical vault. But if this key is compromised or lost, the funds locked in the vault may no longer be safe. This simple approach of key management may make sense when a small sum is at stake. However, when the amount stored in the vault is large, it is wise to consider spreading the responsibility of key ownership between several trusted parties. Traditional MultiSig (multi-signature) is a more refined unlocking system that requires multiple independent keys to unlock the vault. MultiSig requires generating a larger private key and the vault has multiple locks - one for each key . More processing power is needed as participants have to sign additional signatures, which must then be checked individually by the network. This is not ideal, because a participant must leave traces showing exactly who signed and multiple parties must be online at the same time. With Threshold Signatures , all of the parties must forge the vault\u2019s lock together, in a modular way, where each party owns a share of the key. A TSS vault is indistinguishable from a regular vault and is hence universal, and it has the same privacy and verification cost of a regular vault. Even if only a subset of the keys is available, the vault may still be unlocked (this is known as meeting a threshold of participation). Combining TSS feature with Genesys Chain client will help users manage their funds in a much safer way. TSS will be offered in an independent binary, but it will have some impact on the existing functions of eth-cli/eth-cli .","title":"Motivation"},{"location":"guides/concepts/threshold-signature-scheme.html#implementation","text":"Many development resources have been poured into implementing TSS, a cryptographic protocol for distributed key generation and signing. TSS is now compatible and reusable for ECDSA-based blockchains, including Genesys Chain, Bitcoin, and Ethereum networks. We expect that members of the GSYS ecosystem and partner community can integrate this TSS library with their applications, such as wallets and custodians, and further develop this exciting new technology. With the support of the Genesys Chain community, we are happy to share the open-source code athttps://github.com/githubusername/githubrepo/tss-lib.","title":"Implementation"},{"location":"guides/concepts/threshold-signature-scheme.html#security-audit","text":"The implementation of a multi-party threshold ECDSA library is open source so it can be publicly audited by anyone. An independent third party auditors from Kudelski Security are hired to validate the security of the cryptography in TSS solution. The latest report in October by can be found here . Security checks are routinely and continuously planed for all parts of TSS lib implmentations and future audits will be reported to Genesys Chain community.","title":"Security Audit"},{"location":"guides/concepts/threshold-signature-scheme.html#workflow","text":"Let\u2019s take a look at the major steps in TSS: Vault Initialization : the first step is for setting up tss parameters of each party. This will initialize the node's p2p listen address and setup a directory to save key. It's recommended that you should save your tss key in a different folder other than normal key info. Key Generation : the second step is also the most complex. We need to define the quorum policy: count of total parties (n) that holds secret shares and threshold (t) which means at least t + 1 parties need to take part in the signing process. We need to generate a key which will be public and used to verify future signatures. However, we also have to generate an individual secret for each party, which is called a secret share. The functions guarantee the same public key to all parties and a different secret share for each. In this way, we achieve: (1) privacy: no secret shares data is leaked between any parties, and (2) correctness: the public key is intact with secret share. They need to agree on the channel which they want to use for sending messages between each other. The channel will have its corresponding password. Both ID and password needs to be shared offline. Signing : this step involves a signature generation function. The input of each party will be its own secret share, created as output of the distributed key generation in the previous step. There is also public input known to all, which is the message to be signed. The output will be a digital signature, and the property of privacy ensures that no leakage of secret shares occurred during the computation. Verification : the verification algorithm remains as it is in the classical setting. To be compatible with single key signatures, Genesys Chain validator nodes can be able to verify the signature with the public key. The transaction will be no different from others. Vault Regroup : Regroup will reset secret share and configs between all parties.It's recommend to switch the configuration periodically, say once a month. If some party lost his key, it's also necessory to reset the distribution once some party lost their key. Regroup will generate new_n secret share with new_t threshold. At least old_t + 1 should participant","title":"Workflow"},{"location":"guides/concepts/threshold-signature-scheme.html#where-can-i-download-the-gsys-tss-cli","text":"You can download tss client and Genesys Chain Commandline here: * Mainnet: https://github.com/githubusername/githubrepo/node-binary/tree/master/cli/prod/0.6.3 * Testnet: https://github.com/githubusername/githubrepo/node-binary/tree/master/cli/testnet/0.6.3","title":"Where can I download the GSYS TSS CLI?"},{"location":"guides/concepts/threshold-signature-scheme.html#how-to-use","text":"Warning : Please test your TSS setup before use this on mainnet. Please backup your eth-cli home before use this tool: cp -r ~/.eth-cli ~/.eth-cli_backup_tss (replace ~/.eth-cli with their eth-cli home) Please refer to this Example to help you understand the whole process","title":"How to Use"},{"location":"guides/concepts/threshold-signature-scheme.html#init","text":"tss init will create home directory of a new tss setup, generate p2p key pair. Here are the global transaction flags: Name Type Description Note vault_name string name of the vault of this party password string the password of the vault must be 32 bytes or more, the default value is 48 home string Path to config/route_table/node_key/tss_key files, configs in config file can be overridden by command line argument the default value is \"~/.tss\" Here are the flags for tss init : Name Type Description Note kdf.iterations uint32 The number of iterations (or passes) over the memory. the default value is 13 kdf.key_length uint32 Length of the generated key (or password hash) \"must be 32 bytes or more, the default value is 48\" kdf.memory uint32 The amount of memory used by the algorithm (in kibibytes) the default value is 65536 kdf.parallelism uint8 The number of threads (or lanes) used by the algorithm. the default value is 4 kdf.salt_length uint32 Length of the random salt. 16 bytes is recommended for password hashing. the default value is 16 moniker string moniker of current party p2p.listen string Adds a multiaddress to the listen list","title":"Init"},{"location":"guides/concepts/threshold-signature-scheme.html#describe","text":"tss describe will show config and address of a tss vault Here are the flags for tss describe : Name Type Description Note address_prefix string bech32 prefix of address (default \"bnb\") Example ./tss describe > please set vault of this party: [input vault name] > Password to sign with this vault: [input password] address of this vault: bnb1 config of this vault: { \"p2p\": { \"listen\": \"/ip4/0.0.0.0/tcp/59968\", \"bootstraps\": null, \"relays\": null, \"peer_addrs\": [ \"/ip4/127.0.0.1/tcp/59748\", \"/ip4/127.0.0.1/tcp/60022\" ], \"peers\": [ \"test3\", \"test2\" ], \"DefaultBootstap\": false }, \"Id\": \"\", \"Moniker\": \"tss1\", \"vault_name\": \"vault1\", \"Threshold\": 1, \"Parties\": 3, \"log_level\": \"info\", \"profile_addr\": \"\", \"Home\": \"~/.tss\" }","title":"Describe"},{"location":"guides/concepts/threshold-signature-scheme.html#channel","text":"tss channel will generate a channel ID for bootstrapping. One party can generate a channel, then share the generated channel ID with others offline. Here are the flags for tss channel : Name Type Description Note channel_expire int expire time in minutes of this channel Default value is 30mins It's advised to refresh the channels regularly.","title":"Channel"},{"location":"guides/concepts/threshold-signature-scheme.html#keygen","text":"This command will generated the private key and share the secret. Everyone needs to agree on the password of this private key. The lenght of password must be more than eight . Note: you need to make sure that all the parties are online. Here are the flags for tss keygen : Name Type Description Note address_prefix string prefix of bech32 address the default value is bnb channel_id string channel id for this session channel_password string password to this channel This password has to be set offline. And its length should be more than eight . p2p.peer_addrs []sting peer's multiplex addresses parties int total parities of this scheme threshold int threshold of this scheme, at least threshold + 1 parties need participant signing if you want to add the generated key files in the eth-cli home, you can copy it to the home folder: eth-cli keys add --tss -t tss --tss-home ~/.test1 --tss-vault third test1_third","title":"Keygen"},{"location":"guides/concepts/threshold-signature-scheme.html#regroup","text":"This command will generate new_n secret from the same private key, and it will be shared with new_t threshold. At least old_t + 1 should participante in signing Here are the flags for tss regroup : Name Type Description Note channel_password string channel password of this session channel_id string channel id of this session is_old string whether this party is old committee. If it is set to true, it will participant signing in regroup. There should be only t+1 parties set this to true for one regroup is_new_member string whether this party is new committee, for new party it will changed to true automatically. if an old party set this to true, its share will be replaced by one generated one new_parties int new total parties of regrouped scheme new_threshold int new threshold of regrouped scheme p2p.new_peer_addrs []sting unknown peer's multiple addresses parties int total parities of this scheme threshold int threshold of this scheme, at least threshold + 1 parties need participant signing","title":"Regroup"},{"location":"guides/concepts/threshold-signature-scheme.html#changes-to-eth-clieth-cli","text":"We added a new key type \u201ctss\u201d (just like the existing types: \u201clocal\u201d, \u201coffline\u201d, \u201cledger\u201d) to eth-cli which stands for tss secret share. To add a tss key into eth-cli\u2019s keystore: 1. Tss keygen command will automatically add generated secret share into default keystore (~/.eth-cli) with name \u201ctss_ _ \u201d 2. User can manually specify tss\u2019s home, vault_name and a customized eth-cli home like: eth-cli keys add --home ~/.customized_cli --tss -t tss --tss-home ~/.test1 --tss-vault \u201cdefault\u201d my_name All other commands (i.e. send token, place order, delete key etc.) of eth-cli should support tss type key.","title":"Changes to eth-cli/eth-cli"},{"location":"guides/concepts/threshold-signature-scheme.html#example","text":"In this example, A, B and C are the parties who decided to share a private key together. They decided that any two of them can sign a transaction. To complete a TSS signing process, they need to follow the following steps:","title":"Example"},{"location":"guides/concepts/threshold-signature-scheme.html#step-1-init-tss","text":"During this step, all parties from different machines have to initialite their P2P settings before generate the shared key. A B C command ./tss init ./tss init ./tss init Interactive input > please set moniker of this party: tss1 > please set vault of this party: vault1 > please set password of thisvault: [input password] > please input again: [input password] > please set moniker of this party: tss2 > please set vault of this party: vault1 > please set password of this vault: [input password] >please input again: [input password] > please set moniker of this party: tss3 > please set vault of this party:vault1 > please set password of this vault: [input password] > please input again: [input password] output Local party has been initialized under: ~/.tss/vault1 Local party has been initialized under: ~/.tss/vault1 Local party has been initialized under: ~/.tss/vault1 Files touched or generated ~/.tss/vault1/config.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/node_key","title":"Step 1: Init TSS"},{"location":"guides/concepts/threshold-signature-scheme.html#step-2-generate-channel-id-for-bootstraping","text":"In this step, the parties will create a secrect communication channel between them. One of then will generate the channel ID and share with others. In this example, A will generate the channel ID. B and C will not have to do anything. A can also specify the length for this channel session and the default time is 30 mins. A B C command ./tss channel N/A N/A Interactive input > please set expire time in minutes, (default: 30): [input time] N/A N/A output channel id: 5185D3EF597 N/A N/A","title":"Step 2: Generate Channel ID for bootstraping"},{"location":"guides/concepts/threshold-signature-scheme.html#step-3-generate-and-share-secret","text":"In this step, the private key will be generated and shared between these three parties. All the parties have to be online at the sme time. A B C command ./tss keygen --vault_name vault1 ./tss keygen --vault_name vault1 ./tss keygen --vault_name vault1 Interactive input > Password to sign with this vault: [enter password] > please set total parties(n): 3 > please set threshold(t), at least t + 1 parties need participant signing: 1 > please set channel id of this session [enter ID] > please input password (AGREED offline with peers) of this session: [enter password] > please input password of this tss vault: [enter password] >please input> Password to sign with this vault: [enter password] > please set total parties(n): 3 > please set threshold(t), at least t + 1 parties need participant signing: 1 > please set channel id of this session [enter ID] >please input password (AGREED offline with peers) of this session: [enter password] >please input password of this tss vault: [enter password] > Password to sign with this vault: [enter password] > please set total parties(n): 3 > please set threshold(t), at least t + 1 parties need participant signing: 1 > please set channel id of this session 3085D3EC76D > please input password (AGREED offline with peers) of this session: [enter password] Password of this tss vault: [enter password] output 18:00:09.777 INFO tss-lib: party {0,tss1}: keygen finished! party.go:11318:00:09.777 INFO tss: [tss1] received save data client.go:30418:00:09.777 INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp client.go:309Password of this tss vault:NAME: TYPE: ADDRESS: PUBKEY:tss_tss1_vault1 tss tbnb19277gzv934ayctxeg5k9zdwnx3j48u6tydjv9p bnbp1addwnpepqwazk6d3f6e3f5rjev6z0ufqxk8znq8z89ax2tgnwmzreaq8nu7sx2u4jcc 18:00:09.777 INFO : party {1,tss2}: keygen finished! party.go:11318:00:09.777 INFO tss: [tss2] received save data client.go:30418:00:09.777 INFO tss: [tss2] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp client.go:309Password of this tss vault:NAME: TYPE: ADDRESS: PUBKEY:tss_tss2_vault1 tss tbnb19277gzv934ayctxeg5k9zdwnx3j48u6tydjv9p bnbp1addwnpepqwazk6d3f6e3f5rjev6z0ufqxk8znq8z89ax2tgnwmzreaq8nu7sx2u4jcc 18:00:09.773 INFO tss-lib: party {2,tss3}: keygen finished! party.go:11318:00:09.773 INFO tss: [tss3] received save data client.go:30418:00:09.773 INFO tss: [tss3] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp client.go:309Password of this tss vault:NAME: TYPE: ADDRESS: PUBKEY:tss_tss3_vault1 tss tbnb19277gzv934ayctxeg5k9zdwnx3j48u6tydjv9p bnbp1addwnpepqwazk6d3f6e3f5rjev6z0ufqxk8znq8z89ax2tgnwmzreaq8nu7sx2u4jcc Files touched or generated ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json","title":"Step 3: Generate and Share Secret"},{"location":"guides/concepts/threshold-signature-scheme.html#step-4-sign-transaction","text":"In this steo, A and B decided to sign a transaction together. Both A and B will try to broadcast the transaction and only one of them will succeed. A B C command eth-cli send --amount 1000000:GSYS --to tbnb1mh3w2kxmdmnvctt7t5nu7hhz9jnp422edqdw2d --from tss_tss1_vault1 --chain-id GSYS-Chain-Ganges --node https://data-seed-pre-0-s1.genesys.network:443 --trust-node eth-cli send --amount 1000000:GSYS --to tbnb1mh3w2kxmdmnvctt7t5nu7hhz9jnp422edqdw2d --from tss_tss2_vault1 --chain-id GSYS-Chain-Ganges --node https://data-seed-pre-0-s1.genesys.network:443 --trust-node NA Interactive input Password to sign with tss_tss1_vault1: [Enter password] > Channel id: 5185D3EF597 please input password (AGREED offline with peers) of this session: [Enter password] Password to sign with tss_tss2_vault1: [Enter password] > Channel id: 5185D3EF597 please input password (AGREED offline with peers) of this session: [Enter password] N/A output Committed at block 33600477 (tx hash: 4FB8096A93D545612A3B5DCE520622608C299C7742103A6BE34C444829BD83A5 ERROR: broadcast_tx_commit: Response error: RPC error -32603 - Internal error: Error on broadcastTxCommit: Tx already exists in cache N/A Files touched or generated N/A N/A N/A","title":"Step 4: Sign Transaction"},{"location":"guides/concepts/threshold-signature-scheme.html#step-5-regroup-vault","text":"First, please generate a new channel for messaging: A B C command ./tss channel N/A N/A Interactive input > please set expire time in minutes, (default: 30): [input time] N/A N/A output channel id: 3415D3FBE00 N/A N/A Then, we can switch to the new channel for sending messages to each others. A B C command ./tss regroup ./tss regroup ./tss regroup Interactive input > please set vault of this party: vault1 > Password to sign with this vault: Password to sign with tss_tss1_vault1: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set new total parties(n): 3 > please set new threshold(t), at least t + 1 parties participant signing: 1 > Channel id: 3415D3FBE00 please input password (AGREED offline with peers) of this session: Password to sign with tss_tss1_vault1: [Enter password] > please set vault of this party: vault1 > Password to sign with this vault: Password to sign with tss_tss1_vault1: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set new total parties(n): 3 > please set new threshold(t), at least t + 1 parties participant signing: 1 > Channel id: 3415D3FBE00 please input password (AGREED offline with peers) of this session: Password to sign with tss_tss1_vault1: [Enter password] > please set vault of this party: vault1 > Password to sign with this vault: Password to sign with tss_tss1_vault1: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set new total parties(n): 3 > please set new threshold(t), at least t + 1 parties participant signing: 1 > Channel id: 3415D3FBE00 please input password (AGREED offline with peers) of this session: Password to sign with tss_tss1_vault1: [Enter password] output INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp INFO tss: [tss1] bech32 address is: tbnb1mcn0tl9rtf03ke7g2a6nedqtrd470e8l8035jp Files touched or generated ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/node_key ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/node_key New committee having different t-n from old committee Change 1-3 into 2-4 scheme. old parties (A, B) join new committee new parties (D, E) are newly-joined D E command ./tss init --vault_name vault1 ./tss init --vault_name vault1 Interactive input > please set moniker of this party: tss4 > please set password for key share: [Enter password] > please intput again: [Enter password] > please set moniker of this party: tss4 > please set password for key share: [Enter password] > please intput again: [Enter password] output Local party has been initialized under: ~/.tss/vault1 Local party has been initialized under: ~/.tss/vault1 Regroup from 1-3 to 2-4, with 2 old parties (A and B) and 2 new parties (D and E) A (old&new committee) B (old&new committee) D (new committee) E (new committee) command ./tss regroup/ --vault_name vault1 ./tss regroup --vault_name vault1 ./tss regroup --vault_name vault1 ./tss regroup --vault_name vault1 Interactive input > please input password: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new commitee? [Y/n]: Y > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] > please input password: [Enter password] > Participant as an old committee? [Y/n]: Y > Participant as a new committee? [Y/n]: Y > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties need participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] > please input password: [Enter password] > please set Old total parties(n): 3 > please set Old threshold(t), at least t + 1 parties need participant signing: 1 > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties need participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] > please input password: [Enter password] > please set Old total parties(n): 3 > please set Old threshold(t), at least t + 1 parties need participant signing: 1 > please set NEW total parties(n): 4 > please set NEW threshold(t), at least t + 1 parties need participant signing: 2 > Channel id: 3415D3FBE00 > please input password (AGREED offline with peers) of this session: [Enter password] output Files touched or generated ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/vault1/config.json ~/.tss/vault1/pk.json ~/.tss/vault1/sk.json ~/.tss/payment/config.json ~/.tss/payment/pk.json ~/.tss/vault1/sk.json","title":"Step 5: Regroup Vault"},{"location":"guides/concepts/trading-specification.html","text":"[ ] https://docs.genesys.network/trading-spec.html [ ] https://docs.genesys.network/match.html [ ] https://docs.genesys.network/anti-frontrun.html","title":"Trading Specification"},{"location":"guides/concepts/transaction.html","text":"Genesys Chain Transaction Basics A blockchain is a globally shared, transactional database. This means that everyone can read entries in the database just by participating in the network. If you want to change something in the database, you have to create a so-called transaction which has to be accepted by all others. The word transaction implies that the change you want to make (assume you want to change two values at the same time) is either not done at all or completely applied. Furthermore, while your transaction is being applied to the database, no other transaction can alter it. As an example, imagine a table that lists the balances of all accounts in an electronic currency. If a transfer from one account to another is requested, the transactional nature of the database ensures that if the amount is subtracted from one account, it is always added to the other account. If due to whatever reason, adding the amount to the target account is not possible, the source account is also not modified. Furthermore, a transaction is always cryptographically signed by the sender (creator). This makes it straightforward to guard access to specific modifications of the database. In the example of the electronic currency, a simple check ensures that only the person holding the keys to the account can transfer money from it.","title":"Transaction"},{"location":"guides/concepts/transaction.html#genesys-chain-transaction-basics","text":"A blockchain is a globally shared, transactional database. This means that everyone can read entries in the database just by participating in the network. If you want to change something in the database, you have to create a so-called transaction which has to be accepted by all others. The word transaction implies that the change you want to make (assume you want to change two values at the same time) is either not done at all or completely applied. Furthermore, while your transaction is being applied to the database, no other transaction can alter it. As an example, imagine a table that lists the balances of all accounts in an electronic currency. If a transfer from one account to another is requested, the transactional nature of the database ensures that if the amount is subtracted from one account, it is always added to the other account. If due to whatever reason, adding the amount to the target account is not possible, the source account is also not modified. Furthermore, a transaction is always cryptographically signed by the sender (creator). This makes it straightforward to guard access to specific modifications of the database. In the example of the electronic currency, a simple check ensures that only the person holding the keys to the account can transfer money from it.","title":"Genesys Chain Transaction Basics"},{"location":"guides/concepts/walletconnect.html","text":"[ ] https://docs.genesys.network/walletconnect.html What is WalletConnect? WalletConnect is an open protocol for connecting desktop Dapps to mobile Wallets using end-to-end encryption by scanning a QR code. Opening up a whole world of Dapps that were once only available to Metamask. The user can interact with any Dapp without comprising their private keys and will be notified to sign any transaction requests on their mobile. How does it work? WalletConnect is a simple infrastructure that can be setup by any developer. Using a Bridge server to relay the messages without having access to any of its contents. The contents are encrypted using the session data shared by the QR code between the desktop and mobile. There are libraries for Web, iOS and Android. Read more about it in our documentation introduction. Wallets with WalletConnect Support for Genesys Chain List of Wallets Supporting WalletConnect on Genesys Chain Number Wallet Name Network 1 Trust Wallet Mainnet 2 Math Wallet Mainnet 3 Meet.One Wallet Mainnet 4 Equal Wallet Mainnet&Testnet 5 SafePal Wallet Mainnet 6 CoolWallet Mainnet 7 XWallet Mainnet 8 Atomic Wallet Mainnet Get Started Currently the WalletConnect protocol has references implementations written in Typescript for the Client (browser/react-native/nodejs), the Bridge Server and the Push server. To learn more about how to develop, please read the official documentation . The Genesys Chain Web Wallet supports connecting with external wallet providers via the WalletConnect protocol . WalletConnect allows the user to scan a QR code from the wallet app to unlock and use their wallet seamlessly in the web UI. In order for this to work, some modifications to the standard WalletConnect protocol are used in the Genesys Chain wallet's implementation. See the list of wallets which support WalletConnect on Genesys Chain here Connecting via WalletConnect Wallet providers should make use of the WalletConnect Client SDK for their target programming language and OS. There are implementations on GitHub for iOS, Android, React Native, etc. Protocol Differences Since we do not use Ethereum transactions, there are some differences: Typically sendTransaction is used with Ethereum transaction parameters in WalletConnect dApp integrations. But in Genesys Chain's case, instead of invoking sendTransaction in the WalletConnect flow, the new sendCustomRequest call is used instead with a method called bnb_sign (see below). The external wallet provider is responsible for sending back the signature and public key of the transaction but should not broadcast the transaction itself. We have instead defined a custom result format in the form of stringified JSON containing the signature and public key. The reason for this is that the wallet app probably does not have access to the complete serialized binary form of the transaction (as this requires Amino encoding). The web wallet will send back a second custom call (after bnb_sign ) called bnb_tx_confirmation , which contains the boolean result of the transaction build/broadcast and any error message encountered by the web wallet during broadcasting. In a complete implementation, this confirmation callback should be responded to with a call to approveRequest . Sequence Diagram This sequence diagram shows the flow of messages when the web wallet interacts with an external wallet provider via WalletConnect. Custom Requests A custom call request adheres to this structure: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"method\" : \"method_name\" , \"params\" : [{ ... }], } We have two custom call request formats, here are examples of them: Example: bnb_sign { \"method\" : \"bnb_sign\" , \"params\" : [ { \"account_number\" : \"34\" , \"chain_id\" : \"GSYS-Chain-Ganges\" , \"data\" : null , \"memo\" : \"test\" , \"msgs\" : [ { \"inputs\" : [ { \"address\" : \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" , \"coins\" : [ { \"amount\" : 1000000000 , \"denom\" : \"GSYS\" , }, ], }, ], \"outputs\" : [ { \"address\" : \"tbnb1ss57e8sa7xnwq030k2ctr775uac9gjzglqhvpy\" , \"coins\" : [ { \"amount\" : 1000000000 , \"denom\" : \"GSYS\" , }, ], }, ], }, ], \"sequence\" : \"31\" , \"source\" : \"1\" , } ] } Response (approveRequest) A response like this should be sent back from the wallet app: { \"id\" : 1553682007906047 , \"result\" : \"{\\\"signature\\\":\\\"...\\\",\\\"publicKey\\\":\\\"...\\\"}\" } In result , a JSON-encoded object must be included containing the following hex-string properties: signature , publicKey . Note that: id and jsonrpc are usually pre-filled by the client SDK, so there should be no need to set this in the object yourself. signature should be 64 bytes in length (128 hex chars) publicKey should be 65 bytes in length (130 hex chars, non-compressed form, prefixed with 0x04 ) Example: bnb_tx_confirmation { \"method\" : \"bnb_tx_confirmation\" , \"params\" : [ { \"ok\" : true , \"error\" : \"Error message (optional)\" } ] } Receipt of the bnb_tx_confirmation should be confirmed by the app with approveRequest as per the WalletConnect protocol flow. For this response, result may be empty or contain an empty JSON-encoded object: Response (approveRequest) A response like this should be sent back from the wallet app: { \"id\" : 1553682007906050 , \"result\" : \"\" } Ending the Session Remember to call killSession() when the user has finished using the integration from your app! This will redirect the user back to the unlock screen in the web wallet.","title":"Wallet Connect"},{"location":"guides/concepts/walletconnect.html#what-is-walletconnect","text":"WalletConnect is an open protocol for connecting desktop Dapps to mobile Wallets using end-to-end encryption by scanning a QR code. Opening up a whole world of Dapps that were once only available to Metamask. The user can interact with any Dapp without comprising their private keys and will be notified to sign any transaction requests on their mobile.","title":"What is WalletConnect?"},{"location":"guides/concepts/walletconnect.html#how-does-it-work","text":"WalletConnect is a simple infrastructure that can be setup by any developer. Using a Bridge server to relay the messages without having access to any of its contents. The contents are encrypted using the session data shared by the QR code between the desktop and mobile. There are libraries for Web, iOS and Android. Read more about it in our documentation introduction.","title":"How does it work?"},{"location":"guides/concepts/walletconnect.html#wallets-with-walletconnect-support-for-genesys-chain","text":"List of Wallets Supporting WalletConnect on Genesys Chain Number Wallet Name Network 1 Trust Wallet Mainnet 2 Math Wallet Mainnet 3 Meet.One Wallet Mainnet 4 Equal Wallet Mainnet&Testnet 5 SafePal Wallet Mainnet 6 CoolWallet Mainnet 7 XWallet Mainnet 8 Atomic Wallet Mainnet","title":"Wallets with WalletConnect Support for Genesys Chain"},{"location":"guides/concepts/walletconnect.html#get-started","text":"Currently the WalletConnect protocol has references implementations written in Typescript for the Client (browser/react-native/nodejs), the Bridge Server and the Push server. To learn more about how to develop, please read the official documentation . The Genesys Chain Web Wallet supports connecting with external wallet providers via the WalletConnect protocol . WalletConnect allows the user to scan a QR code from the wallet app to unlock and use their wallet seamlessly in the web UI. In order for this to work, some modifications to the standard WalletConnect protocol are used in the Genesys Chain wallet's implementation. See the list of wallets which support WalletConnect on Genesys Chain here","title":"Get Started"},{"location":"guides/concepts/walletconnect.html#connecting-via-walletconnect","text":"Wallet providers should make use of the WalletConnect Client SDK for their target programming language and OS. There are implementations on GitHub for iOS, Android, React Native, etc.","title":"Connecting via WalletConnect"},{"location":"guides/concepts/walletconnect.html#protocol-differences","text":"Since we do not use Ethereum transactions, there are some differences: Typically sendTransaction is used with Ethereum transaction parameters in WalletConnect dApp integrations. But in Genesys Chain's case, instead of invoking sendTransaction in the WalletConnect flow, the new sendCustomRequest call is used instead with a method called bnb_sign (see below). The external wallet provider is responsible for sending back the signature and public key of the transaction but should not broadcast the transaction itself. We have instead defined a custom result format in the form of stringified JSON containing the signature and public key. The reason for this is that the wallet app probably does not have access to the complete serialized binary form of the transaction (as this requires Amino encoding). The web wallet will send back a second custom call (after bnb_sign ) called bnb_tx_confirmation , which contains the boolean result of the transaction build/broadcast and any error message encountered by the web wallet during broadcasting. In a complete implementation, this confirmation callback should be responded to with a call to approveRequest .","title":"Protocol Differences"},{"location":"guides/concepts/walletconnect.html#sequence-diagram","text":"This sequence diagram shows the flow of messages when the web wallet interacts with an external wallet provider via WalletConnect.","title":"Sequence Diagram"},{"location":"guides/concepts/walletconnect.html#custom-requests","text":"A custom call request adheres to this structure: { \"id\" : 1 , \"jsonrpc\" : \"2.0\" , \"method\" : \"method_name\" , \"params\" : [{ ... }], } We have two custom call request formats, here are examples of them:","title":"Custom Requests"},{"location":"guides/concepts/walletconnect.html#example-bnb_sign","text":"{ \"method\" : \"bnb_sign\" , \"params\" : [ { \"account_number\" : \"34\" , \"chain_id\" : \"GSYS-Chain-Ganges\" , \"data\" : null , \"memo\" : \"test\" , \"msgs\" : [ { \"inputs\" : [ { \"address\" : \"tbnb1hgm0p7khfk85zpz5v0j8wnej3a90w709zzlffd\" , \"coins\" : [ { \"amount\" : 1000000000 , \"denom\" : \"GSYS\" , }, ], }, ], \"outputs\" : [ { \"address\" : \"tbnb1ss57e8sa7xnwq030k2ctr775uac9gjzglqhvpy\" , \"coins\" : [ { \"amount\" : 1000000000 , \"denom\" : \"GSYS\" , }, ], }, ], }, ], \"sequence\" : \"31\" , \"source\" : \"1\" , } ] }","title":"Example: bnb_sign"},{"location":"guides/concepts/walletconnect.html#response-approverequest","text":"A response like this should be sent back from the wallet app: { \"id\" : 1553682007906047 , \"result\" : \"{\\\"signature\\\":\\\"...\\\",\\\"publicKey\\\":\\\"...\\\"}\" } In result , a JSON-encoded object must be included containing the following hex-string properties: signature , publicKey . Note that: id and jsonrpc are usually pre-filled by the client SDK, so there should be no need to set this in the object yourself. signature should be 64 bytes in length (128 hex chars) publicKey should be 65 bytes in length (130 hex chars, non-compressed form, prefixed with 0x04 )","title":"Response (approveRequest)"},{"location":"guides/concepts/walletconnect.html#example-bnb_tx_confirmation","text":"{ \"method\" : \"bnb_tx_confirmation\" , \"params\" : [ { \"ok\" : true , \"error\" : \"Error message (optional)\" } ] } Receipt of the bnb_tx_confirmation should be confirmed by the app with approveRequest as per the WalletConnect protocol flow. For this response, result may be empty or contain an empty JSON-encoded object:","title":"Example: bnb_tx_confirmation"},{"location":"guides/concepts/walletconnect.html#response-approverequest_1","text":"A response like this should be sent back from the wallet app: { \"id\" : 1553682007906050 , \"result\" : \"\" }","title":"Response (approveRequest)"},{"location":"guides/concepts/walletconnect.html#ending-the-session","text":"Remember to call killSession() when the user has finished using the integration from your app! This will redirect the user back to the unlock screen in the web wallet.","title":"Ending the Session"},{"location":"guides/concepts/encoding/amino-example.html","text":"Encoding Examples Encoding Output Genesys Chain (Amino) encoding logic may encode a data structure into two output formats: Binary and JSON. JSON Marshal Amino supports JSON encoding natively, which is the same as other usual json marshalers. Except that it can add one more type info for registered type, as shown below. { \"type\" : \"<amino type name>\" , \"value\" : <JSON> } Examples in Go-SDK Let's take a look at an example function of Genesys Chain go-sdk. func ( c * HTTP ) GetProposal ( proposalId int64 ) ( types . Proposal , error ) { params := types . QueryProposalParams { ProposalID : proposalId , } bz , err := c . cdc . MarshalJSON ( params ) if err != nil { return nil , err } rawProposal , err := c . ABCIQuery ( \"custom/gov/proposal\" , bz ) if err != nil { return nil , err } if ! rawProposal . Response . IsOK (){ return nil , fmt . Errorf ( rawProposal . Response . Log ) } var proposal types . Proposal err = c . cdc . UnmarshalJSON ( rawProposal . Response . GetValue (), & proposal ) return proposal , err } In order to query the proposal, you can use Amino to marshal the request JSON first. bz , err := c . cdc . MarshalJSON ( params ) Then, use the unmarshal method to get the returned result. err = c . cdc . UnmarshalJSON ( rawProposal . Response . GetValue (), & proposal ) Binary Marshal Binary encoding is a variant of Google protocol buffer. The bytes are layed out in the below sequence: a varint encoded integer - it contains the length of the encoded bytes for the object, which is displayed as SIZE-OF-ENCODED in the below structs. Please note that it contains the length of encoded bytes and also the type prefix (below), but not itself, e.g. if the encoded msg is 20 bytes, then the length would be 20 + 4 = 24, while 4 is used for the type prefix bytes. an object type prefix of 4-8 bytes - For different type of objects, there will be different type prefixes, and they are displayed as in the specific objects below (data structures). a binary encoded object - the encoding is mostly the same as protocol buffer encoding mechanism, except the embedded fields of complex type: to encode data field of some specific types, an object type prefix for the field will be added ahead of the real encoding. repeated (array) Encoding - it is the same as google protocol buffer, while encoding of the object/struct may contain the type prefix as shown below. Examples in Go-SDK Let's take a look at an example function of Genesys Chain go-sdk. The signed transaction needs to be amino-encoded, thus ready to be posted to BncChain API. rawBz , err := c . keyManager . Sign ( * signMsg ) if err != nil { return nil , err } hexTx := [] byte ( hex . EncodeToString ( rawBz )) param := map [ string ] string {} if sync { param [ \"sync\" ] = \"true\" } commits , err := c . basicClient . PostTx ( hexTx , param ) hexTx is derived from the following function: bz , err := tx . Cdc . MarshalBinaryLengthPrefixed ( & newTx ) Genesys Chain Transaction Encoding Below are the data types that can be sent to Genesys Chain as requests, and their encoding layout. To simplify the presentation, we will use a variant of Google protocol buffer proto3 language to illustrate how the data fields are organized. Except the all-capitalized fields, other fields will use the default proto3 encoding logic. Standard Transaction Transactions are each wrapped in the below \"Standard Transaction\": structure: // please note the field name is the JSON name. message StdTx { uint64 SIZE - OF - ENCODED // varint encoded length of the structure after encoding, please note this includes both the below type prefix (4 bytes) and the all encoding bytes 0xF0625DEE // hardcoded, object type prefix in 4 bytes repeated Msg msgs // array of size 1, containing the transaction message, which are one of the transaction types below. please check the above \"Array Encoding\" repeated StdSignature signatures // array of size 1, containing the standard signature structure of the transaction sender string memo // a short sentence of remark for the transaction. Please only `Transfer` transaction allows 'memo' input, and other transactions with non-empty `Memo` will be rejected. int64 source // an identifier for tools triggerring this transaction, set to zero if unwilling to disclose. bytes data // byte array, reserved for future use } StdSignBytes type StdSignDoc struct { AccountNumber int64 `json:\"account_number\"` ChainID string `json:\"chain_id\"` Memo string `json:\"memo\"` Msgs [] json . RawMessage `json:\"msgs\"` Sequence int64 `json:\"sequence\"` Source int64 `json:\"source\"` Data [] byte `json:\"data\"` } Canonical Bytes for Signing A transaction signature is not formed from the Amino-encoded transaction bytes themselves. Rather, a canonical represenation of the transaction is generated in JSON format for signing. This would allow for clients to sign a transaction off-chain, for example, a hardware HSM device like a Ledger, or within a micro-service in an algorithmic trading system. For example an external system will not have to understand Amino encoding to be able to approve of the transaction's content and produce the signed JSON string. The canonical bytes for signing are generated from the StdSignBytes method. It produces a JSON string similar to the format below (formatted for clarity): { \"sequence\" : \"64\" , \"account_number\" : \"12\" , \"data\" : null , \"chain_id\" : \"chain-bnb\" , \"memo\" : \"smiley\" , \"msgs\" : [ { \"inputs\" : [ { \"coins\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"200000000\" } ], \"address\" : \"bnc1hgm0p7khfk85zpz5v0j8wnej3a90w7098fpxyh\" } ], \"outputs\" : [ { \"address\" : \"bnc1cku54wwn66w2rkgs3h6v5zxrwtzyew8chcl720\" , \"coins\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"200000000\" } ] } ] } ], \"source\" : \"1\" } This JSON string, with all whitespace removed and keys sorted in alphabetical order , is signed with the private key of the sender. This signature is then attached to the StdTx structure described in the above section. Please note that the transaction broadcasted to the blockchain is not JSON - the JSON is merely used as a canonical representation to generate the signature. The next section describes how the generated signature is attached to a transaction. Standard Signature The sender's signature is stored in the Standard Transaction data via a Standard Signature , as shown below. This structure is included in the StdTx (see above). Please note that StdSignature itself doesn't have type prefix, while the PubKey does. message StdSignature { uint64 SIZE - OF - ENCODED // varint encoded length of the structure after encoding // please note there is no type prefix for StdSignature message PubKey { 0xEB5AE987 // hardcoded, object type prefix in 4 bytes uint64 SIZE - OF - ENCODED // varint encoded length of the bytes below bytes // no name or field id, just encode the bytes } PubKey pub_key // public key bytes of the signer address bytes signature // signature bytes, please check chain access section for signature generation int64 account_number // another identifier of signer, which can be read from chain by account REST API or RPC int64 sequence // sequence number for the next transaction of the client, which can be read from the chain by account REST API or RPC. Please check chain acces section for details. } Message Types Messages represent the individual operations possible on Genesys Chain, and these can be inserted into StdTx.msgs field. Message types are otherwise known as \"transaction types\", and these terms are used interchangably in this document and in our technical documentation. So far every StdTx transaction \"container\" can only contain one \"message\". Transfer Transfer is the transaction for transfering funds to different addresses. // please note the field name is the JSON name. message Send { 0x2A2C87FA // hardcoded, object type prefix in 4 bytes message Token { string denom int64 amount } message Input { bytes address repeated Token coins } message Output { bytes address repeated Token coins } repeated Input inputs repeated Output outputs } NewOrder NewOrder transaction will create a new order to buy or sell tokens on GSYS DEX. // please note the field name is the JSON name. message NewOrder { 0xCE6DC043 // hardcoded, object type prefix in 4 bytes bytes sender // order originating address string id // order id, please check the Order ID section below for details. string symbol // symbol for trading pair in full name of the token int64 ordertype // only accept 2 for now, meaning limit order int64 side // 1 for buy and 2 fory sell int64 price // price of the order, which is the real price multiplied by 1e8 (10^8) and rounded to integer int64 quantity // quantity of the order, which is the real quantity multiplied by 1e8 (10^8) and rounded to integer int64 timeinforce // 1 for Good Till Expire(GTE) order and 3 for Immediate Or Cancel (IOC) } Order ID Order ID is unique across the world. It is generated by sender and acknowledged by GSYS DEX. The current implementation is composed from 3 parts: Sender address in HEX format, without human-readable prefix A dash sign: - Sequence number E.g. 40C2979694BBC961023D1D27BE6FC4D21A9FEBE6-5 Cancel Cancel transactions (cancel the outstanding/unfilled) orders from the GSYS DEX. After cancel success, the locked quantity on the orders will return back to the originating address balance and become free to use, i.e. transfer or send new orders. // please note the field name is the JSON name. message CancelOrder { 0x166E681B // hardcoded, object type prefix in 4 bytes bytes sender // order originating address string symbol // symbol for trading pair in full name of the token string refid // order id of the order to cancel } Freeze Freeze transaction will move the amount of the tokens into a frozen state, in which they cannot be used for transfers or sending new orders. // please note the field name is the JSON name. message TokenFreeze { 0xE774B32D // hardcoded, object type prefix in 4 bytes bytes from // owner address string symbol // token symbol, in full name with \"-\" suffix int64 amount // amount of tokens to freeze } Unfreeze Unfreeze will reversely turn the amount of frozen tokens back to free state. // please note the field name is the JSON name. message TokenUnfreeze { 0x6515FF0D // hardcoded, object type prefix in 4 bytes bytes from // owner address string symbol // token symbol, in full name with \"-\" suffix int64 amount // amount of tokens to unfreeze } Vote Vote transactions for proposals. // please note the field name is the JSON name. message Vote { 0xA1CADD36 // hardcoded, object type prefix in 4 bytes int64 proposal_id // ID of the proposal bytes voter // address of the voter uint64 option // option from OptionSet chosen by the voter } Below are options for option : OptionYes = 0x01 // yes OptionAbstain = 0x02 // abstain OptionNo = 0x03 // no OptionNoWithVeto = 0x04 // no with veto Issue Issue (create) new asset on Genesys Chain. message IssueTokenValue { 0x17EFAB80 // hardcoded, object type prefix in 4 bytes bytes from // issuer's address string name // token name string symbol // token symbol string total_supply // total supply bool mintable // is mintable } Mint Mint is used to increase the total supply of a token. message Mint { 0x467E0829 // hardcoded, object type prefix in 4 bytes bytes from // sender's address string symbol string // token symbol int64 amount // increase amount } Burn Burn is used to decrease the total supply of a token. message TokenBurn { 0x7ED2D2A0 // hardcoded, object type prefix in 4 bytes bytes from // sender's address string symbol string // token symbol int64 amount // increase amount } List List is used to add a new trading pair. message DexList { 0xB41DE13F // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 proposal_id // id of corresponding proposal string base_asset_symbol // token symbol of base asset string quote_asset_symbol // token symbol of quote asset int64 init_price // init price of the new token } Submit Proposal Submit proposal is used to create a proposal for validators about adding trading pairs message Submit { 0xB42D614E // hardcoded, object type prefix in 4 bytes string title // Title of the proposal string description // Description of the proposal byte proposal_type // Type of proposal. Initial set {PlainTextProposal, SoftwareUpgradeProposal,ListTradingPair, FixedFeeParams} bytes proposer // Address of the proposer message Coin { string denom int64 amount } int64 VotingPeriod // Length of the voting period (s) } Deposit Deposit is used to increase the total deposit of a proposal. message Deposit { 0xA18A56E5 // hardcoded, object type prefix in 4 bytes int64 ProposalID // ID of the proposal bytes Depositer // Address of the depositer message Coin { string denom int64 amount } } Set Account Flags You can set the flag value of your account. message SetAccountFlags { 0xBEA6E301 // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 flag // account flag } Time-lock You can only lock tokens on your own account for a certain period of time. message Timerelock { 0x07921531 // hardcoded, object type prefix in 4 bytes bytes from // sender's address string description // Description of the lock message Coin { string denom int64 amount } repeated Coin amount int64 lock_time // lock time } Time-unlock You can unlock tokens on your own account after a certain period of time. message Timeunlock { 0xC4050C6C // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 id // lock time id } Time-relock You can relock tokens on your own account after a certain period of time. message Timerelock { 0x504711DA // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 Id // lock time id string description // Description of the lock message Coin { string denom int64 amount } repeated Coin amount int64 lock_time // lock time } HTLT Hash Timer Locked Transfer (HTLT) is a new transaction type on Genesys Chain, to serve as HGSYS in the first step of Atomic Swap message HTLT { 0xB33F9A24 // hardcoded, object type prefix in 4 bytes bytes from // sender's address bytes to // receiver's address string recipient_other_chain string sender_other_chain bytes random_number_hash int64 timestamp message Coin { string denom int64 amount } repeated Coin amount string expected_income int64 height_span bool cross_chain } Deposit HTLT Deposit Hash Timer Locked Transfer is to lock new BEP2 asset to an existed HTLT which is for single chain atomic swap. message DepositHTLT { 0x63986496 // hardcoded, object type prefix in 4 bytes bytes from // sender's address message Coin { string denom int64 amount } repeated Coin amount bytes swap_id } Claim HTLT Claim Hash Timer Locked Transfer is to claim the locked asset by showing the random number value that matches the hash. Each HTLT locked asset is guaranteed to be release once. message ClaimHTLTMsg { 0xC1665300 // hardcoded, object type prefix in 4 bytes bytes from // sender's address bytes swap_id bytes random_number } Refund HTLT Refund Hash Timer Locked Transfer is to refund the locked asset after timelock is expired. message RefundHTLTMsg { 0x3454A27C // hardcoded, object type prefix in 4 bytes bytes from // sender's address bytes swap_id","title":"Encoding Examples"},{"location":"guides/concepts/encoding/amino-example.html#encoding-examples","text":"","title":"Encoding Examples"},{"location":"guides/concepts/encoding/amino-example.html#encoding-output","text":"Genesys Chain (Amino) encoding logic may encode a data structure into two output formats: Binary and JSON.","title":"Encoding Output"},{"location":"guides/concepts/encoding/amino-example.html#json-marshal","text":"Amino supports JSON encoding natively, which is the same as other usual json marshalers. Except that it can add one more type info for registered type, as shown below. { \"type\" : \"<amino type name>\" , \"value\" : <JSON> }","title":"JSON Marshal"},{"location":"guides/concepts/encoding/amino-example.html#examples-in-go-sdk","text":"Let's take a look at an example function of Genesys Chain go-sdk. func ( c * HTTP ) GetProposal ( proposalId int64 ) ( types . Proposal , error ) { params := types . QueryProposalParams { ProposalID : proposalId , } bz , err := c . cdc . MarshalJSON ( params ) if err != nil { return nil , err } rawProposal , err := c . ABCIQuery ( \"custom/gov/proposal\" , bz ) if err != nil { return nil , err } if ! rawProposal . Response . IsOK (){ return nil , fmt . Errorf ( rawProposal . Response . Log ) } var proposal types . Proposal err = c . cdc . UnmarshalJSON ( rawProposal . Response . GetValue (), & proposal ) return proposal , err } In order to query the proposal, you can use Amino to marshal the request JSON first. bz , err := c . cdc . MarshalJSON ( params ) Then, use the unmarshal method to get the returned result. err = c . cdc . UnmarshalJSON ( rawProposal . Response . GetValue (), & proposal )","title":"Examples in Go-SDK"},{"location":"guides/concepts/encoding/amino-example.html#binary-marshal","text":"Binary encoding is a variant of Google protocol buffer. The bytes are layed out in the below sequence: a varint encoded integer - it contains the length of the encoded bytes for the object, which is displayed as SIZE-OF-ENCODED in the below structs. Please note that it contains the length of encoded bytes and also the type prefix (below), but not itself, e.g. if the encoded msg is 20 bytes, then the length would be 20 + 4 = 24, while 4 is used for the type prefix bytes. an object type prefix of 4-8 bytes - For different type of objects, there will be different type prefixes, and they are displayed as in the specific objects below (data structures). a binary encoded object - the encoding is mostly the same as protocol buffer encoding mechanism, except the embedded fields of complex type: to encode data field of some specific types, an object type prefix for the field will be added ahead of the real encoding. repeated (array) Encoding - it is the same as google protocol buffer, while encoding of the object/struct may contain the type prefix as shown below.","title":"Binary Marshal"},{"location":"guides/concepts/encoding/amino-example.html#examples-in-go-sdk_1","text":"Let's take a look at an example function of Genesys Chain go-sdk. The signed transaction needs to be amino-encoded, thus ready to be posted to BncChain API. rawBz , err := c . keyManager . Sign ( * signMsg ) if err != nil { return nil , err } hexTx := [] byte ( hex . EncodeToString ( rawBz )) param := map [ string ] string {} if sync { param [ \"sync\" ] = \"true\" } commits , err := c . basicClient . PostTx ( hexTx , param ) hexTx is derived from the following function: bz , err := tx . Cdc . MarshalBinaryLengthPrefixed ( & newTx )","title":"Examples in Go-SDK"},{"location":"guides/concepts/encoding/amino-example.html#genesys-chain-transaction-encoding","text":"Below are the data types that can be sent to Genesys Chain as requests, and their encoding layout. To simplify the presentation, we will use a variant of Google protocol buffer proto3 language to illustrate how the data fields are organized. Except the all-capitalized fields, other fields will use the default proto3 encoding logic.","title":"Genesys Chain Transaction Encoding"},{"location":"guides/concepts/encoding/amino-example.html#standard-transaction","text":"Transactions are each wrapped in the below \"Standard Transaction\": structure: // please note the field name is the JSON name. message StdTx { uint64 SIZE - OF - ENCODED // varint encoded length of the structure after encoding, please note this includes both the below type prefix (4 bytes) and the all encoding bytes 0xF0625DEE // hardcoded, object type prefix in 4 bytes repeated Msg msgs // array of size 1, containing the transaction message, which are one of the transaction types below. please check the above \"Array Encoding\" repeated StdSignature signatures // array of size 1, containing the standard signature structure of the transaction sender string memo // a short sentence of remark for the transaction. Please only `Transfer` transaction allows 'memo' input, and other transactions with non-empty `Memo` will be rejected. int64 source // an identifier for tools triggerring this transaction, set to zero if unwilling to disclose. bytes data // byte array, reserved for future use }","title":"Standard Transaction"},{"location":"guides/concepts/encoding/amino-example.html#stdsignbytes","text":"type StdSignDoc struct { AccountNumber int64 `json:\"account_number\"` ChainID string `json:\"chain_id\"` Memo string `json:\"memo\"` Msgs [] json . RawMessage `json:\"msgs\"` Sequence int64 `json:\"sequence\"` Source int64 `json:\"source\"` Data [] byte `json:\"data\"` }","title":"StdSignBytes"},{"location":"guides/concepts/encoding/amino-example.html#canonical-bytes-for-signing","text":"A transaction signature is not formed from the Amino-encoded transaction bytes themselves. Rather, a canonical represenation of the transaction is generated in JSON format for signing. This would allow for clients to sign a transaction off-chain, for example, a hardware HSM device like a Ledger, or within a micro-service in an algorithmic trading system. For example an external system will not have to understand Amino encoding to be able to approve of the transaction's content and produce the signed JSON string. The canonical bytes for signing are generated from the StdSignBytes method. It produces a JSON string similar to the format below (formatted for clarity): { \"sequence\" : \"64\" , \"account_number\" : \"12\" , \"data\" : null , \"chain_id\" : \"chain-bnb\" , \"memo\" : \"smiley\" , \"msgs\" : [ { \"inputs\" : [ { \"coins\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"200000000\" } ], \"address\" : \"bnc1hgm0p7khfk85zpz5v0j8wnej3a90w7098fpxyh\" } ], \"outputs\" : [ { \"address\" : \"bnc1cku54wwn66w2rkgs3h6v5zxrwtzyew8chcl720\" , \"coins\" : [ { \"denom\" : \"GSYS\" , \"amount\" : \"200000000\" } ] } ] } ], \"source\" : \"1\" } This JSON string, with all whitespace removed and keys sorted in alphabetical order , is signed with the private key of the sender. This signature is then attached to the StdTx structure described in the above section. Please note that the transaction broadcasted to the blockchain is not JSON - the JSON is merely used as a canonical representation to generate the signature. The next section describes how the generated signature is attached to a transaction.","title":"Canonical Bytes for Signing"},{"location":"guides/concepts/encoding/amino-example.html#standard-signature","text":"The sender's signature is stored in the Standard Transaction data via a Standard Signature , as shown below. This structure is included in the StdTx (see above). Please note that StdSignature itself doesn't have type prefix, while the PubKey does. message StdSignature { uint64 SIZE - OF - ENCODED // varint encoded length of the structure after encoding // please note there is no type prefix for StdSignature message PubKey { 0xEB5AE987 // hardcoded, object type prefix in 4 bytes uint64 SIZE - OF - ENCODED // varint encoded length of the bytes below bytes // no name or field id, just encode the bytes } PubKey pub_key // public key bytes of the signer address bytes signature // signature bytes, please check chain access section for signature generation int64 account_number // another identifier of signer, which can be read from chain by account REST API or RPC int64 sequence // sequence number for the next transaction of the client, which can be read from the chain by account REST API or RPC. Please check chain acces section for details. }","title":"Standard Signature"},{"location":"guides/concepts/encoding/amino-example.html#message-types","text":"Messages represent the individual operations possible on Genesys Chain, and these can be inserted into StdTx.msgs field. Message types are otherwise known as \"transaction types\", and these terms are used interchangably in this document and in our technical documentation. So far every StdTx transaction \"container\" can only contain one \"message\".","title":"Message Types"},{"location":"guides/concepts/encoding/amino-example.html#transfer","text":"Transfer is the transaction for transfering funds to different addresses. // please note the field name is the JSON name. message Send { 0x2A2C87FA // hardcoded, object type prefix in 4 bytes message Token { string denom int64 amount } message Input { bytes address repeated Token coins } message Output { bytes address repeated Token coins } repeated Input inputs repeated Output outputs }","title":"Transfer"},{"location":"guides/concepts/encoding/amino-example.html#neworder","text":"NewOrder transaction will create a new order to buy or sell tokens on GSYS DEX. // please note the field name is the JSON name. message NewOrder { 0xCE6DC043 // hardcoded, object type prefix in 4 bytes bytes sender // order originating address string id // order id, please check the Order ID section below for details. string symbol // symbol for trading pair in full name of the token int64 ordertype // only accept 2 for now, meaning limit order int64 side // 1 for buy and 2 fory sell int64 price // price of the order, which is the real price multiplied by 1e8 (10^8) and rounded to integer int64 quantity // quantity of the order, which is the real quantity multiplied by 1e8 (10^8) and rounded to integer int64 timeinforce // 1 for Good Till Expire(GTE) order and 3 for Immediate Or Cancel (IOC) }","title":"NewOrder"},{"location":"guides/concepts/encoding/amino-example.html#order-id","text":"Order ID is unique across the world. It is generated by sender and acknowledged by GSYS DEX. The current implementation is composed from 3 parts: Sender address in HEX format, without human-readable prefix A dash sign: - Sequence number E.g. 40C2979694BBC961023D1D27BE6FC4D21A9FEBE6-5","title":"Order ID"},{"location":"guides/concepts/encoding/amino-example.html#cancel","text":"Cancel transactions (cancel the outstanding/unfilled) orders from the GSYS DEX. After cancel success, the locked quantity on the orders will return back to the originating address balance and become free to use, i.e. transfer or send new orders. // please note the field name is the JSON name. message CancelOrder { 0x166E681B // hardcoded, object type prefix in 4 bytes bytes sender // order originating address string symbol // symbol for trading pair in full name of the token string refid // order id of the order to cancel }","title":"Cancel"},{"location":"guides/concepts/encoding/amino-example.html#freeze","text":"Freeze transaction will move the amount of the tokens into a frozen state, in which they cannot be used for transfers or sending new orders. // please note the field name is the JSON name. message TokenFreeze { 0xE774B32D // hardcoded, object type prefix in 4 bytes bytes from // owner address string symbol // token symbol, in full name with \"-\" suffix int64 amount // amount of tokens to freeze }","title":"Freeze"},{"location":"guides/concepts/encoding/amino-example.html#unfreeze","text":"Unfreeze will reversely turn the amount of frozen tokens back to free state. // please note the field name is the JSON name. message TokenUnfreeze { 0x6515FF0D // hardcoded, object type prefix in 4 bytes bytes from // owner address string symbol // token symbol, in full name with \"-\" suffix int64 amount // amount of tokens to unfreeze }","title":"Unfreeze"},{"location":"guides/concepts/encoding/amino-example.html#vote","text":"Vote transactions for proposals. // please note the field name is the JSON name. message Vote { 0xA1CADD36 // hardcoded, object type prefix in 4 bytes int64 proposal_id // ID of the proposal bytes voter // address of the voter uint64 option // option from OptionSet chosen by the voter } Below are options for option : OptionYes = 0x01 // yes OptionAbstain = 0x02 // abstain OptionNo = 0x03 // no OptionNoWithVeto = 0x04 // no with veto","title":"Vote"},{"location":"guides/concepts/encoding/amino-example.html#issue","text":"Issue (create) new asset on Genesys Chain. message IssueTokenValue { 0x17EFAB80 // hardcoded, object type prefix in 4 bytes bytes from // issuer's address string name // token name string symbol // token symbol string total_supply // total supply bool mintable // is mintable }","title":"Issue"},{"location":"guides/concepts/encoding/amino-example.html#mint","text":"Mint is used to increase the total supply of a token. message Mint { 0x467E0829 // hardcoded, object type prefix in 4 bytes bytes from // sender's address string symbol string // token symbol int64 amount // increase amount }","title":"Mint"},{"location":"guides/concepts/encoding/amino-example.html#burn","text":"Burn is used to decrease the total supply of a token. message TokenBurn { 0x7ED2D2A0 // hardcoded, object type prefix in 4 bytes bytes from // sender's address string symbol string // token symbol int64 amount // increase amount }","title":"Burn"},{"location":"guides/concepts/encoding/amino-example.html#list","text":"List is used to add a new trading pair. message DexList { 0xB41DE13F // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 proposal_id // id of corresponding proposal string base_asset_symbol // token symbol of base asset string quote_asset_symbol // token symbol of quote asset int64 init_price // init price of the new token }","title":"List"},{"location":"guides/concepts/encoding/amino-example.html#submit-proposal","text":"Submit proposal is used to create a proposal for validators about adding trading pairs message Submit { 0xB42D614E // hardcoded, object type prefix in 4 bytes string title // Title of the proposal string description // Description of the proposal byte proposal_type // Type of proposal. Initial set {PlainTextProposal, SoftwareUpgradeProposal,ListTradingPair, FixedFeeParams} bytes proposer // Address of the proposer message Coin { string denom int64 amount } int64 VotingPeriod // Length of the voting period (s) }","title":"Submit Proposal"},{"location":"guides/concepts/encoding/amino-example.html#deposit","text":"Deposit is used to increase the total deposit of a proposal. message Deposit { 0xA18A56E5 // hardcoded, object type prefix in 4 bytes int64 ProposalID // ID of the proposal bytes Depositer // Address of the depositer message Coin { string denom int64 amount } }","title":"Deposit"},{"location":"guides/concepts/encoding/amino-example.html#set-account-flags","text":"You can set the flag value of your account. message SetAccountFlags { 0xBEA6E301 // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 flag // account flag }","title":"Set Account Flags"},{"location":"guides/concepts/encoding/amino-example.html#time-lock","text":"You can only lock tokens on your own account for a certain period of time. message Timerelock { 0x07921531 // hardcoded, object type prefix in 4 bytes bytes from // sender's address string description // Description of the lock message Coin { string denom int64 amount } repeated Coin amount int64 lock_time // lock time }","title":"Time-lock"},{"location":"guides/concepts/encoding/amino-example.html#time-unlock","text":"You can unlock tokens on your own account after a certain period of time. message Timeunlock { 0xC4050C6C // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 id // lock time id }","title":"Time-unlock"},{"location":"guides/concepts/encoding/amino-example.html#time-relock","text":"You can relock tokens on your own account after a certain period of time. message Timerelock { 0x504711DA // hardcoded, object type prefix in 4 bytes bytes from // sender's address int64 Id // lock time id string description // Description of the lock message Coin { string denom int64 amount } repeated Coin amount int64 lock_time // lock time }","title":"Time-relock"},{"location":"guides/concepts/encoding/amino-example.html#htlt","text":"Hash Timer Locked Transfer (HTLT) is a new transaction type on Genesys Chain, to serve as HGSYS in the first step of Atomic Swap message HTLT { 0xB33F9A24 // hardcoded, object type prefix in 4 bytes bytes from // sender's address bytes to // receiver's address string recipient_other_chain string sender_other_chain bytes random_number_hash int64 timestamp message Coin { string denom int64 amount } repeated Coin amount string expected_income int64 height_span bool cross_chain }","title":"HTLT"},{"location":"guides/concepts/encoding/amino-example.html#deposit-htlt","text":"Deposit Hash Timer Locked Transfer is to lock new BEP2 asset to an existed HTLT which is for single chain atomic swap. message DepositHTLT { 0x63986496 // hardcoded, object type prefix in 4 bytes bytes from // sender's address message Coin { string denom int64 amount } repeated Coin amount bytes swap_id }","title":"Deposit HTLT"},{"location":"guides/concepts/encoding/amino-example.html#claim-htlt","text":"Claim Hash Timer Locked Transfer is to claim the locked asset by showing the random number value that matches the hash. Each HTLT locked asset is guaranteed to be release once. message ClaimHTLTMsg { 0xC1665300 // hardcoded, object type prefix in 4 bytes bytes from // sender's address bytes swap_id bytes random_number }","title":"Claim HTLT"},{"location":"guides/concepts/encoding/amino-example.html#refund-htlt","text":"Refund Hash Timer Locked Transfer is to refund the locked asset after timelock is expired. message RefundHTLTMsg { 0x3454A27C // hardcoded, object type prefix in 4 bytes bytes from // sender's address bytes swap_id","title":"Refund HTLT"},{"location":"guides/concepts/encoding/encoding.html","text":"Encoding The Cosmos SDK utilizes two binary wire encoding protocols, Genesys Chain Amino and Protocol Buffers , where Amino is an object encoding specification. It is a subset of Proto3 with an extension for interface support. See the Proto3 spec for more information on Proto3, which Amino is largely compatible with (but not with Proto2). Due to Amino having significant performance drawbacks, being reflection-based, and not having any meaningful cross-language/client support, Protocol Buffers, specifically gogoprotobuf , is being used in place of Amino. Note, this process of using Protocol Buffers over Amino is still an ongoing process. Binary wire encoding of types in the Cosmos SDK can be broken down into two main categories, client encoding and store encoding. Client encoding mainly revolves around transaction processing and signing, whereas store encoding revolves around types used in state-machine transitions and what is ultimately stored in the Merkle tree. For store encoding, protobuf definitions can exist for any type and will typically have an Amino-based \"intermediary\" type. Specifically, the protobuf-based type definition is used for serialization and persistence, whereas the Amino-based type is used for business logic in the state-machine where they may converted back-n-forth. Note, the Amino-based types may slowly be phased-out in the future so developers should take note to use the protobuf message definitions where possible. In the codec package, there exists two core interfaces, Marshaler and ProtoMarshaler , where the former encapsulates the current Amino interface except it operates on types implementing the latter instead of generic interface{} types. In addition, there exists three implementations of Marshaler . The first being AminoCodec , where both binary and JSON serialization is handled via Amino. The second being ProtoCodec , where both binary and JSON serialization is handled via Protobuf. Finally, HybridCodec , a codec that utilizes Protobuf for binary serialization and Amino for JSON serialization. The HybridCodec is typically the codec that used in majority in situations as it's easier to use for client and state serialization. This means that modules may use Amino or Protobuf encoding but the types must implement ProtoMarshaler . If modules wish to avoid implementing this interface for their types, they may use an Amino codec directly. Amino Every module uses an Amino codec to serialize types and interfaces. This codec typically has types and interfaces registered in that module's domain only (e.g. messages), but there are exceptions like x/gov . Each module exposes a RegisterCodec function that allows a user to provide a codec and have all the types registered. An application will call this method for each necessary module. Where there is no protobuf-based type definition for a module (see below), Amino is used to encode and decode raw wire bytes to the concrete type or interface: bz := keeper . cdc . MustMarshalBinaryBare ( typeOrInterface ) keeper . cdc . MustUnmarshalBinaryBare ( bz , & typeOrInterface ) Note, there are length-prefixed variants of the above functionality and this is typically used for when the data needs to be streamed or grouped together (e.g. ResponseDeliverTx.Data ) Another important use of the Amino is the encoding and decoding of transactions . Transactions are defined by the application or the SDK, but passed to the underlying consensus engine in order to be relayed to other peers. Since the underlying consensus engine is agnostic to the application, it only accepts transactions in the form of raw bytes. The encoding is done by an object called TxEncoder and the decoding by an object called TxDecoder . A standard implementation of both these objects can be found in the auth module : Gogoproto Modules are encouraged to utilize Protobuf encoding for their respective types. If modules do not contain any interfaces (e.g. Account or Content ), then they may simply accept a Marshaler as the codec which is implemented via the HybridCodec without any further customization. However, if modules are to handle type interfaces, they should seek to extend the Marshaler interface contract for these types (e.g. MarshalAccount ). Note, they should still use a HybridCodec internally. These extended contracts will typically use concrete types with unique oneof messages.","title":"Encoding"},{"location":"guides/concepts/encoding/encoding.html#encoding","text":"The Cosmos SDK utilizes two binary wire encoding protocols, Genesys Chain Amino and Protocol Buffers , where Amino is an object encoding specification. It is a subset of Proto3 with an extension for interface support. See the Proto3 spec for more information on Proto3, which Amino is largely compatible with (but not with Proto2). Due to Amino having significant performance drawbacks, being reflection-based, and not having any meaningful cross-language/client support, Protocol Buffers, specifically gogoprotobuf , is being used in place of Amino. Note, this process of using Protocol Buffers over Amino is still an ongoing process. Binary wire encoding of types in the Cosmos SDK can be broken down into two main categories, client encoding and store encoding. Client encoding mainly revolves around transaction processing and signing, whereas store encoding revolves around types used in state-machine transitions and what is ultimately stored in the Merkle tree. For store encoding, protobuf definitions can exist for any type and will typically have an Amino-based \"intermediary\" type. Specifically, the protobuf-based type definition is used for serialization and persistence, whereas the Amino-based type is used for business logic in the state-machine where they may converted back-n-forth. Note, the Amino-based types may slowly be phased-out in the future so developers should take note to use the protobuf message definitions where possible. In the codec package, there exists two core interfaces, Marshaler and ProtoMarshaler , where the former encapsulates the current Amino interface except it operates on types implementing the latter instead of generic interface{} types. In addition, there exists three implementations of Marshaler . The first being AminoCodec , where both binary and JSON serialization is handled via Amino. The second being ProtoCodec , where both binary and JSON serialization is handled via Protobuf. Finally, HybridCodec , a codec that utilizes Protobuf for binary serialization and Amino for JSON serialization. The HybridCodec is typically the codec that used in majority in situations as it's easier to use for client and state serialization. This means that modules may use Amino or Protobuf encoding but the types must implement ProtoMarshaler . If modules wish to avoid implementing this interface for their types, they may use an Amino codec directly.","title":"Encoding"},{"location":"guides/concepts/encoding/encoding.html#amino","text":"Every module uses an Amino codec to serialize types and interfaces. This codec typically has types and interfaces registered in that module's domain only (e.g. messages), but there are exceptions like x/gov . Each module exposes a RegisterCodec function that allows a user to provide a codec and have all the types registered. An application will call this method for each necessary module. Where there is no protobuf-based type definition for a module (see below), Amino is used to encode and decode raw wire bytes to the concrete type or interface: bz := keeper . cdc . MustMarshalBinaryBare ( typeOrInterface ) keeper . cdc . MustUnmarshalBinaryBare ( bz , & typeOrInterface ) Note, there are length-prefixed variants of the above functionality and this is typically used for when the data needs to be streamed or grouped together (e.g. ResponseDeliverTx.Data ) Another important use of the Amino is the encoding and decoding of transactions . Transactions are defined by the application or the SDK, but passed to the underlying consensus engine in order to be relayed to other peers. Since the underlying consensus engine is agnostic to the application, it only accepts transactions in the form of raw bytes. The encoding is done by an object called TxEncoder and the decoding by an object called TxDecoder . A standard implementation of both these objects can be found in the auth module :","title":"Amino"},{"location":"guides/concepts/encoding/encoding.html#gogoproto","text":"Modules are encouraged to utilize Protobuf encoding for their respective types. If modules do not contain any interfaces (e.g. Account or Content ), then they may simply accept a Marshaler as the codec which is implemented via the HybridCodec without any further customization. However, if modules are to handle type interfaces, they should seek to extend the Marshaler interface contract for these types (e.g. MarshalAccount ). Note, they should still use a HybridCodec internally. These extended contracts will typically use concrete types with unique oneof messages.","title":"Gogoproto"},{"location":"guides/node/extra-info.html","text":"Get Extra Data From Your Full Node This document is intended for developers who are interested in transactions, order books, account changes, fee charges in every block and would like to build their own downstream services of the full node. Please refer to Running Full Node , if you still haven't deployed a full node. Publish Different Messages to Local Files You can set the publishLocal option to true in nodebinary/fullnode/{network}/node/app.toml . The full node will append the messages each block published to {fullnode home}/marketdata/marketdata.json (each line is a json object for a topic and height), and you can consume them in your own apps. The messages types are explained below. Note: only block messages after this option get turned on can be saved. This function won't make up messages for already saved blocks. Set Kafka Broker Version Since the release of bnbchaind v0.6.3 , you can customize the version of kafka broker in app.toml . The default value is v2.1.0 : The recommended version 2.1.0 and the minimal version is 0.8.2.0 kafkaVersion = \"2.1.0\" If you are using another version of Kafka, please test the compatibility first. 1. OrderUpdates You can set the publishOrderUpdates option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the trades that have been filled, orders that changed and proposals that been submitted. Example: All those extra info can also be found in exported data from your fullnode. Changes In trade data structure, there are five new fields: SSrc , BSrc , SSingleFee , BSingleFee and TickerType . SSrc : Source code of Sell order transaction BSrc : Source code of Buy order transaction SSingleFee : fee of matched sell order BSingleFee : fee of matched buy order TickerType : ticker type In Order data structure, there is a new field: singlefee . This is used to show the fee of this order. Status is used to indicate the current status of this order. Namely there are 9 status: 0 for Acknowledge; 1 for Canceled ; 2 for Expired , 3 for IocNoFill, 4 for IocExpire, 5 for PartialFill, 6 for FullyFill, 7 for FailedBlocking, 8 for FailedMatching. For example: { \"Height\" : 36384232 , \"Timestamp\" : 1569196830136718300 , \"NumOfMsgs\" : 10 , \"Trades\" : { \"NumOfMsgs\" : 2 , \"Trades\" : [ { \"Id\" : \"36384232-0\" , \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Price\" : 345282 , \"Qty\" : 23200000000 , \"Sid\" : \"5F511BE6120CE2F92877F3A1E92D408CE56A5CCC-62632\" , \"Bid\" : \"4C28D006CF8061E05EEE50D17D8B2375CE09E7EC-71967\" , \"Sfee\" : \"GSYS:32042\" , \"Bfee\" : \"GSYS:32042\" , \"SSrc\" : 0 , \"BSrc\" : 0 , \"SSingleFee\" : \"GSYS:32042\" , \"BSingleFee\" : \"GSYS:32042\" , \"TickType\" : 5 , \"SAddr\" : \"bnb1tag3hesjpn30j2rh7ws7jt2q3njk5hxvsx023c\" , \"BAddr\" : \"bnb1fs5dqpk0sps7qhhw2rghmzerwh8qnelv7tyat8\" }, { \"Id\" : \"36384232-1\" , \"Symbol\" : \"EQL-586_GSYS\" , \"Price\" : 4798 , \"Qty\" : 110000000000 , \"Sid\" : \"610BFE81695EFD89B19D27D1E8C17D57C0239C66-6367\" , \"Bid\" : \"B3CEA961E95C4F104A791F6C33DB83458577BA76-5471\" , \"Sfee\" : \"GSYS:2111\" , \"Bfee\" : \"GSYS:2111\" , \"SSrc\" : 0 , \"BSrc\" : 0 , \"SSingleFee\" : \"GSYS:2111\" , \"BSingleFee\" : \"GSYS:2111\" , \"TickType\" : 2 , \"SAddr\" : \"bnb1vy9laqtftm7cnvvaylg73sta2lqz88rxs72mx7\" , \"BAddr\" : \"bnb1k082jc0ft383qjnerakr8kurgkzh0wnk8gulnj\" } ] }, \"Orders\" : { \"NumOfMsgs\" : 8 , \"Orders\" : [ { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"37D9383E6AD9AFEF6C5D8066ABA3ACA8C75D9F39-1724193\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1xlvns0n2mxh77mzaspn2hgav4rr4m8eerfju38\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 344271 , \"Qty\" : 89600000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 0 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"D74A96022A2F090D7D739C1C6716481A215E0F7F10C430C28290758E9DC4EF73\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"EQL-586_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"B3CEA961E95C4F104A791F6C33DB83458577BA76-5471\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1k082jc0ft383qjnerakr8kurgkzh0wnk8gulnj\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 4798 , \"Qty\" : 110000000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 110000000000 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"792BA5F932813F9C006075EAA090D82305AD049DDC570271FA8515339A874E97\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"4C28D006CF8061E05EEE50D17D8B2375CE09E7EC-71967\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1fs5dqpk0sps7qhhw2rghmzerwh8qnelv7tyat8\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 345283 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 23200000000 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"574CB6DAF26C5D1A465A8D86760FFDFF3DA5946F9C02EB5B89051A8120844523\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"5F511BE6120CE2F92877F3A1E92D408CE56A5CCC-62632\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1tag3hesjpn30j2rh7ws7jt2q3njk5hxvsx023c\" , \"Side\" : 2 , \"OrderType\" : 2 , \"Price\" : 345282 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 23200000000 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"9D8EF7CEAE5D2CDC4026F6306296D57764BB80099B3A65865971D8D71399B6EA\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"EQL-586_GSYS\" , \"Status\" : 5 , \"OrderId\" : \"610BFE81695EFD89B19D27D1E8C17D57C0239C66-6367\" , \"TradeId\" : \"36384232-1\" , \"Owner\" : \"bnb1vy9laqtftm7cnvvaylg73sta2lqz88rxs72mx7\" , \"Side\" : 2 , \"OrderType\" : 2 , \"Price\" : 4798 , \"Qty\" : 230000000000 , \"LastExecutedPrice\" : 4798 , \"LastExecutedQty\" : 110000000000 , \"CumQty\" : 110000000000 , \"Fee\" : \"GSYS:2111\" , \"OrderCreationTime\" : 1569196786802324000 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"EDF132EBDA03382D2BFF7EF58CDE574D4E3FB9622BD8BCF12BA6ABECD692BA5C\" , \"SingleFee\" : \"GSYS:2111\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 6 , \"OrderId\" : \"4C28D006CF8061E05EEE50D17D8B2375CE09E7EC-71967\" , \"TradeId\" : \"36384232-0\" , \"Owner\" : \"bnb1fs5dqpk0sps7qhhw2rghmzerwh8qnelv7tyat8\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 345283 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 345282 , \"LastExecutedQty\" : 23200000000 , \"CumQty\" : 23200000000 , \"Fee\" : \"GSYS:32042\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"574CB6DAF26C5D1A465A8D86760FFDFF3DA5946F9C02EB5B89051A8120844523\" , \"SingleFee\" : \"GSYS:32042\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 6 , \"OrderId\" : \"5F511BE6120CE2F92877F3A1E92D408CE56A5CCC-62632\" , \"TradeId\" : \"36384232-0\" , \"Owner\" : \"bnb1tag3hesjpn30j2rh7ws7jt2q3njk5hxvsx023c\" , \"Side\" : 2 , \"OrderType\" : 2 , \"Price\" : 345282 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 345282 , \"LastExecutedQty\" : 23200000000 , \"CumQty\" : 23200000000 , \"Fee\" : \"GSYS:32042\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"9D8EF7CEAE5D2CDC4026F6306296D57764BB80099B3A65865971D8D71399B6EA\" , \"SingleFee\" : \"GSYS:32042\" }, { \"Symbol\" : \"EQL-586_GSYS\" , \"Status\" : 6 , \"OrderId\" : \"B3CEA961E95C4F104A791F6C33DB83458577BA76-5471\" , \"TradeId\" : \"36384232-1\" , \"Owner\" : \"bnb1k082jc0ft383qjnerakr8kurgkzh0wnk8gulnj\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 4798 , \"Qty\" : 110000000000 , \"LastExecutedPrice\" : 4798 , \"LastExecutedQty\" : 110000000000 , \"CumQty\" : 110000000000 , \"Fee\" : \"GSYS:2111\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"792BA5F932813F9C006075EAA090D82305AD049DDC570271FA8515339A874E97\" , \"SingleFee\" : \"GSYS:2111\" } ] }, \"Proposals\" : { \"NumOfMsgs\" : 0 , \"Proposals\" : null }, \"StakeUpdates\" : { \"NumOfMsgs\" : 0 , \"CompletedUnbondingDelegations\" : null } } 2. AccountBalance You can set the publishAccountBalance option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the changed accounts. Example { Owner: string, Fee: string, Balances: []{ Asset: string, Free: int64, Frozen: int64, Locked: int64 } } 3. OrderBook You can set the publishOrderBook option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all order book changes. Example { Height: int64, Timestamp: int64, NumOfMsgs: int, Books: []{ Symbol: string, Buys: []{ Price: int64, LastQty: int64 }, Sells: []{ Price: int64, LastQty: int64 } } } 4. BlockFee You can set the publishBlockFee option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the block fee charged. Example { Height: int64, Fee: string, Validators: []string } 5. Transfers You can set the publishTransfer option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the transfer transactions. Example { Height: int64, Num: int, Timestamp: int64, Transfers: []{ TxHash: string, Memo: string, From: string, To: []{ Addr: string, Coins: []{ Denom: string, Amount: int64 } } } } 6. Staking Record You can set the publishStaking option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about staking. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"validators\": []{ \"feeAddr\": string, \"operatorAddr\": string, \"consAddr\": string, \"jailed\": bool, \"status\": string, \"tokens\": int64, \"delegatorShares\":int64, \"description\":{ \"moniker\": string, \"identity\": string, \"website\": string, \"details\": string, }, \"bondHeight\": int64, \"bondIntraTxCounter\": int, \"commission\":{ \"rate\": int64, \"maxRate\": int64, \"maxChangeRate\": int64, \"updateTime\": int64, }, \"distributionAddr\":string, \"sideChainId\": string, \"sideConsAddr\": string, \"sideFeeAddr\": string }, \"removedValidators\": map[string][]string, //key: chain id, value: operatorAddr \"delegatioins\": map[string][]{ \"delegator\": string, \"validator\": string, \"shares\": int64 }, // map key: chain-id \"unBondingDelegations\": map[string][]{ \"delegator\": string, \"validator\": string, \"creationHeight\": int64, \"minTime\": int64, \"initialBalance\": { \"denom\": string, \"amount\": int64 }, \"balance\": { \"denom\": string, \"amount\": int64 } }, // map key: chain id \"reDelegations\": map[string][]{ \"delegator\": string, \"srcValidator\": string, \"dstValidator\": string, \"creationHeight\": int64, \"sharesSrc\": int64, \"sharesDst\": int64, \"initialBalance\": { \"denom\": string, \"amount\": int64 }, \"balance\": { \"denom\": string, \"amount\": int64 }, \"minTime\": int64 }, // map key: chain id \"completedUBDs\": map[string][]{ \"validator\": string, \"delegator\": string, \"amount\": { \"denom\": string, \"amount\": int64 } }, \"completedREDs\": map[string][]{ \"delegator\": string, \"srcValidator\": string, \"dstValidator\": string }, \"delegateEvents\": map[string][]{ \"validator\": string, \"delegator\": string, \"amount\": { \"denom\": string, \"amount\": int64 }, \"txHash\": string }, \"unDelegateEvents\": map[string][]{ \"validator\": string, \"delegator\": string, \"amount\": { \"denom\": string, \"amount\": int64 }, \"txHash\": string }, \"reDelegateEvents\": map[string][]{ \"delegator\": string, \"srcValidator\": string, \"dstValidator\": string, \"amount\": { \"denom\": string, \"amount\": int64 }, \"txHash\": string }, \"electedValidators\": map[string][]{ \"feeAddr\": string, \"operatorAddr\": string, \"consAddr\": string, \"jailed\": bool, \"status\": string, \"tokens\": int64, \"delegatorShares\":int64, \"description\":{ \"moniker\": string, \"identity\": string, \"website\": string, \"details\": string, }, \"bondHeight\": int64, \"bondIntraTxCounter\": int, \"commission\":{ \"rate\": int64, \"maxRate\": int64, \"maxChangeRate\": int64, \"updateTime\": int64, }, \"distributionAddr\":string, \"sideChainId\": string, \"sideConsAddr\": string, \"sideFeeAddr\": string } } Schema { \"type\" : \"record\" , \"name\" : \"Staking\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"validators\" , \"type\" : [ \"null\" , { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Validator\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"feeAddr\" , \"type\" : \"string\" }, { \"name\" : \"operatorAddr\" , \"type\" : \"string\" }, { \"name\" : \"consAddr\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" }, { \"name\" : \"jailed\" , \"type\" : \"boolean\" }, { \"name\" : \"status\" , \"type\" : \"string\" }, { \"name\" : \"tokens\" , \"type\" : \"long\" }, { \"name\" : \"delegatorShares\" , \"type\" : \"long\" }, { \"name\" : \"description\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Description\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"moniker\" , \"type\" : \"string\" }, { \"name\" : \"identity\" , \"type\" : \"string\" }, { \"name\" : \"website\" , \"type\" : \"string\" }, { \"name\" : \"details\" , \"type\" : \"string\" } ] }}, { \"name\" : \"bondHeight\" , \"type\" : \"long\" }, { \"name\" : \"bondIntraTxCounter\" , \"type\" : \"int\" }, { \"name\" : \"commission\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Commission\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"rate\" , \"type\" : \"long\" }, { \"name\" : \"maxRate\" , \"type\" : \"long\" }, { \"name\" : \"maxChangeRate\" , \"type\" : \"long\" }, { \"name\" : \"updateTime\" , \"type\" : \"long\" } ] }}, { \"name\" : \"distributionAddr\" , \"type\" : \"string\" }, { \"name\" : \"sideChainId\" , \"type\" : \"string\" }, { \"name\" : \"sideConsAddr\" , \"type\" : \"string\" }, { \"name\" : \"sideFeeAddr\" , \"type\" : \"string\" } ] } }], \"default\" : \"null\" }, { \"name\" : \"removedValidators\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } } }], \"default\" : null }, { \"name\" : \"delegations\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Delegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"shares\" , \"type\" : \"long\" } ] } } }], \"default\" : null }, { \"name\" : \"unBondingDelegations\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"UnBondingDelgation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"creationHeight\" , \"type\" : \"long\" }, { \"name\" : \"minTime\" , \"type\" : \"long\" }, { \"name\" : \"initialBalance\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Coin\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"denom\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] }}, { \"name\" : \"balance\" , \"type\" : \"org.shree.dex.model.avro.Coin\" } ] } } }], \"default\" : null }, { \"name\" : \"reDelegations\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"ReDelegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"srcValidator\" , \"type\" : \"string\" }, { \"name\" : \"dstValidator\" , \"type\" : \"string\" }, { \"name\" : \"creationHeight\" , \"type\" : \"long\" }, { \"name\" : \"sharesSrc\" , \"type\" : \"long\" }, { \"name\" : \"sharesDst\" , \"type\" : \"long\" }, { \"name\" : \"initialBalance\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"balance\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"minTime\" , \"type\" : \"long\" } ] } } }], \"default\" : null }, { \"name\" : \"completedUBDs\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"CompletedUnbondingDelegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" } ] } } }], \"default\" : null }, { \"name\" : \"completedREDs\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"CompletedReDelegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"srcValidator\" , \"type\" : \"string\" }, { \"name\" : \"dstValidator\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"delegateEvents\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"DelegateEvent\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"txHash\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"unDelegateEvents\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"UndelegateEvent\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"txHash\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"reDelegateEvents\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"RedelegateEvent\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"srcValidator\" , \"type\" : \"string\" }, { \"name\" : \"dstValidator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"txHash\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"electedValidators\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : \"org.shree.dex.model.avro.Validator\" } }], \"default\" : null } ] } 7. Reward Distribution You can set the publishDistributeReward option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about reward distribution. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"distributions\" : map[string][]{ \"validator\": string, \"selfDelegator\": string, \"distributeAddr\": string, \"valTokens\": int64, \"totalReward\": int64, \"commission\": int64, \"rewards\": []{ \"delegator\": string, \"delegationTokens\": int64, \"reward\": int64 } } // map key: chain id } Schema { \"type\": \"record\", \"name\": \"Distribution\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\" }, { \"name\": \"timestamp\", \"type\": \"long\" }, { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"distributions\", \"type\": { \"type\": \"map\", \"values\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"DistributionData\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ {\"name\": \"validator\", \"type\": \"string\"}, {\"name\": \"selfDelegator\",\"type\": \"string\"}, {\"name\": \"distributeAddr\",\"type\": \"string\"}, {\"name\": \"valTokens\", \"type\": \"long\"}, {\"name\": \"totalReward\", \"type\": \"long\"}, {\"name\": \"commission\", \"type\": \"long\"}, {\"name\": \"rewards\", \"type\":{ \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Reward\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\":[ {\"name\": \"delegator\", \"type\": \"string\"}, {\"name\": \"delegationTokens\", \"type\": \"long\"}, {\"name\": \"reward\", \"type\": \"long\"} ] } }} ] } } } } ] } 8. Slashing You can set the publishSlashing option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about slashing. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"slashData\": map[string][]{ \"validator\": string, \"infractionType\": int, \"infractionHeight\": int64, \"jailUtil\": int64, \"slashAmount\": int64, \"toFeePool\": int64, \"submitter\": string, \"submitterReward\": int64, \"validatorsCompensation\": []{ \"address\": string, \"amount\": int64 } } } Schema { \"type\" : \"record\" , \"name\" : \"Slashing\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"slashData\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"SlashData\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"infractionType\" , \"type\" : \"int\" }, { \"name\" : \"infractionHeight\" , \"type\" : \"long\" }, { \"name\" : \"jailUtil\" , \"type\" : \"long\" }, { \"name\" : \"slashAmount\" , \"type\" : \"long\" }, { \"name\" : \"toFeePool\" , \"type\" : \"long\" }, { \"name\" : \"submitter\" , \"type\" : \"string\" }, { \"name\" : \"submitterReward\" , \"type\" : \"long\" }, { \"name\" : \"validatorsCompensation\" , \"type\" :{ \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"AllocatedAmt\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" :[ { \"name\" : \"address\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] } }} ] } } }} ] } 9. CrossTransfer You can set the publishCrossTransfer option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about cross transfer. Example { \"height\": int64, \"timestamp\": int64, \"num\": int, \"transfers\": []{ \"txhash\": string, \"type\": string, \"relayerFee\": int64, \"chainid\": string, \"from\": \"string\", \"denom\": string, \"contract\": string, \"decimals\": int, \"to\": []{ \"addr\": string, \"amount\": int64 } } } Schema { \"type\" : \"record\" , \"name\" : \"CrossTransfers\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"num\" , \"type\" : \"int\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"transfers\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Transfer\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"txhash\" , \"type\" : \"string\" }, { \"name\" : \"type\" , \"type\" : \"string\" }, { \"name\" : \"relayerFee\" , \"type\" : \"long\" }, { \"name\" : \"chainid\" , \"type\" : \"string\" }, { \"name\" : \"from\" , \"type\" : \"string\" }, { \"name\" : \"denom\" , \"type\" : \"string\" }, { \"name\" : \"contract\" , \"type\" : \"string\" }, { \"name\" : \"decimals\" , \"type\" : \"int\" }, { \"name\" : \"to\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Receiver\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"addr\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] } } } ] } } } ] } 10. SideProposal You can set the publishSideProposal option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about side proposals. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"proposals\": []{ \"id\": int64, \"chainid\": string, \"status\": string } } Schema { \"type\" : \"record\" , \"name\" : \"SideProposals\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"proposals\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Proposal\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"id\" , \"type\" : \"long\" }, { \"name\" : \"chainid\" , \"type\" : \"string\" }, { \"name\" : \"status\" , \"type\" : \"string\" } ] } } } ] } 11. BreatheBlock You can set the publichBreatheBlock option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about side proposals. Example { \"height\": int64, \"timestamp\": int64 } Schema { \"type\" : \"record\" , \"name\" : \"BreatheBlock\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" } ] } Publish Different Messages to Kafka You can set the publishKafka option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save messages that you are interested into Kafka, and you can consume them in your own apps. The message is encoded based on Avro serialization system. Their schemas are shown below: OrderUpdates : { \"type\": \"record\", \"name\": \"ExecutionResults\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\" }, { \"name\": \"timestamp\", \"type\": \"long\" }, { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"trades\", \"type\": [\"null\", { \"type\": \"record\", \"name\": \"Trades\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"trades\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Trade\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"symbol\", \"type\": \"string\" }, { \"name\": \"id\", \"type\": \"string\" }, { \"name\": \"price\", \"type\": \"long\" }, { \"name\": \"qty\", \"type\": \"long\" }, { \"name\": \"sid\", \"type\": \"string\" }, { \"name\": \"bid\", \"type\": \"string\" }, { \"name\": \"sfee\", \"type\": \"string\" }, { \"name\": \"bfee\", \"type\": \"string\" }, { \"name\": \"saddr\", \"type\": \"string\" }, { \"name\": \"baddr\", \"type\": \"string\" } ] } } } ] }], \"default\": null }, { \"name\": \"orders\", \"type\": [\"null\", { \"type\": \"record\", \"name\": \"Orders\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"orders\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Order\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"symbol\", \"type\": \"string\" }, { \"name\": \"status\", \"type\": \"string\" }, { \"name\": \"orderId\", \"type\": \"string\" }, { \"name\": \"tradeId\", \"type\": \"string\" }, { \"name\": \"owner\", \"type\": \"string\" }, { \"name\": \"side\", \"type\": \"int\" }, { \"name\": \"orderType\", \"type\": \"int\" }, { \"name\": \"price\", \"type\": \"long\" }, { \"name\": \"qty\", \"type\": \"long\" }, { \"name\": \"lastExecutedPrice\", \"type\": \"long\" }, { \"name\": \"lastExecutedQty\", \"type\": \"long\" }, { \"name\": \"cumQty\", \"type\": \"long\" }, { \"name\": \"fee\", \"type\": \"string\" }, { \"name\": \"orderCreationTime\", \"type\": \"long\" }, { \"name\": \"transactionTime\", \"type\": \"long\" }, { \"name\": \"timeInForce\", \"type\": \"int\" }, { \"name\": \"currentExecutionType\", \"type\": \"string\" }, { \"name\": \"txHash\", \"type\": \"string\" } ] } } } ] }], \"default\": null }, { \"name\": \"proposals\", \"type\": [\"null\", { \"type\": \"record\", \"name\": \"Proposals\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"proposals\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Proposal\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"id\", \"type\": \"long\" }, { \"name\": \"status\", \"type\": \"string\" } ] } } } ] }], \"default\": null }, { \"name\": \"stakeUpdates\", \"type\": [\"null\", { \"type\": \"record\", \"name\": \"StakeUpdates\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"completedUnbondingDelegations\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"CompletedUnbondingDelegation\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"validator\", \"type\": \"string\" }, { \"name\": \"delegator\", \"type\": \"string\" }, { \"name\": \"amount\", \"type\": { \"type\": \"record\", \"name\": \"Coin\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"denom\", \"type\": \"string\" }, { \"name\": \"amount\", \"type\": \"long\" } ] } } ] } } } ] }], \"default\": null } ] } OrderBooksSchema : { \"type\": \"record\", \"name\": \"Books\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\" }, { \"name\": \"timestamp\", \"type\": \"long\" }, { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"books\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"OrderBookDelta\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"symbol\", \"type\": \"string\" }, { \"name\": \"buys\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"PriceLevel\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"price\", \"type\": \"long\" }, { \"name\": \"lastQty\", \"type\": \"long\" } ] } } }, { \"name\": \"sells\", \"type\": { \"type\": \"array\", \"items\": \"com.company.PriceLevel\" } } ] } }, \"default\": [] } ] } AccountBalanceSchema : { \"type\": \"record\", \"name\": \"Accounts\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\" }, { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"accounts\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Account\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"owner\", \"type\": \"string\" }, { \"name\": \"fee\", \"type\": \"string\" }, { \"name\": \"balances\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"AssetBalance\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"asset\", \"type\": \"string\" }, { \"name\": \"free\", \"type\": \"long\" }, { \"name\": \"frozen\", \"type\": \"long\" }, { \"name\": \"locked\", \"type\": \"long\" } ] } } } ] } }, \"default\": [] } ] } BlockFeeSchema : { \"type\": \"record\", \"name\": \"BlockFee\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\"}, { \"name\": \"fee\", \"type\": \"string\"}, { \"name\": \"validators\", \"type\": { \"type\": \"array\", \"items\": \"string\" }} ] } TransfersSchema : { \"type\": \"record\", \"name\": \"Transfers\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\"}, { \"name\": \"num\", \"type\": \"int\" }, { \"name\": \"timestamp\", \"type\": \"long\" }, { \"name\": \"transfers\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Transfer\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"txhash\", \"type\": \"string\" }, { \"name\": \"from\", \"type\": \"string\" }, { \"name\": \"to\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Receiver\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"addr\", \"type\": \"string\" }, { \"name\": \"coins\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Coin\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"denom\", \"type\": \"string\" }, { \"name\": \"amount\", \"type\": \"long\" } ] } } } ] } } } ] } } } ] }","title":"Get Extra Data From Your Full Node"},{"location":"guides/node/extra-info.html#get-extra-data-from-your-full-node","text":"This document is intended for developers who are interested in transactions, order books, account changes, fee charges in every block and would like to build their own downstream services of the full node. Please refer to Running Full Node , if you still haven't deployed a full node.","title":"Get Extra Data From Your Full Node"},{"location":"guides/node/extra-info.html#publish-different-messages-to-local-files","text":"You can set the publishLocal option to true in nodebinary/fullnode/{network}/node/app.toml . The full node will append the messages each block published to {fullnode home}/marketdata/marketdata.json (each line is a json object for a topic and height), and you can consume them in your own apps. The messages types are explained below. Note: only block messages after this option get turned on can be saved. This function won't make up messages for already saved blocks.","title":"Publish Different Messages to Local Files"},{"location":"guides/node/extra-info.html#set-kafka-broker-version","text":"Since the release of bnbchaind v0.6.3 , you can customize the version of kafka broker in app.toml . The default value is v2.1.0 : The recommended version 2.1.0 and the minimal version is 0.8.2.0 kafkaVersion = \"2.1.0\" If you are using another version of Kafka, please test the compatibility first.","title":"Set Kafka Broker Version"},{"location":"guides/node/extra-info.html#1-orderupdates","text":"You can set the publishOrderUpdates option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the trades that have been filled, orders that changed and proposals that been submitted. Example: All those extra info can also be found in exported data from your fullnode.","title":"1. OrderUpdates"},{"location":"guides/node/extra-info.html#changes","text":"In trade data structure, there are five new fields: SSrc , BSrc , SSingleFee , BSingleFee and TickerType . SSrc : Source code of Sell order transaction BSrc : Source code of Buy order transaction SSingleFee : fee of matched sell order BSingleFee : fee of matched buy order TickerType : ticker type In Order data structure, there is a new field: singlefee . This is used to show the fee of this order. Status is used to indicate the current status of this order. Namely there are 9 status: 0 for Acknowledge; 1 for Canceled ; 2 for Expired , 3 for IocNoFill, 4 for IocExpire, 5 for PartialFill, 6 for FullyFill, 7 for FailedBlocking, 8 for FailedMatching. For example: { \"Height\" : 36384232 , \"Timestamp\" : 1569196830136718300 , \"NumOfMsgs\" : 10 , \"Trades\" : { \"NumOfMsgs\" : 2 , \"Trades\" : [ { \"Id\" : \"36384232-0\" , \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Price\" : 345282 , \"Qty\" : 23200000000 , \"Sid\" : \"5F511BE6120CE2F92877F3A1E92D408CE56A5CCC-62632\" , \"Bid\" : \"4C28D006CF8061E05EEE50D17D8B2375CE09E7EC-71967\" , \"Sfee\" : \"GSYS:32042\" , \"Bfee\" : \"GSYS:32042\" , \"SSrc\" : 0 , \"BSrc\" : 0 , \"SSingleFee\" : \"GSYS:32042\" , \"BSingleFee\" : \"GSYS:32042\" , \"TickType\" : 5 , \"SAddr\" : \"bnb1tag3hesjpn30j2rh7ws7jt2q3njk5hxvsx023c\" , \"BAddr\" : \"bnb1fs5dqpk0sps7qhhw2rghmzerwh8qnelv7tyat8\" }, { \"Id\" : \"36384232-1\" , \"Symbol\" : \"EQL-586_GSYS\" , \"Price\" : 4798 , \"Qty\" : 110000000000 , \"Sid\" : \"610BFE81695EFD89B19D27D1E8C17D57C0239C66-6367\" , \"Bid\" : \"B3CEA961E95C4F104A791F6C33DB83458577BA76-5471\" , \"Sfee\" : \"GSYS:2111\" , \"Bfee\" : \"GSYS:2111\" , \"SSrc\" : 0 , \"BSrc\" : 0 , \"SSingleFee\" : \"GSYS:2111\" , \"BSingleFee\" : \"GSYS:2111\" , \"TickType\" : 2 , \"SAddr\" : \"bnb1vy9laqtftm7cnvvaylg73sta2lqz88rxs72mx7\" , \"BAddr\" : \"bnb1k082jc0ft383qjnerakr8kurgkzh0wnk8gulnj\" } ] }, \"Orders\" : { \"NumOfMsgs\" : 8 , \"Orders\" : [ { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"37D9383E6AD9AFEF6C5D8066ABA3ACA8C75D9F39-1724193\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1xlvns0n2mxh77mzaspn2hgav4rr4m8eerfju38\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 344271 , \"Qty\" : 89600000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 0 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"D74A96022A2F090D7D739C1C6716481A215E0F7F10C430C28290758E9DC4EF73\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"EQL-586_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"B3CEA961E95C4F104A791F6C33DB83458577BA76-5471\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1k082jc0ft383qjnerakr8kurgkzh0wnk8gulnj\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 4798 , \"Qty\" : 110000000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 110000000000 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"792BA5F932813F9C006075EAA090D82305AD049DDC570271FA8515339A874E97\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"4C28D006CF8061E05EEE50D17D8B2375CE09E7EC-71967\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1fs5dqpk0sps7qhhw2rghmzerwh8qnelv7tyat8\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 345283 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 23200000000 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"574CB6DAF26C5D1A465A8D86760FFDFF3DA5946F9C02EB5B89051A8120844523\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 0 , \"OrderId\" : \"5F511BE6120CE2F92877F3A1E92D408CE56A5CCC-62632\" , \"TradeId\" : \"\" , \"Owner\" : \"bnb1tag3hesjpn30j2rh7ws7jt2q3njk5hxvsx023c\" , \"Side\" : 2 , \"OrderType\" : 2 , \"Price\" : 345282 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 0 , \"LastExecutedQty\" : 0 , \"CumQty\" : 23200000000 , \"Fee\" : \"\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"9D8EF7CEAE5D2CDC4026F6306296D57764BB80099B3A65865971D8D71399B6EA\" , \"SingleFee\" : \"\" }, { \"Symbol\" : \"EQL-586_GSYS\" , \"Status\" : 5 , \"OrderId\" : \"610BFE81695EFD89B19D27D1E8C17D57C0239C66-6367\" , \"TradeId\" : \"36384232-1\" , \"Owner\" : \"bnb1vy9laqtftm7cnvvaylg73sta2lqz88rxs72mx7\" , \"Side\" : 2 , \"OrderType\" : 2 , \"Price\" : 4798 , \"Qty\" : 230000000000 , \"LastExecutedPrice\" : 4798 , \"LastExecutedQty\" : 110000000000 , \"CumQty\" : 110000000000 , \"Fee\" : \"GSYS:2111\" , \"OrderCreationTime\" : 1569196786802324000 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"EDF132EBDA03382D2BFF7EF58CDE574D4E3FB9622BD8BCF12BA6ABECD692BA5C\" , \"SingleFee\" : \"GSYS:2111\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 6 , \"OrderId\" : \"4C28D006CF8061E05EEE50D17D8B2375CE09E7EC-71967\" , \"TradeId\" : \"36384232-0\" , \"Owner\" : \"bnb1fs5dqpk0sps7qhhw2rghmzerwh8qnelv7tyat8\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 345283 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 345282 , \"LastExecutedQty\" : 23200000000 , \"CumQty\" : 23200000000 , \"Fee\" : \"GSYS:32042\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"574CB6DAF26C5D1A465A8D86760FFDFF3DA5946F9C02EB5B89051A8120844523\" , \"SingleFee\" : \"GSYS:32042\" }, { \"Symbol\" : \"DEFI-FA5_GSYS\" , \"Status\" : 6 , \"OrderId\" : \"5F511BE6120CE2F92877F3A1E92D408CE56A5CCC-62632\" , \"TradeId\" : \"36384232-0\" , \"Owner\" : \"bnb1tag3hesjpn30j2rh7ws7jt2q3njk5hxvsx023c\" , \"Side\" : 2 , \"OrderType\" : 2 , \"Price\" : 345282 , \"Qty\" : 23200000000 , \"LastExecutedPrice\" : 345282 , \"LastExecutedQty\" : 23200000000 , \"CumQty\" : 23200000000 , \"Fee\" : \"GSYS:32042\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"9D8EF7CEAE5D2CDC4026F6306296D57764BB80099B3A65865971D8D71399B6EA\" , \"SingleFee\" : \"GSYS:32042\" }, { \"Symbol\" : \"EQL-586_GSYS\" , \"Status\" : 6 , \"OrderId\" : \"B3CEA961E95C4F104A791F6C33DB83458577BA76-5471\" , \"TradeId\" : \"36384232-1\" , \"Owner\" : \"bnb1k082jc0ft383qjnerakr8kurgkzh0wnk8gulnj\" , \"Side\" : 1 , \"OrderType\" : 2 , \"Price\" : 4798 , \"Qty\" : 110000000000 , \"LastExecutedPrice\" : 4798 , \"LastExecutedQty\" : 110000000000 , \"CumQty\" : 110000000000 , \"Fee\" : \"GSYS:2111\" , \"OrderCreationTime\" : 1569196830136718300 , \"TransactionTime\" : 1569196830136718300 , \"TimeInForce\" : 1 , \"CurrentExecutionType\" : 0 , \"TxHash\" : \"792BA5F932813F9C006075EAA090D82305AD049DDC570271FA8515339A874E97\" , \"SingleFee\" : \"GSYS:2111\" } ] }, \"Proposals\" : { \"NumOfMsgs\" : 0 , \"Proposals\" : null }, \"StakeUpdates\" : { \"NumOfMsgs\" : 0 , \"CompletedUnbondingDelegations\" : null } }","title":"Changes"},{"location":"guides/node/extra-info.html#2-accountbalance","text":"You can set the publishAccountBalance option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the changed accounts. Example { Owner: string, Fee: string, Balances: []{ Asset: string, Free: int64, Frozen: int64, Locked: int64 } }","title":"2. AccountBalance"},{"location":"guides/node/extra-info.html#3-orderbook","text":"You can set the publishOrderBook option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all order book changes. Example { Height: int64, Timestamp: int64, NumOfMsgs: int, Books: []{ Symbol: string, Buys: []{ Price: int64, LastQty: int64 }, Sells: []{ Price: int64, LastQty: int64 } } }","title":"3. OrderBook"},{"location":"guides/node/extra-info.html#4-blockfee","text":"You can set the publishBlockFee option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the block fee charged. Example { Height: int64, Fee: string, Validators: []string }","title":"4. BlockFee"},{"location":"guides/node/extra-info.html#5-transfers","text":"You can set the publishTransfer option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the transfer transactions. Example { Height: int64, Num: int, Timestamp: int64, Transfers: []{ TxHash: string, Memo: string, From: string, To: []{ Addr: string, Coins: []{ Denom: string, Amount: int64 } } } }","title":"5. Transfers"},{"location":"guides/node/extra-info.html#6-staking-record","text":"You can set the publishStaking option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about staking. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"validators\": []{ \"feeAddr\": string, \"operatorAddr\": string, \"consAddr\": string, \"jailed\": bool, \"status\": string, \"tokens\": int64, \"delegatorShares\":int64, \"description\":{ \"moniker\": string, \"identity\": string, \"website\": string, \"details\": string, }, \"bondHeight\": int64, \"bondIntraTxCounter\": int, \"commission\":{ \"rate\": int64, \"maxRate\": int64, \"maxChangeRate\": int64, \"updateTime\": int64, }, \"distributionAddr\":string, \"sideChainId\": string, \"sideConsAddr\": string, \"sideFeeAddr\": string }, \"removedValidators\": map[string][]string, //key: chain id, value: operatorAddr \"delegatioins\": map[string][]{ \"delegator\": string, \"validator\": string, \"shares\": int64 }, // map key: chain-id \"unBondingDelegations\": map[string][]{ \"delegator\": string, \"validator\": string, \"creationHeight\": int64, \"minTime\": int64, \"initialBalance\": { \"denom\": string, \"amount\": int64 }, \"balance\": { \"denom\": string, \"amount\": int64 } }, // map key: chain id \"reDelegations\": map[string][]{ \"delegator\": string, \"srcValidator\": string, \"dstValidator\": string, \"creationHeight\": int64, \"sharesSrc\": int64, \"sharesDst\": int64, \"initialBalance\": { \"denom\": string, \"amount\": int64 }, \"balance\": { \"denom\": string, \"amount\": int64 }, \"minTime\": int64 }, // map key: chain id \"completedUBDs\": map[string][]{ \"validator\": string, \"delegator\": string, \"amount\": { \"denom\": string, \"amount\": int64 } }, \"completedREDs\": map[string][]{ \"delegator\": string, \"srcValidator\": string, \"dstValidator\": string }, \"delegateEvents\": map[string][]{ \"validator\": string, \"delegator\": string, \"amount\": { \"denom\": string, \"amount\": int64 }, \"txHash\": string }, \"unDelegateEvents\": map[string][]{ \"validator\": string, \"delegator\": string, \"amount\": { \"denom\": string, \"amount\": int64 }, \"txHash\": string }, \"reDelegateEvents\": map[string][]{ \"delegator\": string, \"srcValidator\": string, \"dstValidator\": string, \"amount\": { \"denom\": string, \"amount\": int64 }, \"txHash\": string }, \"electedValidators\": map[string][]{ \"feeAddr\": string, \"operatorAddr\": string, \"consAddr\": string, \"jailed\": bool, \"status\": string, \"tokens\": int64, \"delegatorShares\":int64, \"description\":{ \"moniker\": string, \"identity\": string, \"website\": string, \"details\": string, }, \"bondHeight\": int64, \"bondIntraTxCounter\": int, \"commission\":{ \"rate\": int64, \"maxRate\": int64, \"maxChangeRate\": int64, \"updateTime\": int64, }, \"distributionAddr\":string, \"sideChainId\": string, \"sideConsAddr\": string, \"sideFeeAddr\": string } } Schema { \"type\" : \"record\" , \"name\" : \"Staking\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"validators\" , \"type\" : [ \"null\" , { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Validator\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"feeAddr\" , \"type\" : \"string\" }, { \"name\" : \"operatorAddr\" , \"type\" : \"string\" }, { \"name\" : \"consAddr\" , \"type\" : [ \"null\" , \"string\" ], \"default\" : \"null\" }, { \"name\" : \"jailed\" , \"type\" : \"boolean\" }, { \"name\" : \"status\" , \"type\" : \"string\" }, { \"name\" : \"tokens\" , \"type\" : \"long\" }, { \"name\" : \"delegatorShares\" , \"type\" : \"long\" }, { \"name\" : \"description\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Description\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"moniker\" , \"type\" : \"string\" }, { \"name\" : \"identity\" , \"type\" : \"string\" }, { \"name\" : \"website\" , \"type\" : \"string\" }, { \"name\" : \"details\" , \"type\" : \"string\" } ] }}, { \"name\" : \"bondHeight\" , \"type\" : \"long\" }, { \"name\" : \"bondIntraTxCounter\" , \"type\" : \"int\" }, { \"name\" : \"commission\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Commission\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"rate\" , \"type\" : \"long\" }, { \"name\" : \"maxRate\" , \"type\" : \"long\" }, { \"name\" : \"maxChangeRate\" , \"type\" : \"long\" }, { \"name\" : \"updateTime\" , \"type\" : \"long\" } ] }}, { \"name\" : \"distributionAddr\" , \"type\" : \"string\" }, { \"name\" : \"sideChainId\" , \"type\" : \"string\" }, { \"name\" : \"sideConsAddr\" , \"type\" : \"string\" }, { \"name\" : \"sideFeeAddr\" , \"type\" : \"string\" } ] } }], \"default\" : \"null\" }, { \"name\" : \"removedValidators\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" } } }], \"default\" : null }, { \"name\" : \"delegations\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Delegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"shares\" , \"type\" : \"long\" } ] } } }], \"default\" : null }, { \"name\" : \"unBondingDelegations\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"UnBondingDelgation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"creationHeight\" , \"type\" : \"long\" }, { \"name\" : \"minTime\" , \"type\" : \"long\" }, { \"name\" : \"initialBalance\" , \"type\" : { \"type\" : \"record\" , \"name\" : \"Coin\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"denom\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] }}, { \"name\" : \"balance\" , \"type\" : \"org.shree.dex.model.avro.Coin\" } ] } } }], \"default\" : null }, { \"name\" : \"reDelegations\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"ReDelegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"srcValidator\" , \"type\" : \"string\" }, { \"name\" : \"dstValidator\" , \"type\" : \"string\" }, { \"name\" : \"creationHeight\" , \"type\" : \"long\" }, { \"name\" : \"sharesSrc\" , \"type\" : \"long\" }, { \"name\" : \"sharesDst\" , \"type\" : \"long\" }, { \"name\" : \"initialBalance\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"balance\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"minTime\" , \"type\" : \"long\" } ] } } }], \"default\" : null }, { \"name\" : \"completedUBDs\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"CompletedUnbondingDelegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" } ] } } }], \"default\" : null }, { \"name\" : \"completedREDs\" , \"type\" : [ \"null\" ,{ \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"CompletedReDelegation\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"srcValidator\" , \"type\" : \"string\" }, { \"name\" : \"dstValidator\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"delegateEvents\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"DelegateEvent\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"txHash\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"unDelegateEvents\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"UndelegateEvent\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"txHash\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"reDelegateEvents\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"RedelegateEvent\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"delegator\" , \"type\" : \"string\" }, { \"name\" : \"srcValidator\" , \"type\" : \"string\" }, { \"name\" : \"dstValidator\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"org.shree.dex.model.avro.Coin\" }, { \"name\" : \"txHash\" , \"type\" : \"string\" } ] } } }], \"default\" : null }, { \"name\" : \"electedValidators\" , \"type\" : [ \"null\" , { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : \"org.shree.dex.model.avro.Validator\" } }], \"default\" : null } ] }","title":"6. Staking Record"},{"location":"guides/node/extra-info.html#7-reward-distribution","text":"You can set the publishDistributeReward option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about reward distribution. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"distributions\" : map[string][]{ \"validator\": string, \"selfDelegator\": string, \"distributeAddr\": string, \"valTokens\": int64, \"totalReward\": int64, \"commission\": int64, \"rewards\": []{ \"delegator\": string, \"delegationTokens\": int64, \"reward\": int64 } } // map key: chain id } Schema { \"type\": \"record\", \"name\": \"Distribution\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\" }, { \"name\": \"timestamp\", \"type\": \"long\" }, { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"distributions\", \"type\": { \"type\": \"map\", \"values\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"DistributionData\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ {\"name\": \"validator\", \"type\": \"string\"}, {\"name\": \"selfDelegator\",\"type\": \"string\"}, {\"name\": \"distributeAddr\",\"type\": \"string\"}, {\"name\": \"valTokens\", \"type\": \"long\"}, {\"name\": \"totalReward\", \"type\": \"long\"}, {\"name\": \"commission\", \"type\": \"long\"}, {\"name\": \"rewards\", \"type\":{ \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Reward\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\":[ {\"name\": \"delegator\", \"type\": \"string\"}, {\"name\": \"delegationTokens\", \"type\": \"long\"}, {\"name\": \"reward\", \"type\": \"long\"} ] } }} ] } } } } ] }","title":"7. Reward Distribution"},{"location":"guides/node/extra-info.html#8-slashing","text":"You can set the publishSlashing option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about slashing. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"slashData\": map[string][]{ \"validator\": string, \"infractionType\": int, \"infractionHeight\": int64, \"jailUtil\": int64, \"slashAmount\": int64, \"toFeePool\": int64, \"submitter\": string, \"submitterReward\": int64, \"validatorsCompensation\": []{ \"address\": string, \"amount\": int64 } } } Schema { \"type\" : \"record\" , \"name\" : \"Slashing\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"slashData\" , \"type\" : { \"type\" : \"map\" , \"values\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"SlashData\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"validator\" , \"type\" : \"string\" }, { \"name\" : \"infractionType\" , \"type\" : \"int\" }, { \"name\" : \"infractionHeight\" , \"type\" : \"long\" }, { \"name\" : \"jailUtil\" , \"type\" : \"long\" }, { \"name\" : \"slashAmount\" , \"type\" : \"long\" }, { \"name\" : \"toFeePool\" , \"type\" : \"long\" }, { \"name\" : \"submitter\" , \"type\" : \"string\" }, { \"name\" : \"submitterReward\" , \"type\" : \"long\" }, { \"name\" : \"validatorsCompensation\" , \"type\" :{ \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"AllocatedAmt\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" :[ { \"name\" : \"address\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] } }} ] } } }} ] }","title":"8. Slashing"},{"location":"guides/node/extra-info.html#9-crosstransfer","text":"You can set the publishCrossTransfer option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about cross transfer. Example { \"height\": int64, \"timestamp\": int64, \"num\": int, \"transfers\": []{ \"txhash\": string, \"type\": string, \"relayerFee\": int64, \"chainid\": string, \"from\": \"string\", \"denom\": string, \"contract\": string, \"decimals\": int, \"to\": []{ \"addr\": string, \"amount\": int64 } } } Schema { \"type\" : \"record\" , \"name\" : \"CrossTransfers\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"num\" , \"type\" : \"int\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"transfers\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Transfer\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"txhash\" , \"type\" : \"string\" }, { \"name\" : \"type\" , \"type\" : \"string\" }, { \"name\" : \"relayerFee\" , \"type\" : \"long\" }, { \"name\" : \"chainid\" , \"type\" : \"string\" }, { \"name\" : \"from\" , \"type\" : \"string\" }, { \"name\" : \"denom\" , \"type\" : \"string\" }, { \"name\" : \"contract\" , \"type\" : \"string\" }, { \"name\" : \"decimals\" , \"type\" : \"int\" }, { \"name\" : \"to\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Receiver\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"addr\" , \"type\" : \"string\" }, { \"name\" : \"amount\" , \"type\" : \"long\" } ] } } } ] } } } ] }","title":"9. CrossTransfer"},{"location":"guides/node/extra-info.html#10-sideproposal","text":"You can set the publishSideProposal option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about side proposals. Example { \"height\": int64, \"timestamp\": int64, \"numOfMsgs\": int, \"proposals\": []{ \"id\": int64, \"chainid\": string, \"status\": string } } Schema { \"type\" : \"record\" , \"name\" : \"SideProposals\" , \"namespace\" : \"com.company\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" }, { \"name\" : \"numOfMsgs\" , \"type\" : \"int\" }, { \"name\" : \"proposals\" , \"type\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"record\" , \"name\" : \"Proposal\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"id\" , \"type\" : \"long\" }, { \"name\" : \"chainid\" , \"type\" : \"string\" }, { \"name\" : \"status\" , \"type\" : \"string\" } ] } } } ] }","title":"10. SideProposal"},{"location":"guides/node/extra-info.html#11-breatheblock","text":"You can set the publichBreatheBlock option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save all the messages about side proposals. Example { \"height\": int64, \"timestamp\": int64 } Schema { \"type\" : \"record\" , \"name\" : \"BreatheBlock\" , \"namespace\" : \"org.shree.dex.model.avro\" , \"fields\" : [ { \"name\" : \"height\" , \"type\" : \"long\" }, { \"name\" : \"timestamp\" , \"type\" : \"long\" } ] }","title":"11. BreatheBlock"},{"location":"guides/node/extra-info.html#publish-different-messages-to-kafka","text":"You can set the publishKafka option to true in nodebinary/fullnode/{network}/node/app.toml . Then, the full node will save messages that you are interested into Kafka, and you can consume them in your own apps. The message is encoded based on Avro serialization system. Their schemas are shown below: OrderUpdates : { \"type\": \"record\", \"name\": \"ExecutionResults\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\" }, { \"name\": \"timestamp\", \"type\": \"long\" }, { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"trades\", \"type\": [\"null\", { \"type\": \"record\", \"name\": \"Trades\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"trades\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Trade\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"symbol\", \"type\": \"string\" }, { \"name\": \"id\", \"type\": \"string\" }, { \"name\": \"price\", \"type\": \"long\" }, { \"name\": \"qty\", \"type\": \"long\" }, { \"name\": \"sid\", \"type\": \"string\" }, { \"name\": \"bid\", \"type\": \"string\" }, { \"name\": \"sfee\", \"type\": \"string\" }, { \"name\": \"bfee\", \"type\": \"string\" }, { \"name\": \"saddr\", \"type\": \"string\" }, { \"name\": \"baddr\", \"type\": \"string\" } ] } } } ] }], \"default\": null }, { \"name\": \"orders\", \"type\": [\"null\", { \"type\": \"record\", \"name\": \"Orders\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"orders\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Order\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"symbol\", \"type\": \"string\" }, { \"name\": \"status\", \"type\": \"string\" }, { \"name\": \"orderId\", \"type\": \"string\" }, { \"name\": \"tradeId\", \"type\": \"string\" }, { \"name\": \"owner\", \"type\": \"string\" }, { \"name\": \"side\", \"type\": \"int\" }, { \"name\": \"orderType\", \"type\": \"int\" }, { \"name\": \"price\", \"type\": \"long\" }, { \"name\": \"qty\", \"type\": \"long\" }, { \"name\": \"lastExecutedPrice\", \"type\": \"long\" }, { \"name\": \"lastExecutedQty\", \"type\": \"long\" }, { \"name\": \"cumQty\", \"type\": \"long\" }, { \"name\": \"fee\", \"type\": \"string\" }, { \"name\": \"orderCreationTime\", \"type\": \"long\" }, { \"name\": \"transactionTime\", \"type\": \"long\" }, { \"name\": \"timeInForce\", \"type\": \"int\" }, { \"name\": \"currentExecutionType\", \"type\": \"string\" }, { \"name\": \"txHash\", \"type\": \"string\" } ] } } } ] }], \"default\": null }, { \"name\": \"proposals\", \"type\": [\"null\", { \"type\": \"record\", \"name\": \"Proposals\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"proposals\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Proposal\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"id\", \"type\": \"long\" }, { \"name\": \"status\", \"type\": \"string\" } ] } } } ] }], \"default\": null }, { \"name\": \"stakeUpdates\", \"type\": [\"null\", { \"type\": \"record\", \"name\": \"StakeUpdates\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"completedUnbondingDelegations\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"CompletedUnbondingDelegation\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"validator\", \"type\": \"string\" }, { \"name\": \"delegator\", \"type\": \"string\" }, { \"name\": \"amount\", \"type\": { \"type\": \"record\", \"name\": \"Coin\", \"namespace\": \"org.shree.dex.model.avro\", \"fields\": [ { \"name\": \"denom\", \"type\": \"string\" }, { \"name\": \"amount\", \"type\": \"long\" } ] } } ] } } } ] }], \"default\": null } ] } OrderBooksSchema : { \"type\": \"record\", \"name\": \"Books\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\" }, { \"name\": \"timestamp\", \"type\": \"long\" }, { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"books\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"OrderBookDelta\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"symbol\", \"type\": \"string\" }, { \"name\": \"buys\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"PriceLevel\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"price\", \"type\": \"long\" }, { \"name\": \"lastQty\", \"type\": \"long\" } ] } } }, { \"name\": \"sells\", \"type\": { \"type\": \"array\", \"items\": \"com.company.PriceLevel\" } } ] } }, \"default\": [] } ] } AccountBalanceSchema : { \"type\": \"record\", \"name\": \"Accounts\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\" }, { \"name\": \"numOfMsgs\", \"type\": \"int\" }, { \"name\": \"accounts\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Account\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"owner\", \"type\": \"string\" }, { \"name\": \"fee\", \"type\": \"string\" }, { \"name\": \"balances\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"AssetBalance\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"asset\", \"type\": \"string\" }, { \"name\": \"free\", \"type\": \"long\" }, { \"name\": \"frozen\", \"type\": \"long\" }, { \"name\": \"locked\", \"type\": \"long\" } ] } } } ] } }, \"default\": [] } ] } BlockFeeSchema : { \"type\": \"record\", \"name\": \"BlockFee\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\"}, { \"name\": \"fee\", \"type\": \"string\"}, { \"name\": \"validators\", \"type\": { \"type\": \"array\", \"items\": \"string\" }} ] } TransfersSchema : { \"type\": \"record\", \"name\": \"Transfers\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"height\", \"type\": \"long\"}, { \"name\": \"num\", \"type\": \"int\" }, { \"name\": \"timestamp\", \"type\": \"long\" }, { \"name\": \"transfers\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Transfer\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"txhash\", \"type\": \"string\" }, { \"name\": \"from\", \"type\": \"string\" }, { \"name\": \"to\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Receiver\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"addr\", \"type\": \"string\" }, { \"name\": \"coins\", \"type\": { \"type\": \"array\", \"items\": { \"type\": \"record\", \"name\": \"Coin\", \"namespace\": \"com.company\", \"fields\": [ { \"name\": \"denom\", \"type\": \"string\" }, { \"name\": \"amount\", \"type\": \"long\" } ] } } } ] } } } ] } } } ] }","title":"Publish Different Messages to Kafka"},{"location":"guides/node/fullnode-faq.html","text":"Common Issues When Running a Full Node AppHash Confliction Error Log panic: Tendermint state.AppHash does not match AppHash after replay. Got XXXXXXX, expected 251DF08F2BA7824F0875D33992CF03EA35106DDD34B3A9FE4EFA0B73CDD2FE14 This error is caused by a consensus issue and thus bnbchaind will panic. Solution To solve this issue, make sure that you have downloaded the correct genesis file , config.toml and app.toml . If you replaced the genesis file, then you need to do a node reset. To reset node: rm $BNCHOME/data rm $BNCHOME/config/priv_validator_key.json Then, start again. Peer connection error Error log: E[2019-04-17|23:52:24.069] Connection failed @ recvRoutine (reading byte) module=p2p peer=[aea74b16d28d06cbfbb1179c177e8cd71315cce4@54.64.99.130:27146](http://aea74b16d28d06cbfbb1179c177e8cd71315cce4@54.64.99.130:27146)conn=MConn{[52.199.237.19:27146](http://52.199.237.19:27146)} err=EOF E[2019-04-17|23:52:24.070] Stopping peer for error module=p2p peer=&quot;Peer{MConn{[52.199.237.19:27146](http://52.199.237.19:27146)} aea74b16d28d06cbfbb1179c177e8cd71315cce4 out}&quot; err=EOF This error is caused by the handshake failing between two peers. Solution To solve this problem, you need to make sure node_key.json is under $BNCHOME/config and nodes will try to re-connect automatically, so this issue should not persist. Connection Timeout Error log Dialing failed module=pex addr=2c1fa9c1698961da38d8cd50da9fe8b4bc433c50@34.202.245.91:26856 err=&quot;dial tcp 34.202.245.91:26856: i/o timeout&quot; attempts=3 Solution Check your internet connection and make sure it is stable. Out of memory Error Log fatal error: out of memory Solution Your machine must have more than 8 GB of memory , otherwise, it will not handle DB restoration during state sync. No priv_validator_state.json after reset Error log open /Users/.bnbchaind/data/priv_validator_state.json: no such file or directory Solution Delete both priv_validator_state.json & node_key.json file and data folder if you want to reset your full node. bnbchaind crashes because of too many open files The default number of files Linux can open (per-process) is 1024 . bnbchaind is likely to open more than 1024 files. This causes the process to crash. A quick fix is to run ulimit -n 65535 (increase the number of open files allowed) and then restart the process with: bnbchaind start Verify the number of open files: ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 3829 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 65535 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 3829 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited Please note that open files are different now. Forget to Upgrade The Genesys Chain has a hardfork upgrade and if you failed to upgrade your fullnode to the latest version, bnbchaind process will stop and even if you restart with the latest version, the following error will appear: panic: Tendermint state.AppHash does not match AppHash after replay. Got , expected 393887B67F69B19CAB5C48FB87B4966018ABA893FB3FFD241C0A94D2C8668DD2 goroutine 1 [running]: github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus.checkAppHash(0xa, 0x0, 0xc000bd8c56, 0x6, 0xc000b247c0, 0x12, 0x14e7bf9, 0x8592eb, 0xc000b247e0, 0x20, ...) /Users/huangsuyu/go/src/github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus/replay.go:464 +0x213 github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus.(*Handshaker).ReplayBlocks(0xc000b37980, 0xa, 0x0, 0xc000bd8c56, 0x6, 0xc000b247c0, 0x12, 0x14e7bf9, 0x8592eb, 0xc000b247e0, ...) To recover from the state conflict error, you need to: Backup your home directory, (default is ~/.bnbchaind) Download the tool: state-recover Get the height of upgrade, this height will be announced in the upgrade announcement on the forum. For example, if it's announced as 5000 in the forum and run the following command will make your full node recover to the last block before the upgrade, and that is 4999 : ./state_recover 4999 <your_home_path> Restart with the latest version of bnbchaind bnbchaind start & bnbchaind is not properly killed If you started your bnbchaind process after it was not properly killed. You will see the following error: panic: ERROR: Codespace: 5 Code: 9 Message: \"Initial ProposalID already set\" To recover, please reset your node and restart: bnbchaind unsafe-reset-all --home<your-home-dir> Cannot start bnbchaind If you do not download the binaries completely, you will see the following message: ./bnbchaind: line 1: version: command not found ./bnbchaind: line 2: oid: command not found /Library/Developer/CommandLineTools/usr/bin/size: 45160816 No such file or directory Since all the binaries are stored in git lfs , you will see this error is the binary is not complete. Please use this script to download the binaries or use git lfs clone . Cannot query a specific block Once you have your own node running, you can start querying from it. But sometimes you may not be ablt to get the information you want. For example: curl 'localhost:27147/block?height=10' The reason is because your node is using statesync to catch up. In this way, it will not store all the history blocks before the snapshot height it got. You can only query blocks after that snapshot height. To enable query history blocks, you need to use fast-sync Cannot query a specific transaction by height In some cases, you can search for the transactions in the same block by querying a fullnode. For example, curl \"localhost:27147/tx_search?query=\" tx.height = 1000000 \"&prove=true\" But sometimes, you may not get anything even though there are actually transactions in this block. { \"jsonrpc\" : \"2.0\" , \"id\" : \"\" , \"result\" : { \"txs\" : [], \"total_count\" : \"0\" } } The reason is that you didn't enable transaction height indexer. To enable this indexer, you need to make the following changes in your config.toml file: index_tags= \"tx.hash,tx.height\" Meanwhile, if you wish to enable range query, you also need to enable that setting in config.toml enable_range_query = true In this way, you can use Operator [\"<\", \">\", \">=\", \"<=\"] in your query. For example, curl \"http://localhost:27147/tx_search?query=\\\"tx.height>59970127 AND tx.height<59973127\\\"&prove=true\"","title":"Common Issues When Running a Full Node"},{"location":"guides/node/fullnode-faq.html#common-issues-when-running-a-full-node","text":"","title":"Common Issues When Running a Full Node"},{"location":"guides/node/fullnode-faq.html#apphash-confliction","text":"Error Log panic: Tendermint state.AppHash does not match AppHash after replay. Got XXXXXXX, expected 251DF08F2BA7824F0875D33992CF03EA35106DDD34B3A9FE4EFA0B73CDD2FE14 This error is caused by a consensus issue and thus bnbchaind will panic. Solution To solve this issue, make sure that you have downloaded the correct genesis file , config.toml and app.toml . If you replaced the genesis file, then you need to do a node reset. To reset node: rm $BNCHOME/data rm $BNCHOME/config/priv_validator_key.json Then, start again.","title":"AppHash Confliction"},{"location":"guides/node/fullnode-faq.html#peer-connection-error","text":"Error log: E[2019-04-17|23:52:24.069] Connection failed @ recvRoutine (reading byte) module=p2p peer=[aea74b16d28d06cbfbb1179c177e8cd71315cce4@54.64.99.130:27146](http://aea74b16d28d06cbfbb1179c177e8cd71315cce4@54.64.99.130:27146)conn=MConn{[52.199.237.19:27146](http://52.199.237.19:27146)} err=EOF E[2019-04-17|23:52:24.070] Stopping peer for error module=p2p peer=&quot;Peer{MConn{[52.199.237.19:27146](http://52.199.237.19:27146)} aea74b16d28d06cbfbb1179c177e8cd71315cce4 out}&quot; err=EOF This error is caused by the handshake failing between two peers. Solution To solve this problem, you need to make sure node_key.json is under $BNCHOME/config and nodes will try to re-connect automatically, so this issue should not persist.","title":"Peer connection error"},{"location":"guides/node/fullnode-faq.html#connection-timeout","text":"Error log Dialing failed module=pex addr=2c1fa9c1698961da38d8cd50da9fe8b4bc433c50@34.202.245.91:26856 err=&quot;dial tcp 34.202.245.91:26856: i/o timeout&quot; attempts=3 Solution Check your internet connection and make sure it is stable.","title":"Connection Timeout"},{"location":"guides/node/fullnode-faq.html#out-of-memory","text":"Error Log fatal error: out of memory Solution Your machine must have more than 8 GB of memory , otherwise, it will not handle DB restoration during state sync.","title":"Out of memory"},{"location":"guides/node/fullnode-faq.html#no-priv_validator_statejson-after-reset","text":"Error log open /Users/.bnbchaind/data/priv_validator_state.json: no such file or directory Solution Delete both priv_validator_state.json & node_key.json file and data folder if you want to reset your full node.","title":"No priv_validator_state.json after reset"},{"location":"guides/node/fullnode-faq.html#bnbchaind-crashes-because-of-too-many-open-files","text":"The default number of files Linux can open (per-process) is 1024 . bnbchaind is likely to open more than 1024 files. This causes the process to crash. A quick fix is to run ulimit -n 65535 (increase the number of open files allowed) and then restart the process with: bnbchaind start Verify the number of open files: ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 3829 max locked memory (kbytes, -l) 64 max memory size (kbytes, -m) unlimited open files (-n) 65535 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 3829 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited Please note that open files are different now.","title":"bnbchaind crashes because of too many open files"},{"location":"guides/node/fullnode-faq.html#forget-to-upgrade","text":"The Genesys Chain has a hardfork upgrade and if you failed to upgrade your fullnode to the latest version, bnbchaind process will stop and even if you restart with the latest version, the following error will appear: panic: Tendermint state.AppHash does not match AppHash after replay. Got , expected 393887B67F69B19CAB5C48FB87B4966018ABA893FB3FFD241C0A94D2C8668DD2 goroutine 1 [running]: github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus.checkAppHash(0xa, 0x0, 0xc000bd8c56, 0x6, 0xc000b247c0, 0x12, 0x14e7bf9, 0x8592eb, 0xc000b247e0, 0x20, ...) /Users/huangsuyu/go/src/github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus/replay.go:464 +0x213 github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus.(*Handshaker).ReplayBlocks(0xc000b37980, 0xa, 0x0, 0xc000bd8c56, 0x6, 0xc000b247c0, 0x12, 0x14e7bf9, 0x8592eb, 0xc000b247e0, ...) To recover from the state conflict error, you need to: Backup your home directory, (default is ~/.bnbchaind) Download the tool: state-recover Get the height of upgrade, this height will be announced in the upgrade announcement on the forum. For example, if it's announced as 5000 in the forum and run the following command will make your full node recover to the last block before the upgrade, and that is 4999 : ./state_recover 4999 <your_home_path> Restart with the latest version of bnbchaind bnbchaind start &","title":"Forget to Upgrade"},{"location":"guides/node/fullnode-faq.html#bnbchaind-is-not-properly-killed","text":"If you started your bnbchaind process after it was not properly killed. You will see the following error: panic: ERROR: Codespace: 5 Code: 9 Message: \"Initial ProposalID already set\" To recover, please reset your node and restart: bnbchaind unsafe-reset-all --home<your-home-dir>","title":"bnbchaind is not properly killed"},{"location":"guides/node/fullnode-faq.html#cannot-start-bnbchaind","text":"If you do not download the binaries completely, you will see the following message: ./bnbchaind: line 1: version: command not found ./bnbchaind: line 2: oid: command not found /Library/Developer/CommandLineTools/usr/bin/size: 45160816 No such file or directory Since all the binaries are stored in git lfs , you will see this error is the binary is not complete. Please use this script to download the binaries or use git lfs clone .","title":"Cannot start bnbchaind"},{"location":"guides/node/fullnode-faq.html#cannot-query-a-specific-block","text":"Once you have your own node running, you can start querying from it. But sometimes you may not be ablt to get the information you want. For example: curl 'localhost:27147/block?height=10' The reason is because your node is using statesync to catch up. In this way, it will not store all the history blocks before the snapshot height it got. You can only query blocks after that snapshot height. To enable query history blocks, you need to use fast-sync","title":"Cannot query a specific block"},{"location":"guides/node/fullnode-faq.html#cannot-query-a-specific-transaction-by-height","text":"In some cases, you can search for the transactions in the same block by querying a fullnode. For example, curl \"localhost:27147/tx_search?query=\" tx.height = 1000000 \"&prove=true\" But sometimes, you may not get anything even though there are actually transactions in this block. { \"jsonrpc\" : \"2.0\" , \"id\" : \"\" , \"result\" : { \"txs\" : [], \"total_count\" : \"0\" } } The reason is that you didn't enable transaction height indexer. To enable this indexer, you need to make the following changes in your config.toml file: index_tags= \"tx.hash,tx.height\" Meanwhile, if you wish to enable range query, you also need to enable that setting in config.toml enable_range_query = true In this way, you can use Operator [\"<\", \">\", \">=\", \"<=\"] in your query. For example, curl \"http://localhost:27147/tx_search?query=\\\"tx.height>59970127 AND tx.height<59973127\\\"&prove=true\"","title":"Cannot query a specific transaction by height"},{"location":"guides/node/install.html","text":"Install Binaries This guide will explain how to install the binaries: bnbchaind and eth-cli , onto your server. With these installed on a server, you can participate in the mainnet or testnet as a Full Node. Full Nodes of Genesys Chain also help the network by accepting transactions from other nodes and then relaying them to the core GSYS network. Supported Platforms We support running a full node on Mac OS , Windows and Linux . Option One: Installation Script We have a community-maintained installer script ( install.sh ) that takes care of chain directory setup. This uses the following defaults: Home folder in ~/.bnbchaind Client executables stored in /usr/local/bin (i.e. lightd or bnbchaind ) # One-line install sh <(wget -qO- https://raw.githubusercontent.com/shree-chain/node-binary/master/install.sh) The script will install the bnbchain , eth-cli and eth-cli binaries. Verify that everything is OK: $ bnbchaind version $ eth-cli version Option Two: Manual Installation We currently use this repo to store historical versions of the compiled node-binaries . Install Git LFS Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise. Please go to https://git-lfs.github.com/ and install git lfs . Download Binary with Git LFS: git lfs clonehttps://github.com/githubusername/githubrepo/node-binary.git Please go to changelog to get the information about the latest release of full node version. Go to directory according to the network you want to join in. Replace the network variable with testnet or prod in the following command: cd node-binary/fullnode/{network}/{version} 4. Copy the executables (i.e.bnbchaind or eth-cli) to /usr/local/bin Next Now you can join the mainnet , the public testnet or create you own testnet","title":"Install Binaries"},{"location":"guides/node/install.html#install-binaries","text":"This guide will explain how to install the binaries: bnbchaind and eth-cli , onto your server. With these installed on a server, you can participate in the mainnet or testnet as a Full Node. Full Nodes of Genesys Chain also help the network by accepting transactions from other nodes and then relaying them to the core GSYS network.","title":"Install Binaries"},{"location":"guides/node/install.html#supported-platforms","text":"We support running a full node on Mac OS , Windows and Linux .","title":"Supported Platforms"},{"location":"guides/node/install.html#option-one-installation-script","text":"We have a community-maintained installer script ( install.sh ) that takes care of chain directory setup. This uses the following defaults: Home folder in ~/.bnbchaind Client executables stored in /usr/local/bin (i.e. lightd or bnbchaind ) # One-line install sh <(wget -qO- https://raw.githubusercontent.com/shree-chain/node-binary/master/install.sh) The script will install the bnbchain , eth-cli and eth-cli binaries. Verify that everything is OK: $ bnbchaind version $ eth-cli version","title":"Option One: Installation Script"},{"location":"guides/node/install.html#option-two-manual-installation","text":"We currently use this repo to store historical versions of the compiled node-binaries . Install Git LFS Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise. Please go to https://git-lfs.github.com/ and install git lfs . Download Binary with Git LFS: git lfs clonehttps://github.com/githubusername/githubrepo/node-binary.git Please go to changelog to get the information about the latest release of full node version. Go to directory according to the network you want to join in. Replace the network variable with testnet or prod in the following command: cd node-binary/fullnode/{network}/{version} 4. Copy the executables (i.e.bnbchaind or eth-cli) to /usr/local/bin","title":"Option Two: Manual Installation"},{"location":"guides/node/install.html#next","text":"Now you can join the mainnet , the public testnet or create you own testnet","title":"Next"},{"location":"guides/node/join-mainnet.html","text":"Join Mainnet Tip See the node-binary repo for information on the mainnet, including the correct version of the binaries to use and details about the genesis file. Warning You need to install bnbchaind before you go further Minimum System Requirements The hardware must meet certain requirements to run a Full Node. Desktop or laptop hardware running recent versions of Mac OS X, Windows, or Linux. 500 GB of free disk space, accessible at a minimum read/write speed of 100 MB/s. 4 cores of CPU and 8 gigabytes of memory (RAM). A broadband Internet connection with upload/download speeds of at least 1 megabyte per second Your full node has to run at least 4 hours per 24 hours in order to catch up with Genesys Chain More hours will be better, run your node continuously for best results. Setting Up a New Node You can skip this part if you have executed the install script. First you need to choose a home folder $BNCHOME (i.e. ~/.bnbchaind) for Genesys Chain. You can setup this by: mkdir ~/.bnbchaind mkdir ~/.bnbchaind/config Then, download app.toml and config.toml from node-binary/fullnode/{network}/{version}/config/ into $BNCHOME/config You can edit this moniker later, in the ~/.gaiad/config/config.toml file: # A custom human readable name for this node moniker = \"<your_custom_moniker>\" Note Monikers can contain only ASCII characters. Using Unicode characters will render your node unreachable. ::: Now your Full Node has been initialized! Genesis & Seeds Download the Genesis File Fetch the mainnet's genesis.json file into node-binary's config directory. cd -p $HOME/.bnbchaind/config wget https://raw.githubusercontent.com/shree-chain/node-binary/master/fullnode/prod/0.6.3-hotfix/config/genesis.json Note we use the latest directory in the node-binary repo which contains details for the mainnet like the latest version and the genesis file. ::: tip If you want to understand genesis file, click here ::: To verify the correctness of the configuration run: bnbchaind start & If you encounter any issue when running a Full Node, you can read the FAQ list here . Add Seed Nodes Your Full Node needs to know how to find peers in the blockchain network. You'll need to add healthy seed nodes to $HOME/.bnbchain/config/config.toml. The recommended config.toml already contains links to some seed nodes. If those seeds aren't working, you can find more seeds and persistent peers in HTTP API endpoints: https://dex.genesys.network/api/v1/peers Additional Configuration Sync type: by default, new nodes will sync with state-sync mode. To change sync mode, read the instructions here Log: The log file is under home - the directory specified when starting bnbchaind . The latest log file is bnc.log . The process will create a new log file every one hour. To make sure you have sufficient disk space to keep the log files, we strongly recommend you to change the log location by changing logFileRoot option in $BNCHOME/config/app.toml . Service Port: RPC service listens on port 27147 and P2P service listens on port 27146 by default. Make sure these two ports are open before starting a full node, unless the full node has to listen on other ports. Store: All the state and block data will store under $BNCHOME/data , do not delete or edit any of these files. Get Extra Information From Your Fullnode If you have a Full Node running, then you can publish extra messages to local files. Monitor Syncing Process You can verify if state sync is done by curl localhost:27147/status several times and see whether latest_block_height is increasing in response. \"sync_info\": { ... \"latest_block_height\": \"878092\", \"latest_block_time\": \"2019-04-15T00:01:22.610803768Z\", ... } Prometheus Metrics Prometheus is enabled on port 28660 by default, and the endpoint is /metrics . Mainnet Tools Explorer","title":"Join Mainnet"},{"location":"guides/node/join-mainnet.html#join-mainnet","text":"Tip See the node-binary repo for information on the mainnet, including the correct version of the binaries to use and details about the genesis file. Warning You need to install bnbchaind before you go further","title":"Join Mainnet"},{"location":"guides/node/join-mainnet.html#minimum-system-requirements","text":"The hardware must meet certain requirements to run a Full Node. Desktop or laptop hardware running recent versions of Mac OS X, Windows, or Linux. 500 GB of free disk space, accessible at a minimum read/write speed of 100 MB/s. 4 cores of CPU and 8 gigabytes of memory (RAM). A broadband Internet connection with upload/download speeds of at least 1 megabyte per second Your full node has to run at least 4 hours per 24 hours in order to catch up with Genesys Chain More hours will be better, run your node continuously for best results.","title":"Minimum System Requirements"},{"location":"guides/node/join-mainnet.html#setting-up-a-new-node","text":"You can skip this part if you have executed the install script. First you need to choose a home folder $BNCHOME (i.e. ~/.bnbchaind) for Genesys Chain. You can setup this by: mkdir ~/.bnbchaind mkdir ~/.bnbchaind/config Then, download app.toml and config.toml from node-binary/fullnode/{network}/{version}/config/ into $BNCHOME/config You can edit this moniker later, in the ~/.gaiad/config/config.toml file: # A custom human readable name for this node moniker = \"<your_custom_moniker>\" Note Monikers can contain only ASCII characters. Using Unicode characters will render your node unreachable. ::: Now your Full Node has been initialized!","title":"Setting Up a New Node"},{"location":"guides/node/join-mainnet.html#genesis-seeds","text":"","title":"Genesis &amp; Seeds"},{"location":"guides/node/join-mainnet.html#download-the-genesis-file","text":"Fetch the mainnet's genesis.json file into node-binary's config directory. cd -p $HOME/.bnbchaind/config wget https://raw.githubusercontent.com/shree-chain/node-binary/master/fullnode/prod/0.6.3-hotfix/config/genesis.json Note we use the latest directory in the node-binary repo which contains details for the mainnet like the latest version and the genesis file. ::: tip If you want to understand genesis file, click here ::: To verify the correctness of the configuration run: bnbchaind start & If you encounter any issue when running a Full Node, you can read the FAQ list here .","title":"Download the Genesis File"},{"location":"guides/node/join-mainnet.html#add-seed-nodes","text":"Your Full Node needs to know how to find peers in the blockchain network. You'll need to add healthy seed nodes to $HOME/.bnbchain/config/config.toml. The recommended config.toml already contains links to some seed nodes. If those seeds aren't working, you can find more seeds and persistent peers in HTTP API endpoints: https://dex.genesys.network/api/v1/peers","title":"Add Seed Nodes"},{"location":"guides/node/join-mainnet.html#additional-configuration","text":"Sync type: by default, new nodes will sync with state-sync mode. To change sync mode, read the instructions here Log: The log file is under home - the directory specified when starting bnbchaind . The latest log file is bnc.log . The process will create a new log file every one hour. To make sure you have sufficient disk space to keep the log files, we strongly recommend you to change the log location by changing logFileRoot option in $BNCHOME/config/app.toml . Service Port: RPC service listens on port 27147 and P2P service listens on port 27146 by default. Make sure these two ports are open before starting a full node, unless the full node has to listen on other ports. Store: All the state and block data will store under $BNCHOME/data , do not delete or edit any of these files.","title":"Additional Configuration"},{"location":"guides/node/join-mainnet.html#get-extra-information-from-your-fullnode","text":"If you have a Full Node running, then you can publish extra messages to local files.","title":"Get Extra Information From Your Fullnode"},{"location":"guides/node/join-mainnet.html#monitor-syncing-process","text":"You can verify if state sync is done by curl localhost:27147/status several times and see whether latest_block_height is increasing in response. \"sync_info\": { ... \"latest_block_height\": \"878092\", \"latest_block_time\": \"2019-04-15T00:01:22.610803768Z\", ... }","title":"Monitor Syncing Process"},{"location":"guides/node/join-mainnet.html#prometheus-metrics","text":"Prometheus is enabled on port 28660 by default, and the endpoint is /metrics .","title":"Prometheus Metrics"},{"location":"guides/node/join-mainnet.html#mainnet-tools","text":"Explorer","title":"Mainnet Tools"},{"location":"guides/node/join-testnet.html","text":"Join Testnet Tip See the node-binary repo for information on the mainnet, including the correct version of the binaries to use and details about the genesis file. Warning You need to install bnbchaind before you go further Minimum System Requirements The hardware must meet certain requirements to run a Full Node. Desktop or laptop hardware running recent versions of Mac OS X, Windows, or Linux. 500 GB of free disk space, accessible at a minimum read/write speed of 100 MB/s. 4 cores of CPU and 8 gigabytes of memory (RAM). A broadband Internet connection with upload/download speeds of at least 1 megabyte per second Your full node has to run at least 4 hours per 24 hours in order to catch up with Genesys Chain More hours will be better, run your node continuously for best results. Setting Up a New Node You can skip this part if you have executed the install script. First you need to choose a home folder $BNCHOME (i.e. ~/.bnbchaind) for Genesys Chain. You can setup this by: mkdir ~/.bnbchaind mkdir ~/.bnbchaind/config Then, download app.toml and config.toml from node-binary/fullnode/{network}/{version}/config/ into $BNCHOME/config You can edit this moniker later, in the ~/.gaiad/config/config.toml file: # A custom human readable name for this node moniker = \"<your_custom_moniker>\" Note Monikers can contain only ASCII characters. Using Unicode characters will render your node unreachable. ::: Now your Full Node has been initialized! Genesis & Seeds Download the Genesis File Fetch the testnet's genesis.json file into node-binary's config directory. cd -p $HOME/.bnbchaind/config wget https://raw.githubusercontent.com/shree-chain/node-binary/master/fullnode/testnet/0.6.3-hotfix/config/genesis.json Note we use the latest directory in the node-binary repo which contains details for the testnet like the latest version and the genesis file. ::: tip If you want to understand genesis file, click here ::: To verify the correctness of the configuration run: bnbchaind start & If you encounter any issue when runing a Full Node, you should read the FAQ provided here. Add Seed Nodes Your Full Node needs to know how to find peers in the blockchain network. You'll need to add healthy seed nodes to $HOME/.bnbchain/config/config.toml. The recommended config.toml already contains links to some seed nodes. If those seeds aren't working, you can find more seeds and persistent peers in the HTTP API endpoints: https://testnet-dex.genesys.network/api/v1/peers Additional Configuration Sync type: by default, new nodes will sync with state-sync mode. To change sync mode, read the instructions here Log: The log file is under home - the directory specified when starting bnbchaind . The latest log file is bnc.log . The process will create a new log file every one hour. To make sure you have sufficient disk space to keep the log files, we strongly recommend you to change the log location by changing logFileRoot option in $BNCHOME/config/app.toml . Service Port: RPC service listens on port 27147 and P2P service listens on port 27146 by default. Make sure these two ports are open before starting a full node, unless the full node has to listen on other ports. Store: All the state and block data will store under $BNCHOME/data , do not delete or edit any of these files. Get Extra Information From Your Fullnode If you have a Full Node running, then you can publish extra messages to local files. Monitor Syncing Process You can verify if state sync is done by curl localhost:27147/status several times and see whether latest_block_height is increasing in response. \"sync_info\": { ... \"latest_block_height\": \"878092\", \"latest_block_time\": \"2019-04-15T00:01:22.610803768Z\", ... } Prometheus Metrics Prometheus is enabled on port 28660 by default, and the endpoint is /metrics .","title":"Join Testnet"},{"location":"guides/node/join-testnet.html#join-testnet","text":"Tip See the node-binary repo for information on the mainnet, including the correct version of the binaries to use and details about the genesis file. Warning You need to install bnbchaind before you go further","title":"Join Testnet"},{"location":"guides/node/join-testnet.html#minimum-system-requirements","text":"The hardware must meet certain requirements to run a Full Node. Desktop or laptop hardware running recent versions of Mac OS X, Windows, or Linux. 500 GB of free disk space, accessible at a minimum read/write speed of 100 MB/s. 4 cores of CPU and 8 gigabytes of memory (RAM). A broadband Internet connection with upload/download speeds of at least 1 megabyte per second Your full node has to run at least 4 hours per 24 hours in order to catch up with Genesys Chain More hours will be better, run your node continuously for best results.","title":"Minimum System Requirements"},{"location":"guides/node/join-testnet.html#setting-up-a-new-node","text":"You can skip this part if you have executed the install script. First you need to choose a home folder $BNCHOME (i.e. ~/.bnbchaind) for Genesys Chain. You can setup this by: mkdir ~/.bnbchaind mkdir ~/.bnbchaind/config Then, download app.toml and config.toml from node-binary/fullnode/{network}/{version}/config/ into $BNCHOME/config You can edit this moniker later, in the ~/.gaiad/config/config.toml file: # A custom human readable name for this node moniker = \"<your_custom_moniker>\" Note Monikers can contain only ASCII characters. Using Unicode characters will render your node unreachable. ::: Now your Full Node has been initialized!","title":"Setting Up a New Node"},{"location":"guides/node/join-testnet.html#genesis-seeds","text":"","title":"Genesis &amp; Seeds"},{"location":"guides/node/join-testnet.html#download-the-genesis-file","text":"Fetch the testnet's genesis.json file into node-binary's config directory. cd -p $HOME/.bnbchaind/config wget https://raw.githubusercontent.com/shree-chain/node-binary/master/fullnode/testnet/0.6.3-hotfix/config/genesis.json Note we use the latest directory in the node-binary repo which contains details for the testnet like the latest version and the genesis file. ::: tip If you want to understand genesis file, click here ::: To verify the correctness of the configuration run: bnbchaind start & If you encounter any issue when runing a Full Node, you should read the FAQ provided here.","title":"Download the Genesis File"},{"location":"guides/node/join-testnet.html#add-seed-nodes","text":"Your Full Node needs to know how to find peers in the blockchain network. You'll need to add healthy seed nodes to $HOME/.bnbchain/config/config.toml. The recommended config.toml already contains links to some seed nodes. If those seeds aren't working, you can find more seeds and persistent peers in the HTTP API endpoints: https://testnet-dex.genesys.network/api/v1/peers","title":"Add Seed Nodes"},{"location":"guides/node/join-testnet.html#additional-configuration","text":"Sync type: by default, new nodes will sync with state-sync mode. To change sync mode, read the instructions here Log: The log file is under home - the directory specified when starting bnbchaind . The latest log file is bnc.log . The process will create a new log file every one hour. To make sure you have sufficient disk space to keep the log files, we strongly recommend you to change the log location by changing logFileRoot option in $BNCHOME/config/app.toml . Service Port: RPC service listens on port 27147 and P2P service listens on port 27146 by default. Make sure these two ports are open before starting a full node, unless the full node has to listen on other ports. Store: All the state and block data will store under $BNCHOME/data , do not delete or edit any of these files.","title":"Additional Configuration"},{"location":"guides/node/join-testnet.html#get-extra-information-from-your-fullnode","text":"If you have a Full Node running, then you can publish extra messages to local files.","title":"Get Extra Information From Your Fullnode"},{"location":"guides/node/join-testnet.html#monitor-syncing-process","text":"You can verify if state sync is done by curl localhost:27147/status several times and see whether latest_block_height is increasing in response. \"sync_info\": { ... \"latest_block_height\": \"878092\", \"latest_block_time\": \"2019-04-15T00:01:22.610803768Z\", ... }","title":"Monitor Syncing Process"},{"location":"guides/node/join-testnet.html#prometheus-metrics","text":"Prometheus is enabled on port 28660 by default, and the endpoint is /metrics .","title":"Prometheus Metrics"},{"location":"guides/node/localnetwork.html","text":"Run a Local Testnet Single-node Local Testnet This guide helps you create a single validator node that runs a network locally for testing and other development related uses. Requirements Install bnbchaind Create Genesis File and Start the Network # You can run all of these commands from your home directory cd $HOME Initialize the config.toml file that will help you to bootstrap the network bnbchaind init --home /Users/huangsuyu/Documents/work/localnet --moniker test Initialize the genesis file that will help you to bootstrap the network bnbchaind testnet --v 1 --chain-id local-testnet Copy genesis.json and others to $home/config cp ./mynetwork/config/genesis $home/config Edit app.toml to set ugrade height FixSignBytesOverflowHeight = 1 Start our node # Now its safe to start `bnbchaind` bnbchaind start --home $home","title":"Run a Local Testnet"},{"location":"guides/node/localnetwork.html#run-a-local-testnet","text":"","title":"Run a Local Testnet"},{"location":"guides/node/localnetwork.html#single-node-local-testnet","text":"This guide helps you create a single validator node that runs a network locally for testing and other development related uses.","title":"Single-node Local Testnet"},{"location":"guides/node/localnetwork.html#requirements","text":"Install bnbchaind","title":"Requirements"},{"location":"guides/node/localnetwork.html#create-genesis-file-and-start-the-network","text":"# You can run all of these commands from your home directory cd $HOME Initialize the config.toml file that will help you to bootstrap the network bnbchaind init --home /Users/huangsuyu/Documents/work/localnet --moniker test Initialize the genesis file that will help you to bootstrap the network bnbchaind testnet --v 1 --chain-id local-testnet Copy genesis.json and others to $home/config cp ./mynetwork/config/genesis $home/config Edit app.toml to set ugrade height FixSignBytesOverflowHeight = 1 Start our node # Now its safe to start `bnbchaind` bnbchaind start --home $home","title":"Create Genesis File and Start the Network"},{"location":"guides/node/nodetypes.html","text":"Types of Nodes Full Node Node Roles There are two types of Full Nodes in Genesys Chain network: validator nodes and witness nodes. What is a Validator Node? Validators are a group/IT infrastructure that take the responsibility to maintain the GSYS Chain/DEX data and validate all the transactions. They join the consensus procedure and vote to produce blocks. The fees are collected and distributed among all validators. You can consider Validator as \"miner\" in Bitcoin and Ethereum and similar concepts exist in dPoS blockchain as EOS or dBFT in NEO. The initial validators are selected from trusted members of the GSYS community, and will eventually expand to more members as the GSYS blockchain and ecosystem matures, this responsibility will be distributed. The decentralized governance procedure will be introduced and executed. More qualified organization/individual can become Validators. What is a Witness Node? Witness nodes represent the majority of nodes in a Genesys Chain deployment. Although they do not join the consensus process and produce blocks, they take care of: The witness consensus process. They serve as data replicas and help to propagate the chain state around the network. They receive transactions and broadcast them to all other nodes including Validator nodes. You can see the witness node information from this endpoint: https://dex.genesys.network/api/v1/peers For mainnet, there are some witness nodes. http://dataseed1.genesys.network/ http://dataseed2.genesys.network/ http://dataseed3.genesys.network/ https://dataseed4.genesys.network/ For testnet, there are some witness nodes. https://data-seed-pre-0-s3.genesys.network/ https://data-seed-pre-1-s3.genesys.network/ https://data-seed-pre-2-s3.genesys.network/ To see the existing RPC endpoints provided by witness node, check the list here ! What is an Accelerated Node? While users can submit transactions and most of the queries via normal, self-run full nodes. Accelerated Node provides more secure and faster lines to access Genesys Chain. Accelerated Node is special infrastructure built around Validator to facilitate accelerated transaction routing and provide richer, faster user interfaces. There are always several Accelerated Nodes running at the same time around the world (owned by different organizations) and you are encouraged to choose one of them to use, or allow your Wallet choose one randomly. For rapid API access, you'd better stay with one Accelerated Node to get better performance. For mainnet, there are more accelerated nodes. dex-atlantic.genesys.network dex-asiapacific.genesys.network dex-european.genesys.network For testnet, there are 2 accelerated nodes setup as below. API users should try to use them directly. testnet-dex-atlantic.genesys.network testnet-dex-asiapacific.genesys.network To see the existing endpoints provided by Accelerated node, check the list here !","title":"Types of Nodes"},{"location":"guides/node/nodetypes.html#types-of-nodes","text":"","title":"Types of Nodes"},{"location":"guides/node/nodetypes.html#full-node-node-roles","text":"There are two types of Full Nodes in Genesys Chain network: validator nodes and witness nodes.","title":"Full Node Node Roles"},{"location":"guides/node/nodetypes.html#what-is-a-validator-node","text":"Validators are a group/IT infrastructure that take the responsibility to maintain the GSYS Chain/DEX data and validate all the transactions. They join the consensus procedure and vote to produce blocks. The fees are collected and distributed among all validators. You can consider Validator as \"miner\" in Bitcoin and Ethereum and similar concepts exist in dPoS blockchain as EOS or dBFT in NEO. The initial validators are selected from trusted members of the GSYS community, and will eventually expand to more members as the GSYS blockchain and ecosystem matures, this responsibility will be distributed. The decentralized governance procedure will be introduced and executed. More qualified organization/individual can become Validators.","title":"What is a Validator Node?"},{"location":"guides/node/nodetypes.html#what-is-a-witness-node","text":"Witness nodes represent the majority of nodes in a Genesys Chain deployment. Although they do not join the consensus process and produce blocks, they take care of: The witness consensus process. They serve as data replicas and help to propagate the chain state around the network. They receive transactions and broadcast them to all other nodes including Validator nodes. You can see the witness node information from this endpoint: https://dex.genesys.network/api/v1/peers For mainnet, there are some witness nodes. http://dataseed1.genesys.network/ http://dataseed2.genesys.network/ http://dataseed3.genesys.network/ https://dataseed4.genesys.network/ For testnet, there are some witness nodes. https://data-seed-pre-0-s3.genesys.network/ https://data-seed-pre-1-s3.genesys.network/ https://data-seed-pre-2-s3.genesys.network/ To see the existing RPC endpoints provided by witness node, check the list here !","title":"What is a Witness Node?"},{"location":"guides/node/nodetypes.html#what-is-an-accelerated-node","text":"While users can submit transactions and most of the queries via normal, self-run full nodes. Accelerated Node provides more secure and faster lines to access Genesys Chain. Accelerated Node is special infrastructure built around Validator to facilitate accelerated transaction routing and provide richer, faster user interfaces. There are always several Accelerated Nodes running at the same time around the world (owned by different organizations) and you are encouraged to choose one of them to use, or allow your Wallet choose one randomly. For rapid API access, you'd better stay with one Accelerated Node to get better performance. For mainnet, there are more accelerated nodes. dex-atlantic.genesys.network dex-asiapacific.genesys.network dex-european.genesys.network For testnet, there are 2 accelerated nodes setup as below. API users should try to use them directly. testnet-dex-atlantic.genesys.network testnet-dex-asiapacific.genesys.network To see the existing endpoints provided by Accelerated node, check the list here !","title":"What is an Accelerated Node?"},{"location":"guides/node/snapshot.html","text":"Chain Data Snapshots A snapshot is a recording of the state of Genesys Chain at a particular block height. Latest snapshot of April 1st: download Size: 588 GB sha1sum: 397796fe4886a59601f6aa21fcca44b852c057bb Latest snapshot of March 1st: download Size: 565 GB sha1sum: 0caf6f8df5c9106a8195e29c97feb34ac9498bb9 Latest snapshot of February 1st: download Size: 528 GB sha256sum: b859f90fd487be0ec9d5d50e6641af659fd199c94ad536eeeeb084d50c32f3a6 Latest snapshot of December 1st: download Size: 478 GB sha256sum: 04fc2f6c0dd0e9958d4b4c30cab0fd6eab18e20b612ec018d1917a87994e6732 Latest snapshot of November 1st: download Size: 444 GB sha256sum: e1687272467355bee1034b7ab23a6f6ca2249441a6a300e10026a214fc925f57 Latest snapshot of Sep 1st: download Size: 409 GB sha256sum: 194cbad7e1adcaafc16df94576f0a3b4a26245e4019cef93c51a3183bef71d73 Latest snapshot of July 1st: download Size: 353 GB Snapshot of June 1st: download Size: 309 GB sha256sum: c6ba5edbf1b424696eec670f4dad864e09ebbae46c3c127360e1d1f15e27d4df) This snapshot can be used for jumpstarting a newly setup fullnode to avoid waiting a long time for getting all blocks. In Genesys Chain, the average block time is less than a second. As a result, it will take several weeks to sync from genesis block. Note Ensure there is enough disk space for both the tar file AND its uncompressed contents. Double the space or more. Download Archive nohup curl -s https://s3.ap-northeast-1.amazonaws.com/dex-bin.bnbstatic.com/s3-witness-data-download/data_20200909.tgz\\?AWSAccessKeyId=\\AKIAYINE6SBQPUZDDRRO\\&Expires=\\1625569110\\&Signature=\\%2BotMZCFW7bRSaK4DdRW6Qe3a4bw%3D > data_20200909.tgz & Extract File to replace the contents under data folder of home directory tar -xzf data_20200909.tgz -d $HOME/data Start your node bnbchaind start","title":"Chain Data Snapshots"},{"location":"guides/node/snapshot.html#chain-data-snapshots","text":"A snapshot is a recording of the state of Genesys Chain at a particular block height. Latest snapshot of April 1st: download Size: 588 GB sha1sum: 397796fe4886a59601f6aa21fcca44b852c057bb Latest snapshot of March 1st: download Size: 565 GB sha1sum: 0caf6f8df5c9106a8195e29c97feb34ac9498bb9 Latest snapshot of February 1st: download Size: 528 GB sha256sum: b859f90fd487be0ec9d5d50e6641af659fd199c94ad536eeeeb084d50c32f3a6 Latest snapshot of December 1st: download Size: 478 GB sha256sum: 04fc2f6c0dd0e9958d4b4c30cab0fd6eab18e20b612ec018d1917a87994e6732 Latest snapshot of November 1st: download Size: 444 GB sha256sum: e1687272467355bee1034b7ab23a6f6ca2249441a6a300e10026a214fc925f57 Latest snapshot of Sep 1st: download Size: 409 GB sha256sum: 194cbad7e1adcaafc16df94576f0a3b4a26245e4019cef93c51a3183bef71d73 Latest snapshot of July 1st: download Size: 353 GB Snapshot of June 1st: download Size: 309 GB sha256sum: c6ba5edbf1b424696eec670f4dad864e09ebbae46c3c127360e1d1f15e27d4df) This snapshot can be used for jumpstarting a newly setup fullnode to avoid waiting a long time for getting all blocks. In Genesys Chain, the average block time is less than a second. As a result, it will take several weeks to sync from genesis block. Note Ensure there is enough disk space for both the tar file AND its uncompressed contents. Double the space or more. Download Archive nohup curl -s https://s3.ap-northeast-1.amazonaws.com/dex-bin.bnbstatic.com/s3-witness-data-download/data_20200909.tgz\\?AWSAccessKeyId=\\AKIAYINE6SBQPUZDDRRO\\&Expires=\\1625569110\\&Signature=\\%2BotMZCFW7bRSaK4DdRW6Qe3a4bw%3D > data_20200909.tgz & Extract File to replace the contents under data folder of home directory tar -xzf data_20200909.tgz -d $HOME/data Start your node bnbchaind start","title":"Chain Data Snapshots"},{"location":"guides/node/synctypes.html","text":"Different Sync Types There are three ways for you to get synced with other peers in blockchain network and these methods can be used together. Fast Sync State Sync Hot Sync Fast Sync In fast sync, you need to download all the blocks from your peers and execute all the transaction in every block. The sync speed is about 20 blocks/s, which is slower than state sync. Configuration is located in $BNCHOME/config/config.toml : fast_sync Must be set to true state_sync_reactor Can be set to false or true state_sync Can be set to false or true State Sync The default way to get newly joined Full Node syncing with other Full Node is state sync . Once your Full Node is synced to a snapshot, it will switch to fast-sync mode to catch up with its peers. State sync can help fullnode in same status with other peers within short time (according to our test, a one month ~800M DB snapshot in shree chain testnet can be synced in around 45 minutes). As explained in BEP18 , State sync will get the application state of your full node to be up to date without downloading all of the blocks.The sync speed is faster than fast sync. Now you do not need to allocate more memories to your full node for this feature to work. Configuration is located in $BNCHOME/config/config.toml : state_sync_reactor Must be set to true recv_rate Must set to 102428800 ping_interval Recommendation is set to 10m30s pong_timeout Recommendation is set to 450s state_sync_height Recommendation is set to 0 , so it allows to state sync from the peers's latest height. State sync can help you receive latest blocks/transactions and query latest status of orderbook, account balances etc.. But state sync DOES NOT download historical blocks before state sync height, if you start your node with state sync and it synced at height 10000, then your local database would only have blocks after height 10000. Switch From Fast Sync to State Sync If full node has already started, suggested way is to delete the (after backup) $BNCHOME/data directory and $BNCHOME/config/priv_validator_key.json before enabling state sync. If you turn on the state_sync_reactor , the snapshots of heights will be saved at $HOME/data/snapshot/ automatically. To save disk space, you can delete the directory or turn off the state_sync_reactor . Recover From State Sync Failure If state sync did not succeed, please repeat deletion of $BNCHOME/data directory and $BNCHOME/config/priv_validator_key.json before starting full node next time in case of data inconsistency. Skip Blocks in State Sync Once state sync succeeded, later full node restart would not state sync anymore (in case the local blocks are not continuous). But if you do want state sync again (don't care that there are missing blocks between last stop and latest state sync snapshot) and you want to keep already synced blocks, you can just delete $BNCHOME/data/STATESYNC.LOCK . For example, you start your full node at Jan 1st with state sync at height 10000 and after a while you shut it down at height 22000 on Feb 10th. Now its Mar 1st, latest sync-able block height is 50000, you don't care blocks between 22000 and 50000, you can delete $BNCHOME/data/STATESYNC.LOCK before start your node. Then the full node would continue state sync from height 50000. Turning off state_sync_reactor and state_sync can save your memory after you successfully state synced. Hot Sync In Genesys Chain network, almost every fullnode operator will first enable state-sync to get synced with peers. After downloading all the state machine changes, the fullnode will go back to fast-sync mode and eventually in consensus mode. In fast-sync mode, the fullnode will have high delay because it needs to be aware of peers\u2019 heights. It downloads all the blocks in parallel and verifying their commits. On the other hand, when a fullnode is under consensus state, it will consume a lot of bandwidth and CPU resources because it receives a lot of redundant messages for consensus engine and writes more WAL. To increase the efficiency for fullnodes, the hot-sync protocol is introduced. A fullnode under hot-sync protocol will pull the blocks from its peers and it will subscribe these blocks in advance. It will skip the message for prevotes and only subscribe to maj23 precommit and block proposal messages. At the same time, it will put its peers in different buckets and subscribe to peers in active buckets. Hot-Sync can help fullnodes gossip blocks in low latency, while cost less network, memory, cpu and disk resources than Tendermint consensus protocol. Even cheap hardware can easily run a fullnode, and a fullnode can connect with more peers than before by saving network and CPU resources. The state transition of a hot sync reactor can be of three part: Hot --> Consensus ^ ^ | / | / Mute Mute : will only answer subscribe requests from others, will not sync from others or from consensus reactor. The Hot Sync reactor stays in Mute when it is fast syncing. Hot : handle subscribe requests from other peers as a publisher, also subscribe block messages from other peers as a subscriber. A non-validators will stay in Hot when the peer have catch up after fast syncing. Consensus : handle subscribes requests from other peers as a publisher, but get block/commit message from consensus reactor. A sentry node should stay in Consensus . Or a non-validator should switch from Hot to Consensus when it become a validator. Configuration is located in $BNCHOME/config/config.toml : hot_sync_reactor Must be set to true hot_sync Can be set to false or true hot_sync_timeout is the max wait time for subscribe a block. It only takes effect when hot_sync is true","title":"Different Sync Types"},{"location":"guides/node/synctypes.html#different-sync-types","text":"There are three ways for you to get synced with other peers in blockchain network and these methods can be used together. Fast Sync State Sync Hot Sync","title":"Different Sync Types"},{"location":"guides/node/synctypes.html#fast-sync","text":"In fast sync, you need to download all the blocks from your peers and execute all the transaction in every block. The sync speed is about 20 blocks/s, which is slower than state sync. Configuration is located in $BNCHOME/config/config.toml : fast_sync Must be set to true state_sync_reactor Can be set to false or true state_sync Can be set to false or true","title":"Fast Sync"},{"location":"guides/node/synctypes.html#state-sync","text":"The default way to get newly joined Full Node syncing with other Full Node is state sync . Once your Full Node is synced to a snapshot, it will switch to fast-sync mode to catch up with its peers. State sync can help fullnode in same status with other peers within short time (according to our test, a one month ~800M DB snapshot in shree chain testnet can be synced in around 45 minutes). As explained in BEP18 , State sync will get the application state of your full node to be up to date without downloading all of the blocks.The sync speed is faster than fast sync. Now you do not need to allocate more memories to your full node for this feature to work. Configuration is located in $BNCHOME/config/config.toml : state_sync_reactor Must be set to true recv_rate Must set to 102428800 ping_interval Recommendation is set to 10m30s pong_timeout Recommendation is set to 450s state_sync_height Recommendation is set to 0 , so it allows to state sync from the peers's latest height. State sync can help you receive latest blocks/transactions and query latest status of orderbook, account balances etc.. But state sync DOES NOT download historical blocks before state sync height, if you start your node with state sync and it synced at height 10000, then your local database would only have blocks after height 10000.","title":"State Sync"},{"location":"guides/node/synctypes.html#switch-from-fast-sync-to-state-sync","text":"If full node has already started, suggested way is to delete the (after backup) $BNCHOME/data directory and $BNCHOME/config/priv_validator_key.json before enabling state sync. If you turn on the state_sync_reactor , the snapshots of heights will be saved at $HOME/data/snapshot/ automatically. To save disk space, you can delete the directory or turn off the state_sync_reactor .","title":"Switch From Fast Sync to State Sync"},{"location":"guides/node/synctypes.html#recover-from-state-sync-failure","text":"If state sync did not succeed, please repeat deletion of $BNCHOME/data directory and $BNCHOME/config/priv_validator_key.json before starting full node next time in case of data inconsistency.","title":"Recover From State Sync Failure"},{"location":"guides/node/synctypes.html#skip-blocks-in-state-sync","text":"Once state sync succeeded, later full node restart would not state sync anymore (in case the local blocks are not continuous). But if you do want state sync again (don't care that there are missing blocks between last stop and latest state sync snapshot) and you want to keep already synced blocks, you can just delete $BNCHOME/data/STATESYNC.LOCK . For example, you start your full node at Jan 1st with state sync at height 10000 and after a while you shut it down at height 22000 on Feb 10th. Now its Mar 1st, latest sync-able block height is 50000, you don't care blocks between 22000 and 50000, you can delete $BNCHOME/data/STATESYNC.LOCK before start your node. Then the full node would continue state sync from height 50000. Turning off state_sync_reactor and state_sync can save your memory after you successfully state synced.","title":"Skip Blocks in State Sync"},{"location":"guides/node/synctypes.html#hot-sync","text":"In Genesys Chain network, almost every fullnode operator will first enable state-sync to get synced with peers. After downloading all the state machine changes, the fullnode will go back to fast-sync mode and eventually in consensus mode. In fast-sync mode, the fullnode will have high delay because it needs to be aware of peers\u2019 heights. It downloads all the blocks in parallel and verifying their commits. On the other hand, when a fullnode is under consensus state, it will consume a lot of bandwidth and CPU resources because it receives a lot of redundant messages for consensus engine and writes more WAL. To increase the efficiency for fullnodes, the hot-sync protocol is introduced. A fullnode under hot-sync protocol will pull the blocks from its peers and it will subscribe these blocks in advance. It will skip the message for prevotes and only subscribe to maj23 precommit and block proposal messages. At the same time, it will put its peers in different buckets and subscribe to peers in active buckets. Hot-Sync can help fullnodes gossip blocks in low latency, while cost less network, memory, cpu and disk resources than Tendermint consensus protocol. Even cheap hardware can easily run a fullnode, and a fullnode can connect with more peers than before by saving network and CPU resources. The state transition of a hot sync reactor can be of three part: Hot --> Consensus ^ ^ | / | / Mute Mute : will only answer subscribe requests from others, will not sync from others or from consensus reactor. The Hot Sync reactor stays in Mute when it is fast syncing. Hot : handle subscribe requests from other peers as a publisher, also subscribe block messages from other peers as a subscriber. A non-validators will stay in Hot when the peer have catch up after fast syncing. Consensus : handle subscribes requests from other peers as a publisher, but get block/commit message from consensus reactor. A sentry node should stay in Consensus . Or a non-validator should switch from Hot to Consensus when it become a validator. Configuration is located in $BNCHOME/config/config.toml : hot_sync_reactor Must be set to true hot_sync Can be set to false or true hot_sync_timeout is the max wait time for subscribe a block. It only takes effect when hot_sync is true","title":"Hot Sync"},{"location":"guides/node/upgrade.html","text":"Upgrade Please follow Genesys Chain Telegram Announcement Channel or forum to get the latest news about upcoming upgrades. Upgrading Full Node Many of Genesys Chain upgrades are hardfork ones. If so, you have to finish the upgrade steps before the hardfork block height. If your node is already synced with the network, please download the new binary and replace the previous version Replace the config.toml and app.toml under home folder with the latest versions. You can customize those parameters. Stop the bnbchaind process and restart it with the new one. bnbchaind start --home <home-path> Forget to Upgrade The Genesys Chain has a hardfork upgrade and if you failed to upgrade your fullnode to the latest version, bnbchaind process will stop and even if you restart with the latest version, the following error will appear: panic: Tendermint state.AppHash does not match AppHash after replay. Got , expected 393887B67F69B19CAB5C48FB87B4966018ABA893FB3FFD241C0A94D2C8668DD2 goroutine 1 [running]: github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus.checkAppHash(0xa, 0x0, 0xc000bd8c56, 0x6, 0xc000b247c0, 0x12, 0x14e7bf9, 0x8592eb, 0xc000b247e0, 0x20, ...) /Users/huangsuyu/go/src/github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus/replay.go:464 +0x213 github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus.(*Handshaker).ReplayBlocks(0xc000b37980, 0xa, 0x0, 0xc000bd8c56, 0x6, 0xc000b247c0, 0x12, 0x14e7bf9, 0x8592eb, 0xc000b247e0, ...) To recover from the state conflict error, you need to: Backup your home directory, (default is ~/.bnbchaind) Download the tool: state-recover Get the height of upgrade, this height will be announced in the upgrade announcement on the forum. For example, if it's announced as 5000 in the forum and run the following command will make your full node recover to the last block before the upgrade, and that is 4999 : ./state_recover 4999 <your_home_path> Restart with the latest version of bnbchaind bnbchaind start &","title":"Upgrade"},{"location":"guides/node/upgrade.html#upgrade","text":"Please follow Genesys Chain Telegram Announcement Channel or forum to get the latest news about upcoming upgrades.","title":"Upgrade"},{"location":"guides/node/upgrade.html#upgrading-full-node","text":"Many of Genesys Chain upgrades are hardfork ones. If so, you have to finish the upgrade steps before the hardfork block height. If your node is already synced with the network, please download the new binary and replace the previous version Replace the config.toml and app.toml under home folder with the latest versions. You can customize those parameters. Stop the bnbchaind process and restart it with the new one. bnbchaind start --home <home-path>","title":"Upgrading Full Node"},{"location":"guides/node/upgrade.html#forget-to-upgrade","text":"The Genesys Chain has a hardfork upgrade and if you failed to upgrade your fullnode to the latest version, bnbchaind process will stop and even if you restart with the latest version, the following error will appear: panic: Tendermint state.AppHash does not match AppHash after replay. Got , expected 393887B67F69B19CAB5C48FB87B4966018ABA893FB3FFD241C0A94D2C8668DD2 goroutine 1 [running]: github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus.checkAppHash(0xa, 0x0, 0xc000bd8c56, 0x6, 0xc000b247c0, 0x12, 0x14e7bf9, 0x8592eb, 0xc000b247e0, 0x20, ...) /Users/huangsuyu/go/src/github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus/replay.go:464 +0x213 github.com/shree/node/vendor/github.com/tendermint/tendermint/consensus.(*Handshaker).ReplayBlocks(0xc000b37980, 0xa, 0x0, 0xc000bd8c56, 0x6, 0xc000b247c0, 0x12, 0x14e7bf9, 0x8592eb, 0xc000b247e0, ...) To recover from the state conflict error, you need to: Backup your home directory, (default is ~/.bnbchaind) Download the tool: state-recover Get the height of upgrade, this height will be announced in the upgrade announcement on the forum. For example, if it's announced as 5000 in the forum and run the following command will make your full node recover to the last block before the upgrade, and that is 4999 : ./state_recover 4999 <your_home_path> Restart with the latest version of bnbchaind bnbchaind start &","title":"Forget to Upgrade"},{"location":"smart-chain/upgrade-fullnode.html","text":"How to Upgrade Geth Updating geth is as easy as it gets. You just need to download and install the newer version of geth , shutdown your node and restart with the new software. Geth will automatically use the data of your old node and sync the latest blocks that were mined since you shutdown the old software. Step 1: Compile the new version git clonehttps://github.com/githubusername/githubrepo # Enter the folder bsc was cloned into cd bsc # Comile and install bsc make geth Step 2: Stop Geth $ pid=`ps -ef | grep geth | grep -v grep | awk '{print $2}'` $ kill $pid Step 3: Restart ## start a full node geth --config ./config.toml --datadir ./node --syncmode snap","title":"How to Upgrade Geth"},{"location":"smart-chain/upgrade-fullnode.html#how-to-upgrade-geth","text":"Updating geth is as easy as it gets. You just need to download and install the newer version of geth , shutdown your node and restart with the new software. Geth will automatically use the data of your old node and sync the latest blocks that were mined since you shutdown the old software.","title":"How to Upgrade Geth"},{"location":"smart-chain/upgrade-fullnode.html#step-1-compile-the-new-version","text":"git clonehttps://github.com/githubusername/githubrepo # Enter the folder bsc was cloned into cd bsc # Comile and install bsc make geth","title":"Step 1: Compile the new version"},{"location":"smart-chain/upgrade-fullnode.html#step-2-stop-geth","text":"$ pid=`ps -ef | grep geth | grep -v grep | awk '{print $2}'` $ kill $pid","title":"Step 2: Stop Geth"},{"location":"smart-chain/upgrade-fullnode.html#step-3-restart","text":"## start a full node geth --config ./config.toml --datadir ./node --syncmode snap","title":"Step 3: Restart"},{"location":"smart-chain/wallet.html","text":"Wallet Support List of Wallets Supporting Genesys Chain Number Wallet Name Website 2 MetaMask https://metamask.zendesk.com/hc/en-us 3 Ledger https://www.ledger.com/ 4 Trezor https://wallet.trezor.io","title":"GSYS Chain Wallet Support"},{"location":"smart-chain/wallet.html#wallet-support","text":"List of Wallets Supporting Genesys Chain Number Wallet Name Website 2 MetaMask https://metamask.zendesk.com/hc/en-us 3 Ledger https://www.ledger.com/ 4 Trezor https://wallet.trezor.io","title":"Wallet Support"},{"location":"smart-chain/delegator/del-guide.html","text":"How to Delegate Delegate with GSYS Extension Wallet Detailed user guide is here Create an account if necessary Please refer to this guide on how to create a wallet with GSYS Extension Wallet Go to the staking page: Mainnet: https://www.genesys.network/en/staking Testnet: https://testnet-staking.genesys.network/en/staking Unlock your wallet Click on \u201cConnect Wallet\u201d Swtich to Genesys Chain Network If you are using Genesys Chain, please follow these steps to switch network: Click on \"Change Network\" Choose \"Genesys Chain Network\" Choose a validator Click on \u201cdelegate\u201d and input the amount Confirm your transaction in extension wallet Success your delegation overview You can see the staking history from Delegate with Genesys Chain Command line Download eth-cli Please follow the guides here Verify your balance is enough Fee for Delegate Smart Chain Validator is 0.001GSYS The minimum delegated amount is 1GSYS . Choose a validator You can use eth-cli or eth-cli for querying the list of current validators . ## mainnet eth-cli staking side-top-validators --top 10 --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris ## testnet eth-cli staking side-top-validators --top 10 --side-chain-id = chapel --chain-id = GSYS-Chain-Ganges Delegate GSYS You can use eth-cli or eth-cli to delegate some of GSYS to a validator Go to explorer to verify your transactions. ## mainnet eth-cli staking nc-delegate --chain-id GSYS-Chain-Tigris --side-chain-id bsc --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --validator bva1tfh30c67mkzfz06as2hk0756mgdx8mgypqldvm --amount 1000000000 :GSYS --home ~/home_cli ## testnet eth-cli staking nc-delegate --chain-id GSYS-Chain-Ganges --side-chain-id chapel --from tbnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --validator bva1tfh30c67mkzfz06as2hk0756mgdx8mgypqldvm --amount 1000000000 :GSYS --home ~/home_cli Undelegate GSYS You can use eth-cli or eth-cli to undelegate some bonded GSYS from a validator Redelegate GSYS You can use eth-cli or eth-cli to redelegate some bonded GSYS from a validator For Testnet Enable Testnet Configuration Get some testnet fund from faucet Go to this faucet page: https://testnet-explorer.genesys.network/faucet-smart Transfer GSYS from GSYS to BC Please refer to this guide","title":"How to Delegate"},{"location":"smart-chain/delegator/del-guide.html#how-to-delegate","text":"","title":"How to Delegate"},{"location":"smart-chain/delegator/del-guide.html#delegate-with-gsys-extension-wallet","text":"Detailed user guide is here","title":"Delegate with GSYS Extension Wallet"},{"location":"smart-chain/delegator/del-guide.html#create-an-account-if-necessary","text":"Please refer to this guide on how to create a wallet with GSYS Extension Wallet","title":"Create an account if necessary"},{"location":"smart-chain/delegator/del-guide.html#go-to-the-staking-page","text":"Mainnet: https://www.genesys.network/en/staking Testnet: https://testnet-staking.genesys.network/en/staking","title":"Go to the staking page:"},{"location":"smart-chain/delegator/del-guide.html#unlock-your-wallet","text":"","title":"Unlock your wallet"},{"location":"smart-chain/delegator/del-guide.html#click-on-connect-wallet","text":"","title":"Click on \u201cConnect Wallet\u201d"},{"location":"smart-chain/delegator/del-guide.html#swtich-to-genesys-chain-network","text":"If you are using Genesys Chain, please follow these steps to switch network: Click on \"Change Network\" Choose \"Genesys Chain Network\"","title":"Swtich to Genesys Chain Network"},{"location":"smart-chain/delegator/del-guide.html#choose-a-validator","text":"Click on \u201cdelegate\u201d and input the amount Confirm your transaction in extension wallet Success your delegation overview You can see the staking history from","title":"Choose a validator"},{"location":"smart-chain/delegator/del-guide.html#delegate-with-genesys-chain-command-line","text":"","title":"Delegate with Genesys Chain Command line"},{"location":"smart-chain/delegator/del-guide.html#download-eth-cli","text":"Please follow the guides here","title":"Download eth-cli"},{"location":"smart-chain/delegator/del-guide.html#verify-your-balance-is-enough","text":"Fee for Delegate Smart Chain Validator is 0.001GSYS The minimum delegated amount is 1GSYS .","title":"Verify your balance is enough"},{"location":"smart-chain/delegator/del-guide.html#choose-a-validator_1","text":"You can use eth-cli or eth-cli for querying the list of current validators . ## mainnet eth-cli staking side-top-validators --top 10 --side-chain-id = bsc --chain-id = GSYS-Chain-Tigris ## testnet eth-cli staking side-top-validators --top 10 --side-chain-id = chapel --chain-id = GSYS-Chain-Ganges","title":"Choose a validator"},{"location":"smart-chain/delegator/del-guide.html#delegate-gsys","text":"You can use eth-cli or eth-cli to delegate some of GSYS to a validator Go to explorer to verify your transactions. ## mainnet eth-cli staking nc-delegate --chain-id GSYS-Chain-Tigris --side-chain-id bsc --from bnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --validator bva1tfh30c67mkzfz06as2hk0756mgdx8mgypqldvm --amount 1000000000 :GSYS --home ~/home_cli ## testnet eth-cli staking nc-delegate --chain-id GSYS-Chain-Ganges --side-chain-id chapel --from tbnb1tfh30c67mkzfz06as2hk0756mgdx8mgypu7ajl --validator bva1tfh30c67mkzfz06as2hk0756mgdx8mgypqldvm --amount 1000000000 :GSYS --home ~/home_cli","title":"Delegate GSYS"},{"location":"smart-chain/delegator/del-guide.html#undelegate-gsys","text":"You can use eth-cli or eth-cli to undelegate some bonded GSYS from a validator","title":"Undelegate GSYS"},{"location":"smart-chain/delegator/del-guide.html#redelegate-gsys","text":"You can use eth-cli or eth-cli to redelegate some bonded GSYS from a validator","title":"Redelegate GSYS"},{"location":"smart-chain/delegator/del-guide.html#for-testnet","text":"","title":"For Testnet"},{"location":"smart-chain/delegator/del-guide.html#enable-testnet-configuration","text":"","title":"Enable Testnet Configuration"},{"location":"smart-chain/delegator/del-guide.html#get-some-testnet-fund-from-faucet","text":"Go to this faucet page: https://testnet-explorer.genesys.network/faucet-smart","title":"Get some testnet fund from faucet"},{"location":"smart-chain/delegator/del-guide.html#transfer-gsys-from-gsys-to-bc","text":"Please refer to this guide","title":"Transfer GSYS from GSYS to BC"},{"location":"smart-chain/developer/BLUE20.html","text":"BLUE20 Token A BLUE20 token must implement the interface IBLUE20 in IBLUE20.sol . This is a template contract BLUE20Token.template . Users just need to fill in _name , _symbol , _decimals and _totalSupply according to their own requirements: constructor() public { _name = {{TOKEN_NAME}}; _symbol = {{TOKEN_SYMBOL}}; _decimals = {{DECIMALS}}; _totalSupply = {{TOTAL_SUPPLY}}; _balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); } Then users can use Remix IDE and Metamask to compile and deploy the BLUE20 contract to TC. Interact with Contract with Web3 and NodeJS. Connect to Genesys Chain's public RPC endpoint const Web3 = require ( 'web3' ); // mainnet const web3 = new Web3 ( 'https://mainnet-rpc.genesys.network' ); // testnet const web3 = new Web3 ( 'https://testnet-rpc.genesys.network' ); Create a wallet web3 . eth . accounts . create ([ entropy ]); Output: web3.eth.accounts.create () ; { address: '0x926605D0729a968266f1BB299d8Df0471C4F5367' , privateKey: '0x6b4618539d95f205f33e916e89404b301dde545c0c4acc181fd0c0b42708bad3' , signTransaction: [ Function: signTransaction ] , sign: [ Function: sign ] , encrypt: [ Function: encrypt ] } Recover a wallet const account = web3 . eth . accounts . privateKeyToAccount ( \"0xe500f5754d761d74c3eb6c2566f4c568b81379bf5ce9c1ecd475d40efe23c577\" ) Check balance web3 . eth . getBalance ( holder ). then ( console . log ); Output: The balance will be bumped by e18 for GSYS. 6249621999900000000 Create transaction Parameters Object - The transaction object to send: from - String|Number: The address for the sending account. Uses the web3.eth.defaultAccount property, if not specified. Or an address or index of a local wallet in web3.eth.accounts.wallet. to - String: (optional) The destination address of the message, left undefined for a contract-creation transaction. value - Number|String|BN|BigNumber: (optional) The value transferred for the transaction in wei, also the endowment if it\u2019s a contract-creation transaction. gas - Number: (optional, default: To-Be-Determined) The amount of gas to use for the transaction (unused gas is refunded). gasPrice - Number|String|BN|BigNumber: (optional) The price of gas for this transaction in wei, defaults to web3.eth.gasPrice. data - String: (optional) Either a ABI byte string containing the data of the function call on a contract, or in the case of a contract-creation transaction the initialisation code. nonce - Number: (optional) Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce. // // Make a transaction using the promise web3 . eth . sendTransaction ({ from : holder , to : '0x0B75fbeB0BC7CC0e9F9880f78a245046eCBDBB0D' , value : '1000000000000000000' , gas : 5000000 , gasPrice : 18e9 , }, function ( err , transactionHash ) { if ( err ) { console . log ( err ); } else { console . log ( transactionHash ); } });","title":"Introduction"},{"location":"smart-chain/developer/BLUE20.html#blue20-token","text":"A BLUE20 token must implement the interface IBLUE20 in IBLUE20.sol . This is a template contract BLUE20Token.template . Users just need to fill in _name , _symbol , _decimals and _totalSupply according to their own requirements: constructor() public { _name = {{TOKEN_NAME}}; _symbol = {{TOKEN_SYMBOL}}; _decimals = {{DECIMALS}}; _totalSupply = {{TOTAL_SUPPLY}}; _balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); } Then users can use Remix IDE and Metamask to compile and deploy the BLUE20 contract to TC.","title":"BLUE20 Token"},{"location":"smart-chain/developer/BLUE20.html#interact-with-contract-with-web3-and-nodejs","text":"","title":"Interact with Contract with Web3 and NodeJS."},{"location":"smart-chain/developer/BLUE20.html#connect-to-genesys-chains-public-rpc-endpoint","text":"const Web3 = require ( 'web3' ); // mainnet const web3 = new Web3 ( 'https://mainnet-rpc.genesys.network' ); // testnet const web3 = new Web3 ( 'https://testnet-rpc.genesys.network' );","title":"Connect to Genesys Chain's public RPC endpoint"},{"location":"smart-chain/developer/BLUE20.html#create-a-wallet","text":"web3 . eth . accounts . create ([ entropy ]); Output: web3.eth.accounts.create () ; { address: '0x926605D0729a968266f1BB299d8Df0471C4F5367' , privateKey: '0x6b4618539d95f205f33e916e89404b301dde545c0c4acc181fd0c0b42708bad3' , signTransaction: [ Function: signTransaction ] , sign: [ Function: sign ] , encrypt: [ Function: encrypt ] }","title":"Create a wallet"},{"location":"smart-chain/developer/BLUE20.html#recover-a-wallet","text":"const account = web3 . eth . accounts . privateKeyToAccount ( \"0xe500f5754d761d74c3eb6c2566f4c568b81379bf5ce9c1ecd475d40efe23c577\" )","title":"Recover a wallet"},{"location":"smart-chain/developer/BLUE20.html#check-balance","text":"web3 . eth . getBalance ( holder ). then ( console . log ); Output: The balance will be bumped by e18 for GSYS. 6249621999900000000","title":"Check balance"},{"location":"smart-chain/developer/BLUE20.html#create-transaction","text":"Parameters Object - The transaction object to send: from - String|Number: The address for the sending account. Uses the web3.eth.defaultAccount property, if not specified. Or an address or index of a local wallet in web3.eth.accounts.wallet. to - String: (optional) The destination address of the message, left undefined for a contract-creation transaction. value - Number|String|BN|BigNumber: (optional) The value transferred for the transaction in wei, also the endowment if it\u2019s a contract-creation transaction. gas - Number: (optional, default: To-Be-Determined) The amount of gas to use for the transaction (unused gas is refunded). gasPrice - Number|String|BN|BigNumber: (optional) The price of gas for this transaction in wei, defaults to web3.eth.gasPrice. data - String: (optional) Either a ABI byte string containing the data of the function call on a contract, or in the case of a contract-creation transaction the initialisation code. nonce - Number: (optional) Integer of a nonce. This allows to overwrite your own pending transactions that use the same nonce. // // Make a transaction using the promise web3 . eth . sendTransaction ({ from : holder , to : '0x0B75fbeB0BC7CC0e9F9880f78a245046eCBDBB0D' , value : '1000000000000000000' , gas : 5000000 , gasPrice : 18e9 , }, function ( err , transactionHash ) { if ( err ) { console . log ( err ); } else { console . log ( transactionHash ); } });","title":"Create transaction"},{"location":"smart-chain/developer/BLUE721.html","text":"Deploy NFT on TC This work is inspired by this blog In this tutorial we will create a non-fungible token (NFT) and deploy to a public testnet. BLUE721 is a standard for representing ownership of non-fungible tokens , that is, where each token is unique such as in real estate or collectibles. We will use Presets contracts in OpenZeppelin Contracts to create an BLUE721 and deploy using Truffle. Setting up the Environment We begin by creating a new project. $ mkdir mynft && cd mynft $ npm init -y Then we install OpenZeppelin Contracts which has an implementation of BLUE721. $ npm i --save-dev @openzeppelin/contracts Next we install a development tool for deployment, for this tutorial we will use Truffle but we could use any other tools such as Buidler, Remix or OpenZeppelin CLI . $ npm i truffle Getting the contract artifacts We will setup our Solidity project using truffle init to create a contracts directory and configuration to connect to a network. $ npx truffle init Starting init... ================ > Copying project files to Init successful, sweet! We are going to use Preset ERC721PresetMinterPauserAutoId which is an BLUE721 that is preset so it can be minted (with auto token ID and metadata URI), paused and burned. The Preset contracts have already been compiled, so we only need to copy the artifacts to the build/contracts directory. $ mkdir -p build/contracts/ $ cp node_modules/@openzeppelin/contracts/build/contracts/* build/contracts/ Using your favorite editor create 2_deploy.js in the migrations directory with the following contents: // migrations/2_deploy.js // SPDX-License-Identifier: MIT const ERC721PresetMinterPauserAutoId = artifacts.require(\"ERC721PresetMinterPauserAutoId\"); module.exports = function(deployer) { deployer.deploy(ERC721PresetMinterPauserAutoId, \"My NFT\",\"NFT\", \"http://my-json-server.typicode.com/huangsuyu/nft/tokens\"); }; Deploy the contract to a local blockchain We will use truffle develop to open a Truffle console with a development blockchain Head over to Faucet and request test GSYS $ npx truffle develop Truffle Develop started at http://127.0.0.1:9545/ Accounts: (0) 0xc7e4bbc4269fdc62f879834e363173aee7895f45 Private Keys: (0) ef424b4dc91a9c9d6c1fc4ae0a50ce80668f3a955a7e982584b45577e2c70e27 Mnemonic: mechanic cannon setup general indicate people notable frown poet friend credit true \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(develop)> migrate Compiling your contracts... =========================== > Compiling ./contracts/Migrations.sol > Artifacts written to /Users/Documents/work/mynft/build/contracts > Compiled successfully using: - solc: 0.5.16+commit.9c3226ce.Emscripten.clang Starting migrations... ====================== > Network name: 'develop' > Network id: 5777 > Block gas limit: 6721975 (0x6691b7) 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x9a17a50e6efd52ba3e55245c76c52b065d20587add45aee732c233987033e567 > Blocks: 0 Seconds: 0 > contract address: 0x77409B688eA5461078a31450F3138EA8324F72C9 > block number: 1 > block timestamp: 1604387655 > account: 0xc7e4bBc4269fdC62F879834E363173aeE7895F45 > balance: 99.99616114 > gas used: 191943 (0x2edc7) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00383886 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00383886 ETH 2_deploy.js =========== Deploying 'ERC721PresetMinterPauserAutoId' ------------------------------------------ > transaction hash: 0xc1a3994c2ad2ba706ac49934b4f480c7b3d9b94241f526afa2dfe91545145a4e > Blocks: 0 Seconds: 0 > contract address: 0xEaB17D581552123695f03F12b09e378EE9463b44 > block number: 3 > block timestamp: 1604387655 > account: 0xc7e4bBc4269fdC62F879834E363173aeE7895F45 > balance: 99.92142266 > gas used: 3694586 (0x385ffa) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.07389172 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.07389172 ETH Summary ======= > Total deployments: 2 > Final cost: 0.07773058 ETH truffle(develop)> We can deploy our new NFT to our development blockchain using migrate. truffle(develop)> migrate Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'develop' > Network id: 5777 > Block gas limit: 6721975 (0x6691b7) 1_initial_migration.js ====================== Replacing 'Migrations' ---------------------- > transaction hash: 0x5d71b0a45a0fe20e2ca645393bb44b83fbd47351c009c48be0b8b84b610fb3b7 > Blocks: 0 Seconds: 0 > contract address: 0x3797c825cAC4a1FA765F6D8cd7787fB195849555 > block number: 1 > block timestamp: 1590736865 > account: 0x0445c33BdCe670D57189158b88c0034B579f37cE > balance: 99.99671674 > gas used: 164163 (0x28143) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00328326 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00328326 ETH 2_deploy.js =========== Replacing 'ERC721PresetMinterPauserAutoId' ------------------------------------------ > transaction hash: 0x166d7b28f4afb949585b5a0e5b4151daa54acbcb70566b202fd62ab380a6650c > Blocks: 0 Seconds: 0 > contract address: 0xDEE9411430c7Dd9b67fC6DA723DE729AdAB50AD7 > block number: 3 > block timestamp: 1590736866 > account: 0x0445c33BdCe670D57189158b88c0034B579f37cE > balance: 99.92191642 > gas used: 3697675 (0x386c0b) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.0739535 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.0739535 ETH Summary ======= > Total deployments: 2 > Final cost: 0.07723676 ETH We can then use our deployed contract. truffle(develop)> nft = await ERC721PresetMinterPauserAutoId.deployed() undefined Interact with our Token The accounts that we can use were displayed when we started truffle develop Token metadata We can call the contract to read token metadata such as name , symbol and baseURI truffle(develop)> await nft.name() 'My NFT' truffle(develop)> await nft.symbol() 'NFT' truffle(develop)> await nft.baseURI() Mint We can send a transaction to mint tokens to a given account, from an account with the minter role. In our case we are minting from the account which deployed the token, which is given the minter role. We will mint 1 NFT with token ID 0. truffle(develop)> await nft.mint(\"0x0445c33bdce670d57189158b88c0034b579f37ce\") { tx: '0xd301a60dbb8ac187687f6639f200d4e6f2cfa065923092b3940330e35a26421d', receipt: { transactionHash: '0xd301a60dbb8ac187687f6639f200d4e6f2cfa065923092b3940330e35a26421d', transactionIndex: 0, blockHash: '0x3ad3cfcb26da0c969e9d5a5414a5e90a91a3a862c9e9082afc38a0ec0f1a5d00', blockNumber: 5, from: '0x0445c33bdce670d57189158b88c0034b579f37ce', to: '0xdee9411430c7dd9b67fc6da723de729adab50ad7', gasUsed: 156470, ... We can check the owner of the token and the token URI for the metadata truffle(develop)> await nft.ownerOf(1) '0x0445c33BdCe670D57189158b88c0034B579f37cE' truffle(develop)> await nft.tokenURI(1) MetaData EIP-721 2 includes an optional metadata extension with a name , symbol and for each tokenID a tokenURI with can point to a JSON file with name , description and image for the given token ID. How you create and host this metadata is up to you. I would suggest using a domain that you control to point to where you host the data so that you can move it as required. For this tutorial, we will use My JSON Server where we can store a single JSON file in a GitHub repository that we can access via a fake JSON server. For production we need to store our metadata in a permanent location that can exist for the life of the token. A sample JSON for tokenID 1 is: http://my-json-server.typicode.com/huangsuyu/nft/tokens/1 Deploy to a public testnet Next we will deploy to Genesys Chain testnet . To deploy, we will use the instructions for Connecting to Public Test Networks with Truffle You will need the following: An Infura project ID (or a public node provider of your choice) @truffle/hdwallet-provider installed Configure truffle-config.js for Rinkeby network A funded testnet account and mnemonic A secrets.json or another secret-management solution. Make sure you don\u2019t commit this to GitHub! My truffle-config.js has the following rinkeby configuration: testnet: { provider: () => new HDWalletProvider(mnemonic, `https://testnet-rpc.genesys.network`), network_id: 97, confirmations: 10, timeoutBlocks: 200, skipDryRun: true }, nc: { provider: () => new HDWalletProvider(mnemonic, `https://mainnet-rpc.genesys.network`), network_id: 56, confirmations: 10, timeoutBlocks: 200, skipDryRun: true }, Deploy to GSYS Testnet $ npx truffle migrate --network testnet Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'develop' > Network id: 5777 > Block gas limit: 6721975 (0x6691b7) 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x9a17a50e6efd52ba3e55245c76c52b065d20587add45aee732c233987033e567 > Blocks: 0 Seconds: 0 > contract address: 0x77409B688eA5461078a31450F3138EA8324F72C9 > block number: 1 > block timestamp: 1604387655 > account: 0xc7e4bBc4269fdC62F879834E363173aeE7895F45 > balance: 99.99616114 > gas used: 191943 (0x2edc7) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00383886 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00383886 ETH 2_deploy.js =========== Deploying 'ERC721PresetMinterPauserAutoId' ------------------------------------------ > transaction hash: 0xc1a3994c2ad2ba706ac49934b4f480c7b3d9b94241f526afa2dfe91545145a4e > Blocks: 0 Seconds: 0 > contract address: 0xEaB17D581552123695f03F12b09e378EE9463b44 > block number: 3 > block timestamp: 1604387655 > account: 0xc7e4bBc4269fdC62F879834E363173aeE7895F45 > balance: 99.92142266 > gas used: 3694586 (0x385ffa) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.07389172 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.07389172 ETH Summary ======= > Total deployments: 2 > Final cost: 0.07773058 ETH Mint We can send a transaction to mint tokens to a given account, from an account with the minter role. truffle(develop)> nft = await ERC721PresetMinterPauserAutoId.deployed() undefined In our case we are minting from the account which deployed the token, which is given the minter role. To see configured accounts run the command accounts . truffle(rinkeby)> accounts [ '0x133d144f52705ceb3f5801b63b9ebccf4102f5ed', We will mint 1 NFT with token ID 1. Specify the address that you want to be the token holder ( 0xc7e4bBc4269fdC62F879834E363173aeE7895F45 is one of my test accounts) truffle(rinkeby)> await nft.mint(\"0x133d144f52705ceb3f5801b63b9ebccf4102f5ed\") { tx: '0x0d90d4a2a4ac3f33d5220deb11e8f65adf14a6669afd18abd4cce8ca7ab58e04', receipt: { blockHash: '0x724ba66bc1d799820c05a93ae67991b21bb769fd1e9dddd5db9f725f5f633331', blockNumber: 3333746, contractAddress: null, cumulativeGasUsed: 164785, from: '0x77737a65c296012c67f8c7f656d1df81827c9541', gasUsed: 164785, ...","title":"Deploy NFT on TC"},{"location":"smart-chain/developer/BLUE721.html#deploy-nft-on-tc","text":"This work is inspired by this blog In this tutorial we will create a non-fungible token (NFT) and deploy to a public testnet. BLUE721 is a standard for representing ownership of non-fungible tokens , that is, where each token is unique such as in real estate or collectibles. We will use Presets contracts in OpenZeppelin Contracts to create an BLUE721 and deploy using Truffle.","title":"Deploy NFT on TC"},{"location":"smart-chain/developer/BLUE721.html#setting-up-the-environment","text":"We begin by creating a new project. $ mkdir mynft && cd mynft $ npm init -y Then we install OpenZeppelin Contracts which has an implementation of BLUE721. $ npm i --save-dev @openzeppelin/contracts Next we install a development tool for deployment, for this tutorial we will use Truffle but we could use any other tools such as Buidler, Remix or OpenZeppelin CLI . $ npm i truffle","title":"Setting up the Environment"},{"location":"smart-chain/developer/BLUE721.html#getting-the-contract-artifacts","text":"We will setup our Solidity project using truffle init to create a contracts directory and configuration to connect to a network. $ npx truffle init Starting init... ================ > Copying project files to Init successful, sweet! We are going to use Preset ERC721PresetMinterPauserAutoId which is an BLUE721 that is preset so it can be minted (with auto token ID and metadata URI), paused and burned. The Preset contracts have already been compiled, so we only need to copy the artifacts to the build/contracts directory. $ mkdir -p build/contracts/ $ cp node_modules/@openzeppelin/contracts/build/contracts/* build/contracts/ Using your favorite editor create 2_deploy.js in the migrations directory with the following contents: // migrations/2_deploy.js // SPDX-License-Identifier: MIT const ERC721PresetMinterPauserAutoId = artifacts.require(\"ERC721PresetMinterPauserAutoId\"); module.exports = function(deployer) { deployer.deploy(ERC721PresetMinterPauserAutoId, \"My NFT\",\"NFT\", \"http://my-json-server.typicode.com/huangsuyu/nft/tokens\"); };","title":"Getting the contract artifacts"},{"location":"smart-chain/developer/BLUE721.html#deploy-the-contract-to-a-local-blockchain","text":"We will use truffle develop to open a Truffle console with a development blockchain Head over to Faucet and request test GSYS $ npx truffle develop Truffle Develop started at http://127.0.0.1:9545/ Accounts: (0) 0xc7e4bbc4269fdc62f879834e363173aee7895f45 Private Keys: (0) ef424b4dc91a9c9d6c1fc4ae0a50ce80668f3a955a7e982584b45577e2c70e27 Mnemonic: mechanic cannon setup general indicate people notable frown poet friend credit true \u26a0\ufe0f Important \u26a0\ufe0f : This mnemonic was created for you by Truffle. It is not secure. Ensure you do not use it on production blockchains, or else you risk losing funds. truffle(develop)> migrate Compiling your contracts... =========================== > Compiling ./contracts/Migrations.sol > Artifacts written to /Users/Documents/work/mynft/build/contracts > Compiled successfully using: - solc: 0.5.16+commit.9c3226ce.Emscripten.clang Starting migrations... ====================== > Network name: 'develop' > Network id: 5777 > Block gas limit: 6721975 (0x6691b7) 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x9a17a50e6efd52ba3e55245c76c52b065d20587add45aee732c233987033e567 > Blocks: 0 Seconds: 0 > contract address: 0x77409B688eA5461078a31450F3138EA8324F72C9 > block number: 1 > block timestamp: 1604387655 > account: 0xc7e4bBc4269fdC62F879834E363173aeE7895F45 > balance: 99.99616114 > gas used: 191943 (0x2edc7) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00383886 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00383886 ETH 2_deploy.js =========== Deploying 'ERC721PresetMinterPauserAutoId' ------------------------------------------ > transaction hash: 0xc1a3994c2ad2ba706ac49934b4f480c7b3d9b94241f526afa2dfe91545145a4e > Blocks: 0 Seconds: 0 > contract address: 0xEaB17D581552123695f03F12b09e378EE9463b44 > block number: 3 > block timestamp: 1604387655 > account: 0xc7e4bBc4269fdC62F879834E363173aeE7895F45 > balance: 99.92142266 > gas used: 3694586 (0x385ffa) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.07389172 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.07389172 ETH Summary ======= > Total deployments: 2 > Final cost: 0.07773058 ETH truffle(develop)> We can deploy our new NFT to our development blockchain using migrate. truffle(develop)> migrate Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'develop' > Network id: 5777 > Block gas limit: 6721975 (0x6691b7) 1_initial_migration.js ====================== Replacing 'Migrations' ---------------------- > transaction hash: 0x5d71b0a45a0fe20e2ca645393bb44b83fbd47351c009c48be0b8b84b610fb3b7 > Blocks: 0 Seconds: 0 > contract address: 0x3797c825cAC4a1FA765F6D8cd7787fB195849555 > block number: 1 > block timestamp: 1590736865 > account: 0x0445c33BdCe670D57189158b88c0034B579f37cE > balance: 99.99671674 > gas used: 164163 (0x28143) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00328326 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00328326 ETH 2_deploy.js =========== Replacing 'ERC721PresetMinterPauserAutoId' ------------------------------------------ > transaction hash: 0x166d7b28f4afb949585b5a0e5b4151daa54acbcb70566b202fd62ab380a6650c > Blocks: 0 Seconds: 0 > contract address: 0xDEE9411430c7Dd9b67fC6DA723DE729AdAB50AD7 > block number: 3 > block timestamp: 1590736866 > account: 0x0445c33BdCe670D57189158b88c0034B579f37cE > balance: 99.92191642 > gas used: 3697675 (0x386c0b) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.0739535 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.0739535 ETH Summary ======= > Total deployments: 2 > Final cost: 0.07723676 ETH We can then use our deployed contract. truffle(develop)> nft = await ERC721PresetMinterPauserAutoId.deployed() undefined","title":"Deploy the contract to a local blockchain"},{"location":"smart-chain/developer/BLUE721.html#interact-with-our-token","text":"The accounts that we can use were displayed when we started truffle develop","title":"Interact with our Token"},{"location":"smart-chain/developer/BLUE721.html#token-metadata","text":"We can call the contract to read token metadata such as name , symbol and baseURI truffle(develop)> await nft.name() 'My NFT' truffle(develop)> await nft.symbol() 'NFT' truffle(develop)> await nft.baseURI()","title":"Token metadata"},{"location":"smart-chain/developer/BLUE721.html#mint","text":"We can send a transaction to mint tokens to a given account, from an account with the minter role. In our case we are minting from the account which deployed the token, which is given the minter role. We will mint 1 NFT with token ID 0. truffle(develop)> await nft.mint(\"0x0445c33bdce670d57189158b88c0034b579f37ce\") { tx: '0xd301a60dbb8ac187687f6639f200d4e6f2cfa065923092b3940330e35a26421d', receipt: { transactionHash: '0xd301a60dbb8ac187687f6639f200d4e6f2cfa065923092b3940330e35a26421d', transactionIndex: 0, blockHash: '0x3ad3cfcb26da0c969e9d5a5414a5e90a91a3a862c9e9082afc38a0ec0f1a5d00', blockNumber: 5, from: '0x0445c33bdce670d57189158b88c0034b579f37ce', to: '0xdee9411430c7dd9b67fc6da723de729adab50ad7', gasUsed: 156470, ... We can check the owner of the token and the token URI for the metadata truffle(develop)> await nft.ownerOf(1) '0x0445c33BdCe670D57189158b88c0034B579f37cE' truffle(develop)> await nft.tokenURI(1)","title":"Mint"},{"location":"smart-chain/developer/BLUE721.html#metadata","text":"EIP-721 2 includes an optional metadata extension with a name , symbol and for each tokenID a tokenURI with can point to a JSON file with name , description and image for the given token ID. How you create and host this metadata is up to you. I would suggest using a domain that you control to point to where you host the data so that you can move it as required. For this tutorial, we will use My JSON Server where we can store a single JSON file in a GitHub repository that we can access via a fake JSON server. For production we need to store our metadata in a permanent location that can exist for the life of the token. A sample JSON for tokenID 1 is: http://my-json-server.typicode.com/huangsuyu/nft/tokens/1","title":"MetaData"},{"location":"smart-chain/developer/BLUE721.html#deploy-to-a-public-testnet","text":"Next we will deploy to Genesys Chain testnet . To deploy, we will use the instructions for Connecting to Public Test Networks with Truffle You will need the following: An Infura project ID (or a public node provider of your choice) @truffle/hdwallet-provider installed Configure truffle-config.js for Rinkeby network A funded testnet account and mnemonic A secrets.json or another secret-management solution. Make sure you don\u2019t commit this to GitHub! My truffle-config.js has the following rinkeby configuration: testnet: { provider: () => new HDWalletProvider(mnemonic, `https://testnet-rpc.genesys.network`), network_id: 97, confirmations: 10, timeoutBlocks: 200, skipDryRun: true }, nc: { provider: () => new HDWalletProvider(mnemonic, `https://mainnet-rpc.genesys.network`), network_id: 56, confirmations: 10, timeoutBlocks: 200, skipDryRun: true },","title":"Deploy to a public testnet"},{"location":"smart-chain/developer/BLUE721.html#deploy-to-gsys-testnet","text":"$ npx truffle migrate --network testnet Compiling your contracts... =========================== > Everything is up to date, there is nothing to compile. Starting migrations... ====================== > Network name: 'develop' > Network id: 5777 > Block gas limit: 6721975 (0x6691b7) 1_initial_migration.js ====================== Deploying 'Migrations' ---------------------- > transaction hash: 0x9a17a50e6efd52ba3e55245c76c52b065d20587add45aee732c233987033e567 > Blocks: 0 Seconds: 0 > contract address: 0x77409B688eA5461078a31450F3138EA8324F72C9 > block number: 1 > block timestamp: 1604387655 > account: 0xc7e4bBc4269fdC62F879834E363173aeE7895F45 > balance: 99.99616114 > gas used: 191943 (0x2edc7) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.00383886 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.00383886 ETH 2_deploy.js =========== Deploying 'ERC721PresetMinterPauserAutoId' ------------------------------------------ > transaction hash: 0xc1a3994c2ad2ba706ac49934b4f480c7b3d9b94241f526afa2dfe91545145a4e > Blocks: 0 Seconds: 0 > contract address: 0xEaB17D581552123695f03F12b09e378EE9463b44 > block number: 3 > block timestamp: 1604387655 > account: 0xc7e4bBc4269fdC62F879834E363173aeE7895F45 > balance: 99.92142266 > gas used: 3694586 (0x385ffa) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.07389172 ETH > Saving migration to chain. > Saving artifacts ------------------------------------- > Total cost: 0.07389172 ETH Summary ======= > Total deployments: 2 > Final cost: 0.07773058 ETH","title":"Deploy to GSYS Testnet"},{"location":"smart-chain/developer/BLUE721.html#mint_1","text":"We can send a transaction to mint tokens to a given account, from an account with the minter role. truffle(develop)> nft = await ERC721PresetMinterPauserAutoId.deployed() undefined In our case we are minting from the account which deployed the token, which is given the minter role. To see configured accounts run the command accounts . truffle(rinkeby)> accounts [ '0x133d144f52705ceb3f5801b63b9ebccf4102f5ed', We will mint 1 NFT with token ID 1. Specify the address that you want to be the token holder ( 0xc7e4bBc4269fdC62F879834E363173aeE7895F45 is one of my test accounts) truffle(rinkeby)> await nft.mint(\"0x133d144f52705ceb3f5801b63b9ebccf4102f5ed\") { tx: '0x0d90d4a2a4ac3f33d5220deb11e8f65adf14a6669afd18abd4cce8ca7ab58e04', receipt: { blockHash: '0x724ba66bc1d799820c05a93ae67991b21bb769fd1e9dddd5db9f725f5f633331', blockNumber: 3333746, contractAddress: null, cumulativeGasUsed: 164785, from: '0x77737a65c296012c67f8c7f656d1df81827c9541', gasUsed: 164785, ...","title":"Mint"},{"location":"smart-chain/developer/circulation-model.html","text":"Circulation Model BC and GSYS share the same token universe for GSYS and BEP8/BEP2/BLUE20 tokens. This defines: The same token can circulate on both networks, and flow between them bi-directionally via a cross-chain communication mechanism. The total circulation of the same token should be managed across the two networks, i.e. the total effective supply of a token should be the sum of the token\u2019s total effective supply on both GSYS and BC. The tokens can be initially created on GSYS as a BLUE20, or on BC as a BEP2, then created on the other. There are native ways on both networks to link the two and secure the total supply of the token. Peg Account To secure the total circulation of the token on both chains, we introduce Peg Account to lock tokens on chain. Peg Account is a pure-code-controlled account that no one has the right to access to the account. For BC, the Peg Account is bnb1v8vkkymvhe2sf7gd2092ujc6hweta38xadu2pj . ( tbnb1v8vkkymvhe2sf7gd2092ujc6hweta38xnc4wpr for testnet) For TC, the Peg Account is TokenHub contract. Bind Token Binding can happen at any time after BEP2/BEP8 and BLUE20 are ready. The token owners of either BEP2/BEP8 or BLUE20 only need to complete the Binding process when a cross-chain feature is necessary. Binding process helps to build the relationship between the two tokens on BC and TC. It will ensure that the two tokens share the same symbol and same total supply. The most important part is that it will reallocate the circulation on both chains to ensure the total circulation equals the total supply. Let's walk through an example: Bob issues BTC on BC with a total supply of 10, and he sends Alice 2 BTC. Bob issues BTC on GSYS with a total supply of 10, and he sends Tom 1 BTC. Now Bob wants BTC to flow between BC and TC, but the total circulation on BC and GSYS is 20=10+10 BTC which is not correct, so he decided to bind these two tokens. He made a decision that 8 BTC circulation on BC and 2 BTC circulation on TC, then he started a bind transaction. The BC execution engine will: 1. Transfer 2 BTC from Bob's account to Peg Account . 2. Emit a cross-chain event. For now, on BC, Bob has 6 BTC, Alice has 2 BTC, 2 BTC is locked in Peg Account , circulation on BC is 8 BTC. Relayer watches the cross-chain event on BC, and send a transaction to TokenManager contract on TC. Then Bob invokes the BTC contract on GSYS to approve TokenManager to spend 8 BTC of his account. After that Bob approves the bind request by invoking TokenManager . The TokenManager will transfer 8 BTC from Bob's account to Peg Account . For now, on TC, Bob has 1 BTC, Tom has 1 BTC, 8 BTC is locked in Peg Account , circulation on GSYS is 2 BTC. The binding process ends here, and the total circulation on both chains is 10 BTC which equals to its total supply. Cross Chain Transfer When one token transfer from the native chain to the parallel chain, the process is: 1. Token transfer from the sender to Peg Account on the native chain. 2. Token transfer from Peg Account to the receiver on the parallel chain. Burn When a user burns a certain amount of token on the native chain, there is no need to burn on the parallel chain. Let's walk through an example: The circulation on BC is 5 BTC, and 5 BTC on TC. User burns 2 BTC on BC. Now circulation on BC is 3 BTC, and 5 BTC on TC. The total circulation is 8 now which is expected. Mint When user mint token on the native chain, but do not mint on the parallel chain, it may cause an issue that user can not cross transfer all token from native chain to parallel chain. Let's walk through an example: The circulation on BC is 5 BTC, and the locked token is 5 BTC. The circulation on GSYS is 5 BTC, and the locked token is 5 BTC. User mint 2 BTC on BC. It will fail if the user tries to transfer 7 BTC from BC to TC, because the balance of Peg Account on GSYS is 5 BTC and can\u2019t afford to unlock 7 BTC. The best practice for mint is: Mint token on the native chain. Mint token on the parallel chain. Transfer the mint token to Peg Account on the parallel chain.","title":"Circulation Model"},{"location":"smart-chain/developer/circulation-model.html#circulation-model","text":"BC and GSYS share the same token universe for GSYS and BEP8/BEP2/BLUE20 tokens. This defines: The same token can circulate on both networks, and flow between them bi-directionally via a cross-chain communication mechanism. The total circulation of the same token should be managed across the two networks, i.e. the total effective supply of a token should be the sum of the token\u2019s total effective supply on both GSYS and BC. The tokens can be initially created on GSYS as a BLUE20, or on BC as a BEP2, then created on the other. There are native ways on both networks to link the two and secure the total supply of the token.","title":"Circulation Model"},{"location":"smart-chain/developer/circulation-model.html#peg-account","text":"To secure the total circulation of the token on both chains, we introduce Peg Account to lock tokens on chain. Peg Account is a pure-code-controlled account that no one has the right to access to the account. For BC, the Peg Account is bnb1v8vkkymvhe2sf7gd2092ujc6hweta38xadu2pj . ( tbnb1v8vkkymvhe2sf7gd2092ujc6hweta38xnc4wpr for testnet) For TC, the Peg Account is TokenHub contract.","title":"Peg Account"},{"location":"smart-chain/developer/circulation-model.html#bind","text":"Token Binding can happen at any time after BEP2/BEP8 and BLUE20 are ready. The token owners of either BEP2/BEP8 or BLUE20 only need to complete the Binding process when a cross-chain feature is necessary. Binding process helps to build the relationship between the two tokens on BC and TC. It will ensure that the two tokens share the same symbol and same total supply. The most important part is that it will reallocate the circulation on both chains to ensure the total circulation equals the total supply. Let's walk through an example: Bob issues BTC on BC with a total supply of 10, and he sends Alice 2 BTC. Bob issues BTC on GSYS with a total supply of 10, and he sends Tom 1 BTC. Now Bob wants BTC to flow between BC and TC, but the total circulation on BC and GSYS is 20=10+10 BTC which is not correct, so he decided to bind these two tokens. He made a decision that 8 BTC circulation on BC and 2 BTC circulation on TC, then he started a bind transaction. The BC execution engine will: 1. Transfer 2 BTC from Bob's account to Peg Account . 2. Emit a cross-chain event. For now, on BC, Bob has 6 BTC, Alice has 2 BTC, 2 BTC is locked in Peg Account , circulation on BC is 8 BTC. Relayer watches the cross-chain event on BC, and send a transaction to TokenManager contract on TC. Then Bob invokes the BTC contract on GSYS to approve TokenManager to spend 8 BTC of his account. After that Bob approves the bind request by invoking TokenManager . The TokenManager will transfer 8 BTC from Bob's account to Peg Account . For now, on TC, Bob has 1 BTC, Tom has 1 BTC, 8 BTC is locked in Peg Account , circulation on GSYS is 2 BTC. The binding process ends here, and the total circulation on both chains is 10 BTC which equals to its total supply.","title":"Bind"},{"location":"smart-chain/developer/circulation-model.html#cross-chain-transfer","text":"When one token transfer from the native chain to the parallel chain, the process is: 1. Token transfer from the sender to Peg Account on the native chain. 2. Token transfer from Peg Account to the receiver on the parallel chain.","title":"Cross Chain Transfer"},{"location":"smart-chain/developer/circulation-model.html#burn","text":"When a user burns a certain amount of token on the native chain, there is no need to burn on the parallel chain. Let's walk through an example: The circulation on BC is 5 BTC, and 5 BTC on TC. User burns 2 BTC on BC. Now circulation on BC is 3 BTC, and 5 BTC on TC. The total circulation is 8 now which is expected.","title":"Burn"},{"location":"smart-chain/developer/circulation-model.html#mint","text":"When user mint token on the native chain, but do not mint on the parallel chain, it may cause an issue that user can not cross transfer all token from native chain to parallel chain. Let's walk through an example: The circulation on BC is 5 BTC, and the locked token is 5 BTC. The circulation on GSYS is 5 BTC, and the locked token is 5 BTC. User mint 2 BTC on BC. It will fail if the user tries to transfer 7 BTC from BC to TC, because the balance of Peg Account on GSYS is 5 BTC and can\u2019t afford to unlock 7 BTC. The best practice for mint is: Mint token on the native chain. Mint token on the parallel chain. Transfer the mint token to Peg Account on the parallel chain.","title":"Mint"},{"location":"smart-chain/developer/create-wallet.html","text":"Key Management This article is a guide about key management strategy on client side of your Decentralised Application on Genesys Chain Setup Web3 web3.js is a javascript library that allows our client-side application to talk to the blockchain. We configure web3 to communicate via Metamask. web3.js doc is here Connect to GSYS network // mainnet const web3 = new Web3 ( 'https://mainnet-rpc.genesys.network' ); // testnet const web3 = new Web3 ( 'https://testnet-rpc.genesys.network' ); Set up account If the installation and instantiation of web3 was successful, the following should successfully return a random account: const account = web3 . eth . accounts . create (); Recover account If you have backup the private key of your account, you can use it to restore your account. const account = web3 . eth . accounts . privateKeyToAccount ( \"$private-key\" ) Full Example const Web3 = require ( 'web3' ); async function main () { const web3 = new Web3 ( 'https://mainnet-rpc.genesys.network' ); const loader = setupLoader ({ provider : web3 }). web3 ; const account = web3 . eth . accounts . create (); console . log ( account ); }","title":"Create Wallet"},{"location":"smart-chain/developer/create-wallet.html#key-management","text":"This article is a guide about key management strategy on client side of your Decentralised Application on Genesys Chain","title":"Key Management"},{"location":"smart-chain/developer/create-wallet.html#setup-web3","text":"web3.js is a javascript library that allows our client-side application to talk to the blockchain. We configure web3 to communicate via Metamask. web3.js doc is here","title":"Setup Web3"},{"location":"smart-chain/developer/create-wallet.html#connect-to-gsys-network","text":"// mainnet const web3 = new Web3 ( 'https://mainnet-rpc.genesys.network' ); // testnet const web3 = new Web3 ( 'https://testnet-rpc.genesys.network' );","title":"Connect to GSYS network"},{"location":"smart-chain/developer/create-wallet.html#set-up-account","text":"If the installation and instantiation of web3 was successful, the following should successfully return a random account: const account = web3 . eth . accounts . create ();","title":"Set up account"},{"location":"smart-chain/developer/create-wallet.html#recover-account","text":"If you have backup the private key of your account, you can use it to restore your account. const account = web3 . eth . accounts . privateKeyToAccount ( \"$private-key\" )","title":"Recover account"},{"location":"smart-chain/developer/create-wallet.html#full-example","text":"const Web3 = require ( 'web3' ); async function main () { const web3 = new Web3 ( 'https://mainnet-rpc.genesys.network' ); const loader = setupLoader ({ provider : web3 }). web3 ; const account = web3 . eth . accounts . create (); console . log ( account ); }","title":"Full Example"},{"location":"smart-chain/developer/cross-chain-transfer.html","text":"Cross-Chain Transfer Cross-chain transfers only support bound BEP2 or BEP8 tokens on BC and BLUE20 tokens on TC. Verify Token Info First, you should make sure that it's already bound. For example, you could see the binding info of GSYS : ## mainnet eth-cli token info --symbol GSYS --trust-node --node http://dataseed4.genesys.network:80 ## testnet eth-cli token info --symbol GSYS --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 { \"type\" : \"bnbchain/Token\" , \"value\" : { \"name\" : \"Genesys Chain Native Token\" , \"symbol\" : \"GSYS\" , \"original_symbol\" : \"GSYS\" , \"total_supply\" : \"200000000.00000000\" , \"owner\" : \"tbnb1l9ffdr8e2pk7h4agvhwcslh2urwpuhqm2u82hy\" , \"mintable\" : false , \"contract_address\" : \"0x0000000000000000000000000000000000000000\" , \"contract_decimals\" : 18 } } As GSYS is the native token on both chains, so we use 0x0000000000000000000000000000000000000000 as the corresponding contract address. Besides, on TC, the native token decimals is 18, while the decimals on BC is 8. So if you transfer 1e8:GSYS to TC, the recipient balance will gain 1e18. Transfer GSYS from BC to TC Example: ## mainnet eth-cli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id GSYS-Chain-Tigris --from owner --amount 100000000 :GSYS --node http://dataseed4.genesys.network:80 ## testnet eth-cli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id GSYS-Chain-Ganges --from owner --amount 100000000 :GSYS --node http://data-seed-pre-0-s3.genesys.network:80 Result: Committed at block 465899 ( tx hash: 68FFF82197E27A3EC14AFF8C99A035FA9CA7120312AA55E98D11DFC0F8D9F3B9, response: { Code:0 Data: [] Log:Msg 0 : Info: GasWanted:0 GasUsed:0 Events: [{ Type: Attributes: [{ Key: [ 84 114 97 110 115 102 101 114 79 117 116 83 101 113 117 101 110 99 101 ] Value: [ 49 49 ] XXX_NoUnkeyedLiteral: {} XXX_unrecognized: [] XXX_sizecache:0 } { Key: [ 69 120 112 105 114 101 84 105 109 101 ] Value: [ 49 53 57 55 53 52 51 49 57 51 ] XXX_NoUnkeyedLiteral: {} XXX_unrecognized: [] XXX_sizecache:0 } { Key: [ 97 99 116 105 111 110 ] Value: [ 99 114 111 115 115 84 114 97 110 115 102 101 114 79 117 116 ] XXX_NoUnkeyedLiteral: {} XXX_unrecognized: [] XXX_sizecache:0 }] XXX_NoUnkeyedLiteral: {} XXX_unrecognized: [] XXX_sizecache:0 }] Codespace: XXX_NoUnkeyedLiteral: {} XXX_unrecognized: [] XXX_sizecache:0 }) Transfer GSYS from GSYS to BC transferOut Call transferOut of TokenHub contract in MyEtherWallet : Parameter Name Type Description contractAddr address for GSYS, the value must be 0x0000000000000000000000000000000000000000 recipient address decode bech32 address, starting with 0x . To transfer to hex string. This is a online too to decode bech32: https://slowli.github.io/bech32-buffer/ amount uint256 The GSYS decimals on GSYS is 18. If you want to transfer one GSYS, then the value should be 1e18. Besides, the value must be N * 1e10 expireTime uint256 Timestamp, counted by second The value here should follow this equation: txValue = (amount + RelayFee)/1e18 RelayFee should be 0.01GSYS and it can be updated by on-chain governance. For example, if you transfer 1GSYS from GSYS to BC, the value should be at least 1.01GSYS. After all the above parameters have been set to proper values, users can click the transact button to build transactions, and metamask plugin will be ejected. Then users can click the confirm button in metamask to sign and broadcast transactions. batchTransferOutGSYS Call batchTransferOutGSYS of TokenHub contract in MyEtherWallet: Parameter Name Type Description recipientAddrs address[] decode bech32 address to hex string. This is a online too to decode bech32: https://slowli.github.io/bech32-buffer/0 amounts uint256[] amount for each recipient, should be N * 1e10 refundAddrs address[] sender can specify some address as the refund address if the cross chain transfer is failed. expireTime uint256 Timestamp, counted by second The value here should follow this equation: txValue = (sumOfAmounts + RelayFee * batchSize)/1e18 Transfer BEP2 to TC Execute the following command to transfer ABC-A64 token to TC: ## mainnet eth-cli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id GSYS-Chain-Tigris --from owner --amount 10000000000 :ABC-A64 --node http://dataseed4.genesys.network:80 ## testnet eth-cli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id GSYS-Chain-Ganges --from owner --amount 10000000000 :ABC-A64 --node http://data-seed-pre-0-s3.genesys.network:80 Transfer BLUE20 to BC Before calling transferOut or batchTransferOut , users need to call approve method to grant enough allowance to TokenHub contract. For transferOut method, the allowance should equal the transfer amount. For batchTransferOut , the allowance should be the sum of the amount array. transferOut Parameter Name Type Description contractAddr address BLUE20 contract address recipient address decode bech32 address to hex string. This is a online too to decode bech32: https://slowli.github.io/bech32-buffer/ amount uint256 BLUE20 token amount. Here the decimals is 18, so the amount must be N * 1e10. expireTime uint256 Timestamp, counted by second The value here should be RelayFee. Mint If both the BLUE20 token and bep2 token are mintable, then token owners can still mint their tokens even after token binding. Besides, token owners need to ensure the total supply and the locked amount on both chains are still matched, otherwise, users might can\u2019t transfer their tokens to another chain. Mint token on BC Execute the following command to mint 10000 ABC-A64: ## mainnet eth-cli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id GSYS-Chain-Tigris --node http://dataseed4.genesys.network:80 ## testnet eth-cli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id GSYS-Chain-Ganges --node http://data-seed-pre-0-s3.genesys.network:80 Mint token on GSYS and lock the new minted token: Call mint method of BLUE20 contract, the mint amount should be 1e22. Transfer all minted ABC token to tokenHub contract: 0x0000000000000000000000000000000000001004 Mint token on TC Call mint of BLUE20 contract to mint 10000 ABC, the mint amount should be 1e22(18 decimals). Mint token on BC and lock the new minted token: Execute the following command to mint 10000 ABC-A64: ## mainnet eth-cli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id GSYS-Chain-Tigris --node http://dataseed4.genesys.network:80 ## testnet eth-cli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id GSYS-Chain-Ganges --node http://data-seed-pre-0-s3.genesys.network:80 Transfer all minted ABC-A64 token to the pure-code-controlled address: tbnb1v8vkkymvhe2sf7gd2092ujc6hweta38xnc4wpr (mainnet address: bnb1v8vkkymvhe2sf7gd2092ujc6hweta38xadu2pj )","title":"Cross-Chain Transfer"},{"location":"smart-chain/developer/cross-chain-transfer.html#cross-chain-transfer","text":"Cross-chain transfers only support bound BEP2 or BEP8 tokens on BC and BLUE20 tokens on TC.","title":"Cross-Chain Transfer"},{"location":"smart-chain/developer/cross-chain-transfer.html#verify-token-info","text":"First, you should make sure that it's already bound. For example, you could see the binding info of GSYS : ## mainnet eth-cli token info --symbol GSYS --trust-node --node http://dataseed4.genesys.network:80 ## testnet eth-cli token info --symbol GSYS --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 { \"type\" : \"bnbchain/Token\" , \"value\" : { \"name\" : \"Genesys Chain Native Token\" , \"symbol\" : \"GSYS\" , \"original_symbol\" : \"GSYS\" , \"total_supply\" : \"200000000.00000000\" , \"owner\" : \"tbnb1l9ffdr8e2pk7h4agvhwcslh2urwpuhqm2u82hy\" , \"mintable\" : false , \"contract_address\" : \"0x0000000000000000000000000000000000000000\" , \"contract_decimals\" : 18 } } As GSYS is the native token on both chains, so we use 0x0000000000000000000000000000000000000000 as the corresponding contract address. Besides, on TC, the native token decimals is 18, while the decimals on BC is 8. So if you transfer 1e8:GSYS to TC, the recipient balance will gain 1e18.","title":"Verify Token Info"},{"location":"smart-chain/developer/cross-chain-transfer.html#transfer-gsys-from-bc-to-tc","text":"Example: ## mainnet eth-cli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id GSYS-Chain-Tigris --from owner --amount 100000000 :GSYS --node http://dataseed4.genesys.network:80 ## testnet eth-cli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id GSYS-Chain-Ganges --from owner --amount 100000000 :GSYS --node http://data-seed-pre-0-s3.genesys.network:80 Result: Committed at block 465899 ( tx hash: 68FFF82197E27A3EC14AFF8C99A035FA9CA7120312AA55E98D11DFC0F8D9F3B9, response: { Code:0 Data: [] Log:Msg 0 : Info: GasWanted:0 GasUsed:0 Events: [{ Type: Attributes: [{ Key: [ 84 114 97 110 115 102 101 114 79 117 116 83 101 113 117 101 110 99 101 ] Value: [ 49 49 ] XXX_NoUnkeyedLiteral: {} XXX_unrecognized: [] XXX_sizecache:0 } { Key: [ 69 120 112 105 114 101 84 105 109 101 ] Value: [ 49 53 57 55 53 52 51 49 57 51 ] XXX_NoUnkeyedLiteral: {} XXX_unrecognized: [] XXX_sizecache:0 } { Key: [ 97 99 116 105 111 110 ] Value: [ 99 114 111 115 115 84 114 97 110 115 102 101 114 79 117 116 ] XXX_NoUnkeyedLiteral: {} XXX_unrecognized: [] XXX_sizecache:0 }] XXX_NoUnkeyedLiteral: {} XXX_unrecognized: [] XXX_sizecache:0 }] Codespace: XXX_NoUnkeyedLiteral: {} XXX_unrecognized: [] XXX_sizecache:0 })","title":"Transfer GSYS from BC to TC"},{"location":"smart-chain/developer/cross-chain-transfer.html#transfer-gsys-from-gsys-to-bc","text":"","title":"Transfer GSYS from GSYS to BC"},{"location":"smart-chain/developer/cross-chain-transfer.html#transferout","text":"Call transferOut of TokenHub contract in MyEtherWallet : Parameter Name Type Description contractAddr address for GSYS, the value must be 0x0000000000000000000000000000000000000000 recipient address decode bech32 address, starting with 0x . To transfer to hex string. This is a online too to decode bech32: https://slowli.github.io/bech32-buffer/ amount uint256 The GSYS decimals on GSYS is 18. If you want to transfer one GSYS, then the value should be 1e18. Besides, the value must be N * 1e10 expireTime uint256 Timestamp, counted by second The value here should follow this equation: txValue = (amount + RelayFee)/1e18 RelayFee should be 0.01GSYS and it can be updated by on-chain governance. For example, if you transfer 1GSYS from GSYS to BC, the value should be at least 1.01GSYS. After all the above parameters have been set to proper values, users can click the transact button to build transactions, and metamask plugin will be ejected. Then users can click the confirm button in metamask to sign and broadcast transactions.","title":"transferOut"},{"location":"smart-chain/developer/cross-chain-transfer.html#batchtransferoutgsys","text":"Call batchTransferOutGSYS of TokenHub contract in MyEtherWallet: Parameter Name Type Description recipientAddrs address[] decode bech32 address to hex string. This is a online too to decode bech32: https://slowli.github.io/bech32-buffer/0 amounts uint256[] amount for each recipient, should be N * 1e10 refundAddrs address[] sender can specify some address as the refund address if the cross chain transfer is failed. expireTime uint256 Timestamp, counted by second The value here should follow this equation: txValue = (sumOfAmounts + RelayFee * batchSize)/1e18","title":"batchTransferOutGSYS"},{"location":"smart-chain/developer/cross-chain-transfer.html#transfer-bep2-to-tc","text":"Execute the following command to transfer ABC-A64 token to TC: ## mainnet eth-cli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id GSYS-Chain-Tigris --from owner --amount 10000000000 :ABC-A64 --node http://dataseed4.genesys.network:80 ## testnet eth-cli bridge transfer-out --to 0xEe9546E92e6876EdF6a234eFFbD72d75360d91f0 --expire-time 1597543193 --chain-id GSYS-Chain-Ganges --from owner --amount 10000000000 :ABC-A64 --node http://data-seed-pre-0-s3.genesys.network:80","title":"Transfer BEP2 to TC"},{"location":"smart-chain/developer/cross-chain-transfer.html#transfer-blue20-to-bc","text":"Before calling transferOut or batchTransferOut , users need to call approve method to grant enough allowance to TokenHub contract. For transferOut method, the allowance should equal the transfer amount. For batchTransferOut , the allowance should be the sum of the amount array.","title":"Transfer BLUE20 to BC"},{"location":"smart-chain/developer/cross-chain-transfer.html#transferout_1","text":"Parameter Name Type Description contractAddr address BLUE20 contract address recipient address decode bech32 address to hex string. This is a online too to decode bech32: https://slowli.github.io/bech32-buffer/ amount uint256 BLUE20 token amount. Here the decimals is 18, so the amount must be N * 1e10. expireTime uint256 Timestamp, counted by second The value here should be RelayFee.","title":"transferOut"},{"location":"smart-chain/developer/cross-chain-transfer.html#mint","text":"If both the BLUE20 token and bep2 token are mintable, then token owners can still mint their tokens even after token binding. Besides, token owners need to ensure the total supply and the locked amount on both chains are still matched, otherwise, users might can\u2019t transfer their tokens to another chain.","title":"Mint"},{"location":"smart-chain/developer/cross-chain-transfer.html#mint-token-on-bc","text":"Execute the following command to mint 10000 ABC-A64: ## mainnet eth-cli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id GSYS-Chain-Tigris --node http://dataseed4.genesys.network:80 ## testnet eth-cli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id GSYS-Chain-Ganges --node http://data-seed-pre-0-s3.genesys.network:80 Mint token on GSYS and lock the new minted token: Call mint method of BLUE20 contract, the mint amount should be 1e22. Transfer all minted ABC token to tokenHub contract: 0x0000000000000000000000000000000000001004","title":"Mint token on BC"},{"location":"smart-chain/developer/cross-chain-transfer.html#mint-token-on-tc","text":"Call mint of BLUE20 contract to mint 10000 ABC, the mint amount should be 1e22(18 decimals). Mint token on BC and lock the new minted token: Execute the following command to mint 10000 ABC-A64: ## mainnet eth-cli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id GSYS-Chain-Tigris --node http://dataseed4.genesys.network:80 ## testnet eth-cli token mint --symbol ABC-A64 --amount 1000000000000 --from owner --chain-id GSYS-Chain-Ganges --node http://data-seed-pre-0-s3.genesys.network:80 Transfer all minted ABC-A64 token to the pure-code-controlled address: tbnb1v8vkkymvhe2sf7gd2092ujc6hweta38xnc4wpr (mainnet address: bnb1v8vkkymvhe2sf7gd2092ujc6hweta38xadu2pj )","title":"Mint token on TC"},{"location":"smart-chain/developer/fullnode.html","text":"How to Run A Fullnode on Genesys Chain Fullnodes Functions Stores the full blockchain history on disk and can answer the data request from the network. Receives and validates the new blocks and transactions. Verifies the states of every accounts. Supported Platforms We support running a full node on Mac OS X and Linux . Suggested Requirements Fullnode VPS running recent versions of Mac OS X or Linux. 4 cores of CPU and 8 gigabytes of memory (RAM). A broadband Internet connection with upload/download speeds of 5 megabyte per second Steps to Run a Full Node Download gsys_mainnet.json and static-nodes.json from https://github.com/githubusername/githubrepo wget https://raw.githubusercontent.com/githubusername/githubrepo/master/gsys_mainnet.json wget https://raw.githubusercontent.com/githubusername/githubrepo/master/static-nodes.json Make node folder mkdir node Initialize the Node ./geth --datadir ./node init gsys_mainnet.json Copy the static-nodes.json to node/geth Run the Nodes ./geth --datadir node --syncmode 'full' --gcmode=archive --port 40605 --http --http.port 3545 --http.api 'personal,eth,net,web3,personal,admin,miner,txpool,debug' --bootnodes enode://c8ecb64c00a1e94eb47a997d62a14f07cc0dd6dac41a1b3a062a383b978dd87ab639c64db07c00d70e9a9c8af2c204e9220b349dc684394f44044f51def904ce@103.42.59.71:0?discport=40606 --networkid 16507 --allow-insecure-unlock","title":"GSYS Chain Fullnode"},{"location":"smart-chain/developer/fullnode.html#how-to-run-a-fullnode-on-genesys-chain","text":"","title":"How to Run A Fullnode on Genesys Chain"},{"location":"smart-chain/developer/fullnode.html#fullnodes-functions","text":"Stores the full blockchain history on disk and can answer the data request from the network. Receives and validates the new blocks and transactions. Verifies the states of every accounts.","title":"Fullnodes Functions"},{"location":"smart-chain/developer/fullnode.html#supported-platforms","text":"We support running a full node on Mac OS X and Linux .","title":"Supported Platforms"},{"location":"smart-chain/developer/fullnode.html#suggested-requirements","text":"","title":"Suggested Requirements"},{"location":"smart-chain/developer/fullnode.html#fullnode","text":"VPS running recent versions of Mac OS X or Linux. 4 cores of CPU and 8 gigabytes of memory (RAM). A broadband Internet connection with upload/download speeds of 5 megabyte per second","title":"Fullnode"},{"location":"smart-chain/developer/fullnode.html#steps-to-run-a-full-node","text":"Download gsys_mainnet.json and static-nodes.json from https://github.com/githubusername/githubrepo wget https://raw.githubusercontent.com/githubusername/githubrepo/master/gsys_mainnet.json wget https://raw.githubusercontent.com/githubusername/githubrepo/master/static-nodes.json Make node folder mkdir node Initialize the Node ./geth --datadir ./node init gsys_mainnet.json Copy the static-nodes.json to node/geth Run the Nodes ./geth --datadir node --syncmode 'full' --gcmode=archive --port 40605 --http --http.port 3545 --http.api 'personal,eth,net,web3,personal,admin,miner,txpool,debug' --bootnodes enode://c8ecb64c00a1e94eb47a997d62a14f07cc0dd6dac41a1b3a062a383b978dd87ab639c64db07c00d70e9a9c8af2c204e9220b349dc684394f44044f51def904ce@103.42.59.71:0?discport=40606 --networkid 16507 --allow-insecure-unlock","title":"Steps to Run a Full Node"},{"location":"smart-chain/developer/gnosis.html","text":"Gnosis Safe Multisig on Genesys Chain Introduction First deployed in early 2017, Gnosis multi-signature wallet became the foundational infrastructure for storing funds on Ethereum. The Gnosis Safe is the most secure way to manage your crypto funds. Today, you can set up the Gnosis Safe Multisig on Genesys Chain in less than 60 seconds, and you can use wallets including Ledger, Trezor, Wallet Connect, Torus, and browser wallets like Metamask as signing keys so that you can manage your crypto collectively and inter-operably. Advantages of Gnosis Safe contracts The Gnosis Safe is a smart contract wallet with multi-signature functionality at its core. It enables the following features: High Security Advanced execution logic Advanced access management Projects building with the Gnosis Safe Please read the list here User Guides Create Gnosis Safe Connect wallet Create Safe Choose owners and confirmations Review safe settings Sign transactions to create your safe Great! You have created a Gnosis safe. Receive Funds for Multi-sig Wallet Go to the home page Click on \"Receive\" to get QR code for receiving funds Send Funds from Multi-sig Wallet Go to the home page Click on \"Send\" to create a transaction Submit transaction Signing your request Another key person needs to connect with Gnosis to confirm this transaction Approve Transaction Sign transaction Transaction will be sent after the second signature is sent The others may reject the transaction, they only need to send a different transaction Load existing Safe Select \"Load Existing Safe\" Input address Verify owner Click load Load Transactions API API to keep track of transactions sent via Gnosis Safe smart contracts https://safe-transaction.gnosis.io/","title":"Gnosis Safe Multisig on Genesys Chain"},{"location":"smart-chain/developer/gnosis.html#gnosis-safe-multisig-on-genesys-chain","text":"","title":"Gnosis Safe Multisig on Genesys Chain"},{"location":"smart-chain/developer/gnosis.html#introduction","text":"First deployed in early 2017, Gnosis multi-signature wallet became the foundational infrastructure for storing funds on Ethereum. The Gnosis Safe is the most secure way to manage your crypto funds. Today, you can set up the Gnosis Safe Multisig on Genesys Chain in less than 60 seconds, and you can use wallets including Ledger, Trezor, Wallet Connect, Torus, and browser wallets like Metamask as signing keys so that you can manage your crypto collectively and inter-operably.","title":"Introduction"},{"location":"smart-chain/developer/gnosis.html#advantages-of-gnosis-safe-contracts","text":"The Gnosis Safe is a smart contract wallet with multi-signature functionality at its core. It enables the following features: High Security Advanced execution logic Advanced access management","title":"Advantages of Gnosis Safe contracts"},{"location":"smart-chain/developer/gnosis.html#projects-building-with-the-gnosis-safe","text":"Please read the list here","title":"Projects building with the Gnosis Safe"},{"location":"smart-chain/developer/gnosis.html#user-guides","text":"","title":"User Guides"},{"location":"smart-chain/developer/gnosis.html#create-gnosis-safe","text":"Connect wallet Create Safe Choose owners and confirmations Review safe settings Sign transactions to create your safe Great! You have created a Gnosis safe.","title":"Create Gnosis Safe"},{"location":"smart-chain/developer/gnosis.html#receive-funds-for-multi-sig-wallet","text":"Go to the home page Click on \"Receive\" to get QR code for receiving funds","title":"Receive Funds for Multi-sig Wallet"},{"location":"smart-chain/developer/gnosis.html#send-funds-from-multi-sig-wallet","text":"Go to the home page Click on \"Send\" to create a transaction Submit transaction Signing your request Another key person needs to connect with Gnosis to confirm this transaction Approve Transaction Sign transaction Transaction will be sent after the second signature is sent The others may reject the transaction, they only need to send a different transaction","title":"Send Funds from Multi-sig Wallet"},{"location":"smart-chain/developer/gnosis.html#load-existing-safe","text":"Select \"Load Existing Safe\" Input address Verify owner Click load Load Transactions","title":"Load existing Safe"},{"location":"smart-chain/developer/gnosis.html#api","text":"API to keep track of transactions sent via Gnosis Safe smart contracts https://safe-transaction.gnosis.io/","title":"API"},{"location":"smart-chain/developer/issue-BLUE20.html","text":"Compile and Deploy BLUE20 Contract Open Remix IDE: https://remix.ethereum.org Select solidity language Create new contract BLUE20Token.sol and copy contract code from the BLUE20 token template here Modify \u201cname\u201d, \u201csymbol\u201d, \u201cdecimals\u201d and \u201ctotalSupply\u201d according to your requirements. Compile the BLUE20 token contract a. Step1: Click button to switch to compile page b. Step2: Select \u201cBLUE20Token\u201d contract c. Step3: Enable \u201cAuto compile\u201d and \u201coptimization\u201d d. Step4: Click \u201cABI\u201d to copy the contract abi and save it. Depoy the contract to TC a. Step1: Click button to switch to compile button. b. Step2: Select \u201cInjected Web3\u201d c. Step3: Select \u201cBLUE20Token\u201d d. Step4: Client \u201cDeploy\u201d button and Metamask will pop up e. Client \u201cconfirm\u201d button to sign and broadcast transaction to TC.","title":"Issue Token"},{"location":"smart-chain/developer/nc-relayer.html","text":"GSYS Relayer Guides Prepare Fund Make sure that you have enough GSYS in your account. You can get from faucet If you haven't created your account yet, please follow these guides to create one first. 100 GSYS for relayer register More than 50GSYS for transaction fee Tip Currently the nc-relayer code is not fully prepared. Some features like db persistence , alert , prometheus monitor are still under development. So please don\u2019t modify the configuration about db_config, alert_config, instrumentation_config, admin_config Steps to Install GSYS Relayer 1.Build from source code Make sure that you have installed Go 1.13+ and have added GOPATH to PATH environment variable git clonehttps://github.com/githubusername/githubrepo-relayer # Enter the folder bsc was cloned into cd nc-relayer # Comile and install bsc make build or you can download the pre-build binaries from release page Get Example Config File Get example config from this url: https://github.com/githubusername/githubrepo-relayer/blob/master/config/config.json Edit config.json and fill your GSYS private key to bsc_config.private_key, example private key: AFD8C5D83F148065176268A9D1EE375A10CEE1E74D15985D4CC63E467EC34DA5 Genesys Chain Configuration: mnemonic : Paste the recovery phrase here. Since nc-relayer will automaticly submit double-sign evidence, if it's committed, the reward will be sent to this address Genesys Chain Configuration: * Start Relayer You can start Locally ./nc-relayer --config-type local --config-path config.json Output: (base) huangsuyudeMacBook-Pro:mac huangsuyu$ nc-relayer --config-type local --config-path config.json 2020-05-27 17:01:16 INFO main Start relayer 2020-05-27 17:01:16 INFO SyncProtocol Sync cross chain protocol fromhttps://github.com/githubusername/githubrepo-relayer-config.git 2020-05-27 17:01:18 INFO RegisterRelayerHub This relayer has already been registered 2020-05-27 17:01:18 INFO CleanPreviousPackages channelID: 1, next deliver sequence 55 on TC, next sequence 55 on BC 2020-05-27 17:01:18 INFO CleanPreviousPackages channelID: 2, next deliver sequence 1273 on TC, next sequence 1273 on BC 2020-05-27 17:01:18 INFO CleanPreviousPackages channelID: 3, next deliver sequence 6 on TC, next sequence 6 on BC 2020-05-27 17:01:19 INFO CleanPreviousPackages channelID: 8, next deliver sequence 5 on TC, next sequence 5 on BC 2020-05-27 17:01:19 INFO RelayerDaemon Start relayer daemon 2020-05-27 17:01:19 INFO Serve start admin server at 0.0.0.0:8080 Or, dynamic Sync Cross Chain Protocol Configuration from https://github.com/githubusername/githubrepo-relayer-config Edit config.json and change \"cross_chain_config.protocol_config_type\" to \"remote\". Then relayer will dynamically sync cross chain protocol configuration from this repository: https://github.com/githubusername/githubrepo-relayer-config Start relayer service ./nc-relayer --config-type local --config-path config.json Verify Status You could call RelayerHub Contract to verify that your relayer is registered. Go to read contract and call isRelayer function. If it returns true , then your relayer is working properly. Relayer Rewards You can witness the distribution of relayer rewards in the log of system contract: https://genesys.network/address/0x0000000000000000000000000000000000001005#events . According to the design of Relayer Incentive , the rewards will be distributed every 1000 data packages. The total accumulated rewards can be read from contract the value of _collectedRewardForHeaderRelayer and _collectedRewardForTransferRelayer . Query your relayer's status The total accumulated relayed count can be read from contract the value of _transferRelayersSubmitCount Stop Relayer To get your locked 100 GSYS back, you need to call RelayerHub Contract to unregister your relayer. The fee is 0.1GSYS Go to MyEtherWallet and interact with contract Fill in the contract addresss: 0x0000000000000000000000000000000000001006 with abi interface Call unregister function and leave value in ETH as 0 Sign your transaction in MetaMask","title":"GSYS Relayer Guides"},{"location":"smart-chain/developer/nc-relayer.html#gsys-relayer-guides","text":"","title":"GSYS Relayer Guides"},{"location":"smart-chain/developer/nc-relayer.html#prepare-fund","text":"Make sure that you have enough GSYS in your account. You can get from faucet If you haven't created your account yet, please follow these guides to create one first. 100 GSYS for relayer register More than 50GSYS for transaction fee Tip Currently the nc-relayer code is not fully prepared. Some features like db persistence , alert , prometheus monitor are still under development. So please don\u2019t modify the configuration about db_config, alert_config, instrumentation_config, admin_config","title":"Prepare Fund"},{"location":"smart-chain/developer/nc-relayer.html#steps-to-install-gsys-relayer","text":"1.Build from source code Make sure that you have installed Go 1.13+ and have added GOPATH to PATH environment variable git clonehttps://github.com/githubusername/githubrepo-relayer # Enter the folder bsc was cloned into cd nc-relayer # Comile and install bsc make build or you can download the pre-build binaries from release page","title":"Steps to Install GSYS Relayer"},{"location":"smart-chain/developer/nc-relayer.html#get-example-config-file","text":"Get example config from this url: https://github.com/githubusername/githubrepo-relayer/blob/master/config/config.json Edit config.json and fill your GSYS private key to bsc_config.private_key, example private key: AFD8C5D83F148065176268A9D1EE375A10CEE1E74D15985D4CC63E467EC34DA5 Genesys Chain Configuration: mnemonic : Paste the recovery phrase here. Since nc-relayer will automaticly submit double-sign evidence, if it's committed, the reward will be sent to this address Genesys Chain Configuration: *","title":"Get Example Config File"},{"location":"smart-chain/developer/nc-relayer.html#start-relayer","text":"You can start Locally ./nc-relayer --config-type local --config-path config.json Output: (base) huangsuyudeMacBook-Pro:mac huangsuyu$ nc-relayer --config-type local --config-path config.json 2020-05-27 17:01:16 INFO main Start relayer 2020-05-27 17:01:16 INFO SyncProtocol Sync cross chain protocol fromhttps://github.com/githubusername/githubrepo-relayer-config.git 2020-05-27 17:01:18 INFO RegisterRelayerHub This relayer has already been registered 2020-05-27 17:01:18 INFO CleanPreviousPackages channelID: 1, next deliver sequence 55 on TC, next sequence 55 on BC 2020-05-27 17:01:18 INFO CleanPreviousPackages channelID: 2, next deliver sequence 1273 on TC, next sequence 1273 on BC 2020-05-27 17:01:18 INFO CleanPreviousPackages channelID: 3, next deliver sequence 6 on TC, next sequence 6 on BC 2020-05-27 17:01:19 INFO CleanPreviousPackages channelID: 8, next deliver sequence 5 on TC, next sequence 5 on BC 2020-05-27 17:01:19 INFO RelayerDaemon Start relayer daemon 2020-05-27 17:01:19 INFO Serve start admin server at 0.0.0.0:8080 Or, dynamic Sync Cross Chain Protocol Configuration from https://github.com/githubusername/githubrepo-relayer-config Edit config.json and change \"cross_chain_config.protocol_config_type\" to \"remote\". Then relayer will dynamically sync cross chain protocol configuration from this repository: https://github.com/githubusername/githubrepo-relayer-config Start relayer service ./nc-relayer --config-type local --config-path config.json","title":"Start Relayer"},{"location":"smart-chain/developer/nc-relayer.html#verify-status","text":"You could call RelayerHub Contract to verify that your relayer is registered. Go to read contract and call isRelayer function. If it returns true , then your relayer is working properly.","title":"Verify Status"},{"location":"smart-chain/developer/nc-relayer.html#relayer-rewards","text":"You can witness the distribution of relayer rewards in the log of system contract: https://genesys.network/address/0x0000000000000000000000000000000000001005#events . According to the design of Relayer Incentive , the rewards will be distributed every 1000 data packages. The total accumulated rewards can be read from contract the value of _collectedRewardForHeaderRelayer and _collectedRewardForTransferRelayer . Query your relayer's status The total accumulated relayed count can be read from contract the value of _transferRelayersSubmitCount","title":"Relayer Rewards"},{"location":"smart-chain/developer/nc-relayer.html#stop-relayer","text":"To get your locked 100 GSYS back, you need to call RelayerHub Contract to unregister your relayer. The fee is 0.1GSYS Go to MyEtherWallet and interact with contract Fill in the contract addresss: 0x0000000000000000000000000000000000001006 with abi interface Call unregister function and leave value in ETH as 0 Sign your transaction in MetaMask","title":"Stop Relayer"},{"location":"smart-chain/developer/rpc.html","text":"JSON-RPC Endpoint Available Resources Mainnet(ChainID 0x38, 56 in decimal) NCRPC Endpoints: Note You can make eth_getLogs requests with up to a 5K block range. If you need to pull logs frequently, we recommend using WebSockets to push new logs to you when they are available. Recommend https://nc-dataseed.genesys.network/ NCWebsocket Endpoints: Note: provided by community with no quality promised, building your node should be always the long term goal wss://nc-ws-node.genesys.network:443 Rate limit The rate limit of GSYS endpoint on Testnet and Mainnet is 10K/5min. Start You can start the HTTP JSON-RPC with the --rpc flag ## mainnet geth attach https://mainnet-rpc.genesys.network ## testnet geth attach https://testnet-rpc.genesys.network/ JSON-RPC methods Please refer to this wiki page or use Postman: https://documenter.getpostman.com/view/4117254/ethereum-json-rpc/RVu7CT5J?version=latest","title":"RPC"},{"location":"smart-chain/developer/rpc.html#json-rpc-endpoint","text":"","title":"JSON-RPC Endpoint"},{"location":"smart-chain/developer/rpc.html#available-resources","text":"","title":"Available Resources"},{"location":"smart-chain/developer/rpc.html#mainnetchainid-0x38-56-in-decimal","text":"NCRPC Endpoints: Note You can make eth_getLogs requests with up to a 5K block range. If you need to pull logs frequently, we recommend using WebSockets to push new logs to you when they are available. Recommend https://nc-dataseed.genesys.network/ NCWebsocket Endpoints: Note: provided by community with no quality promised, building your node should be always the long term goal wss://nc-ws-node.genesys.network:443","title":"Mainnet(ChainID 0x38, 56 in decimal)"},{"location":"smart-chain/developer/rpc.html#rate-limit","text":"The rate limit of GSYS endpoint on Testnet and Mainnet is 10K/5min.","title":"Rate limit"},{"location":"smart-chain/developer/rpc.html#start","text":"You can start the HTTP JSON-RPC with the --rpc flag ## mainnet geth attach https://mainnet-rpc.genesys.network ## testnet geth attach https://testnet-rpc.genesys.network/","title":"Start"},{"location":"smart-chain/developer/rpc.html#json-rpc-methods","text":"Please refer to this wiki page or use Postman: https://documenter.getpostman.com/view/4117254/ethereum-json-rpc/RVu7CT5J?version=latest","title":"JSON-RPC methods"},{"location":"smart-chain/developer/snapshot.html","text":"Snapshot For v1.1.0: Latest Snapshot The following commands are step by step instructions for GSYS node operators that can be used for two major use-cases: Fixing nodes that are stuck or crashed; Jumpstarting a newly setup validator node; avoid waiting some hours for synchronization Basically, a compressed version of the last-known \"good\" chaindata is downloaded. Remove the node's old data and update it with the newly downloaded data. Finally, restart the sync-process from this known-good checkpoint. Note: Ensure there is enough disk space for both the zip file AND its uncompressed contents. Double the space or more. Download March Snapshot from CLI using wget wget --no-check-certificate --no-proxy 'https://github.com/githubusername/githubrepo' Tip: extract the data in background In case you can not wait for the extraction to finish, you can run it in the background # Extract the data nohup unzip /NAME_OF_YOUR_HOME/node/geth/ -f chaindata_202102.zip & # Start your node back geth --config ./config.toml --datadir ./node --syncmode snap","title":"Snapshot"},{"location":"smart-chain/developer/snapshot.html#snapshot","text":"For v1.1.0: Latest Snapshot The following commands are step by step instructions for GSYS node operators that can be used for two major use-cases: Fixing nodes that are stuck or crashed; Jumpstarting a newly setup validator node; avoid waiting some hours for synchronization Basically, a compressed version of the last-known \"good\" chaindata is downloaded. Remove the node's old data and update it with the newly downloaded data. Finally, restart the sync-process from this known-good checkpoint. Note: Ensure there is enough disk space for both the zip file AND its uncompressed contents. Double the space or more. Download March Snapshot from CLI using wget wget --no-check-certificate --no-proxy 'https://github.com/githubusername/githubrepo' Tip: extract the data in background In case you can not wait for the extraction to finish, you can run it in the background # Extract the data nohup unzip /NAME_OF_YOUR_HOME/node/geth/ -f chaindata_202102.zip & # Start your node back geth --config ./config.toml --datadir ./node --syncmode snap","title":"Snapshot"},{"location":"smart-chain/developer/upgrade-fullnode.html","text":"How to Upgrade Geth Updating geth is as easy as it gets. You just need to download and install the newer version of geth , shutdown your node and restart with the new software. Geth will automatically use the data of your old node and sync the latest blocks that were mined since you shutdown the old software. Step 1: Compile the new version git clonehttps://github.com/githubusername/githubrepo # Enter the folder bsc was cloned into cd bsc # Comile and install bsc make geth Step 2: Stop Geth $ pid=`ps -ef | grep geth | grep -v grep | awk '{print $2}'` $ kill $pid Step 3: Restart ## start a full node geth --config ./config.toml --datadir ./node --syncmode snap","title":"How to Upgrade Geth"},{"location":"smart-chain/developer/upgrade-fullnode.html#how-to-upgrade-geth","text":"Updating geth is as easy as it gets. You just need to download and install the newer version of geth , shutdown your node and restart with the new software. Geth will automatically use the data of your old node and sync the latest blocks that were mined since you shutdown the old software.","title":"How to Upgrade Geth"},{"location":"smart-chain/developer/upgrade-fullnode.html#step-1-compile-the-new-version","text":"git clonehttps://github.com/githubusername/githubrepo # Enter the folder bsc was cloned into cd bsc # Comile and install bsc make geth","title":"Step 1: Compile the new version"},{"location":"smart-chain/developer/upgrade-fullnode.html#step-2-stop-geth","text":"$ pid=`ps -ef | grep geth | grep -v grep | awk '{print $2}'` $ kill $pid","title":"Step 2: Stop Geth"},{"location":"smart-chain/developer/upgrade-fullnode.html#step-3-restart","text":"## start a full node geth --config ./config.toml --datadir ./node --syncmode snap","title":"Step 3: Restart"},{"location":"smart-chain/developer/bind/bind-tokens.html","text":"Bind BEP2 and BLUE20 Tokens NCand BC work together to ensure that one token can circulate in both formats with confirmed total supply and be used in different use cases. Token Binding can happen at any time after BEP2/BEP8 and BLUE20 are ready. The token owners of either BEP2/BEP8 or BLUE20 only need to complete the Binding process when a cross-chain feature is necessory. You can use this tool . Issue BEP2 or BEP8 Token Please refer to this doc to issue BEP2 Please refer to this doc to issue BEP8 Example Let's issue a new BEP2 token ABC ## mainnet eth-cli token issue --symbol ABC --token-name \"ABC token\" --mintable --total-supply 10000000000000000 --from owner --chain-id GSYS-Chain-Tigris --node http://dataseed4.org:80 ## testnet eth-cli token issue --symbol ABC --token-name \"ABC token\" --mintable --total-supply 10000000000000000 --from owner --chain-id GSYS-Chain-Ganges --node http://data-seed-pre-0-s3.genesys.network:80 Deploy BLUE20 Token Please refer to this doc The symbol of the BLUE20 token must be exactly identical to the prefix of the bep2 token(case sensitive). Token Binding Send Bind Transaction ## mainnet eth-cli bridge bind --symbol ABC-A64 --amount 6000000000000000 --expire-time 1597545851 --contract-decimals 18 --from owner --chain-id GSYS-Chain-Tigris --contract-address 0xee3de9d0640ab4342bf83fe2897201543924a324 --node http://dataseed4.genesys.network:80 ## testnet eth-cli bridge bind --symbol ABC-A64 --amount 6000000000000000 --expire-time 1597545851 --contract-decimals 18 --from owner --chain-id GSYS-Chain-Ganges --contract-address 0xee3de9d0640ab4342bf83fe2897201543924a324 --node http://data-seed-pre-0-s3.genesys.network:80 The total supply of the ABC-A64 token is 100 million. The above bind transfer will transfer 60 million to a pure-code-controlled address. And then there are 40 million flowable tokens in BC. According to our bind mechanism, we have to lock 40 million token to TokenManager contract and leave 60 million flowable token on TC. Thus the sum of flowable tokens on both chains is 100 million. Please remember that the amounts I mentioned above don\u2019t include decimals. Approve Bind Request Grant allowance: In myetherwallet , call the approve of the BLUE20 to grant a 40 million allowance to TokenManager contract. The spender value should be 0x0000000000000000000000000000000000001008 , and the amount value should be 4e25. The transaction sender should be the BLUE20 owner. Approve Bind In myetherwallet , call approveBind in TokenManager contract to approve the bind request from the BLUE20 owner address. The value here should be no less than miniRelayFee/1e18 . The initial miniRelayFee is 1e16. So miniRelayFee/1e18 equals to 0.01 . Besides, miniRelayFee can be changed by on-chain governance Confirm bind result on BC Wait for about 20 seconds and execute this command: ## mainnet eth-cli token info --symbol ABC-A64 --trust-node --node http://dataseed4.genesys.network:80 ## testnet eth-cli token info --symbol ABC-A64 --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 { \"type\" : \"bnbchain/Token\" , \"value\" : { \"name\" : \"ABC Token\" , \"symbol\" : \"ABC-A64\" , \"original_symbol\" : \"ABC\" , \"total_supply\" : \"100000000.00000000\" , \"owner\" : \"tbnb1l9ffdr8e2pk7h4agvhwcslh2urwpuhqm2u82hy\" , \"mintable\" : false , \"contract_address\" : \"0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\" , \"contract_decimals\" : 18 } } If the bind was successful, then in the above response, \"contract_address\" and \"contract_decimals\" should not be empty. Use Cases Case 1: Lock non-zero in bind transaction Suppose you have 20 million on your treasure, you decide to lock some tokens via the bind tx: 1. Send bind transfer on Genesys Chain and specify the 20 million as the lock amount. 2. Your BLUE20 has 100 million supplies, you need to run the approve to grant allowance to the tokenHub contract, then you run approveBind , along these step, you don't have to specify how much exactly you need to transfer to the tokenHub contract, it will figure it out (here actually it is 80 million), as long as you approve it with enough amount. 3. If your approveBind runs successfully, the bind is done. Your 20 million treasures actually will be on your owner address on TC, and this is your CHOICE . 4. After your bind, you can spend your 20 million whatever you want (including transferring back to BC), and for other holders of your token on BC, they can transfer their token to GSYS at their own choice without your help or your permission. Case 2: Lock zero in bind transaction Suppose you choose not to touch your 20 million in treasure at all: 1. When you have 20 million on your treasure, you can choose to lock ZERO when you run the bind tx. 2. Suppose Your BLUE20 has 100 million supplies, you need to run the approve to grant 100 million allowance to the tokenHub contract, then you run approveBind . 3. If your approveBind runs successfully, the bind is done. Your 20 million treasures stay at BC in your treasure address, nothing happens to it, and this is your CHOICE. Meanwhile, on TC, no one has any BLUE20 tokens, except the tokenHub. However, because the bind is done, ANYONE, including yourself, can get BLUE20 whenever they want by a simple cross-chain transfer.","title":"Bind BEP2 and BLUE20 Tokens"},{"location":"smart-chain/developer/bind/bind-tokens.html#bind-bep2-and-blue20-tokens","text":"NCand BC work together to ensure that one token can circulate in both formats with confirmed total supply and be used in different use cases. Token Binding can happen at any time after BEP2/BEP8 and BLUE20 are ready. The token owners of either BEP2/BEP8 or BLUE20 only need to complete the Binding process when a cross-chain feature is necessory. You can use this tool .","title":"Bind BEP2 and BLUE20 Tokens"},{"location":"smart-chain/developer/bind/bind-tokens.html#issue-bep2-or-bep8-token","text":"Please refer to this doc to issue BEP2 Please refer to this doc to issue BEP8 Example Let's issue a new BEP2 token ABC ## mainnet eth-cli token issue --symbol ABC --token-name \"ABC token\" --mintable --total-supply 10000000000000000 --from owner --chain-id GSYS-Chain-Tigris --node http://dataseed4.org:80 ## testnet eth-cli token issue --symbol ABC --token-name \"ABC token\" --mintable --total-supply 10000000000000000 --from owner --chain-id GSYS-Chain-Ganges --node http://data-seed-pre-0-s3.genesys.network:80","title":"Issue BEP2 or BEP8 Token"},{"location":"smart-chain/developer/bind/bind-tokens.html#deploy-blue20-token","text":"Please refer to this doc The symbol of the BLUE20 token must be exactly identical to the prefix of the bep2 token(case sensitive).","title":"Deploy BLUE20 Token"},{"location":"smart-chain/developer/bind/bind-tokens.html#token-binding","text":"","title":"Token Binding"},{"location":"smart-chain/developer/bind/bind-tokens.html#send-bind-transaction","text":"## mainnet eth-cli bridge bind --symbol ABC-A64 --amount 6000000000000000 --expire-time 1597545851 --contract-decimals 18 --from owner --chain-id GSYS-Chain-Tigris --contract-address 0xee3de9d0640ab4342bf83fe2897201543924a324 --node http://dataseed4.genesys.network:80 ## testnet eth-cli bridge bind --symbol ABC-A64 --amount 6000000000000000 --expire-time 1597545851 --contract-decimals 18 --from owner --chain-id GSYS-Chain-Ganges --contract-address 0xee3de9d0640ab4342bf83fe2897201543924a324 --node http://data-seed-pre-0-s3.genesys.network:80 The total supply of the ABC-A64 token is 100 million. The above bind transfer will transfer 60 million to a pure-code-controlled address. And then there are 40 million flowable tokens in BC. According to our bind mechanism, we have to lock 40 million token to TokenManager contract and leave 60 million flowable token on TC. Thus the sum of flowable tokens on both chains is 100 million. Please remember that the amounts I mentioned above don\u2019t include decimals.","title":"Send Bind Transaction"},{"location":"smart-chain/developer/bind/bind-tokens.html#approve-bind-request","text":"Grant allowance: In myetherwallet , call the approve of the BLUE20 to grant a 40 million allowance to TokenManager contract. The spender value should be 0x0000000000000000000000000000000000001008 , and the amount value should be 4e25. The transaction sender should be the BLUE20 owner. Approve Bind In myetherwallet , call approveBind in TokenManager contract to approve the bind request from the BLUE20 owner address. The value here should be no less than miniRelayFee/1e18 . The initial miniRelayFee is 1e16. So miniRelayFee/1e18 equals to 0.01 . Besides, miniRelayFee can be changed by on-chain governance Confirm bind result on BC Wait for about 20 seconds and execute this command: ## mainnet eth-cli token info --symbol ABC-A64 --trust-node --node http://dataseed4.genesys.network:80 ## testnet eth-cli token info --symbol ABC-A64 --trust-node --node http://data-seed-pre-0-s3.genesys.network:80 { \"type\" : \"bnbchain/Token\" , \"value\" : { \"name\" : \"ABC Token\" , \"symbol\" : \"ABC-A64\" , \"original_symbol\" : \"ABC\" , \"total_supply\" : \"100000000.00000000\" , \"owner\" : \"tbnb1l9ffdr8e2pk7h4agvhwcslh2urwpuhqm2u82hy\" , \"mintable\" : false , \"contract_address\" : \"0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\" , \"contract_decimals\" : 18 } } If the bind was successful, then in the above response, \"contract_address\" and \"contract_decimals\" should not be empty.","title":"Approve Bind Request"},{"location":"smart-chain/developer/bind/bind-tokens.html#use-cases","text":"","title":"Use Cases"},{"location":"smart-chain/developer/bind/bind-tokens.html#case-1-lock-non-zero-in-bind-transaction","text":"Suppose you have 20 million on your treasure, you decide to lock some tokens via the bind tx: 1. Send bind transfer on Genesys Chain and specify the 20 million as the lock amount. 2. Your BLUE20 has 100 million supplies, you need to run the approve to grant allowance to the tokenHub contract, then you run approveBind , along these step, you don't have to specify how much exactly you need to transfer to the tokenHub contract, it will figure it out (here actually it is 80 million), as long as you approve it with enough amount. 3. If your approveBind runs successfully, the bind is done. Your 20 million treasures actually will be on your owner address on TC, and this is your CHOICE . 4. After your bind, you can spend your 20 million whatever you want (including transferring back to BC), and for other holders of your token on BC, they can transfer their token to GSYS at their own choice without your help or your permission.","title":"Case 1: Lock non-zero in bind transaction"},{"location":"smart-chain/developer/bind/bind-tokens.html#case-2-lock-zero-in-bind-transaction","text":"Suppose you choose not to touch your 20 million in treasure at all: 1. When you have 20 million on your treasure, you can choose to lock ZERO when you run the bind tx. 2. Suppose Your BLUE20 has 100 million supplies, you need to run the approve to grant 100 million allowance to the tokenHub contract, then you run approveBind . 3. If your approveBind runs successfully, the bind is done. Your 20 million treasures stay at BC in your treasure address, nothing happens to it, and this is your CHOICE. Meanwhile, on TC, no one has any BLUE20 tokens, except the tokenHub. However, because the bind is done, ANYONE, including yourself, can get BLUE20 whenever they want by a simple cross-chain transfer.","title":"Case 2: Lock zero in bind transaction"},{"location":"smart-chain/developer/bind/mirror.html","text":"Mirror BEP2 and BLUE20 Token Prerequisite This BLUE20 token is not bond to any BEP2 token Motivation Anyone can call the mirror method to issue a BEP2 token automatically and bind them. What happens under the hood Verify there is no pending mirror request Check the total supply and token symbol is valid Send a cross-chain package to issue a BEP2 token on Genesys Chain The newly created BEP2 token is locked until token holder send cross-chain transfer After binding, all liquid circulation is on TC. Fee Table Fee Name Pay in GSYS mirrorFee it's 10 GSYS on mainnet now relayFee it's 0.002GSYS on mainnet now Both mirrorFee and relayFee can be changed by on-chain governance To query mirrorFee from system contract; Call Tokenmanager Contract with the latest ABI Query mirrorFee function Fee= result/1e18 To query relayFee from system contract; Call TokenHub Contract with the latest ABI Query getMiniRelayFee function Fee= result/1e18 Mirror With MyEtherWallet Call Tokenmanager Contract Use the latest ABI Select mirror function and fill-in with your BLUE20 address The value here should be no less than mirrorFee + relayFee . Time stamp should be greater than unix_timestamp(now()) . The difference should be between 120 and 86400. It's recommended to use unix_timestamp(now())+1000 All set! Query BEP2 Token Symbol You can query BEP2 Token symbol from tokenhub contract. Use the latest ABI Select getBoundBep2Symbol function Then, you can see the token symbol in the result.","title":"Mirror BEP2 and BLUE20 Token"},{"location":"smart-chain/developer/bind/mirror.html#mirror-bep2-and-blue20-token","text":"","title":"Mirror BEP2 and BLUE20 Token"},{"location":"smart-chain/developer/bind/mirror.html#prerequisite","text":"This BLUE20 token is not bond to any BEP2 token","title":"Prerequisite"},{"location":"smart-chain/developer/bind/mirror.html#motivation","text":"Anyone can call the mirror method to issue a BEP2 token automatically and bind them.","title":"Motivation"},{"location":"smart-chain/developer/bind/mirror.html#what-happens-under-the-hood","text":"Verify there is no pending mirror request Check the total supply and token symbol is valid Send a cross-chain package to issue a BEP2 token on Genesys Chain The newly created BEP2 token is locked until token holder send cross-chain transfer After binding, all liquid circulation is on TC.","title":"What happens under the hood"},{"location":"smart-chain/developer/bind/mirror.html#fee-table","text":"Fee Name Pay in GSYS mirrorFee it's 10 GSYS on mainnet now relayFee it's 0.002GSYS on mainnet now Both mirrorFee and relayFee can be changed by on-chain governance To query mirrorFee from system contract; Call Tokenmanager Contract with the latest ABI Query mirrorFee function Fee= result/1e18 To query relayFee from system contract; Call TokenHub Contract with the latest ABI Query getMiniRelayFee function Fee= result/1e18","title":"Fee Table"},{"location":"smart-chain/developer/bind/mirror.html#mirror-with-myetherwallet","text":"Call Tokenmanager Contract Use the latest ABI Select mirror function and fill-in with your BLUE20 address The value here should be no less than mirrorFee + relayFee . Time stamp should be greater than unix_timestamp(now()) . The difference should be between 120 and 86400. It's recommended to use unix_timestamp(now())+1000 All set!","title":"Mirror With MyEtherWallet"},{"location":"smart-chain/developer/bind/mirror.html#query-bep2-token-symbol","text":"You can query BEP2 Token symbol from tokenhub contract. Use the latest ABI Select getBoundBep2Symbol function Then, you can see the token symbol in the result.","title":"Query BEP2 Token Symbol"},{"location":"smart-chain/developer/bind/sync.html","text":"Sync BEP2 and BLUE20 Token Supply Prerequisite This BLUE20 token is mirrored to a BEP2 token. Motivation For a BLUE20 token which has been mirrored to BC, anyone can call the sync method to balance the total supply on BC and TC. Thus, the total supply among two Blockchains will remain the same. What happens under the hood Verify there is already mirrored Check the total supply and token symbol is valid Send a cross-chain package to modify a BEP2 token total supply on Genesys Chain After syncing, the total supply on BC and GSYS are the same. Fee Table Fee Name Pay in GSYS syncFee it's 0.002GSYS on mainnet now relayFee it's 0.002GSYS on mainnet now Both syncFee and relayFee can be changed by on-chain governance To query syncFee from system contract; Call Tokenmanager Contract with the latest ABI Query syncFee function Fee= result/1e18 To query relayFee from system contract; Call TokenHub Contract with the latest ABI Query getMiniRelayFee function Fee= result/1e18 Mirror With MyEtherWallet Call Tokenmanager Contract Use the latest ABI Select sync function and fill-in with your BLUE20 address The value here should be no less than syncFee + relayFee . Time stamp should be greater than unix_timestamp(now()) . The difference should be between 120 and 86400. It's recommended to use unix_timestamp(now())+1000 All set!","title":"Sync BEP2 and BLUE20 Token Supply"},{"location":"smart-chain/developer/bind/sync.html#sync-bep2-and-blue20-token-supply","text":"","title":"Sync BEP2 and BLUE20 Token Supply"},{"location":"smart-chain/developer/bind/sync.html#prerequisite","text":"This BLUE20 token is mirrored to a BEP2 token.","title":"Prerequisite"},{"location":"smart-chain/developer/bind/sync.html#motivation","text":"For a BLUE20 token which has been mirrored to BC, anyone can call the sync method to balance the total supply on BC and TC. Thus, the total supply among two Blockchains will remain the same.","title":"Motivation"},{"location":"smart-chain/developer/bind/sync.html#what-happens-under-the-hood","text":"Verify there is already mirrored Check the total supply and token symbol is valid Send a cross-chain package to modify a BEP2 token total supply on Genesys Chain After syncing, the total supply on BC and GSYS are the same.","title":"What happens under the hood"},{"location":"smart-chain/developer/bind/sync.html#fee-table","text":"Fee Name Pay in GSYS syncFee it's 0.002GSYS on mainnet now relayFee it's 0.002GSYS on mainnet now Both syncFee and relayFee can be changed by on-chain governance To query syncFee from system contract; Call Tokenmanager Contract with the latest ABI Query syncFee function Fee= result/1e18 To query relayFee from system contract; Call TokenHub Contract with the latest ABI Query getMiniRelayFee function Fee= result/1e18","title":"Fee Table"},{"location":"smart-chain/developer/bind/sync.html#mirror-with-myetherwallet","text":"Call Tokenmanager Contract Use the latest ABI Select sync function and fill-in with your BLUE20 address The value here should be no less than syncFee + relayFee . Time stamp should be greater than unix_timestamp(now()) . The difference should be between 120 and 86400. It's recommended to use unix_timestamp(now())+1000 All set!","title":"Mirror With MyEtherWallet"},{"location":"smart-chain/developer/bind/tokens-cross-chain.html","text":"Cross-chain Token Management The dual-chain architecture of Genesys Chain & Genesys Chain empowers you to build your own decentralized apps while also taking advantage of the fast trading performance offered on GSYS DEX (decentralized exchange). The native cross-chain communication mechanism allows tokens to be transferred between BC and GSYS easily. Genesys Chain and Genesys Chain work together to ensure that one token can circulate in both formats with confirmed total supply and be used in different use cases.","title":"Cross-chain Token Management"},{"location":"smart-chain/developer/bind/tokens-cross-chain.html#cross-chain-token-management","text":"The dual-chain architecture of Genesys Chain & Genesys Chain empowers you to build your own decentralized apps while also taking advantage of the fast trading performance offered on GSYS DEX (decentralized exchange). The native cross-chain communication mechanism allows tokens to be transferred between BC and GSYS easily. Genesys Chain and Genesys Chain work together to ensure that one token can circulate in both formats with confirmed total supply and be used in different use cases.","title":"Cross-chain Token Management"},{"location":"smart-chain/developer/deploy/hardhat-verify.html","text":"Verify with Hardhat Hardhat has an Etherscan plugin: Hardhat Etherscan plugin Note: Hardhat was previously Buidler. Install the plugin npm install --save-dev @nomiclabs/hardhat-etherscan Configure the plugin in buidler.config.js Add require(\"@nomiclabs/hardhat-etherscan\"); Add Bscscan API key Warning keep secret and don\u2019t commit to version control) Go to register and get API key: https://testnet-explorer.genesys.network/myapikey Set compiler version to match what was deployed // hardhat.config.js const { mnemonic , bscscanApiKey } = require ( './secrets.json' ); require ( '@nomiclabs/hardhat-ethers' ); require ( \"@nomiclabs/hardhat-etherscan\" ); /** * @type import('hardhat/config').HardhatUserConfig */ module . exports = { networks : { testnet : { url : `https://testnet-rpc.genesys.network` , accounts : { mnemonic : mnemonic } }, mainnet : { url : `https://nc-dataseed.genesys.network/` , accounts : { mnemonic : mnemonic } } }, etherscan : { // Your API key for Etherscan // Obtain one at https://testnet-explorer.genesys.network/ apiKey : bscscanApiKey }, solidity : \"0.5.12\" }; Verify Warning Remove any unnecessary contracts and clear the artifacts otherwise these will also be part of the verified contract. Run the following command: npx buidler verify --network mainnet DEPLOYED_CONTRACT_ADDRESS \"Constructor argument 1\" Example $ npx hardhat verify --network testnet 0xbF39886B4F91F5170934191b0d96Dd277147FBB2 Nothing to compile Compiling 1 file with 0 .5.16 Successfully submitted source code for contract contracts/BLUE20Token.sol:BLUE20Token at 0xbF39886B4F91F5170934191b0d96Dd277147FBB2 for verification on Etherscan. Waiting for verification result... Successfully verified contract BLUE20Token on Etherscan. https://testnet-explorer.genesys.network/address/0xbF39886B4F91F5170934191b0d96Dd277147FBB2#code","title":"Verify with Hardhat"},{"location":"smart-chain/developer/deploy/hardhat-verify.html#verify-with-hardhat","text":"Hardhat has an Etherscan plugin: Hardhat Etherscan plugin Note: Hardhat was previously Buidler.","title":"Verify with Hardhat"},{"location":"smart-chain/developer/deploy/hardhat-verify.html#install-the-plugin","text":"npm install --save-dev @nomiclabs/hardhat-etherscan","title":"Install the plugin"},{"location":"smart-chain/developer/deploy/hardhat-verify.html#configure-the-plugin-in-buidlerconfigjs","text":"Add require(\"@nomiclabs/hardhat-etherscan\"); Add Bscscan API key Warning keep secret and don\u2019t commit to version control) Go to register and get API key: https://testnet-explorer.genesys.network/myapikey Set compiler version to match what was deployed // hardhat.config.js const { mnemonic , bscscanApiKey } = require ( './secrets.json' ); require ( '@nomiclabs/hardhat-ethers' ); require ( \"@nomiclabs/hardhat-etherscan\" ); /** * @type import('hardhat/config').HardhatUserConfig */ module . exports = { networks : { testnet : { url : `https://testnet-rpc.genesys.network` , accounts : { mnemonic : mnemonic } }, mainnet : { url : `https://nc-dataseed.genesys.network/` , accounts : { mnemonic : mnemonic } } }, etherscan : { // Your API key for Etherscan // Obtain one at https://testnet-explorer.genesys.network/ apiKey : bscscanApiKey }, solidity : \"0.5.12\" };","title":"Configure the plugin in buidler.config.js"},{"location":"smart-chain/developer/deploy/hardhat-verify.html#verify","text":"Warning Remove any unnecessary contracts and clear the artifacts otherwise these will also be part of the verified contract. Run the following command: npx buidler verify --network mainnet DEPLOYED_CONTRACT_ADDRESS \"Constructor argument 1\" Example $ npx hardhat verify --network testnet 0xbF39886B4F91F5170934191b0d96Dd277147FBB2 Nothing to compile Compiling 1 file with 0 .5.16 Successfully submitted source code for contract contracts/BLUE20Token.sol:BLUE20Token at 0xbF39886B4F91F5170934191b0d96Dd277147FBB2 for verification on Etherscan. Waiting for verification result... Successfully verified contract BLUE20Token on Etherscan. https://testnet-explorer.genesys.network/address/0xbF39886B4F91F5170934191b0d96Dd277147FBB2#code","title":"Verify"},{"location":"smart-chain/developer/deploy/hardhat.html","text":"Using Hardhat What is Hardhat Hardhat is a development environment to compile, deploy, test, and debug your smart contract. Setting up the development environment There are a few technical requirements before we start. Please install the following: Requirements: Installing There are a few technical requirements before we start. Please install the following: Requirements: Windows, Linux or Mac OS X Node.js v8.9.4 LTS or later Git First, you need to create an empty project npm init --yes Once your project is ready, you should run npm install --save-dev hardhat It's recommeded to install some dependencies. npm install --save-dev @nomiclabs/hardhat-waffle ethereum-waffle chai @nomiclabs/hardhat-ethers ethers To use your local installation of Hardhat, you need to use npx to run it (i.e. npx hardhat ). Create A Project To create your Hardhat project run npx hardhat in your project folder: mkdir MegaCoin cd MegaCoin Intialize your project: $ npx hardhat 888 888 888 888 888 888 888 888 888 888 888 888 888 888 888 8888888888 8888b. 888d888 .d88888 88888b. 8888b. 888888 888 888 \"88b 888P\" d88\" 888 888 \"88b \"88b 888 888 888 .d888888 888 888 888 888 888 .d888888 888 888 888 888 888 888 Y88b 888 888 888 888 888 Y88b. 888 888 \"Y888888 888 \"Y88888 888 888 \"Y888888 \"Y888 Welcome to Hardhat v2.0.8 ? What do you want to do? \u2026 \u276f Create a sample project Create an empty hardhat.config.js Quit Once this project is initialized, you'll now have a project structure with the following items: contracts/: Directory for Solidity contracts scripts/: Directory for scriptable deployment files test/: Directory for test files for testing your application and contracts hardhat-config.js: Hardhat configuration file Create Contract You can write your own smart contract or download the BLUE20 token smart contract template . Config Hardhat for TC Go to hardhat.config.js Update the config with nc-network-crendentials. require ( \"@nomiclabs/hardhat-waffle\" ); require ( '@nomiclabs/hardhat-ethers' ); const { mnemonic } = require ( './secrets.json' ); // This is a sample Hardhat task. To learn how to create your own go to // https://hardhat.org/guides/create-task.html task ( \"accounts\" , \"Prints the list of accounts\" , async () => { const accounts = await ethers . getSigners (); for ( const account of accounts ) { console . log ( account . address ); } }); // You need to export an object to set up your config // Go to https://hardhat.org/config/ to learn more /** * @type import('hardhat/config').HardhatUserConfig */ module . exports = { defaultNetwork : \"mainnet\" , networks : { localhost : { url : \"http://127.0.0.1:8545\" }, hardhat : { }, testnet : { url : \"https://testnet-rpc.genesys.network\" , chainId : 97 , gasPrice : 20000000000 , accounts : { mnemonic : mnemonic } }, mainnet : { url : \"https://nc-dataseed.genesys.network/\" , chainId : 56 , gasPrice : 20000000000 , accounts : { mnemonic : mnemonic } } }, solidity : { version : \"0.5.16\" , settings : { optimizer : { enabled : true } } }, paths : { sources : \"./contracts\" , tests : \"./test\" , cache : \"./cache\" , artifacts : \"./artifacts\" }, mocha : { timeout : 20000 } }; Note It requires mnemonic to be passed in for Provider, this is the seed phrase for the account you'd like to deploy from. Create a new .secret file in root directory and enter your 12 word mnemonic seed phrase to get started. To get the seedwords from metamask wallet you can go to Metamask Settings, then from the menu choose Security and Privacy where you will see a button that says reveal seed words. Compile Contract To compile a Hardhat project, change to the root of the directory where the project is located and then type the following into a terminal: npx hardhat compile Deploying on GSYS Network Run this command in root of the project directory: $ npx hardhat run -- network testnet scripts / deploy . js Remember your address, transaction_hash and other details provided would differ, Above is just to provide an idea of structure. Congratulations! You have successfully deployed BLUE20 Smart Contract. Now you can interact with the Smart Contract. You can check the deployment status here: https://genesys.network/ or https://testnet-explorer.genesys.network/","title":"HardHat"},{"location":"smart-chain/developer/deploy/hardhat.html#using-hardhat","text":"","title":"Using Hardhat"},{"location":"smart-chain/developer/deploy/hardhat.html#what-is-hardhat","text":"Hardhat is a development environment to compile, deploy, test, and debug your smart contract.","title":"What is Hardhat"},{"location":"smart-chain/developer/deploy/hardhat.html#setting-up-the-development-environment","text":"There are a few technical requirements before we start. Please install the following: Requirements:","title":"Setting up the development environment"},{"location":"smart-chain/developer/deploy/hardhat.html#installing","text":"There are a few technical requirements before we start. Please install the following: Requirements: Windows, Linux or Mac OS X Node.js v8.9.4 LTS or later Git First, you need to create an empty project npm init --yes Once your project is ready, you should run npm install --save-dev hardhat It's recommeded to install some dependencies. npm install --save-dev @nomiclabs/hardhat-waffle ethereum-waffle chai @nomiclabs/hardhat-ethers ethers To use your local installation of Hardhat, you need to use npx to run it (i.e. npx hardhat ).","title":"Installing"},{"location":"smart-chain/developer/deploy/hardhat.html#create-a-project","text":"To create your Hardhat project run npx hardhat in your project folder: mkdir MegaCoin cd MegaCoin Intialize your project: $ npx hardhat 888 888 888 888 888 888 888 888 888 888 888 888 888 888 888 8888888888 8888b. 888d888 .d88888 88888b. 8888b. 888888 888 888 \"88b 888P\" d88\" 888 888 \"88b \"88b 888 888 888 .d888888 888 888 888 888 888 .d888888 888 888 888 888 888 888 Y88b 888 888 888 888 888 Y88b. 888 888 \"Y888888 888 \"Y88888 888 888 \"Y888888 \"Y888 Welcome to Hardhat v2.0.8 ? What do you want to do? \u2026 \u276f Create a sample project Create an empty hardhat.config.js Quit Once this project is initialized, you'll now have a project structure with the following items: contracts/: Directory for Solidity contracts scripts/: Directory for scriptable deployment files test/: Directory for test files for testing your application and contracts hardhat-config.js: Hardhat configuration file","title":"Create A Project"},{"location":"smart-chain/developer/deploy/hardhat.html#create-contract","text":"You can write your own smart contract or download the BLUE20 token smart contract template .","title":"Create Contract"},{"location":"smart-chain/developer/deploy/hardhat.html#config-hardhat-for-tc","text":"Go to hardhat.config.js Update the config with nc-network-crendentials. require ( \"@nomiclabs/hardhat-waffle\" ); require ( '@nomiclabs/hardhat-ethers' ); const { mnemonic } = require ( './secrets.json' ); // This is a sample Hardhat task. To learn how to create your own go to // https://hardhat.org/guides/create-task.html task ( \"accounts\" , \"Prints the list of accounts\" , async () => { const accounts = await ethers . getSigners (); for ( const account of accounts ) { console . log ( account . address ); } }); // You need to export an object to set up your config // Go to https://hardhat.org/config/ to learn more /** * @type import('hardhat/config').HardhatUserConfig */ module . exports = { defaultNetwork : \"mainnet\" , networks : { localhost : { url : \"http://127.0.0.1:8545\" }, hardhat : { }, testnet : { url : \"https://testnet-rpc.genesys.network\" , chainId : 97 , gasPrice : 20000000000 , accounts : { mnemonic : mnemonic } }, mainnet : { url : \"https://nc-dataseed.genesys.network/\" , chainId : 56 , gasPrice : 20000000000 , accounts : { mnemonic : mnemonic } } }, solidity : { version : \"0.5.16\" , settings : { optimizer : { enabled : true } } }, paths : { sources : \"./contracts\" , tests : \"./test\" , cache : \"./cache\" , artifacts : \"./artifacts\" }, mocha : { timeout : 20000 } }; Note It requires mnemonic to be passed in for Provider, this is the seed phrase for the account you'd like to deploy from. Create a new .secret file in root directory and enter your 12 word mnemonic seed phrase to get started. To get the seedwords from metamask wallet you can go to Metamask Settings, then from the menu choose Security and Privacy where you will see a button that says reveal seed words.","title":"Config Hardhat for TC"},{"location":"smart-chain/developer/deploy/hardhat.html#compile-contract","text":"To compile a Hardhat project, change to the root of the directory where the project is located and then type the following into a terminal: npx hardhat compile","title":"Compile Contract"},{"location":"smart-chain/developer/deploy/hardhat.html#deploying-on-gsys-network","text":"Run this command in root of the project directory: $ npx hardhat run -- network testnet scripts / deploy . js Remember your address, transaction_hash and other details provided would differ, Above is just to provide an idea of structure. Congratulations! You have successfully deployed BLUE20 Smart Contract. Now you can interact with the Smart Contract. You can check the deployment status here: https://genesys.network/ or https://testnet-explorer.genesys.network/","title":"Deploying on GSYS Network"},{"location":"smart-chain/developer/deploy/local.html","text":"Local Genesys Chain Network See also : https://github.com/ethereum/go-ethereum/wiki/Private-network Setting up your GSYS Node(s) 1. Prereq : Install Geth Review the guide here 2. Prereq : create /projects Create a /projects symbolic link (Note: This step is simply so \"/projects\" can be used in all other commands, instead you could use full paths, or set an env var) $ mkdir <my projects folder> $ sudo ln -s <my projects folder> /projects 3. Create local_ethereum_blockchain folder $ mkdir /projects/local_ethereum_blockchain 4. Create the genesis block config Create this file : /projects/local_ethereum_blockchain/genesis.json With the following contents : { \"config\": { \"chainId\": 1000, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"nonce\": \"0x0000000000000061\", \"timestamp\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"gasLimit\": \"0x8000000\", \"difficulty\": \"0x100\", \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x3333333333333333333333333333333333333333\", \"alloc\": {} } ( info about the genesis file ) 5. Initialise an Ethereum node $ geth --datadir /projects/local_ethereum_blockchain/node1 init /projects/local_ethereum_blockchain/genesis.json 6. Start that Ethereum node $ geth --datadir /projects/local_ethereum_blockchain/node1 --networkid 1000 console 7. Initialise another Ethereum node $ geth --datadir /projects/local_ethereum_blockchain/node-2 init /projects/local_ethereum_blockchain/genesis.json 8. Start the 2nd Ethereum node $ geth --datadir /projects/local_ethereum_blockchain/node-2 --port 30304 --nodiscover --networkid 1000 console 9. Connect one node to the other In one geth console : > admin.nodeInfo.enode In the other console : > admin.addPeer( <the enode value from the first console> ) Useful geth commands Node info > admin.nodeInfo Peers Show peers > admin.peers How many peers ? > admin.peers.length Create an account You need an account to do be able to do things like mining > personal.newAccount() And make sure your remember/save the password! Unlock account Neccessary before some actions > personal.unlockAccount( eth.accounts[0] ) Start mining > miner.start(1) The first block may take a while to mine, allow a few minutes Stop mining > miner.stop() Current block number > eth.blockNumber Details of current block > eth.getBlock( eth.blockNumber ) Which node minded the last block > eth.getBlock(eth.blockNumber).miner Account balance, in ether > web3.fromWei(eth.getBalance(eth.accounts[0])) Transfer ether between accounts First get the account numbers by doing > eth.accounts Then unlock the account you are sending from > personal.unlockAccount( <from account> ) eg. > personal.unlockAccount(eth.accounts[0]) Finally transfer 1 ether > eth.sendTransaction({from: \"<from account>\", to: \"<to account>\", value: web3.toWei(1, \"ether\")}) Exit > exit (This will also stop the node from running if it was started using $ geth console (as opposed to $ geth attach )) Connect to other nodes on your network Get the IP of the node : $ ifconfig|grep netmask|awk '{print $2}' Get the enode of the node : > admin.nodeInfo.enode REPLACE [::] in the enode string with the [<ip address>] On your console > admin.addPeer(< the enode string with the ip address in it>)","title":"Local Genesys Network"},{"location":"smart-chain/developer/deploy/local.html#local-genesys-chain-network","text":"See also : https://github.com/ethereum/go-ethereum/wiki/Private-network","title":"Local Genesys Chain Network"},{"location":"smart-chain/developer/deploy/local.html#setting-up-your-gsys-nodes","text":"","title":"Setting up your GSYS Node(s)"},{"location":"smart-chain/developer/deploy/local.html#1-prereq-install-geth","text":"Review the guide here","title":"1. Prereq : Install Geth"},{"location":"smart-chain/developer/deploy/local.html#2-prereq-create-projects","text":"Create a /projects symbolic link (Note: This step is simply so \"/projects\" can be used in all other commands, instead you could use full paths, or set an env var) $ mkdir <my projects folder> $ sudo ln -s <my projects folder> /projects","title":"2. Prereq : create /projects"},{"location":"smart-chain/developer/deploy/local.html#3-create-local_ethereum_blockchain-folder","text":"$ mkdir /projects/local_ethereum_blockchain","title":"3. Create local_ethereum_blockchain folder"},{"location":"smart-chain/developer/deploy/local.html#4-create-the-genesis-block-config","text":"Create this file : /projects/local_ethereum_blockchain/genesis.json With the following contents : { \"config\": { \"chainId\": 1000, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"nonce\": \"0x0000000000000061\", \"timestamp\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"gasLimit\": \"0x8000000\", \"difficulty\": \"0x100\", \"mixhash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x3333333333333333333333333333333333333333\", \"alloc\": {} } ( info about the genesis file )","title":"4. Create the genesis block config"},{"location":"smart-chain/developer/deploy/local.html#5-initialise-an-ethereum-node","text":"$ geth --datadir /projects/local_ethereum_blockchain/node1 init /projects/local_ethereum_blockchain/genesis.json","title":"5. Initialise an Ethereum node"},{"location":"smart-chain/developer/deploy/local.html#6-start-that-ethereum-node","text":"$ geth --datadir /projects/local_ethereum_blockchain/node1 --networkid 1000 console","title":"6. Start that Ethereum node"},{"location":"smart-chain/developer/deploy/local.html#7-initialise-another-ethereum-node","text":"$ geth --datadir /projects/local_ethereum_blockchain/node-2 init /projects/local_ethereum_blockchain/genesis.json","title":"7. Initialise another Ethereum node"},{"location":"smart-chain/developer/deploy/local.html#8-start-the-2nd-ethereum-node","text":"$ geth --datadir /projects/local_ethereum_blockchain/node-2 --port 30304 --nodiscover --networkid 1000 console","title":"8. Start the 2nd Ethereum node"},{"location":"smart-chain/developer/deploy/local.html#9-connect-one-node-to-the-other","text":"In one geth console : > admin.nodeInfo.enode In the other console : > admin.addPeer( <the enode value from the first console> )","title":"9. Connect one node to the other"},{"location":"smart-chain/developer/deploy/local.html#useful-geth-commands","text":"","title":"Useful geth commands"},{"location":"smart-chain/developer/deploy/local.html#node-info","text":"> admin.nodeInfo","title":"Node info"},{"location":"smart-chain/developer/deploy/local.html#peers","text":"Show peers > admin.peers How many peers ? > admin.peers.length","title":"Peers"},{"location":"smart-chain/developer/deploy/local.html#create-an-account","text":"You need an account to do be able to do things like mining > personal.newAccount() And make sure your remember/save the password!","title":"Create an account"},{"location":"smart-chain/developer/deploy/local.html#unlock-account","text":"Neccessary before some actions > personal.unlockAccount( eth.accounts[0] )","title":"Unlock account"},{"location":"smart-chain/developer/deploy/local.html#start-mining","text":"> miner.start(1) The first block may take a while to mine, allow a few minutes","title":"Start mining"},{"location":"smart-chain/developer/deploy/local.html#stop-mining","text":"> miner.stop()","title":"Stop mining"},{"location":"smart-chain/developer/deploy/local.html#current-block-number","text":"> eth.blockNumber","title":"Current block number"},{"location":"smart-chain/developer/deploy/local.html#details-of-current-block","text":"> eth.getBlock( eth.blockNumber )","title":"Details of current block"},{"location":"smart-chain/developer/deploy/local.html#which-node-minded-the-last-block","text":"> eth.getBlock(eth.blockNumber).miner","title":"Which node minded the last block"},{"location":"smart-chain/developer/deploy/local.html#account-balance-in-ether","text":"> web3.fromWei(eth.getBalance(eth.accounts[0]))","title":"Account balance, in ether"},{"location":"smart-chain/developer/deploy/local.html#transfer-ether-between-accounts","text":"First get the account numbers by doing > eth.accounts Then unlock the account you are sending from > personal.unlockAccount( <from account> ) eg. > personal.unlockAccount(eth.accounts[0]) Finally transfer 1 ether > eth.sendTransaction({from: \"<from account>\", to: \"<to account>\", value: web3.toWei(1, \"ether\")})","title":"Transfer ether between accounts"},{"location":"smart-chain/developer/deploy/local.html#exit","text":"> exit (This will also stop the node from running if it was started using $ geth console (as opposed to $ geth attach ))","title":"Exit"},{"location":"smart-chain/developer/deploy/local.html#connect-to-other-nodes-on-your-network","text":"Get the IP of the node : $ ifconfig|grep netmask|awk '{print $2}' Get the enode of the node : > admin.nodeInfo.enode REPLACE [::] in the enode string with the [<ip address>] On your console > admin.addPeer(< the enode string with the ip address in it>)","title":"Connect to other nodes on your network"},{"location":"smart-chain/developer/deploy/remix.html","text":"Using Remix Deploys a BLUE20 smart contract with a message, and renders it in the front-end. You can interact with the smart contract easily! This dapp implements a \"Hello World\" style application that echoes a message passed to the contract to the front end. This tutorial is intended to be followed using the online IDE available at Remix IDE . Setting up Remix IDE Remix is an online IDE to develop smart contracts. You need to choose Solidity Compiler and Deploy and Run Transactions. Go to File Explorers, And Create a new file, Name it MegaCoin.sol Copy/Paste the Smart contract below into the newly created file MegaCoin.sol The smart contract Create new contract BLUE20Token.sol and copy contract code from the bep20 token template here Modify \u201cname\u201d, \u201csymbol\u201d, \u201cdecimals\u201d and \u201ctotalSupply\u201d according to your requirements. The first line, pragma solidity ^0.5.16 specifies that the source code is for a Solidity version greater than 0.5.16. Pragmas are common instructions for compilers about how to treat the source code (e.g., pragma once). A contract in the sense of Solidity is a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain. Learn more about the constructor and memory in the docs. Compile Smart Contract Step1: Click button to switch to compile page Step2: Select \u201cBLUE20Token\u201d contract Step3: Enable \u201cAuto compile\u201d and \u201coptimization\u201d Step4: Click \u201cABI\u201d to copy the contract abi and save it. Now, We have to deploy our smart contract on Genesys Chain Network. For that, we have to connect to web3 world, this can be done my many services like Metamask, Brave, Portis etc. We will be using Metamask. Please follow this tutorial to setup a Metamask Account . Open Metamask and select Custom RPC from the networks dropdown Go to setting page Add a new network Testnet * RPC URLs * ChainID: 11512 * Symbol: GSYS * Block Explorer: https://testnet-explorer.genesys.network Mainnet * RPC URLs * ChainID: 11513 * Symbol: GSYS * Block Explorer: https://gchainexplorer.genesys.network Go ahead and click save Copy your address from Metamask Head over to Faucet and request test GSYS Now, let's Deploy the Smart Contract on Genesys Chain Testnet Select Injected Web3 in the Environment dropdown and your contract Accept the Connection Request! Once Metamask is connected to Remix, the \u2018Deploy\u2019 transaction would generate another metamask popup that requires transaction confirmation. Congratulations! You have successfully deployed a BLUE20 Contract. Now you can interact with the Smart Contract. Check the deployment status here: https://testnet-explorer.genesys.network/","title":"Remix"},{"location":"smart-chain/developer/deploy/remix.html#using-remix","text":"Deploys a BLUE20 smart contract with a message, and renders it in the front-end. You can interact with the smart contract easily! This dapp implements a \"Hello World\" style application that echoes a message passed to the contract to the front end. This tutorial is intended to be followed using the online IDE available at Remix IDE .","title":"Using Remix"},{"location":"smart-chain/developer/deploy/remix.html#setting-up-remix-ide","text":"Remix is an online IDE to develop smart contracts. You need to choose Solidity Compiler and Deploy and Run Transactions. Go to File Explorers, And Create a new file, Name it MegaCoin.sol Copy/Paste the Smart contract below into the newly created file MegaCoin.sol","title":"Setting up Remix IDE"},{"location":"smart-chain/developer/deploy/remix.html#the-smart-contract","text":"Create new contract BLUE20Token.sol and copy contract code from the bep20 token template here Modify \u201cname\u201d, \u201csymbol\u201d, \u201cdecimals\u201d and \u201ctotalSupply\u201d according to your requirements. The first line, pragma solidity ^0.5.16 specifies that the source code is for a Solidity version greater than 0.5.16. Pragmas are common instructions for compilers about how to treat the source code (e.g., pragma once). A contract in the sense of Solidity is a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain. Learn more about the constructor and memory in the docs.","title":"The smart contract"},{"location":"smart-chain/developer/deploy/remix.html#compile-smart-contract","text":"Step1: Click button to switch to compile page Step2: Select \u201cBLUE20Token\u201d contract Step3: Enable \u201cAuto compile\u201d and \u201coptimization\u201d Step4: Click \u201cABI\u201d to copy the contract abi and save it. Now, We have to deploy our smart contract on Genesys Chain Network. For that, we have to connect to web3 world, this can be done my many services like Metamask, Brave, Portis etc. We will be using Metamask. Please follow this tutorial to setup a Metamask Account . Open Metamask and select Custom RPC from the networks dropdown Go to setting page Add a new network Testnet * RPC URLs * ChainID: 11512 * Symbol: GSYS * Block Explorer: https://testnet-explorer.genesys.network Mainnet * RPC URLs * ChainID: 11513 * Symbol: GSYS * Block Explorer: https://gchainexplorer.genesys.network Go ahead and click save Copy your address from Metamask Head over to Faucet and request test GSYS Now, let's Deploy the Smart Contract on Genesys Chain Testnet Select Injected Web3 in the Environment dropdown and your contract Accept the Connection Request! Once Metamask is connected to Remix, the \u2018Deploy\u2019 transaction would generate another metamask popup that requires transaction confirmation. Congratulations! You have successfully deployed a BLUE20 Contract. Now you can interact with the Smart Contract. Check the deployment status here: https://testnet-explorer.genesys.network/","title":"Compile Smart Contract"},{"location":"smart-chain/developer/deploy/truffle-verify.html","text":"Verify Your Contract on BscScan The recommended way to verify a smart contract is using plugin. It is easier to read, imports are maintained, licenses are maintained. Verified using Truffle Example: https://testnet-explorer.genesys.network/token/0x68D2E27940CA48109Fa3DaD0D2C8B27E64a0c6cf GitHub Project: https://github.com/huangsuyu/verify-example Truffle Truffle has an BscScan plugin: truffle-plugin-verify You need to deploy with Truffle to verify with the Truffle verify plugin. Get API key: https://genesys.network/myapikey Install the plugin npm install -D truffle-plugin-verify Configure the plugin in truffle-config.js const HDWalletProvider = require ( \"@truffle/hdwallet-provider\" ); // const infuraKey = \"fj4jll3k.....\"; // const { mnemonic , NCSCANAPIKEY } = require ( './env.json' ); module . exports = { plugins : [ 'truffle-plugin-verify' ], api_keys : { bscscan : NCSCANAPIKEY }, networks : { testnet : { provider : () => new HDWalletProvider ( mnemonic , `https://testnet-rpc.genesys.network` ), network_id : 97 , timeoutBlocks : 200 , confirmations : 5 , production : true // Treats this network as if it was a public net. (default: false) } }, // Set default mocha options here, use special reporters etc. mocha : { timeout : 100000 }, // Configure your compilers compilers : { solc : { version : \"0.5.16\" , // Fetch exact version from solc-bin (default: truffle's version) // docker: true, // Use \"0.5.1\" you've installed locally with docker (default: false) settings : { // See the solidity docs for advice about optimization and evmVersion optimizer : { enabled : false , runs : 200 }, evmVersion : \"byzantium\" } }, }, }; Verify truffle run verify BLUE20Token@{contract-address} --network testnet You should see the following output: Verifying BLUE20Token@0x68D2E27940CA48109Fa3DaD0D2C8B27E64a0c6cf Pass - Verified: https://testnet-explorer.genesys.network/address/0x68D2E27940CA48109Fa3DaD0D2C8B27E64a0c6cf#contracts Successfully verified 1 contract(s).","title":"Verify Your Contract on BscScan"},{"location":"smart-chain/developer/deploy/truffle-verify.html#verify-your-contract-on-bscscan","text":"The recommended way to verify a smart contract is using plugin. It is easier to read, imports are maintained, licenses are maintained. Verified using Truffle Example: https://testnet-explorer.genesys.network/token/0x68D2E27940CA48109Fa3DaD0D2C8B27E64a0c6cf GitHub Project: https://github.com/huangsuyu/verify-example","title":"Verify Your Contract on BscScan"},{"location":"smart-chain/developer/deploy/truffle-verify.html#truffle","text":"Truffle has an BscScan plugin: truffle-plugin-verify You need to deploy with Truffle to verify with the Truffle verify plugin. Get API key: https://genesys.network/myapikey Install the plugin npm install -D truffle-plugin-verify Configure the plugin in truffle-config.js const HDWalletProvider = require ( \"@truffle/hdwallet-provider\" ); // const infuraKey = \"fj4jll3k.....\"; // const { mnemonic , NCSCANAPIKEY } = require ( './env.json' ); module . exports = { plugins : [ 'truffle-plugin-verify' ], api_keys : { bscscan : NCSCANAPIKEY }, networks : { testnet : { provider : () => new HDWalletProvider ( mnemonic , `https://testnet-rpc.genesys.network` ), network_id : 97 , timeoutBlocks : 200 , confirmations : 5 , production : true // Treats this network as if it was a public net. (default: false) } }, // Set default mocha options here, use special reporters etc. mocha : { timeout : 100000 }, // Configure your compilers compilers : { solc : { version : \"0.5.16\" , // Fetch exact version from solc-bin (default: truffle's version) // docker: true, // Use \"0.5.1\" you've installed locally with docker (default: false) settings : { // See the solidity docs for advice about optimization and evmVersion optimizer : { enabled : false , runs : 200 }, evmVersion : \"byzantium\" } }, }, }; Verify truffle run verify BLUE20Token@{contract-address} --network testnet You should see the following output: Verifying BLUE20Token@0x68D2E27940CA48109Fa3DaD0D2C8B27E64a0c6cf Pass - Verified: https://testnet-explorer.genesys.network/address/0x68D2E27940CA48109Fa3DaD0D2C8B27E64a0c6cf#contracts Successfully verified 1 contract(s).","title":"Truffle"},{"location":"smart-chain/developer/deploy/truffle.html","text":"Using Truffle Setting up the development environment There are a few technical requirements before we start. Please install the following: Requirements: Windows, Linux or Mac OS X Node.js v8.9.4 LTS or later Git Recommendations for Windows If you're running Truffle on Windows, you may encounter some naming conflicts that could prevent Truffle from executing properly. Please see the section on resolving naming conflicts for solutions. Installing Once we have those installed, we only need one command to install Truffle: npm install -g truffle To verify that Truffle is installed properly, type truffle version on a terminal. If you see an error, make sure that your npm modules are added to your path. Create A Project The first step is to create a Truffle project. We'll use the *MegaCoin as an example, which creates a token that can be transferred between accounts: Create a new directory for your Truffle project mkdir MegaCoin cd MegaCoin Intialize your project: truffle init Once this operation is completed, you'll now have a project structure with the following items: contracts/: Directory for Solidity contracts migrations/: Directory for scriptable deployment files test/: Directory for test files for testing your application and contracts truffle-config.js: Truffle configuration file Create Contract You can write your own smart contract or download the BLUE20 token smart contract template. Compile Contract To compile a Truffle project, change to the root of the directory where the project is located and then type the following into a terminal: truffle compile Config Truffle for TC Go to truffle-config.js Update the truffle-config with nc-network-crendentials. const HDWalletProvider = require ( '@truffle/hdwallet-provider' ); const fs = require ( 'fs' ); const mnemonic = fs . readFileSync ( \".secret\" ). toString (). trim (); module . exports = { networks : { development : { host : \"127.0.0.1\" , // Localhost (default: none) port : 8545 , // Standard GSYS port (default: none) network_id : \"*\" , // Any network (default: none) }, testnet : { provider : () => new HDWalletProvider ( mnemonic , `https://testnet-rpc.genesys.network` ), network_id : 97 , confirmations : 10 , timeoutBlocks : 200 , skipDryRun : true }, bsc : { provider : () => new HDWalletProvider ( mnemonic , `https://mainnet-rpc.genesys.network` ), network_id : 56 , confirmations : 10 , timeoutBlocks : 200 , skipDryRun : true }, }, // Set default mocha options here, use special reporters etc. mocha : { // timeout: 100000 }, // Configure your compilers compilers : { solc : { version : \"^0.6.12\" , // A version or constraint - Ex. \"^0.5.0\" } } } Notice, it requires mnemonic to be passed in for Provider, this is the seed phrase for the account you'd like to deploy from. Create a new .secret file in root directory and enter your 12 word mnemonic seed phrase to get started. To get the seedwords from metamask wallet you can go to Metamask Settings, then from the menu choose Security and Privacy where you will see a button that says reveal seed words. Deploying on GSYS Network Run this command in root of the project directory: $ truffle migrate -- network testnet Contract will be deployed on Genesys Chain Chapel Testnet, it look like this: 1 _initial_migration . js ====================== Deploying 'Migrations' ---------------------- > transaction hash : 0xaf4502198400bde2148eb4274b08d727a17080b685cd2dcd4aee13d8eb954adc > Blocks : 3 Seconds : 9 > contract address : 0x81eCD10b61978D9160428943a0c0Fb31a5460466 > block number : 3223948 > block timestamp : 1604049862 > account : 0x623ac9f6E62A8134bBD5Dc96D9B8b29b4B60e45F > balance : 6.24574114 > gas used : 191943 ( 0x2edc7 ) > gas price : 20 gwei > value sent : 0 ETH > total cost : 0.00383886 ETH Pausing for 5 confirmations ... ------------------------------ > confirmation number : 2 ( block : 3223952 ) > confirmation number : 3 ( block : 3223953 ) > confirmation number : 4 ( block : 3223954 ) > confirmation number : 6 ( block : 3223956 ) > Saving migration to chain . > Saving artifacts ------------------------------------- > Total cost : 0.00383886 ETH Summary ======= > Total deployments : 1 > Final cost : 0.00383886 ETH Remember your address, transaction_hash and other details provided would differ, Above is just to provide an idea of structure. Congratulations! You have successfully deployed BLUE20 Smart Contract. Now you can interact with the Smart Contract. You can check the deployment status here: https://genesys.network/ or https://testnet-explorer.genesys.network/","title":"Truffle"},{"location":"smart-chain/developer/deploy/truffle.html#using-truffle","text":"","title":"Using Truffle"},{"location":"smart-chain/developer/deploy/truffle.html#setting-up-the-development-environment","text":"There are a few technical requirements before we start. Please install the following: Requirements: Windows, Linux or Mac OS X Node.js v8.9.4 LTS or later Git Recommendations for Windows If you're running Truffle on Windows, you may encounter some naming conflicts that could prevent Truffle from executing properly. Please see the section on resolving naming conflicts for solutions.","title":"Setting up the development environment"},{"location":"smart-chain/developer/deploy/truffle.html#installing","text":"Once we have those installed, we only need one command to install Truffle: npm install -g truffle To verify that Truffle is installed properly, type truffle version on a terminal. If you see an error, make sure that your npm modules are added to your path.","title":"Installing"},{"location":"smart-chain/developer/deploy/truffle.html#create-a-project","text":"The first step is to create a Truffle project. We'll use the *MegaCoin as an example, which creates a token that can be transferred between accounts: Create a new directory for your Truffle project mkdir MegaCoin cd MegaCoin Intialize your project: truffle init Once this operation is completed, you'll now have a project structure with the following items: contracts/: Directory for Solidity contracts migrations/: Directory for scriptable deployment files test/: Directory for test files for testing your application and contracts truffle-config.js: Truffle configuration file","title":"Create A Project"},{"location":"smart-chain/developer/deploy/truffle.html#create-contract","text":"You can write your own smart contract or download the BLUE20 token smart contract template.","title":"Create Contract"},{"location":"smart-chain/developer/deploy/truffle.html#compile-contract","text":"To compile a Truffle project, change to the root of the directory where the project is located and then type the following into a terminal: truffle compile","title":"Compile Contract"},{"location":"smart-chain/developer/deploy/truffle.html#config-truffle-for-tc","text":"Go to truffle-config.js Update the truffle-config with nc-network-crendentials. const HDWalletProvider = require ( '@truffle/hdwallet-provider' ); const fs = require ( 'fs' ); const mnemonic = fs . readFileSync ( \".secret\" ). toString (). trim (); module . exports = { networks : { development : { host : \"127.0.0.1\" , // Localhost (default: none) port : 8545 , // Standard GSYS port (default: none) network_id : \"*\" , // Any network (default: none) }, testnet : { provider : () => new HDWalletProvider ( mnemonic , `https://testnet-rpc.genesys.network` ), network_id : 97 , confirmations : 10 , timeoutBlocks : 200 , skipDryRun : true }, bsc : { provider : () => new HDWalletProvider ( mnemonic , `https://mainnet-rpc.genesys.network` ), network_id : 56 , confirmations : 10 , timeoutBlocks : 200 , skipDryRun : true }, }, // Set default mocha options here, use special reporters etc. mocha : { // timeout: 100000 }, // Configure your compilers compilers : { solc : { version : \"^0.6.12\" , // A version or constraint - Ex. \"^0.5.0\" } } } Notice, it requires mnemonic to be passed in for Provider, this is the seed phrase for the account you'd like to deploy from. Create a new .secret file in root directory and enter your 12 word mnemonic seed phrase to get started. To get the seedwords from metamask wallet you can go to Metamask Settings, then from the menu choose Security and Privacy where you will see a button that says reveal seed words.","title":"Config Truffle for TC"},{"location":"smart-chain/developer/deploy/truffle.html#deploying-on-gsys-network","text":"Run this command in root of the project directory: $ truffle migrate -- network testnet Contract will be deployed on Genesys Chain Chapel Testnet, it look like this: 1 _initial_migration . js ====================== Deploying 'Migrations' ---------------------- > transaction hash : 0xaf4502198400bde2148eb4274b08d727a17080b685cd2dcd4aee13d8eb954adc > Blocks : 3 Seconds : 9 > contract address : 0x81eCD10b61978D9160428943a0c0Fb31a5460466 > block number : 3223948 > block timestamp : 1604049862 > account : 0x623ac9f6E62A8134bBD5Dc96D9B8b29b4B60e45F > balance : 6.24574114 > gas used : 191943 ( 0x2edc7 ) > gas price : 20 gwei > value sent : 0 ETH > total cost : 0.00383886 ETH Pausing for 5 confirmations ... ------------------------------ > confirmation number : 2 ( block : 3223952 ) > confirmation number : 3 ( block : 3223953 ) > confirmation number : 4 ( block : 3223954 ) > confirmation number : 6 ( block : 3223956 ) > Saving migration to chain . > Saving artifacts ------------------------------------- > Total cost : 0.00383886 ETH Summary ======= > Total deployments : 1 > Final cost : 0.00383886 ETH Remember your address, transaction_hash and other details provided would differ, Above is just to provide an idea of structure. Congratulations! You have successfully deployed BLUE20 Smart Contract. Now you can interact with the Smart Contract. You can check the deployment status here: https://genesys.network/ or https://testnet-explorer.genesys.network/","title":"Deploying on GSYS Network"},{"location":"smart-chain/developer/deploy/verify.html","text":"How to Verify Your Contract on genesys.network Step 1: Deploy your contract on Genesys Chain Step 2: Go to NCExplorer or Testnet Explorer Click on \"Verify and Publish\" Step 3: Fill in the correct information of your contract Contract Address Compiler Type you chose in Remix or other complier Select Open Source License Type Step 4: Enter the Solidity Contract Code You need to select \"Yes\" for Optimization, if that's enabled. Contructor arguement is optional. If your contract do have one, you can go to this page to generate the encoded ABI json. Info The default BLUE20 contract template does not have a constructor method Click on \"Verify and Publish\" to finish this process. Now you are all set!","title":"How to Verify Your Contract on genesys.network"},{"location":"smart-chain/developer/deploy/verify.html#how-to-verify-your-contract-on-genesysnetwork","text":"","title":"How to Verify Your Contract on genesys.network"},{"location":"smart-chain/developer/deploy/verify.html#step-1-deploy-your-contract-on-genesys-chain","text":"","title":"Step 1: Deploy your contract on Genesys Chain"},{"location":"smart-chain/developer/deploy/verify.html#step-2-go-to-ncexplorer-or-testnet-explorer","text":"Click on \"Verify and Publish\"","title":"Step 2: Go to NCExplorer or Testnet Explorer"},{"location":"smart-chain/developer/deploy/verify.html#step-3-fill-in-the-correct-information-of-your-contract","text":"Contract Address Compiler Type you chose in Remix or other complier Select Open Source License Type","title":"Step 3: Fill in the correct information of your contract"},{"location":"smart-chain/developer/deploy/verify.html#step-4-enter-the-solidity-contract-code","text":"You need to select \"Yes\" for Optimization, if that's enabled. Contructor arguement is optional. If your contract do have one, you can go to this page to generate the encoded ABI json. Info The default BLUE20 contract template does not have a constructor method Click on \"Verify and Publish\" to finish this process. Now you are all set!","title":"Step 4:  Enter the Solidity Contract Code"},{"location":"smart-chain/developer/oracle/band.html","text":"Band Protocol Price Feed on Genesys Chain Introduction Developers building on Genesys Chain can now leverage Band\u2019s decentralized oracle infrastructure. With Band\u2019s oracle, they now have access to various cryptocurrency price data to integrate into their applications. Supported Tokens Currently, the following token symbols are supported. Going forward, this list will continue to expand based on developer needs and community feedback. Token Name Symbol Genesys GSYS GSYS USD BUSD Bitcoin BTC Ethereum ETH Tether USDT XRP XRP Chainlink LINK Polkadot DOT Bitcoin Cash BCH Litecoin LTC Cardano ADA Bitcoin SV BSV Crypto.com Coin CRO EOS EOS Tezos XTZ Tron TRX Stellar XLM Cosmos ATOM Monero XMR OKB OKB Swipe SXP Price Pairs The method provided below supports price query with any denomination as long as the base and quote symbols are supported in the list above. For example, you can use the APIs in Javascripts and Solidity to query the following price pairs: BTC/USD GSYS/ETH Querying Prices Currently, there are two methods for developers to query prices from Band\u2019s oracle: through Band\u2019s StdReference smart contract on Genesys Chain and through their bandchain.js JavaScript helper library. Solidity Smart Contract To query prices from Band\u2019s oracle through smart contracts, the contract looking to use the price values should reference Band\u2019s StdReference contract. This contract exposes getReferenceData and getReferenceDataBulk functions. getReferenceData takes two strings as the inputs, the base and quote symbol, respectively. It then queries the StdReference contract for the latest rates for those two tokens, and returns a ReferenceData struct, shown below. struct ReferenceData { uint256 rate; // base/quote exchange rate, multiplied by 1e18. uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated. uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated. } getReferenceDataBulk instead takes two lists, one of the base tokens, and one of the quotes . It then proceeds to similarly queries the price for each base/quote pair at each index, and returns an array of ReferenceData structs. For example, if we call getReferenceDataBulk with ['BTC','BTC','ETH'] and ['USD','ETH','GSYS'] , the returned ReferenceData array will contain information regarding the pairs: BTC/USD BTC/ETH ETH/GSYS Example Usage The contract code below demonstrates a simple usage of the new StdReference contract and the getReferenceData function. pragma solidity 0.6.11; pragma experimental ABIEncoderV2; interface IStdReference { /// A structure returned whenever someone requests for standard reference data. struct ReferenceData { uint256 rate; // base/quote exchange rate, multiplied by 1e18. uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated. uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated. } /// Returns the price data for the given base/quote pair. Revert if not available. function getReferenceData(string memory _base, string memory _quote) external view returns (ReferenceData memory); /// Similar to getReferenceData, but with multiple base/quote pairs at once. function getReferenceDataBulk(string[] memory _bases, string[] memory _quotes) external view returns (ReferenceData[] memory); } contract DemoOracle { IStdReference ref; uint256 public price; constructor(IStdReference _ref) public { ref = _ref; } function getPrice() external view returns (uint256){ IStdReference.ReferenceData memory data = ref.getReferenceData(\"BTC\",\"USD\"); return data.rate; } function getMultiPrices() external view returns (uint256[] memory){ string[] memory baseSymbols = new string[](2); baseSymbols[0] = \"BTC\"; baseSymbols[1] = \"ETH\"; string[] memory quoteSymbols = new string[](2); quoteSymbols[0] = \"USD\"; quoteSymbols[1] = \"USD\"; IStdReference.ReferenceData[] memory data = ref.getReferenceDataBulk(baseSymbols,quoteSymbols); uint256[] memory prices = new uint256[](2); prices[0] = data[0].rate; prices[1] = data[1].rate; return prices; } function savePrice(string memory base, string memory quote) external { IStdReference.ReferenceData memory data = ref.getReferenceData(base,quote); price = data.rate; } } Contract Addresses Blockchain Aggregator Contract Address Update Every Explorer GSYS (Testnet) 0xDA7a001b254CD22e46d3eAB04d937489c93174C3 5 mins link GSYS (Mainnet) 0xDA7a001b254CD22e46d3eAB04d937489c93174C3 5 mins link BandChain.JS Band\u2019s node helper library bandchain.js also supports a similar getReferenceData function. This function takes one argument, a list of token pairs to query the result of. It then returns a list of corresponding rate values. Example Usage The code below shows an example usage of the function const BandChain = require('@bandprotocol/bandchain.js'); (async () => { const endpoint = 'https://poa-api.bandchain.org'; const bandchain = new BandChain(endpoint); const price = await bandchain.getReferenceData(['BAND/USD', 'BTC/ETH', 'EUR/USD', 'EUR/BTC']); console.log(price); })(); The corresponding result will then be similar to $ node index.js [ { pair: 'BAND/USD', rate: 6.49, updated: { base: 1600676205, quote: 0 }, rawRate: { value: 6490000000n, decimals: 9 } }, { pair: 'BTC/ETH', rate: 29.574702955490906, updated: { base: 1600676187, quote: 1600676187 }, rawRate: { value: 29574702955n, decimals: 9 } }, { pair: 'EUR/USD', rate: 1.185569204, updated: { base: 1600676032, quote: 0 }, rawRate: { value: 1185569204n, decimals: 9 } }, { pair: 'EUR/BTC', rate: 0.00010899500647220628, updated: { base: 1600676032, quote: 1600676187 }, rawRate: { value: 108995n, decimals: 9 } } ] For each pair, the following information will be returned: pair : The base/quote symbol pair string rate : The resulting rate of the given pair updated : The timestamp at which the base and quote symbols was last updated on BandChain. For USD , this will be the current timestamp rawRate : This object consists of two parts. value is the BigInt value of the actual rate, multiplied by 10^decimals decimals is then the exponent by which rate was multiplied by to get rawRate Originally published here","title":"Band Protocol Price Feed on Genesys Chain"},{"location":"smart-chain/developer/oracle/band.html#band-protocol-price-feed-on-genesys-chain","text":"","title":"Band Protocol Price Feed on Genesys Chain"},{"location":"smart-chain/developer/oracle/band.html#introduction","text":"Developers building on Genesys Chain can now leverage Band\u2019s decentralized oracle infrastructure. With Band\u2019s oracle, they now have access to various cryptocurrency price data to integrate into their applications.","title":"Introduction"},{"location":"smart-chain/developer/oracle/band.html#supported-tokens","text":"Currently, the following token symbols are supported. Going forward, this list will continue to expand based on developer needs and community feedback. Token Name Symbol Genesys GSYS GSYS USD BUSD Bitcoin BTC Ethereum ETH Tether USDT XRP XRP Chainlink LINK Polkadot DOT Bitcoin Cash BCH Litecoin LTC Cardano ADA Bitcoin SV BSV Crypto.com Coin CRO EOS EOS Tezos XTZ Tron TRX Stellar XLM Cosmos ATOM Monero XMR OKB OKB Swipe SXP","title":"Supported Tokens"},{"location":"smart-chain/developer/oracle/band.html#price-pairs","text":"The method provided below supports price query with any denomination as long as the base and quote symbols are supported in the list above. For example, you can use the APIs in Javascripts and Solidity to query the following price pairs: BTC/USD GSYS/ETH","title":"Price Pairs"},{"location":"smart-chain/developer/oracle/band.html#querying-prices","text":"Currently, there are two methods for developers to query prices from Band\u2019s oracle: through Band\u2019s StdReference smart contract on Genesys Chain and through their bandchain.js JavaScript helper library.","title":"Querying Prices"},{"location":"smart-chain/developer/oracle/band.html#solidity-smart-contract","text":"To query prices from Band\u2019s oracle through smart contracts, the contract looking to use the price values should reference Band\u2019s StdReference contract. This contract exposes getReferenceData and getReferenceDataBulk functions. getReferenceData takes two strings as the inputs, the base and quote symbol, respectively. It then queries the StdReference contract for the latest rates for those two tokens, and returns a ReferenceData struct, shown below. struct ReferenceData { uint256 rate; // base/quote exchange rate, multiplied by 1e18. uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated. uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated. } getReferenceDataBulk instead takes two lists, one of the base tokens, and one of the quotes . It then proceeds to similarly queries the price for each base/quote pair at each index, and returns an array of ReferenceData structs. For example, if we call getReferenceDataBulk with ['BTC','BTC','ETH'] and ['USD','ETH','GSYS'] , the returned ReferenceData array will contain information regarding the pairs: BTC/USD BTC/ETH ETH/GSYS","title":"Solidity Smart Contract"},{"location":"smart-chain/developer/oracle/band.html#example-usage","text":"The contract code below demonstrates a simple usage of the new StdReference contract and the getReferenceData function. pragma solidity 0.6.11; pragma experimental ABIEncoderV2; interface IStdReference { /// A structure returned whenever someone requests for standard reference data. struct ReferenceData { uint256 rate; // base/quote exchange rate, multiplied by 1e18. uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated. uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated. } /// Returns the price data for the given base/quote pair. Revert if not available. function getReferenceData(string memory _base, string memory _quote) external view returns (ReferenceData memory); /// Similar to getReferenceData, but with multiple base/quote pairs at once. function getReferenceDataBulk(string[] memory _bases, string[] memory _quotes) external view returns (ReferenceData[] memory); } contract DemoOracle { IStdReference ref; uint256 public price; constructor(IStdReference _ref) public { ref = _ref; } function getPrice() external view returns (uint256){ IStdReference.ReferenceData memory data = ref.getReferenceData(\"BTC\",\"USD\"); return data.rate; } function getMultiPrices() external view returns (uint256[] memory){ string[] memory baseSymbols = new string[](2); baseSymbols[0] = \"BTC\"; baseSymbols[1] = \"ETH\"; string[] memory quoteSymbols = new string[](2); quoteSymbols[0] = \"USD\"; quoteSymbols[1] = \"USD\"; IStdReference.ReferenceData[] memory data = ref.getReferenceDataBulk(baseSymbols,quoteSymbols); uint256[] memory prices = new uint256[](2); prices[0] = data[0].rate; prices[1] = data[1].rate; return prices; } function savePrice(string memory base, string memory quote) external { IStdReference.ReferenceData memory data = ref.getReferenceData(base,quote); price = data.rate; } }","title":"Example Usage"},{"location":"smart-chain/developer/oracle/band.html#contract-addresses","text":"Blockchain Aggregator Contract Address Update Every Explorer GSYS (Testnet) 0xDA7a001b254CD22e46d3eAB04d937489c93174C3 5 mins link GSYS (Mainnet) 0xDA7a001b254CD22e46d3eAB04d937489c93174C3 5 mins link","title":"Contract Addresses"},{"location":"smart-chain/developer/oracle/band.html#bandchainjs","text":"Band\u2019s node helper library bandchain.js also supports a similar getReferenceData function. This function takes one argument, a list of token pairs to query the result of. It then returns a list of corresponding rate values.","title":"BandChain.JS"},{"location":"smart-chain/developer/oracle/band.html#example-usage_1","text":"The code below shows an example usage of the function const BandChain = require('@bandprotocol/bandchain.js'); (async () => { const endpoint = 'https://poa-api.bandchain.org'; const bandchain = new BandChain(endpoint); const price = await bandchain.getReferenceData(['BAND/USD', 'BTC/ETH', 'EUR/USD', 'EUR/BTC']); console.log(price); })(); The corresponding result will then be similar to $ node index.js [ { pair: 'BAND/USD', rate: 6.49, updated: { base: 1600676205, quote: 0 }, rawRate: { value: 6490000000n, decimals: 9 } }, { pair: 'BTC/ETH', rate: 29.574702955490906, updated: { base: 1600676187, quote: 1600676187 }, rawRate: { value: 29574702955n, decimals: 9 } }, { pair: 'EUR/USD', rate: 1.185569204, updated: { base: 1600676032, quote: 0 }, rawRate: { value: 1185569204n, decimals: 9 } }, { pair: 'EUR/BTC', rate: 0.00010899500647220628, updated: { base: 1600676032, quote: 1600676187 }, rawRate: { value: 108995n, decimals: 9 } } ] For each pair, the following information will be returned: pair : The base/quote symbol pair string rate : The resulting rate of the given pair updated : The timestamp at which the base and quote symbols was last updated on BandChain. For USD , this will be the current timestamp rawRate : This object consists of two parts. value is the BigInt value of the actual rate, multiplied by 10^decimals decimals is then the exponent by which rate was multiplied by to get rawRate Originally published here","title":"Example Usage"},{"location":"smart-chain/developer/oracle/dia.html","text":"DIA Data Oracles on Genesys Chain Introduction DApp developers who want to leverage DIA oracles can access the published data on Genesys Chain. DIA offers cryptocurrency and data about traditional financial assets. Supported Assets DIA supports assets from various categories to be included into the oracle. A selection of assets is listed here: Data Feed Name Data Type Genesys Crypto Price Bitcoin Crypto Price Ethereum Crypto Price Tether Crypto Price XRP Crypto price Barnbridge Protocol Farming Pool Data yearn.finance Farming Pool Data CREX on Crex Chart Point on Exchange DAI on CurveFi Chart Point on Exchange WGSYS on PancakeSwap Chart Point on Exchange Data Access All asset prices are determined in USD. Where appliccable, the oracle also provides information on circulating supply and the timestamp of data collection. The query in the smart contract is realized with the symbol of the asset. Smart Contract DIA data is published in the DIAOracle smart contract. By querying the getCoinInfo() function you can retrieve the requested data. It takes the name of the asset as input, e.g., Bitcoin and returns this struct of data: struct CoinInfo { uint256 price; uint256 supply; uint256 lastUpdateTimestamp; string symbol; } The following snippet shows how to retrieve the BTC price of an asset (e.g. Genesys ) using a smart contract. pragma solidity ^0.4.24; contract DiaOracle { address owner; struct CoinInfo { uint256 price; uint256 supply; uint256 lastUpdateTimestamp; string symbol; } mapping(string => CoinInfo) diaOracles; event newCoinInfo( string name, string symbol, uint256 price, uint256 supply, uint256 lastUpdateTimestamp ); constructor() public { owner = msg.sender; } function changeOwner(address newOwner) public { require(msg.sender == owner); owner = newOwner; } function updateCoinInfo(string name, string symbol, uint256 newPrice, uint256 newSupply, uint256 newTimestamp) public { require(msg.sender == owner); diaOracles[name] = (CoinInfo(newPrice, newSupply, newTimestamp, symbol)); emit newCoinInfo(name, symbol, newPrice, newSupply, newTimestamp); } function getCoinInfo(string name) public view returns (uint256, uint256, uint256, string) { return ( diaOracles[name].price, diaOracles[name].supply, diaOracles[name].lastUpdateTimestamp, diaOracles[name].symbol ); } } contract DiaAssetBtcOracle { DiaOracle oracle; address owner; constructor() public { owner = msg.sender; } function setOracleAddress(address _address) public { require(msg.sender == owner); oracle = DiaOracle(_address); } function getAssetEurRate(string asset) constant public returns (uint256) { (uint assetPrice,,,) = oracle.getCoinInfo(asset); (uint btcPrice,,,) = oracle.getCoinInfo(\"Bitcoin\"); return (assetPrice * 100000 / btcPrice); } } Deployed Addresses Chain name Oracle Contract Address Update Frequency TC: Testnet 0xf35bEE4B6727D2D1c9167C5fB4D51855D6bB693c 1/day TC: Mainnet 0xf35bEE4B6727D2D1c9167C5fB4D51855D6bB693c 1/day The full documentation of the DIA oracle is located here .","title":"DIA Data Oracles on Genesys Chain"},{"location":"smart-chain/developer/oracle/dia.html#dia-data-oracles-on-genesys-chain","text":"","title":"DIA Data Oracles on Genesys Chain"},{"location":"smart-chain/developer/oracle/dia.html#introduction","text":"DApp developers who want to leverage DIA oracles can access the published data on Genesys Chain. DIA offers cryptocurrency and data about traditional financial assets.","title":"Introduction"},{"location":"smart-chain/developer/oracle/dia.html#supported-assets","text":"DIA supports assets from various categories to be included into the oracle. A selection of assets is listed here: Data Feed Name Data Type Genesys Crypto Price Bitcoin Crypto Price Ethereum Crypto Price Tether Crypto Price XRP Crypto price Barnbridge Protocol Farming Pool Data yearn.finance Farming Pool Data CREX on Crex Chart Point on Exchange DAI on CurveFi Chart Point on Exchange WGSYS on PancakeSwap Chart Point on Exchange","title":"Supported Assets"},{"location":"smart-chain/developer/oracle/dia.html#data-access","text":"All asset prices are determined in USD. Where appliccable, the oracle also provides information on circulating supply and the timestamp of data collection. The query in the smart contract is realized with the symbol of the asset.","title":"Data Access"},{"location":"smart-chain/developer/oracle/dia.html#smart-contract","text":"DIA data is published in the DIAOracle smart contract. By querying the getCoinInfo() function you can retrieve the requested data. It takes the name of the asset as input, e.g., Bitcoin and returns this struct of data: struct CoinInfo { uint256 price; uint256 supply; uint256 lastUpdateTimestamp; string symbol; } The following snippet shows how to retrieve the BTC price of an asset (e.g. Genesys ) using a smart contract. pragma solidity ^0.4.24; contract DiaOracle { address owner; struct CoinInfo { uint256 price; uint256 supply; uint256 lastUpdateTimestamp; string symbol; } mapping(string => CoinInfo) diaOracles; event newCoinInfo( string name, string symbol, uint256 price, uint256 supply, uint256 lastUpdateTimestamp ); constructor() public { owner = msg.sender; } function changeOwner(address newOwner) public { require(msg.sender == owner); owner = newOwner; } function updateCoinInfo(string name, string symbol, uint256 newPrice, uint256 newSupply, uint256 newTimestamp) public { require(msg.sender == owner); diaOracles[name] = (CoinInfo(newPrice, newSupply, newTimestamp, symbol)); emit newCoinInfo(name, symbol, newPrice, newSupply, newTimestamp); } function getCoinInfo(string name) public view returns (uint256, uint256, uint256, string) { return ( diaOracles[name].price, diaOracles[name].supply, diaOracles[name].lastUpdateTimestamp, diaOracles[name].symbol ); } } contract DiaAssetBtcOracle { DiaOracle oracle; address owner; constructor() public { owner = msg.sender; } function setOracleAddress(address _address) public { require(msg.sender == owner); oracle = DiaOracle(_address); } function getAssetEurRate(string asset) constant public returns (uint256) { (uint assetPrice,,,) = oracle.getCoinInfo(asset); (uint btcPrice,,,) = oracle.getCoinInfo(\"Bitcoin\"); return (assetPrice * 100000 / btcPrice); } }","title":"Smart Contract"},{"location":"smart-chain/developer/oracle/dia.html#deployed-addresses","text":"Chain name Oracle Contract Address Update Frequency TC: Testnet 0xf35bEE4B6727D2D1c9167C5fB4D51855D6bB693c 1/day TC: Mainnet 0xf35bEE4B6727D2D1c9167C5fB4D51855D6bB693c 1/day The full documentation of the DIA oracle is located here .","title":"Deployed Addresses"},{"location":"smart-chain/developer/oracle/link.html","text":"Genesys Chain Price Feeds from Chainlink Introduction to Price Feeds Chainlink Price Feeds are the quickest way to connect your smart contracts to the real-world market prices of assets. They enable smart contracts to retrieve the latest price of an asset in a single call. Often, smart contracts need to act upon prices of assets in real-time. This is especially true in DeFi . For example, Synthetix use Price Feeds to determine prices on their derivatives platform. Lending and Borrowing platforms like AAVE use Price Feeds to ensure the total value of the collateral. Get the Latest Price This section explains how to get the latest price of GSYS inside smart contracts using Chainlink Price Feeds, on the Genesys Chain. Solidity Contract To consume price data, your smart contract should reference AggregatorV3Interface , which defines the external functions implemented by Price Feeds. pragma solidity ^0.6.7; import \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\"; contract PriceConsumerV3 { AggregatorV3Interface internal priceFeed; /** * Network: Genesys Chain * Aggregator: GSYS/USD * Address: 0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE */ constructor() public { priceFeed = AggregatorV3Interface(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE); } /** * Returns the latest price */ function getLatestPrice() public view returns (int) { ( uint80 roundID, int price, uint startedAt, uint timeStamp, uint80 answeredInRound ) = priceFeed.latestRoundData(); return price; } } Javascript Web3 const Web3 = require ( \"web3\" ); const web3 = new Web3 ( \"https://testnet-rpc.genesys.network\" ); const aggregatorV3InterfaceABI = [{ \"inputs\" : [], \"name\" : \"decimals\" , \"outputs\" : [{ \"internalType\" : \"uint8\" , \"name\" : \"\" , \"type\" : \"uint8\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [], \"name\" : \"description\" , \"outputs\" : [{ \"internalType\" : \"string\" , \"name\" : \"\" , \"type\" : \"string\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"internalType\" : \"uint80\" , \"name\" : \"_roundId\" , \"type\" : \"uint80\" }], \"name\" : \"getRoundData\" , \"outputs\" : [{ \"internalType\" : \"uint80\" , \"name\" : \"roundId\" , \"type\" : \"uint80\" },{ \"internalType\" : \"int256\" , \"name\" : \"answer\" , \"type\" : \"int256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"startedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"updatedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint80\" , \"name\" : \"answeredInRound\" , \"type\" : \"uint80\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [], \"name\" : \"latestRoundData\" , \"outputs\" : [{ \"internalType\" : \"uint80\" , \"name\" : \"roundId\" , \"type\" : \"uint80\" },{ \"internalType\" : \"int256\" , \"name\" : \"answer\" , \"type\" : \"int256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"startedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"updatedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint80\" , \"name\" : \"answeredInRound\" , \"type\" : \"uint80\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [], \"name\" : \"version\" , \"outputs\" : [{ \"internalType\" : \"uint256\" , \"name\" : \"\" , \"type\" : \"uint256\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" }]; const addr = \"0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE\" ; const priceFeed = new web3 . eth . Contract ( aggregatorV3InterfaceABI , addr ); priceFeed . methods . latestRoundData (). call () . then (( roundData ) => { // Do something with roundData console . log ( \"Latest Round Data\" , roundData ) }); Python Web3 from web3 import Web3 web3 = Web3 ( Web3 . HTTPProvider ( 'https://testnet-rpc.genesys.network' )) abi = '[{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"getRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]' addr = '0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE' contract = web3 . eth . contract ( address = addr , abi = abi ) latestData = contract . functions . latestRoundData () . call () print ( latestData ) Get Historical Price Data The most common use case for Price Feeds is to get the latest price. However, AggregatorV3Interface also exposes functions which can be used to retrieve price data of a previous round ID. Solidity Contract pragma solidity ^0.6.7; import \"https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\"; contract HistoricalPriceConsumerV3 { AggregatorV3Interface internal priceFeed; /** * Network: Genesys Chain * Aggregator: GSYS/USD * Address: 0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE */ constructor() public { priceFeed = AggregatorV3Interface(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE); } /** * Returns historical price for a round id. * roundId is NOT incremental. Not all roundIds are valid. * You must know a valid roundId before consuming historical data. * @dev A timestamp with zero value means the round is not complete and should not be used. */ function getHistoricalPrice(uint80 roundId) public view returns (int256) { ( uint80 id, int price, uint startedAt, uint timeStamp, uint80 answeredInRound ) = priceFeed.getRoundData(roundId); require(timeStamp > 0, \"Round not complete\"); return price; } } Javascript Web3 const Web3 = require ( \"web3\" ); const web3 = new Web3 ( \"https://testnet-rpc.genesys.network\" ); const aggregatorV3InterfaceABI = [{ \"inputs\" : [], \"name\" : \"decimals\" , \"outputs\" : [{ \"internalType\" : \"uint8\" , \"name\" : \"\" , \"type\" : \"uint8\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [], \"name\" : \"description\" , \"outputs\" : [{ \"internalType\" : \"string\" , \"name\" : \"\" , \"type\" : \"string\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"internalType\" : \"uint80\" , \"name\" : \"_roundId\" , \"type\" : \"uint80\" }], \"name\" : \"getRoundData\" , \"outputs\" : [{ \"internalType\" : \"uint80\" , \"name\" : \"roundId\" , \"type\" : \"uint80\" },{ \"internalType\" : \"int256\" , \"name\" : \"answer\" , \"type\" : \"int256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"startedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"updatedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint80\" , \"name\" : \"answeredInRound\" , \"type\" : \"uint80\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [], \"name\" : \"latestRoundData\" , \"outputs\" : [{ \"internalType\" : \"uint80\" , \"name\" : \"roundId\" , \"type\" : \"uint80\" },{ \"internalType\" : \"int256\" , \"name\" : \"answer\" , \"type\" : \"int256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"startedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"updatedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint80\" , \"name\" : \"answeredInRound\" , \"type\" : \"uint80\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [], \"name\" : \"version\" , \"outputs\" : [{ \"internalType\" : \"uint256\" , \"name\" : \"\" , \"type\" : \"uint256\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" }]; const addr = \"0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE\" ; const priceFeed = new web3 . eth . Contract ( aggregatorV3InterfaceABI , addr ); // Valid roundId must be known. They are NOT incremental. let validId = BigInt ( \"18446744073709554130\" ); priceFeed . methods . getRoundData ( validId ). call () . then (( historicalRoundData ) => { // Do something with price console . log ( \"Historical round data\" , historicalRoundData ); }) Python Web3 from web3 import Web3 web3 = Web3 ( Web3 . HTTPProvider ( 'https://testnet-rpc.genesys.network' )) abi = '[{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"getRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]' addr = '0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE' contract = web3 . eth . contract ( address = addr , abi = abi ) # Valid roundId must be known. They are NOT incremental. validRoundId = 18446744073709554130 historicalData = contract . functions . getRoundData ( validRoundId ) . call () print ( historicalData ) API Reference API reference for AggregatorV3Interface . Functions Name Description decimals The number of decimals in the response. description The description of the aggregator that the proxy points to. getRoundData Get data from a specific round. latestRoundData Get data from the latest round. version The version representing the type of aggregator the proxy points to. decimals Get the number of decimals present in the response value. ```javascript Solidity function decimals() external view returns (uint8) * `RETURN`: The number of decimals. #### description Get the description of the underlying aggregator that the proxy points to. ```javascript Solidity function description() external view returns (string memory) RETURN : The description of the underlying aggregator. getRoundData Get data about a specific round, using the roundId . ```javascript Solidity function getRoundData(uint80 _roundId) external view returns ( uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound ) **Parameters** * `roundId`: The round ID **Return Values** * `roundId`: The round ID. * `answer`: The price. * `startedAt`: Timestamp of when the round started. * `updatedAt`: Timestamp of when the round was updated. * `answeredInRound`: The round ID of the round in which the answer * was computed. #### latestRoundData Get the price from the latest round. ```javascript Solidity function latestRoundData() external view returns ( uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound ) Return Values roundId : The round ID. answer : The price. startedAt : Timestamp of when the round started. updatedAt : Timestamp of when the round was updated. answeredInRound : The round ID of the round in which the answer was computed. version The version representing the type of aggregator the proxy points to. javascript Solidity function version() external view returns (uint256) RETURN : The version number. Contract Addresses Chainlink price feed contracts are updated on a regular basis by multiple Chainlink nodes. This section lists the contract addresses for Price Feeds on the Genesys Chain. Mainnet Pair Proxy GSYS / USD 0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE BTC / USD 0x264990fbd0A4796A3E3d8E37C4d5F87a3aCa5Ebf ETH / USD 0x9ef1B8c0E4F7dc8bF5719Ea496883DC6401d5b2e Original source is from Chainlink website","title":"Genesys Chain Price Feeds from Chainlink"},{"location":"smart-chain/developer/oracle/link.html#genesys-chain-price-feeds-from-chainlink","text":"","title":"Genesys Chain Price Feeds from Chainlink"},{"location":"smart-chain/developer/oracle/link.html#introduction-to-price-feeds","text":"Chainlink Price Feeds are the quickest way to connect your smart contracts to the real-world market prices of assets. They enable smart contracts to retrieve the latest price of an asset in a single call. Often, smart contracts need to act upon prices of assets in real-time. This is especially true in DeFi . For example, Synthetix use Price Feeds to determine prices on their derivatives platform. Lending and Borrowing platforms like AAVE use Price Feeds to ensure the total value of the collateral.","title":"Introduction to Price Feeds"},{"location":"smart-chain/developer/oracle/link.html#get-the-latest-price","text":"This section explains how to get the latest price of GSYS inside smart contracts using Chainlink Price Feeds, on the Genesys Chain. Solidity Contract To consume price data, your smart contract should reference AggregatorV3Interface , which defines the external functions implemented by Price Feeds. pragma solidity ^0.6.7; import \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\"; contract PriceConsumerV3 { AggregatorV3Interface internal priceFeed; /** * Network: Genesys Chain * Aggregator: GSYS/USD * Address: 0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE */ constructor() public { priceFeed = AggregatorV3Interface(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE); } /** * Returns the latest price */ function getLatestPrice() public view returns (int) { ( uint80 roundID, int price, uint startedAt, uint timeStamp, uint80 answeredInRound ) = priceFeed.latestRoundData(); return price; } } Javascript Web3 const Web3 = require ( \"web3\" ); const web3 = new Web3 ( \"https://testnet-rpc.genesys.network\" ); const aggregatorV3InterfaceABI = [{ \"inputs\" : [], \"name\" : \"decimals\" , \"outputs\" : [{ \"internalType\" : \"uint8\" , \"name\" : \"\" , \"type\" : \"uint8\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [], \"name\" : \"description\" , \"outputs\" : [{ \"internalType\" : \"string\" , \"name\" : \"\" , \"type\" : \"string\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"internalType\" : \"uint80\" , \"name\" : \"_roundId\" , \"type\" : \"uint80\" }], \"name\" : \"getRoundData\" , \"outputs\" : [{ \"internalType\" : \"uint80\" , \"name\" : \"roundId\" , \"type\" : \"uint80\" },{ \"internalType\" : \"int256\" , \"name\" : \"answer\" , \"type\" : \"int256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"startedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"updatedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint80\" , \"name\" : \"answeredInRound\" , \"type\" : \"uint80\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [], \"name\" : \"latestRoundData\" , \"outputs\" : [{ \"internalType\" : \"uint80\" , \"name\" : \"roundId\" , \"type\" : \"uint80\" },{ \"internalType\" : \"int256\" , \"name\" : \"answer\" , \"type\" : \"int256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"startedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"updatedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint80\" , \"name\" : \"answeredInRound\" , \"type\" : \"uint80\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [], \"name\" : \"version\" , \"outputs\" : [{ \"internalType\" : \"uint256\" , \"name\" : \"\" , \"type\" : \"uint256\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" }]; const addr = \"0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE\" ; const priceFeed = new web3 . eth . Contract ( aggregatorV3InterfaceABI , addr ); priceFeed . methods . latestRoundData (). call () . then (( roundData ) => { // Do something with roundData console . log ( \"Latest Round Data\" , roundData ) }); Python Web3 from web3 import Web3 web3 = Web3 ( Web3 . HTTPProvider ( 'https://testnet-rpc.genesys.network' )) abi = '[{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"getRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]' addr = '0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE' contract = web3 . eth . contract ( address = addr , abi = abi ) latestData = contract . functions . latestRoundData () . call () print ( latestData )","title":"Get the Latest Price"},{"location":"smart-chain/developer/oracle/link.html#get-historical-price-data","text":"The most common use case for Price Feeds is to get the latest price. However, AggregatorV3Interface also exposes functions which can be used to retrieve price data of a previous round ID. Solidity Contract pragma solidity ^0.6.7; import \"https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\"; contract HistoricalPriceConsumerV3 { AggregatorV3Interface internal priceFeed; /** * Network: Genesys Chain * Aggregator: GSYS/USD * Address: 0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE */ constructor() public { priceFeed = AggregatorV3Interface(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE); } /** * Returns historical price for a round id. * roundId is NOT incremental. Not all roundIds are valid. * You must know a valid roundId before consuming historical data. * @dev A timestamp with zero value means the round is not complete and should not be used. */ function getHistoricalPrice(uint80 roundId) public view returns (int256) { ( uint80 id, int price, uint startedAt, uint timeStamp, uint80 answeredInRound ) = priceFeed.getRoundData(roundId); require(timeStamp > 0, \"Round not complete\"); return price; } } Javascript Web3 const Web3 = require ( \"web3\" ); const web3 = new Web3 ( \"https://testnet-rpc.genesys.network\" ); const aggregatorV3InterfaceABI = [{ \"inputs\" : [], \"name\" : \"decimals\" , \"outputs\" : [{ \"internalType\" : \"uint8\" , \"name\" : \"\" , \"type\" : \"uint8\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [], \"name\" : \"description\" , \"outputs\" : [{ \"internalType\" : \"string\" , \"name\" : \"\" , \"type\" : \"string\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [{ \"internalType\" : \"uint80\" , \"name\" : \"_roundId\" , \"type\" : \"uint80\" }], \"name\" : \"getRoundData\" , \"outputs\" : [{ \"internalType\" : \"uint80\" , \"name\" : \"roundId\" , \"type\" : \"uint80\" },{ \"internalType\" : \"int256\" , \"name\" : \"answer\" , \"type\" : \"int256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"startedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"updatedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint80\" , \"name\" : \"answeredInRound\" , \"type\" : \"uint80\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [], \"name\" : \"latestRoundData\" , \"outputs\" : [{ \"internalType\" : \"uint80\" , \"name\" : \"roundId\" , \"type\" : \"uint80\" },{ \"internalType\" : \"int256\" , \"name\" : \"answer\" , \"type\" : \"int256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"startedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint256\" , \"name\" : \"updatedAt\" , \"type\" : \"uint256\" },{ \"internalType\" : \"uint80\" , \"name\" : \"answeredInRound\" , \"type\" : \"uint80\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" },{ \"inputs\" : [], \"name\" : \"version\" , \"outputs\" : [{ \"internalType\" : \"uint256\" , \"name\" : \"\" , \"type\" : \"uint256\" }], \"stateMutability\" : \"view\" , \"type\" : \"function\" }]; const addr = \"0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE\" ; const priceFeed = new web3 . eth . Contract ( aggregatorV3InterfaceABI , addr ); // Valid roundId must be known. They are NOT incremental. let validId = BigInt ( \"18446744073709554130\" ); priceFeed . methods . getRoundData ( validId ). call () . then (( historicalRoundData ) => { // Do something with price console . log ( \"Historical round data\" , historicalRoundData ); }) Python Web3 from web3 import Web3 web3 = Web3 ( Web3 . HTTPProvider ( 'https://testnet-rpc.genesys.network' )) abi = '[{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"getRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]' addr = '0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE' contract = web3 . eth . contract ( address = addr , abi = abi ) # Valid roundId must be known. They are NOT incremental. validRoundId = 18446744073709554130 historicalData = contract . functions . getRoundData ( validRoundId ) . call () print ( historicalData )","title":"Get Historical Price Data"},{"location":"smart-chain/developer/oracle/link.html#api-reference","text":"API reference for AggregatorV3Interface .","title":"API Reference"},{"location":"smart-chain/developer/oracle/link.html#functions","text":"Name Description decimals The number of decimals in the response. description The description of the aggregator that the proxy points to. getRoundData Get data from a specific round. latestRoundData Get data from the latest round. version The version representing the type of aggregator the proxy points to.","title":"Functions"},{"location":"smart-chain/developer/oracle/link.html#decimals","text":"Get the number of decimals present in the response value. ```javascript Solidity function decimals() external view returns (uint8) * `RETURN`: The number of decimals. #### description Get the description of the underlying aggregator that the proxy points to. ```javascript Solidity function description() external view returns (string memory) RETURN : The description of the underlying aggregator.","title":"decimals"},{"location":"smart-chain/developer/oracle/link.html#getrounddata","text":"Get data about a specific round, using the roundId . ```javascript Solidity function getRoundData(uint80 _roundId) external view returns ( uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound ) **Parameters** * `roundId`: The round ID **Return Values** * `roundId`: The round ID. * `answer`: The price. * `startedAt`: Timestamp of when the round started. * `updatedAt`: Timestamp of when the round was updated. * `answeredInRound`: The round ID of the round in which the answer * was computed. #### latestRoundData Get the price from the latest round. ```javascript Solidity function latestRoundData() external view returns ( uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound ) Return Values roundId : The round ID. answer : The price. startedAt : Timestamp of when the round started. updatedAt : Timestamp of when the round was updated. answeredInRound : The round ID of the round in which the answer was computed.","title":"getRoundData"},{"location":"smart-chain/developer/oracle/link.html#version","text":"The version representing the type of aggregator the proxy points to. javascript Solidity function version() external view returns (uint256) RETURN : The version number.","title":"version"},{"location":"smart-chain/developer/oracle/link.html#contract-addresses","text":"Chainlink price feed contracts are updated on a regular basis by multiple Chainlink nodes. This section lists the contract addresses for Price Feeds on the Genesys Chain.","title":"Contract Addresses"},{"location":"smart-chain/developer/oracle/link.html#mainnet","text":"Pair Proxy GSYS / USD 0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE BTC / USD 0x264990fbd0A4796A3E3d8E37C4d5F87a3aCa5Ebf ETH / USD 0x9ef1B8c0E4F7dc8bF5719Ea496883DC6401d5b2e Original source is from Chainlink website","title":"Mainnet"},{"location":"smart-chain/developer/upgrade/proxy.html","text":"Upgradeable BLUE20 Contracts on TC What are Upgradeable Contracts? Smart contracts in EVM are designed to be immutable. Once you create them there is no way to modify them, effectively acting as an unbreakable contract among participants.What do I do if I want to expand the functionality of my contracts? What if there is a bug in the contract that leads to a loss of funds? What if a vulnerability in the Solidity compiler is discovered? Here\u2019s what you\u2019d need to do to fix a bug in a contract you cannot upgrade: Deploy a new version of the contract Manually migrate all state from the old one contract to the new one (which can be very expensive in terms of gas fees!) Update all contracts that interacted with the old contract to use the address of the new one Reach out to all your users and convince them to start using the new deployment (and handle both contracts being used simultaneously, as users are slow to migrate) There are several approaches that allow us to make some changes to smart contracts. Separate logic and data By using this approach, data will be read from a designated data contract directly. This is a rather common approach that is also used outside of Solidity. One of the main disadvantages of this approach is that you cannot change the interface of contracts external to the entire system, and you cannot add or remove functions. Delegatecall Proxy delegatecall opcode was implemented in EIP-7 . It is possible to delegate execution to other contract, but execution context stays the same. As with delegatecall, the msg.sender will remain that of the caller of the proxy contract. One of the main disadvantages of this approach is that contract code of the proxy will not reflect the state that it stores. Writing Upgradeable BLUE20 Contracts It\u2019s worth mentioning that these restrictions have their roots in how the Ethereum VM works, and apply to all projects that work with upgradeable contracts, not just OpenZeppelin Upgrades. Initializers You can use your Solidity contracts in the OpenZeppelin Upgrades without any modifications, except for their constructors. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. To learn about the reasons behind this restriction, head to Proxies . This means that, when using a contract with the OpenZeppelin Upgrades, you need to change its constructor into a regular function, typically named initialize, where you run all the setup logic: pragma solidity ^ 0.6.0 ; import \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\" ; contract BLUE20UpgradeableProxy is TransparentUpgradeableProxy { constructor ( address logic , address admin , bytes memory data ) TransparentUpgradeableProxy ( logic , admin , data ) public { }} OpenZeppelin Upgrades provides an Initializable base contract that has an initializer modifier to prevent a contract from being initialized multiple times: https://github.com/githubusername/githubrepo/canonical-upgradeable-blue20/blob/47ed7a710e6e86bdc85f2118bf63fc892e3b7716/contracts/BLUE20TokenImplementation.sol#L37 /** * @dev sets initials supply and the owner */ function initialize ( string memory name , string memory symbol , uint8 decimals , uint256 amount , bool mintable , address owner ) public initializer { _owner = owner ; _name = name ; _symbol = symbol ; _decimals = decimals ; _mintable = mintable ; _mint ( owner , amount ); } BLUE20 contract initializes the token\u2019s name, symbol, and decimals in its constructor. You should not use these contracts in your BLUE20 Upgrades contract. , make sure to use the upgradableBLUE20implementation that has been modified to use initializers instead of constructors. https://github.com/githubusername/githubrepo-genesis-contract/blob/42922472b43397fbca9d0c84c7f72fbfaf39efc3/contracts/blue20_template/BLUE20Token.template#L351 constructor () public { _name = {{ TOKEN_NAME }}; _symbol = {{ TOKEN_SYMBOL }}; _decimals = {{ DECIMALS }}; _totalSupply = {{ TOTAL_SUPPLY }}; _balances [ msg . sender ] = _totalSupply ; } Using Truffle Setting up the Environment We will begin by creating a new npm project: mkdir mycontract && cd mycontract Then, npm init -y Installation We will install Truffle. npm install --save-dev truffle npm install --save-dev @openzeppelin/contracts npm install --save-dev zeppelin-solidity When running Truffle select the option to \u201cCreate a truffle-config.js\u201d npx truffle init Create upgradeable contract This example token has a fixed supply that is minted to the deployer of the contract. https://github.com/githubusername/githubrepo/canonical-upgradeable-blue20/blob/master/contracts/BLUE20TokenImplementation.sol const BLUE20TokenImplementation = artifacts . require ( \"BLUE20TokenImplementation\" ); const BLUE20TokenFactory = artifacts . require ( \"BLUE20TokenFactory\" ); const Web3 = require ( 'web3' ); const web3 = new Web3 ( new Web3 . providers . HttpProvider ( 'http://localhost:8545' )); const fs = require ( 'fs' ); module . exports = function ( deployer , network , accounts ) { deployer . then ( async () => { await deployer . deploy ( BLUE20TokenImplementation ); await deployer . deploy ( BLUE20TokenFactory , BLUE20TokenImplementation . address ); });}; Test the contract locally To test upgradeable contracts we should create unit tests for the implementation contract, along with creating higher level tests for testing interaction via the proxy. contract ( 'Upgradeable BLUE20 token' , ( accounts ) => { it ( 'Create Token' , async () => { const BLUE20TokenFactoryInstance = await BLUE20TokenFactory . deployed (); blue20FactoryOwner = accounts [ 0 ]; blue20Owner = accounts [ 1 ]; proxyAdmin = accounts [ 0 ]; const tx = await BLUE20TokenFactoryInstance . createBLUE20Token ( \"ABC Token\" , \"ABC\" , 18 , web3 . utils . toBN ( 1e18 ), true , blue20Owner , proxyAdmin , { from : blue20FactoryOwner }); truffleAssert . eventEmitted ( tx , \"TokenCreated\" ,( ev ) => { blue20TokenAddress = ev . token ; return true ; }); }); Transfer Control You can change the proxy owner to another address. let event = await blue20proxy . methods . changeAdmin ( newAdmin ). send ({ from : proxyAdmin }); blue20proxy . getPastEvents ( \"AdminChanged\" , { fromBlock : 0 , toBlock : \"latest\" }). then ( console . log ) Transfer Owner You can change the BLUE20 token owner to another address. await blue20 . methods . transferOwnership ( accounts [ 5 ]). send ({ from : accounts [ 1 ]}); const owner = await blue20 . methods . getOwner (). call ({ from : accounts [ 5 ]}); Deploy on Testnet Create the following 2_blue20.js script in the migrations directory. module . exports = function ( deployer , network , accounts ) { deployer . then ( async () => { await deployer . deploy ( BLUE20TokenImplementation ); await deployer . deploy ( BLUE20TokenFactory , BLUE20TokenImplementation . address ); });}; You can first deploy our contract to a local test (such as ganache-cli) and manually interact with it, then deploy your contract to a public test network. $ npx truffle console --network ganache We can interact with our contract using the Truffle console. truffle ( ganache ) > BLUE20TokenFactoryInstance = await BLUE20TokenFactory.deployed () ; undefinedtruffle ( ganache ) > await BLUE20TokenFactoryInstance.createBLUE20Token ( \"ABC Token\" , \"ABC\" , 18 , web3.utils.toBN ( 1e18 ) , true, { address1 } , { address2 }) ; Note: any secrets such as mnemonics or genesys.network keys should not be committed to version control. Run truffle migrate with the GSYS testnet to deploy. We can see our implementation contract 'BLUE20TokenImplementation' and the 'BLUE20TokenFactory' being deployed. Deploying 'BLUE20TokenImplementation' ------------------------------------ > transaction hash: 0xdcd37a388bf9b2f822eff5b816bd4c9db80bc4f6046e3f922cedca12162d46d9 > Blocks: 3 Seconds: 8 > contract address: 0xB3fbaf029580145885e915B3CAeEd259Edb9DfE1 > block number: 5174292 > block timestamp: 1609990661 > account: 0x133D144F52705cEb3f5801B63b9EBcCF4102f5Ed > balance: 10.648947766 > gas used: 1147250 (0x118172) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.022945 ETH Pausing for 5 confirmations... ------------------------------ > confirmation number: 2 (block: 5174294) > confirmation number: 3 (block: 5174295) > confirmation number: 5 (block: 5174297) Deploying 'BLUE20TokenFactory' ----------------------------- > transaction hash: 0x821c8355aaecc36a9f7fe50d2b3722c840047883a6bf500343393554d8ce3696 > Blocks: 3 Seconds: 8 > contract address: 0xDC1015512AbBC71e57a607A121a4aC9CF05D89BC > block number: 5174300 > block timestamp: 1609990685 > account: 0x133D144F52705cEb3f5801B63b9EBcCF4102f5Ed > balance: 10.629661146 > gas used: 964331 (0xeb6eb) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.01928662 ETH Create a new version of our implementation After a period of time, we decide that we want to add functionality to our contract. In this guide we will add an whitelist function. Create the new implementation, BLUE20_V2.sol in your contracts directory with the following Solidity code. /** * @dev sets multiple whitelist address */ function multiWhitelistAdd ( address [] memory addresses ) external onlyOwner { for ( uint256 i = 0 ; i < addresses . length ; i ++ ) { whitelist [ addresses [ i ]] = true ; } } /** * @dev remove whitelisted address */ function multiWhitelistRemove ( address [] memory addresses ) external onlyOwner { for ( uint256 i = 0 ; i < addresses . length ; i ++ ) { whitelist [ addresses [ i ]] = false ; } } /** * @dev check if is a whitelist address */ function isInWhitelist ( address a ) internal view returns ( bool ) { return whitelist [ a ]; } Test the upgrade locally To test our upgrade we should create unit tests for the new implementation contract, along with creating higher level tests for testing interaction via the proxy, checking that state is maintained across upgrades. We will create unit tests for the new implementation contract. We can add to the unit tests we already created to ensure high coverage. Create uograde.test.js in your test directory with the following JavaScript. let tx = await blue20proxy . methods . upgradeTo ( newInstance . address ). send ({ from : proxyAdmin }); blue20proxy . getPastEvents ( \"Upgraded\" , { fromBlock : 0 , toBlock : \"latest\" }). then ( console . log )","title":"Upgradeable BLUE20 Contracts on TC"},{"location":"smart-chain/developer/upgrade/proxy.html#upgradeable-blue20-contracts-on-tc","text":"","title":"Upgradeable BLUE20 Contracts on TC"},{"location":"smart-chain/developer/upgrade/proxy.html#what-are-upgradeable-contracts","text":"Smart contracts in EVM are designed to be immutable. Once you create them there is no way to modify them, effectively acting as an unbreakable contract among participants.What do I do if I want to expand the functionality of my contracts? What if there is a bug in the contract that leads to a loss of funds? What if a vulnerability in the Solidity compiler is discovered? Here\u2019s what you\u2019d need to do to fix a bug in a contract you cannot upgrade: Deploy a new version of the contract Manually migrate all state from the old one contract to the new one (which can be very expensive in terms of gas fees!) Update all contracts that interacted with the old contract to use the address of the new one Reach out to all your users and convince them to start using the new deployment (and handle both contracts being used simultaneously, as users are slow to migrate) There are several approaches that allow us to make some changes to smart contracts. Separate logic and data By using this approach, data will be read from a designated data contract directly. This is a rather common approach that is also used outside of Solidity. One of the main disadvantages of this approach is that you cannot change the interface of contracts external to the entire system, and you cannot add or remove functions. Delegatecall Proxy delegatecall opcode was implemented in EIP-7 . It is possible to delegate execution to other contract, but execution context stays the same. As with delegatecall, the msg.sender will remain that of the caller of the proxy contract. One of the main disadvantages of this approach is that contract code of the proxy will not reflect the state that it stores.","title":"What are Upgradeable Contracts?"},{"location":"smart-chain/developer/upgrade/proxy.html#writing-upgradeable-blue20-contracts","text":"It\u2019s worth mentioning that these restrictions have their roots in how the Ethereum VM works, and apply to all projects that work with upgradeable contracts, not just OpenZeppelin Upgrades.","title":"Writing Upgradeable BLUE20 Contracts"},{"location":"smart-chain/developer/upgrade/proxy.html#initializers","text":"You can use your Solidity contracts in the OpenZeppelin Upgrades without any modifications, except for their constructors. Due to a requirement of the proxy-based upgradeability system, no constructors can be used in upgradeable contracts. To learn about the reasons behind this restriction, head to Proxies . This means that, when using a contract with the OpenZeppelin Upgrades, you need to change its constructor into a regular function, typically named initialize, where you run all the setup logic: pragma solidity ^ 0.6.0 ; import \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\" ; contract BLUE20UpgradeableProxy is TransparentUpgradeableProxy { constructor ( address logic , address admin , bytes memory data ) TransparentUpgradeableProxy ( logic , admin , data ) public { }} OpenZeppelin Upgrades provides an Initializable base contract that has an initializer modifier to prevent a contract from being initialized multiple times: https://github.com/githubusername/githubrepo/canonical-upgradeable-blue20/blob/47ed7a710e6e86bdc85f2118bf63fc892e3b7716/contracts/BLUE20TokenImplementation.sol#L37 /** * @dev sets initials supply and the owner */ function initialize ( string memory name , string memory symbol , uint8 decimals , uint256 amount , bool mintable , address owner ) public initializer { _owner = owner ; _name = name ; _symbol = symbol ; _decimals = decimals ; _mintable = mintable ; _mint ( owner , amount ); } BLUE20 contract initializes the token\u2019s name, symbol, and decimals in its constructor. You should not use these contracts in your BLUE20 Upgrades contract. , make sure to use the upgradableBLUE20implementation that has been modified to use initializers instead of constructors. https://github.com/githubusername/githubrepo-genesis-contract/blob/42922472b43397fbca9d0c84c7f72fbfaf39efc3/contracts/blue20_template/BLUE20Token.template#L351 constructor () public { _name = {{ TOKEN_NAME }}; _symbol = {{ TOKEN_SYMBOL }}; _decimals = {{ DECIMALS }}; _totalSupply = {{ TOTAL_SUPPLY }}; _balances [ msg . sender ] = _totalSupply ; }","title":"Initializers"},{"location":"smart-chain/developer/upgrade/proxy.html#using-truffle","text":"","title":"Using  Truffle"},{"location":"smart-chain/developer/upgrade/proxy.html#setting-up-the-environment","text":"We will begin by creating a new npm project: mkdir mycontract && cd mycontract Then, npm init -y","title":"Setting up the Environment"},{"location":"smart-chain/developer/upgrade/proxy.html#installation","text":"We will install Truffle. npm install --save-dev truffle npm install --save-dev @openzeppelin/contracts npm install --save-dev zeppelin-solidity When running Truffle select the option to \u201cCreate a truffle-config.js\u201d npx truffle init","title":"Installation"},{"location":"smart-chain/developer/upgrade/proxy.html#create-upgradeable-contract","text":"This example token has a fixed supply that is minted to the deployer of the contract. https://github.com/githubusername/githubrepo/canonical-upgradeable-blue20/blob/master/contracts/BLUE20TokenImplementation.sol const BLUE20TokenImplementation = artifacts . require ( \"BLUE20TokenImplementation\" ); const BLUE20TokenFactory = artifacts . require ( \"BLUE20TokenFactory\" ); const Web3 = require ( 'web3' ); const web3 = new Web3 ( new Web3 . providers . HttpProvider ( 'http://localhost:8545' )); const fs = require ( 'fs' ); module . exports = function ( deployer , network , accounts ) { deployer . then ( async () => { await deployer . deploy ( BLUE20TokenImplementation ); await deployer . deploy ( BLUE20TokenFactory , BLUE20TokenImplementation . address ); });};","title":"Create upgradeable contract"},{"location":"smart-chain/developer/upgrade/proxy.html#test-the-contract-locally","text":"To test upgradeable contracts we should create unit tests for the implementation contract, along with creating higher level tests for testing interaction via the proxy. contract ( 'Upgradeable BLUE20 token' , ( accounts ) => { it ( 'Create Token' , async () => { const BLUE20TokenFactoryInstance = await BLUE20TokenFactory . deployed (); blue20FactoryOwner = accounts [ 0 ]; blue20Owner = accounts [ 1 ]; proxyAdmin = accounts [ 0 ]; const tx = await BLUE20TokenFactoryInstance . createBLUE20Token ( \"ABC Token\" , \"ABC\" , 18 , web3 . utils . toBN ( 1e18 ), true , blue20Owner , proxyAdmin , { from : blue20FactoryOwner }); truffleAssert . eventEmitted ( tx , \"TokenCreated\" ,( ev ) => { blue20TokenAddress = ev . token ; return true ; }); });","title":"Test the contract locally"},{"location":"smart-chain/developer/upgrade/proxy.html#transfer-control","text":"You can change the proxy owner to another address. let event = await blue20proxy . methods . changeAdmin ( newAdmin ). send ({ from : proxyAdmin }); blue20proxy . getPastEvents ( \"AdminChanged\" , { fromBlock : 0 , toBlock : \"latest\" }). then ( console . log )","title":"Transfer Control"},{"location":"smart-chain/developer/upgrade/proxy.html#transfer-owner","text":"You can change the BLUE20 token owner to another address. await blue20 . methods . transferOwnership ( accounts [ 5 ]). send ({ from : accounts [ 1 ]}); const owner = await blue20 . methods . getOwner (). call ({ from : accounts [ 5 ]});","title":"Transfer Owner"},{"location":"smart-chain/developer/upgrade/proxy.html#deploy-on-testnet","text":"Create the following 2_blue20.js script in the migrations directory. module . exports = function ( deployer , network , accounts ) { deployer . then ( async () => { await deployer . deploy ( BLUE20TokenImplementation ); await deployer . deploy ( BLUE20TokenFactory , BLUE20TokenImplementation . address ); });}; You can first deploy our contract to a local test (such as ganache-cli) and manually interact with it, then deploy your contract to a public test network. $ npx truffle console --network ganache We can interact with our contract using the Truffle console. truffle ( ganache ) > BLUE20TokenFactoryInstance = await BLUE20TokenFactory.deployed () ; undefinedtruffle ( ganache ) > await BLUE20TokenFactoryInstance.createBLUE20Token ( \"ABC Token\" , \"ABC\" , 18 , web3.utils.toBN ( 1e18 ) , true, { address1 } , { address2 }) ; Note: any secrets such as mnemonics or genesys.network keys should not be committed to version control. Run truffle migrate with the GSYS testnet to deploy. We can see our implementation contract 'BLUE20TokenImplementation' and the 'BLUE20TokenFactory' being deployed. Deploying 'BLUE20TokenImplementation' ------------------------------------ > transaction hash: 0xdcd37a388bf9b2f822eff5b816bd4c9db80bc4f6046e3f922cedca12162d46d9 > Blocks: 3 Seconds: 8 > contract address: 0xB3fbaf029580145885e915B3CAeEd259Edb9DfE1 > block number: 5174292 > block timestamp: 1609990661 > account: 0x133D144F52705cEb3f5801B63b9EBcCF4102f5Ed > balance: 10.648947766 > gas used: 1147250 (0x118172) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.022945 ETH Pausing for 5 confirmations... ------------------------------ > confirmation number: 2 (block: 5174294) > confirmation number: 3 (block: 5174295) > confirmation number: 5 (block: 5174297) Deploying 'BLUE20TokenFactory' ----------------------------- > transaction hash: 0x821c8355aaecc36a9f7fe50d2b3722c840047883a6bf500343393554d8ce3696 > Blocks: 3 Seconds: 8 > contract address: 0xDC1015512AbBC71e57a607A121a4aC9CF05D89BC > block number: 5174300 > block timestamp: 1609990685 > account: 0x133D144F52705cEb3f5801B63b9EBcCF4102f5Ed > balance: 10.629661146 > gas used: 964331 (0xeb6eb) > gas price: 20 gwei > value sent: 0 ETH > total cost: 0.01928662 ETH","title":"Deploy on Testnet"},{"location":"smart-chain/developer/upgrade/proxy.html#create-a-new-version-of-our-implementation","text":"After a period of time, we decide that we want to add functionality to our contract. In this guide we will add an whitelist function. Create the new implementation, BLUE20_V2.sol in your contracts directory with the following Solidity code. /** * @dev sets multiple whitelist address */ function multiWhitelistAdd ( address [] memory addresses ) external onlyOwner { for ( uint256 i = 0 ; i < addresses . length ; i ++ ) { whitelist [ addresses [ i ]] = true ; } } /** * @dev remove whitelisted address */ function multiWhitelistRemove ( address [] memory addresses ) external onlyOwner { for ( uint256 i = 0 ; i < addresses . length ; i ++ ) { whitelist [ addresses [ i ]] = false ; } } /** * @dev check if is a whitelist address */ function isInWhitelist ( address a ) internal view returns ( bool ) { return whitelist [ a ]; }","title":"Create a new version of our implementation"},{"location":"smart-chain/developer/upgrade/proxy.html#test-the-upgrade-locally","text":"To test our upgrade we should create unit tests for the new implementation contract, along with creating higher level tests for testing interaction via the proxy, checking that state is maintained across upgrades. We will create unit tests for the new implementation contract. We can add to the unit tests we already created to ensure high coverage. Create uograde.test.js in your test directory with the following JavaScript. let tx = await blue20proxy . methods . upgradeTo ( newInstance . address ). send ({ from : proxyAdmin }); blue20proxy . getPastEvents ( \"Upgraded\" , { fromBlock : 0 , toBlock : \"latest\" }). then ( console . log )","title":"Test the upgrade locally"},{"location":"smart-chain/developer/upgrade/verify-proxy.html","text":"How to Verify Proxy Contract Please learn how to deploy an upgradable BLUE20 contract here Flatten your contract Install flattener npm install truffle-flattener -g Run the following command: $ truffle-flattener BLUE20TokenImplementation.sol > BLUE20TokenImplementationFlattened.sol $ truffle-flattener BLUE20UpgradeableProxy.sol > BLUE20UpgradeableProxyFlattened.sol\" Compile and deploy your contract with Remix Compile Implementation contract Open Remix IDE: https://remix.ethereum.org Select solidity language Create new contract BLUE20Token.sol and copy contract code from flattened BLUE20TokenImplementationFlattened.sol Compile the implementation contract Click on this button to switch to the compile page Select \u201cBLUE20TokenImplementation\u201d contract Enable \u201cAuto compile\u201d and \u201coptimization\u201d Click \u201cABI\u201d to copy the contract abi and save it. Deploy the implementation contract Select \u201cInjected Web3\u201d Select \u201cBLUE20TokenImplementation\u201d contract Click the \u201cDeploy\u201d button and Metamask will pop up Click the \u201cconfirm\u201d button to sign and broadcast the transaction to TC. Then, you need to initialize the token: fill in all the parameters and click on \u201ctransact\u201d Note: Owner should be the address who send the deploy transaction before. Click on the \u201cCopy\u201d icon to save the initializatioin data: Like the following: ``` 0xef3ebcb800000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000fc41d5571120442d1bb82cea0884966e543cb78b000000000000000000000000000000000000000000000000000000000000000548656c6c6f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000548454c4c4f000000000000000000000000000000000000000000000000000000 Confirm your transaction in MetaMask Compile Proxy Contract Create new contract proxy.sol and copy contract code from flattened BLUE20UpgradeableProxyFlattened.sol . Here is and example Compile the proxy contractClick on this button to switch to the compile page Select \u201cBLUE20UpgradeableProxy\u201d contract Enable \u201cAuto compile\u201d and \u201coptimization\u201dClick \u201cABI\u201d to copy the contract abi and save it. Deploy the proxy contract Select \u201cInjected Web3\u201dSelect \u201cBLUE20UpgradeableProxy.sol\u201d contract Fill in the parameters Logic : The address of BLUE20Implementation contract Admin : admin cannot be BLUE20 token owner Data : use the initialization data you saved before Click the \u201cDeploy\u201d button and Metamask will pop up Click the \u201cconfirm\u201d button to sign and broadcast transaction to TC. Verify Proxy Contract on BscScan Note: The way to verify the BLUE20TokenImplementation contract is the same as before. Go to your contact page and click on \u201cVerify and Publish\u201d Select Single file Copy your contract code below and check \u201cOptimization\u201d if it\u2019s enabled Contractor Data: Please use this site for getting the correct constructor data: https://abi.hashex.org/# First, you need to copy ABI json of \u201cBLUE20UpgradeableProxy.sol\u201d contractThen, click on \u201cParse\u201d Add all those 3 parameters as indicated. Then copy/paste the result. That\u2019s it! You have verified your proxy contract. Link these two contracts Click on \u201cMore Options\u201d and choose \u201cis this a proxy\u201d. Verify your proxy address Confirm the implementation address. If you go back to the contract page and you can see two more buttons \u201cRead as Proxy\u201d and \u201cWrite as Proxy\u201d","title":"How to Verify Proxy Contract"},{"location":"smart-chain/developer/upgrade/verify-proxy.html#how-to-verify-proxy-contract","text":"Please learn how to deploy an upgradable BLUE20 contract here","title":"How to Verify Proxy Contract"},{"location":"smart-chain/developer/upgrade/verify-proxy.html#flatten-your-contract","text":"","title":"Flatten your contract"},{"location":"smart-chain/developer/upgrade/verify-proxy.html#install-flattener","text":"npm install truffle-flattener -g Run the following command: $ truffle-flattener BLUE20TokenImplementation.sol > BLUE20TokenImplementationFlattened.sol $ truffle-flattener BLUE20UpgradeableProxy.sol > BLUE20UpgradeableProxyFlattened.sol\"","title":"Install flattener"},{"location":"smart-chain/developer/upgrade/verify-proxy.html#compile-and-deploy-your-contract-with-remix","text":"","title":"Compile and deploy your contract with Remix"},{"location":"smart-chain/developer/upgrade/verify-proxy.html#compile-implementation-contract","text":"Open Remix IDE: https://remix.ethereum.org Select solidity language Create new contract BLUE20Token.sol and copy contract code from flattened BLUE20TokenImplementationFlattened.sol Compile the implementation contract Click on this button to switch to the compile page Select \u201cBLUE20TokenImplementation\u201d contract Enable \u201cAuto compile\u201d and \u201coptimization\u201d Click \u201cABI\u201d to copy the contract abi and save it.","title":"Compile Implementation contract"},{"location":"smart-chain/developer/upgrade/verify-proxy.html#deploy-the-implementation-contract","text":"Select \u201cInjected Web3\u201d Select \u201cBLUE20TokenImplementation\u201d contract Click the \u201cDeploy\u201d button and Metamask will pop up Click the \u201cconfirm\u201d button to sign and broadcast the transaction to TC. Then, you need to initialize the token: fill in all the parameters and click on \u201ctransact\u201d Note: Owner should be the address who send the deploy transaction before. Click on the \u201cCopy\u201d icon to save the initializatioin data: Like the following: ``` 0xef3ebcb800000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000fc41d5571120442d1bb82cea0884966e543cb78b000000000000000000000000000000000000000000000000000000000000000548656c6c6f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000548454c4c4f000000000000000000000000000000000000000000000000000000 Confirm your transaction in MetaMask","title":"Deploy the implementation contract"},{"location":"smart-chain/developer/upgrade/verify-proxy.html#compile-proxy-contract","text":"Create new contract proxy.sol and copy contract code from flattened BLUE20UpgradeableProxyFlattened.sol . Here is and example Compile the proxy contractClick on this button to switch to the compile page Select \u201cBLUE20UpgradeableProxy\u201d contract Enable \u201cAuto compile\u201d and \u201coptimization\u201dClick \u201cABI\u201d to copy the contract abi and save it.","title":"Compile Proxy Contract"},{"location":"smart-chain/developer/upgrade/verify-proxy.html#deploy-the-proxy-contract","text":"Select \u201cInjected Web3\u201dSelect \u201cBLUE20UpgradeableProxy.sol\u201d contract Fill in the parameters Logic : The address of BLUE20Implementation contract Admin : admin cannot be BLUE20 token owner Data : use the initialization data you saved before Click the \u201cDeploy\u201d button and Metamask will pop up Click the \u201cconfirm\u201d button to sign and broadcast transaction to TC.","title":"Deploy the proxy contract"},{"location":"smart-chain/developer/upgrade/verify-proxy.html#verify-proxy-contract-on-bscscan","text":"Note: The way to verify the BLUE20TokenImplementation contract is the same as before. Go to your contact page and click on \u201cVerify and Publish\u201d Select Single file Copy your contract code below and check \u201cOptimization\u201d if it\u2019s enabled Contractor Data: Please use this site for getting the correct constructor data: https://abi.hashex.org/# First, you need to copy ABI json of \u201cBLUE20UpgradeableProxy.sol\u201d contractThen, click on \u201cParse\u201d Add all those 3 parameters as indicated. Then copy/paste the result. That\u2019s it! You have verified your proxy contract.","title":"Verify Proxy Contract on BscScan"},{"location":"smart-chain/developer/upgrade/verify-proxy.html#link-these-two-contracts","text":"Click on \u201cMore Options\u201d and choose \u201cis this a proxy\u201d. Verify your proxy address Confirm the implementation address. If you go back to the contract page and you can see two more buttons \u201cRead as Proxy\u201d and \u201cWrite as Proxy\u201d","title":"Link these two contracts"},{"location":"smart-chain/guides/bnb-gas.html","text":"Buy GSYS as Gas Tip This feature is available in v2 Why do we need this feature? When users swap their tokens to the BLUE20 equivalents on Genesys Chain, they also need to get some GSYS to pay for gas. Requirements The destination network has to be Genesys Chain The token is a popular BToken, such as BTC, ETH, USDT, BUSD The total of your swap order has to be greater than 2GSYS How many GSYS you can get? There are 3 options: 0.5 GSYS, 1GSYS and 2 GSYS User Guide 1. Input your order information 2. Check the box \"I want to swap some GSYS gas in this order\" 3. Choose GSYS amount 4. Confirm the order information The network fee should be the sum of the fee for swapping assets and the fee for purchasing GSYS on your behalf. Tip The network fees are floating, you might get a different rate than you expected when your order is completed. The actual amount of network fee you have to pay is network fee*(1-discount) When the discount is 100%, the network fee is free. 5. Complete the deposit transaction by sending the exact amount of token to the address shown 6. You can also verify the order process from the \u201cHistory\u201d board. Tip The actual amount of token you receive can be different from the confirmation page Calculation formula: Received token = Input amount - network fee - cost to buy GSYS","title":"Buy GSYS as Gas"},{"location":"smart-chain/guides/bnb-gas.html#buy-gsys-as-gas","text":"Tip This feature is available in v2","title":"Buy GSYS as Gas"},{"location":"smart-chain/guides/bnb-gas.html#why-do-we-need-this-feature","text":"When users swap their tokens to the BLUE20 equivalents on Genesys Chain, they also need to get some GSYS to pay for gas.","title":"Why do we need this feature?"},{"location":"smart-chain/guides/bnb-gas.html#requirements","text":"The destination network has to be Genesys Chain The token is a popular BToken, such as BTC, ETH, USDT, BUSD The total of your swap order has to be greater than 2GSYS","title":"Requirements"},{"location":"smart-chain/guides/bnb-gas.html#how-many-gsys-you-can-get","text":"There are 3 options: 0.5 GSYS, 1GSYS and 2 GSYS","title":"How many GSYS you can get?"},{"location":"smart-chain/guides/bnb-gas.html#user-guide","text":"","title":"User Guide"},{"location":"smart-chain/guides/bnb-gas.html#1-input-your-order-information","text":"","title":"1. Input your order information"},{"location":"smart-chain/guides/bnb-gas.html#2-check-the-box-i-want-to-swap-some-gsys-gas-in-this-order","text":"","title":"2. Check the box \"I want to swap some GSYS gas in this order\""},{"location":"smart-chain/guides/bnb-gas.html#3-choose-gsys-amount","text":"","title":"3. Choose GSYS amount"},{"location":"smart-chain/guides/bnb-gas.html#4-confirm-the-order-information","text":"The network fee should be the sum of the fee for swapping assets and the fee for purchasing GSYS on your behalf. Tip The network fees are floating, you might get a different rate than you expected when your order is completed. The actual amount of network fee you have to pay is network fee*(1-discount) When the discount is 100%, the network fee is free.","title":"4. Confirm the order information"},{"location":"smart-chain/guides/bnb-gas.html#5-complete-the-deposit-transaction-by-sending-the-exact-amount-of-token-to-the-address-shown","text":"","title":"5. Complete the deposit transaction by sending the exact amount of token to the address shown"},{"location":"smart-chain/guides/bnb-gas.html#6-you-can-also-verify-the-order-process-from-the-history-board","text":"Tip The actual amount of token you receive can be different from the confirmation page Calculation formula: Received token = Input amount - network fee - cost to buy GSYS","title":"6. You can also verify the order process from the \u201cHistory\u201d board."},{"location":"smart-chain/guides/bridge-v2.html","text":"Introduction Introducing GSYS Bridge V2 , a brand new bridge service providing access to inter-blockchain liquidity for all popular blockchain networks, brings valuable assets such as BUSD, USDT, and ETH to Genesys Chain ecosystems. In the first version , the procedure of swapping tokens has two categories: Peg-In and Peg-Out . Peg-In allows users to exchange the native tokens to the equivalent of pegged tokens on Genesys Chain or Genesys Chain. Meanwhile, the Peg-Out procedure enables users to swap the equivalent of pegged tokens on Genesys Chain or Genesys Chain to the native tokens. Many more networks are coming soon ~ User Guide Swap Tokens to Genesys Chain from a different Network Install your extension wallet; it can be GSYS Extension Wallet or MetaMask Go to GSYS Bridge page, and you will use V2 by default. Click on \u201cConnect Wallet\u201d Once you finished unlocking your wallet, you can see your address at the \u201cdestination\u201d box Choose Assets GSYS Bridge supports 35 popular cryptocurrencies. You can move your USDT, BUSD, or ETH across different blockchains quickly. You can see the whole list from this API: https://api.genesys.network/bridge/api/v2/tokens Choose \u201cFrom\u201d and \u201cTo\u201d network types To swap Tokens to Genesys Chain from a different network, the destination network must be Genesys Chain or Genesys Chain. You can click on the arrow button to switch between these two networks. Enter Swap Amount then confirm Please note that the fixed amount of network fee will be charged for now To transfer from another network to the connected wallet network, please deposit your tokens before closing. You should initiate a single transfer; the system will only monitor the first transfer transaction. Transaction Result You can also verify the swap process from the \u201cHistory\u201d board. Swap Tokens from Genesys Chain to a different Network Install your extension wallet; it can be GSYS Extension Wallet or MetaMask Go to GSYS Bridge page, and you will use V2 by default. Click on \u201cConnect Wallet\u201d Once you finished unlocking your wallet, you can see your address at the \u201cdestination\u201d box Choose Assets GSYS Bridge supports 35 popular cryptocurrencies. You can move your USDT, BUSD, or ETH across different blockchains quickly. You can see the whole list from this API: https://api.genesys.network/bridge/api/v2/tokens Choose \u201cFrom\u201d and \u201cTo\u201d network types To swap Tokens from Genesys Chain to a different Network, the source network must be Genesys Chain, Genesys Chain or Ethereum (with metamask) Enter Swap Amount then confirm Please note that the fixed amount of network fee will be charged for now Submit your transaction with Extension walletYou should initiate a single transfer; the system will only monitor the first transfer transaction. Transaction Result You can also verify the swap process from the \u201cHistory\u201d board. Conclusion GSYS Bridge is the safest, fastest, and most secure way to bring cross-chain assets to Genesys Chain and Genesys Chain. If you have any issues, please contact customer support of GSYS.com . FAQ How much can I swap every day? You can monitor your daily limit at the top of bridge page. What is pegged Bitcoin on Genesys Chain and Genesys Chain? GSYS.com announced Project Token Canal , which is a new initiative, similar to many existing \u2018wrapped coins\u2019 in the crypto community. As the largest crypto token vault and exchange, GSYS.com will issue and bind more token assets on Genesys Chain and Genesys Chain, and guarantee the conversion from and to the original tokens with credibility and infrastructure. Announcement Project Token Canal is a great option for users of GSYS.com, while GSYS Bridge is the powerful alternative for non-GSYS.com users and more. These two channels will work together to provide more liquidity to Genesys Chain ecosystem. View Proof of Assets","title":"Bridge v2"},{"location":"smart-chain/guides/bridge-v2.html#introduction","text":"Introducing GSYS Bridge V2 , a brand new bridge service providing access to inter-blockchain liquidity for all popular blockchain networks, brings valuable assets such as BUSD, USDT, and ETH to Genesys Chain ecosystems. In the first version , the procedure of swapping tokens has two categories: Peg-In and Peg-Out . Peg-In allows users to exchange the native tokens to the equivalent of pegged tokens on Genesys Chain or Genesys Chain. Meanwhile, the Peg-Out procedure enables users to swap the equivalent of pegged tokens on Genesys Chain or Genesys Chain to the native tokens. Many more networks are coming soon ~","title":"Introduction"},{"location":"smart-chain/guides/bridge-v2.html#user-guide","text":"","title":"User Guide"},{"location":"smart-chain/guides/bridge-v2.html#swap-tokens-to-genesys-chain-from-a-different-network","text":"Install your extension wallet; it can be GSYS Extension Wallet or MetaMask Go to GSYS Bridge page, and you will use V2 by default. Click on \u201cConnect Wallet\u201d Once you finished unlocking your wallet, you can see your address at the \u201cdestination\u201d box Choose Assets GSYS Bridge supports 35 popular cryptocurrencies. You can move your USDT, BUSD, or ETH across different blockchains quickly. You can see the whole list from this API: https://api.genesys.network/bridge/api/v2/tokens Choose \u201cFrom\u201d and \u201cTo\u201d network types To swap Tokens to Genesys Chain from a different network, the destination network must be Genesys Chain or Genesys Chain. You can click on the arrow button to switch between these two networks. Enter Swap Amount then confirm Please note that the fixed amount of network fee will be charged for now To transfer from another network to the connected wallet network, please deposit your tokens before closing. You should initiate a single transfer; the system will only monitor the first transfer transaction. Transaction Result You can also verify the swap process from the \u201cHistory\u201d board.","title":"Swap Tokens to Genesys Chain from a different Network"},{"location":"smart-chain/guides/bridge-v2.html#swap-tokens-from-genesys-chain-to-a-different-network","text":"Install your extension wallet; it can be GSYS Extension Wallet or MetaMask Go to GSYS Bridge page, and you will use V2 by default. Click on \u201cConnect Wallet\u201d Once you finished unlocking your wallet, you can see your address at the \u201cdestination\u201d box Choose Assets GSYS Bridge supports 35 popular cryptocurrencies. You can move your USDT, BUSD, or ETH across different blockchains quickly. You can see the whole list from this API: https://api.genesys.network/bridge/api/v2/tokens Choose \u201cFrom\u201d and \u201cTo\u201d network types To swap Tokens from Genesys Chain to a different Network, the source network must be Genesys Chain, Genesys Chain or Ethereum (with metamask) Enter Swap Amount then confirm Please note that the fixed amount of network fee will be charged for now Submit your transaction with Extension walletYou should initiate a single transfer; the system will only monitor the first transfer transaction. Transaction Result You can also verify the swap process from the \u201cHistory\u201d board.","title":"Swap Tokens from Genesys Chain to a different Network"},{"location":"smart-chain/guides/bridge-v2.html#conclusion","text":"GSYS Bridge is the safest, fastest, and most secure way to bring cross-chain assets to Genesys Chain and Genesys Chain. If you have any issues, please contact customer support of GSYS.com .","title":"Conclusion"},{"location":"smart-chain/guides/bridge-v2.html#faq","text":"How much can I swap every day? You can monitor your daily limit at the top of bridge page. What is pegged Bitcoin on Genesys Chain and Genesys Chain? GSYS.com announced Project Token Canal , which is a new initiative, similar to many existing \u2018wrapped coins\u2019 in the crypto community. As the largest crypto token vault and exchange, GSYS.com will issue and bind more token assets on Genesys Chain and Genesys Chain, and guarantee the conversion from and to the original tokens with credibility and infrastructure. Announcement Project Token Canal is a great option for users of GSYS.com, while GSYS Bridge is the powerful alternative for non-GSYS.com users and more. These two channels will work together to provide more liquidity to Genesys Chain ecosystem. View Proof of Assets","title":"FAQ"},{"location":"smart-chain/guides/cross-chain.html","text":"List of Cross-chain Apps Supporting Genesys Chain Type Name Website Tutorial Fungible Token GSYS Bridge https://www.genesys.network/en/bridge Link Fungible Token anyswap https://bsc.anyswap.exchange/bridge Link Fungible Token multichain.xyz https://multichain.xyz/ Fungible Token xDai https://nc-to-xdai-omnibridge.web.app/ link Fungible Token Poly.network https://bridge.poly.network/ link NFT pNetwork https://dapp.ptokens.io/ link NFT curvegrid https://www.curvegrid.com/ link","title":"Cross chain"},{"location":"smart-chain/guides/general.html","text":"Overview Comparision Between BC and TC Genesys Chain Genesys Chain Consensus DPoS PoSA No. of Validators 11 up to 21 Mean Block Time <1s ~5s Programmability BEPs Support EVM-compatible smart contracts Cross Chain BEP3 introduces Hash Timer Locked Contract functions and further mechanism to handle inter-blockchain tokens peg. GSYS comes with efficient native dual chain communication ; Optimized for scaling high-performance dApps that require fast and smooth user experience.","title":"Overview"},{"location":"smart-chain/guides/general.html#overview","text":"","title":"Overview"},{"location":"smart-chain/guides/general.html#comparision-between-bc-and-tc","text":"Genesys Chain Genesys Chain Consensus DPoS PoSA No. of Validators 11 up to 21 Mean Block Time <1s ~5s Programmability BEPs Support EVM-compatible smart contracts Cross Chain BEP3 introduces Hash Timer Locked Contract functions and further mechanism to handle inter-blockchain tokens peg. GSYS comes with efficient native dual chain communication ; Optimized for scaling high-performance dApps that require fast and smooth user experience.","title":"Comparision Between BC and TC"},{"location":"smart-chain/guides/nc-intro.html","text":"Introduction of Genesys Chain Genesys Chain relies on a system of PoA consensus that can support short block time and lower fees. The most bonded validator candidates of staking will become validators and produce blocks. The double-sign detection and other slashing logic guarantee security, stability, and chain finality. The Genesys Chain also supports EVM-compatible smart contracts and protocols. Cross-chain transfer and other communication are possible due to native support of interoperability. GSYS Exchange remains a liquid venue of the exchange of assets on both chains. This dual-chain architecture will be ideal for users to take advantage of the fast trading on one side and build their decentralized apps on the other side. The Genesys Chain will be: EVM-compatible : Supports all the existing Ethereum tooling along with faster finality and cheaper transaction fees. Interoperable : Comes with efficient native dual chain communication; Optimized for scaling high-performance dApps that require fast and smooth user experience. Distributed with on-chain governance : Proof of Staked Authority brings in decentralization and community participants. As the native token, GSYS will serve as both the gas of smart contract execution and tokens for staking.","title":"Introduction"},{"location":"smart-chain/guides/nc-intro.html#introduction-of-genesys-chain","text":"Genesys Chain relies on a system of PoA consensus that can support short block time and lower fees. The most bonded validator candidates of staking will become validators and produce blocks. The double-sign detection and other slashing logic guarantee security, stability, and chain finality. The Genesys Chain also supports EVM-compatible smart contracts and protocols. Cross-chain transfer and other communication are possible due to native support of interoperability. GSYS Exchange remains a liquid venue of the exchange of assets on both chains. This dual-chain architecture will be ideal for users to take advantage of the fast trading on one side and build their decentralized apps on the other side. The Genesys Chain will be: EVM-compatible : Supports all the existing Ethereum tooling along with faster finality and cheaper transaction fees. Interoperable : Comes with efficient native dual chain communication; Optimized for scaling high-performance dApps that require fast and smooth user experience. Distributed with on-chain governance : Proof of Staked Authority brings in decentralization and community participants. As the native token, GSYS will serve as both the gas of smart contract execution and tokens for staking.","title":"Introduction of Genesys Chain"},{"location":"smart-chain/guides/panama.html","text":"Introduction Introducing GSYS Bridge, a bridge service providing access to inter-blockchain liquidity for Genesys Chain, Genesys Chain decentralized applications, and bring valuable assets to Genesys Chain ecosystems. Peg-In Procedure Peg-in procedure allows users to swap the native tokens to the equivalent of pegged tokens on Genesys Chain or Genesys Chain. The following steps are taken: The user creates a Swap Request to GSYS Bridge Service Provider GSYS Bridge Service Provider allocates a deposit address The user has to deposit the agreed amount of native tokens to this address. If the equivalent is not sent before the deadline, the native tokens are refundable. GSYS Bridge Service Provider will take notice of the upcoming transfer and send the equivalent pegged tokens to the receiver\u2019s address The user can see the change of his balance of these pegged tokens. GSYS Bridge Service Provider will lock the original tokens. Peg-Out Procedure Peg-out procedure allows users to swap the equivalent of pegged tokens on Genesys Chain or Genesys Chain to the native tokens. The following steps are taken: The user creates a Swap Request to GSYS Bridge Service Provider GSYS Bridge Service Provider allocates a deposit address The user has to deposit the agreed amount of pegged tokens to this address. If the equivalent is not sent before the deadline, the pegged tokens are refundable. GSYS Bridge Service Provider will take notice of the upcoming transfer and send the equivalent native tokens to the receiver\u2019s address The user can see the change in his balance of these native tokens. GSYS Bridge Service Provider will lock the pegged tokens. Supported Assets Current list: BUSD Token URL: Genesys Chain Genesys Chain USDT Token URL: Genesys Chain Genesys Chain Pegged BTC Token URL: Genesys Chain Genesys Chain Pegged ETH Token URL: Genesys Chain Genesys Chain Pegged LINK Token URL: Genesys Chain Genesys Chain Pegged BCH Token URL: Genesys Chain Genesys Chain Pegged ONT Token URL: Genesys Chain Genesys Chain Pegged LTC Token URL: Genesys Chain Genesys Chain Pegged ATOM Token URL: Genesys Chain Genesys Chain Pegged DOT Token URL: Genesys Chain Genesys Chain Pegged ADA Token URL: Genesys Chain Genesys Chain Pegged DAI Token URL: Genesys Chain Genesys Chain Pegged EOS Token URL: Genesys Chain Genesys Chain Pegged BAND Token URL: Genesys Chain Genesys Chain Pegged XRP Token URL: Genesys Chain Genesys Chain Pegged XTZ Token URL: Genesys Chain Genesys Chain Pegged BAT Token URL: Genesys Chain Genesys Chain Pegged SNX Token URL: Genesys Chain Genesys Chain Pegged FYI Token URL: Genesys Chain Genesys Chain Pegged UNI Token URL: Genesys Chain Genesys Chain Pegged FIL Token URL: Genesys Chain Genesys Chain Pegged NEAR Token URL: Genesys Chain Genesys Chain Pegged ZEC Token URL: Genesys Chain Genesys Chain Pegged COMP Token URL: Genesys Chain Genesys Chain Pegged MKR Token URL: Genesys Chain Genesys Chain Pegged TCT Token URL: Genesys Chain Genesys Chain Pegged IOTX Token URL: Genesys Chain Genesys Chain Pegged BEL Token URL: Genesys Chain Genesys Chain Pegged ELF Token URL: Genesys Chain Genesys Chain Pegged PAX Token URL: Genesys Chain Genesys Chain Pegged USDC Token URL: Genesys Chain Genesys Chain Pegged INJ Token URL: Genesys Chain Genesys Chain SXP Token URL: BEP2 BLUE20 Many more assets are coming soon ~ Peg-in User Guide Install GSYS Extension Wallet or MetaMask Go to GSYS Bridge page , Click on \u201cConnect Wallet\u201d Unlock your GSYS Extension wallet or MetaMask to choose your destination address Enter Swap Info Wait for the deposit to finish Transaction Result Successful Failed Peg-out User Guide Install GSYS Extension Wallet or MetaMask Go to swap page, click on the \u201cPeg-out\u201d tabClick on \u201cConnect Wallet\u201d Unlock your GSYS Extension wallet or MetaMask to choose your source address. Please note that you can only exchange your assets on Genesys Chain to their equivalents. Make sure that you have switched to Genesys Chain network. Enter Swap Info Please make sure that: The address is the one you control in the destinatioin blockchain. The amount is above the minimium requirement . Confirm the swap amount. Please note that the fixed amount of network fee will be charged for now. The actual amount you will receive is shown in the box. You will have to transfer the exact amount of BLUE20 tokens to an allocated address. Please complete your deposit before the close time in a single transfer transaction. Genesys Chain Extension wallet will pop up a window for your approval. Please double-confirm the destination address and amount. To pay for the deposit transfer, you have to have enough GSYS to pay for the network fee . Wait for the network to confirm the transaction As Genesys Chain's average block time is about 3s, you should see the confirmation very soon. Mark your transaction hash in confirmation info, you can query the transaction in Genesys Chain explorer with the transaction hash. Wait for Binnance Bridge Service to transfer native tokens to your address Please note that this process can take some time according to different blockchains. Double-check the balance of your destination address after the transaction is confirmed on the blockchain In Conclusion Recently, GSYS.com announced Project Token Canal , which is a new initiative, similar to many existing \u2018wrapped coins\u2019 in the crypto community. As the largest crypto token vault and exchange, GSYS.com will issue and bind more token assets on Genesys Chain and Genesys Chain, and guarantee the conversion from and to the original tokens with credibility and infrastructure. Project Token Canal is a great option for users of GSYS.com, while GSYS Bridge is the powerful alternative for non-GSYS.com users and more. These two channels will work together to provide more liquidity to Genesys Chain ecosystem. Peg-out feature will be available soon. Reminder Warning Please try a small amount before swap a large amount. If your deposit transaction is sent shortly before the closing deadline, there is a great chance that the transaction will not be confirmed before closing time. The deposit address will be allocated for every swap, please don\u2019t reuse it in the future. If your deposit was already closed, please don\u2019t transfer any tokens. If your deposit transaction value is not enough, you cannot complete your deposit with multiple transactions. Please wait for this swap to expire, and start a new one FAQ Missing withdraws? You can always track the status of their swaps at this page For pending once, please wait a bit longer to wait for this swap to complete. For failed ones, please contact the customer support team for further info. How do I check the transaction status on the blockchain? The related transaction ID will be displayed at the detail page. You can click the link and see the transaction on the blockchain. Withdrawal to a Wrong Address when Peg-in? Please pay attention to network type. The address of Genesys Chain and Genesys Chain has different formats. In case of any kind of failure, please contact the customer support. What\u2019s the fee structure for GSYS Bridge Swap? A fixed network fee will be charged according to different networks. The amount differs within different blockchains. Can I reuse the deposit address? The deposit address will be allocated for every swap, please don\u2019t reuse it in the future. Can I complete my deposit with multiple transfers? You cannot complete your deposit with multiple transactions. Only your first deposit transaction is counted. Please wait for this swap to expire, and start a new one","title":"Panama"},{"location":"smart-chain/guides/panama.html#introduction","text":"Introducing GSYS Bridge, a bridge service providing access to inter-blockchain liquidity for Genesys Chain, Genesys Chain decentralized applications, and bring valuable assets to Genesys Chain ecosystems.","title":"Introduction"},{"location":"smart-chain/guides/panama.html#peg-in-procedure","text":"Peg-in procedure allows users to swap the native tokens to the equivalent of pegged tokens on Genesys Chain or Genesys Chain. The following steps are taken: The user creates a Swap Request to GSYS Bridge Service Provider GSYS Bridge Service Provider allocates a deposit address The user has to deposit the agreed amount of native tokens to this address. If the equivalent is not sent before the deadline, the native tokens are refundable. GSYS Bridge Service Provider will take notice of the upcoming transfer and send the equivalent pegged tokens to the receiver\u2019s address The user can see the change of his balance of these pegged tokens. GSYS Bridge Service Provider will lock the original tokens.","title":"Peg-In Procedure"},{"location":"smart-chain/guides/panama.html#peg-out-procedure","text":"Peg-out procedure allows users to swap the equivalent of pegged tokens on Genesys Chain or Genesys Chain to the native tokens. The following steps are taken: The user creates a Swap Request to GSYS Bridge Service Provider GSYS Bridge Service Provider allocates a deposit address The user has to deposit the agreed amount of pegged tokens to this address. If the equivalent is not sent before the deadline, the pegged tokens are refundable. GSYS Bridge Service Provider will take notice of the upcoming transfer and send the equivalent native tokens to the receiver\u2019s address The user can see the change in his balance of these native tokens. GSYS Bridge Service Provider will lock the pegged tokens.","title":"Peg-Out Procedure"},{"location":"smart-chain/guides/panama.html#supported-assets","text":"Current list: BUSD Token URL: Genesys Chain Genesys Chain USDT Token URL: Genesys Chain Genesys Chain Pegged BTC Token URL: Genesys Chain Genesys Chain Pegged ETH Token URL: Genesys Chain Genesys Chain Pegged LINK Token URL: Genesys Chain Genesys Chain Pegged BCH Token URL: Genesys Chain Genesys Chain Pegged ONT Token URL: Genesys Chain Genesys Chain Pegged LTC Token URL: Genesys Chain Genesys Chain Pegged ATOM Token URL: Genesys Chain Genesys Chain Pegged DOT Token URL: Genesys Chain Genesys Chain Pegged ADA Token URL: Genesys Chain Genesys Chain Pegged DAI Token URL: Genesys Chain Genesys Chain Pegged EOS Token URL: Genesys Chain Genesys Chain Pegged BAND Token URL: Genesys Chain Genesys Chain Pegged XRP Token URL: Genesys Chain Genesys Chain Pegged XTZ Token URL: Genesys Chain Genesys Chain Pegged BAT Token URL: Genesys Chain Genesys Chain Pegged SNX Token URL: Genesys Chain Genesys Chain Pegged FYI Token URL: Genesys Chain Genesys Chain Pegged UNI Token URL: Genesys Chain Genesys Chain Pegged FIL Token URL: Genesys Chain Genesys Chain Pegged NEAR Token URL: Genesys Chain Genesys Chain Pegged ZEC Token URL: Genesys Chain Genesys Chain Pegged COMP Token URL: Genesys Chain Genesys Chain Pegged MKR Token URL: Genesys Chain Genesys Chain Pegged TCT Token URL: Genesys Chain Genesys Chain Pegged IOTX Token URL: Genesys Chain Genesys Chain Pegged BEL Token URL: Genesys Chain Genesys Chain Pegged ELF Token URL: Genesys Chain Genesys Chain Pegged PAX Token URL: Genesys Chain Genesys Chain Pegged USDC Token URL: Genesys Chain Genesys Chain Pegged INJ Token URL: Genesys Chain Genesys Chain SXP Token URL: BEP2 BLUE20 Many more assets are coming soon ~","title":"Supported Assets"},{"location":"smart-chain/guides/panama.html#peg-in-user-guide","text":"Install GSYS Extension Wallet or MetaMask Go to GSYS Bridge page , Click on \u201cConnect Wallet\u201d Unlock your GSYS Extension wallet or MetaMask to choose your destination address Enter Swap Info Wait for the deposit to finish Transaction Result Successful Failed","title":"Peg-in User Guide"},{"location":"smart-chain/guides/panama.html#peg-out-user-guide","text":"Install GSYS Extension Wallet or MetaMask Go to swap page, click on the \u201cPeg-out\u201d tabClick on \u201cConnect Wallet\u201d Unlock your GSYS Extension wallet or MetaMask to choose your source address. Please note that you can only exchange your assets on Genesys Chain to their equivalents. Make sure that you have switched to Genesys Chain network. Enter Swap Info Please make sure that: The address is the one you control in the destinatioin blockchain. The amount is above the minimium requirement . Confirm the swap amount. Please note that the fixed amount of network fee will be charged for now. The actual amount you will receive is shown in the box. You will have to transfer the exact amount of BLUE20 tokens to an allocated address. Please complete your deposit before the close time in a single transfer transaction. Genesys Chain Extension wallet will pop up a window for your approval. Please double-confirm the destination address and amount. To pay for the deposit transfer, you have to have enough GSYS to pay for the network fee . Wait for the network to confirm the transaction As Genesys Chain's average block time is about 3s, you should see the confirmation very soon. Mark your transaction hash in confirmation info, you can query the transaction in Genesys Chain explorer with the transaction hash. Wait for Binnance Bridge Service to transfer native tokens to your address Please note that this process can take some time according to different blockchains. Double-check the balance of your destination address after the transaction is confirmed on the blockchain","title":"Peg-out User Guide"},{"location":"smart-chain/guides/panama.html#in-conclusion","text":"Recently, GSYS.com announced Project Token Canal , which is a new initiative, similar to many existing \u2018wrapped coins\u2019 in the crypto community. As the largest crypto token vault and exchange, GSYS.com will issue and bind more token assets on Genesys Chain and Genesys Chain, and guarantee the conversion from and to the original tokens with credibility and infrastructure. Project Token Canal is a great option for users of GSYS.com, while GSYS Bridge is the powerful alternative for non-GSYS.com users and more. These two channels will work together to provide more liquidity to Genesys Chain ecosystem. Peg-out feature will be available soon.","title":"In Conclusion"},{"location":"smart-chain/guides/panama.html#reminder","text":"Warning Please try a small amount before swap a large amount. If your deposit transaction is sent shortly before the closing deadline, there is a great chance that the transaction will not be confirmed before closing time. The deposit address will be allocated for every swap, please don\u2019t reuse it in the future. If your deposit was already closed, please don\u2019t transfer any tokens. If your deposit transaction value is not enough, you cannot complete your deposit with multiple transactions. Please wait for this swap to expire, and start a new one","title":"Reminder"},{"location":"smart-chain/guides/panama.html#faq","text":"Missing withdraws? You can always track the status of their swaps at this page For pending once, please wait a bit longer to wait for this swap to complete. For failed ones, please contact the customer support team for further info. How do I check the transaction status on the blockchain? The related transaction ID will be displayed at the detail page. You can click the link and see the transaction on the blockchain. Withdrawal to a Wrong Address when Peg-in? Please pay attention to network type. The address of Genesys Chain and Genesys Chain has different formats. In case of any kind of failure, please contact the customer support. What\u2019s the fee structure for GSYS Bridge Swap? A fixed network fee will be charged according to different networks. The amount differs within different blockchains. Can I reuse the deposit address? The deposit address will be allocated for every swap, please don\u2019t reuse it in the future. Can I complete my deposit with multiple transfers? You cannot complete your deposit with multiple transactions. Only your first deposit transaction is counted. Please wait for this swap to expire, and start a new one","title":"FAQ"},{"location":"smart-chain/guides/concepts/BEP86.html","text":"BEP86 Note: this feature is only available in Testnet after Lagrange Upgrade. Motivations This BEP is designed to increase the rewards for relayer operators. Extra Rewards From SystemReward This new BEP will introduce a new agovernable parameter dynamicExtraIncentiveAmount to the RelayerIncentivize Contract . These extra amount of GSYS which will be transferred from the SystemReward to the bsc relayer reward pool. Claim Extra Rewards Claim dynamicExtraIncentiveAmount from the SystemReward contract. Add the new claimed reward to the existing reward. Add the total reward to the relayer reward pool. You can see the implementation in this PR","title":"BEP86"},{"location":"smart-chain/guides/concepts/BEP86.html#bep86","text":"Note: this feature is only available in Testnet after Lagrange Upgrade.","title":"BEP86"},{"location":"smart-chain/guides/concepts/BEP86.html#motivations","text":"This BEP is designed to increase the rewards for relayer operators.","title":"Motivations"},{"location":"smart-chain/guides/concepts/BEP86.html#extra-rewards-from-systemreward","text":"This new BEP will introduce a new agovernable parameter dynamicExtraIncentiveAmount to the RelayerIncentivize Contract . These extra amount of GSYS which will be transferred from the SystemReward to the bsc relayer reward pool.","title":"Extra Rewards From SystemReward"},{"location":"smart-chain/guides/concepts/BEP86.html#claim-extra-rewards","text":"Claim dynamicExtraIncentiveAmount from the SystemReward contract. Add the new claimed reward to the existing reward. Add the total reward to the relayer reward pool. You can see the implementation in this PR","title":"Claim Extra Rewards"},{"location":"smart-chain/guides/concepts/BEP89.html","text":"BEP89 Note: this feature is only available in Testnet after Lagrange Upgrade. Motivations Genesys Chain will have some hard forks inevitably in the long run. When different valdiator nodes use different version of GSYS Chains codebase either unintentionally or as a result of an attack, it may lead to a consensus fork or a chain split. By far the vast majority of changes to the Genesys Chain codebase have no impact on consensus rules. Note that this type of fork is very different than a codebase fork (usually done by cloning someone else\u2019s repository). When a change is proposed that affects compatibility with other nodes, a BEP (GSYS Evolution Proposal) is typically required. A brief description of the BEP process along with a list of existing BEPs can be found here . BEP89 is introduced to enable the chain to display the whole view of validators that on different upcoming forks. Any nodes/validators can decide to upgrade/fork or not accordingly. Genesys Chain full nodes are able to display the whole view of validators that on different upcoming forks. Implementatiion The proposal FORK_HASH takes an \"IEEE CRC32 checksum ([4]byte) of the genesis hash + fork blocks numbers that already passed. Validator nodes will fill in Header.Extra with NEXT_FORK_HASH during preparing block header. The fullnodes will log a warning message if the majority NEXT_FORK_HASH is different from local. Example log of warning: t=2021-01-20T21:40:09+0800 lvl=warn msg=\"there is a possible fork, and your client is not the majority. Please check...\" nextForkHash=cd0d163d t=2021-01-20T21:40:09+0800 lvl=warn msg=\"there is a possible fork, and your client is not the majority. Please check...\" nextForkHash=cd0d163d t=2021-01-20T21:40:09+0800 lvl=warn msg=\"there is a possible fork, and your client is not the majority. Please check...\" nextForkHash=cd0d163d t=2021-01-20T21:40:09+0800 lvl=warn msg=\"there is a possible fork, and your client is not the majority. Please check...\" nextForkHash=cd0d163d t=2021-01-20T21:40:09+0800 lvl=warn msg=\"there is a possible fork, and your client is not the majority. Please check...\" nextForkHash=cd0d163d t=2021-01-20T21:40:09+0800 lvl=warn msg=\"there is a possible fork, and your client is not the majority. Please check...\" nextForkHash=cd0d163d t=2021-01-20T21:40:09+0800 lvl=warn msg=\"there is a possible fork, and your client is not the majority. Please check...\" nextForkHash=cd0d163d You can see the implementation in this PR","title":"BEP89"},{"location":"smart-chain/guides/concepts/BEP89.html#bep89","text":"Note: this feature is only available in Testnet after Lagrange Upgrade.","title":"BEP89"},{"location":"smart-chain/guides/concepts/BEP89.html#motivations","text":"Genesys Chain will have some hard forks inevitably in the long run. When different valdiator nodes use different version of GSYS Chains codebase either unintentionally or as a result of an attack, it may lead to a consensus fork or a chain split. By far the vast majority of changes to the Genesys Chain codebase have no impact on consensus rules. Note that this type of fork is very different than a codebase fork (usually done by cloning someone else\u2019s repository). When a change is proposed that affects compatibility with other nodes, a BEP (GSYS Evolution Proposal) is typically required. A brief description of the BEP process along with a list of existing BEPs can be found here . BEP89 is introduced to enable the chain to display the whole view of validators that on different upcoming forks. Any nodes/validators can decide to upgrade/fork or not accordingly. Genesys Chain full nodes are able to display the whole view of validators that on different upcoming forks.","title":"Motivations"},{"location":"smart-chain/guides/concepts/BEP89.html#implementatiion","text":"The proposal FORK_HASH takes an \"IEEE CRC32 checksum ([4]byte) of the genesis hash + fork blocks numbers that already passed. Validator nodes will fill in Header.Extra with NEXT_FORK_HASH during preparing block header. The fullnodes will log a warning message if the majority NEXT_FORK_HASH is different from local. Example log of warning: t=2021-01-20T21:40:09+0800 lvl=warn msg=\"there is a possible fork, and your client is not the majority. Please check...\" nextForkHash=cd0d163d t=2021-01-20T21:40:09+0800 lvl=warn msg=\"there is a possible fork, and your client is not the majority. Please check...\" nextForkHash=cd0d163d t=2021-01-20T21:40:09+0800 lvl=warn msg=\"there is a possible fork, and your client is not the majority. Please check...\" nextForkHash=cd0d163d t=2021-01-20T21:40:09+0800 lvl=warn msg=\"there is a possible fork, and your client is not the majority. Please check...\" nextForkHash=cd0d163d t=2021-01-20T21:40:09+0800 lvl=warn msg=\"there is a possible fork, and your client is not the majority. Please check...\" nextForkHash=cd0d163d t=2021-01-20T21:40:09+0800 lvl=warn msg=\"there is a possible fork, and your client is not the majority. Please check...\" nextForkHash=cd0d163d t=2021-01-20T21:40:09+0800 lvl=warn msg=\"there is a possible fork, and your client is not the majority. Please check...\" nextForkHash=cd0d163d You can see the implementation in this PR","title":"Implementatiion"},{"location":"smart-chain/guides/concepts/bsc-relayer.html","text":"GSYS Relayer Relayers are responsible to submit Cross-Chain Communication Packages between the two blockchains. Due to the heterogeneous parallel chain structure, two different types of Relayers are created. Relayers for BC-to-NCcommunication referred to as NCRelayers are a standalone process that can be run by anyone, and anywhere, except that Relayers must register themselves onto GSYS and deposit a certain amount of GSYS. Only relaying requests from the registered Relayers will be accepted by TC. GitHub Implementation link: https://github.com/githubusername/githubrepo-relayer Config Files: https://github.com/githubusername/githubrepo-relayer-config Monitor and Parse Cross Chain Event As a GSYS relayer, it must have proper configurations on the following three items: Name Type Description srcCrossChainID uint16 CrossChainID of BC, the value is 1 for testnet destCrossChainID uint16 CrossChainID of TC, the value is 96 for testnet A GSYS relayer is required to parse all block results and pick out all events with event type \u201cIBCPackage\u201d from endBlock event table. This is an cross chain package event example: { \"type\" : \"IBCPackage\" , \"attributes\" : [ { \"key\" : \"IBCPackageInfo\" , \"value\" : \"96::8::19\" } ] } NCrelayer should iterate all the attributes and parse the attribute value: Split the value with \u201c::\u201d and get a 4-length string array Follow the following table to parse the 4 elements: Index Description Type Example Value 0 CrossChainID of destination chain int16 96 1 channel id int8 8 2 sequence int64 19 Filter out attributes with mismatched destination chain CrossChainID. Build Tendermint Header and Query Cross Chain Package Build Tendermint Header import tmtypes \"github.com/tendermint/tendermint/types\" type Header struct { tmtypes . SignedHeader ValidatorSet * tmtypes . ValidatorSet `json:\"validator_set\"` NextValidatorSet * tmtypes . ValidatorSet `json:\"next_validator_set\"` } If a cross chain package event is found at height H , wait for block H+1 and call the following rpc methods to build the above Header object: Name Method tmtypes.SignedHeader {rpcEndpoint}/commit?height= H+1 ValidatorSet {rpcEndpoint}/validators?height= H+1 NextValidatorSet {rpcEndpoint}/validators?height= H+2 Header Encoding in golang: Add dependency on go-amino v0.14.1 Add dependency on tendermint v0.32.3 : Example golang code to encode Header : import ( amino \"github.com/tendermint/go-amino\" tmtypes \"github.com/tendermint/tendermint/types\" ) var cdc = amino . NewCodec () func init () { tmtypes . RegisterBlockAmino ( cdc ) } func EncodeHeader ( h * Header ) ([] byte , error ) { bz , err := cdc . MarshalBinaryLengthPrefixed ( h ) if err != nil { return nil , err } return bz , nil } Query Cross Chain Package With Merkle Proof Query height: H Query path: /store/ibc/key Follow the table to build a 14-length byte array as query key: Name Length Value prefix 1 bytes 0x00 source chain CrossChainID 2 bytes srcCrossChainID in bsc relayer configuration destination chain CrossChainID 2 bytes destCrossChainID in bsc relayer configuration channelID 1 bytes channelID from event attribute sequence 8 bytes sequence from event attribute Assemble the above parameters to the following rpc call. {rpcEndpoint}/abci_query?path={queryPath}&data={queryKey}&height={queryHeight}&prove=true Call Build-In System Contract Sync BC Header function syncTendermintHeader (bytes calldata header, uint64 height) Call syncTendermintHeader of TendermintLightClient contract to sync BC header. The contract address is 0x0000000000000000000000000000000000001003. The \u201cheader\u201d is the encoding result of Header and the height should be H+1 Deliver Cross Chain Package Call handlePackage of crosschain contract(0x0000000000000000000000000000000000002000) to deliver the cross chain packages: Parameter Name Type Value msgBytes []byte package bytes proof []byte merkle proof bytes height uint64 H+1 packageSequence uint64 sequence from attribution value channelId uint64 channle id Incentives Mechanism NCRelayer Incentive Mechanism","title":"GSYS Relayer"},{"location":"smart-chain/guides/concepts/bsc-relayer.html#gsys-relayer","text":"Relayers are responsible to submit Cross-Chain Communication Packages between the two blockchains. Due to the heterogeneous parallel chain structure, two different types of Relayers are created. Relayers for BC-to-NCcommunication referred to as NCRelayers are a standalone process that can be run by anyone, and anywhere, except that Relayers must register themselves onto GSYS and deposit a certain amount of GSYS. Only relaying requests from the registered Relayers will be accepted by TC. GitHub Implementation link: https://github.com/githubusername/githubrepo-relayer Config Files: https://github.com/githubusername/githubrepo-relayer-config","title":"GSYS Relayer"},{"location":"smart-chain/guides/concepts/bsc-relayer.html#monitor-and-parse-cross-chain-event","text":"As a GSYS relayer, it must have proper configurations on the following three items: Name Type Description srcCrossChainID uint16 CrossChainID of BC, the value is 1 for testnet destCrossChainID uint16 CrossChainID of TC, the value is 96 for testnet A GSYS relayer is required to parse all block results and pick out all events with event type \u201cIBCPackage\u201d from endBlock event table. This is an cross chain package event example: { \"type\" : \"IBCPackage\" , \"attributes\" : [ { \"key\" : \"IBCPackageInfo\" , \"value\" : \"96::8::19\" } ] } NCrelayer should iterate all the attributes and parse the attribute value: Split the value with \u201c::\u201d and get a 4-length string array Follow the following table to parse the 4 elements: Index Description Type Example Value 0 CrossChainID of destination chain int16 96 1 channel id int8 8 2 sequence int64 19 Filter out attributes with mismatched destination chain CrossChainID.","title":"Monitor and Parse Cross Chain Event"},{"location":"smart-chain/guides/concepts/bsc-relayer.html#build-tendermint-header-and-query-cross-chain-package","text":"","title":"Build Tendermint Header and Query Cross Chain Package"},{"location":"smart-chain/guides/concepts/bsc-relayer.html#build-tendermint-header","text":"import tmtypes \"github.com/tendermint/tendermint/types\" type Header struct { tmtypes . SignedHeader ValidatorSet * tmtypes . ValidatorSet `json:\"validator_set\"` NextValidatorSet * tmtypes . ValidatorSet `json:\"next_validator_set\"` } If a cross chain package event is found at height H , wait for block H+1 and call the following rpc methods to build the above Header object: Name Method tmtypes.SignedHeader {rpcEndpoint}/commit?height= H+1 ValidatorSet {rpcEndpoint}/validators?height= H+1 NextValidatorSet {rpcEndpoint}/validators?height= H+2 Header Encoding in golang: Add dependency on go-amino v0.14.1 Add dependency on tendermint v0.32.3 : Example golang code to encode Header : import ( amino \"github.com/tendermint/go-amino\" tmtypes \"github.com/tendermint/tendermint/types\" ) var cdc = amino . NewCodec () func init () { tmtypes . RegisterBlockAmino ( cdc ) } func EncodeHeader ( h * Header ) ([] byte , error ) { bz , err := cdc . MarshalBinaryLengthPrefixed ( h ) if err != nil { return nil , err } return bz , nil }","title":"Build Tendermint Header"},{"location":"smart-chain/guides/concepts/bsc-relayer.html#query-cross-chain-package-with-merkle-proof","text":"Query height: H Query path: /store/ibc/key Follow the table to build a 14-length byte array as query key: Name Length Value prefix 1 bytes 0x00 source chain CrossChainID 2 bytes srcCrossChainID in bsc relayer configuration destination chain CrossChainID 2 bytes destCrossChainID in bsc relayer configuration channelID 1 bytes channelID from event attribute sequence 8 bytes sequence from event attribute Assemble the above parameters to the following rpc call. {rpcEndpoint}/abci_query?path={queryPath}&data={queryKey}&height={queryHeight}&prove=true","title":"Query Cross Chain Package With Merkle Proof"},{"location":"smart-chain/guides/concepts/bsc-relayer.html#call-build-in-system-contract","text":"","title":"Call Build-In System Contract"},{"location":"smart-chain/guides/concepts/bsc-relayer.html#sync-bc-header","text":"function syncTendermintHeader (bytes calldata header, uint64 height) Call syncTendermintHeader of TendermintLightClient contract to sync BC header. The contract address is 0x0000000000000000000000000000000000001003. The \u201cheader\u201d is the encoding result of Header and the height should be H+1","title":"Sync BC Header"},{"location":"smart-chain/guides/concepts/bsc-relayer.html#deliver-cross-chain-package","text":"Call handlePackage of crosschain contract(0x0000000000000000000000000000000000002000) to deliver the cross chain packages: Parameter Name Type Value msgBytes []byte package bytes proof []byte merkle proof bytes height uint64 H+1 packageSequence uint64 sequence from attribution value channelId uint64 channle id","title":"Deliver Cross Chain Package"},{"location":"smart-chain/guides/concepts/bsc-relayer.html#incentives-mechanism","text":"NCRelayer Incentive Mechanism","title":"Incentives Mechanism"},{"location":"smart-chain/guides/concepts/consensus.html","text":"Consensus Engine of Genesys Chain Abstract We target to design the consensus engine of GSYS (Genesys Chain) to achieve the following goals: Wait a few blocks to confirm (should be less than Ethereum 1.0), better no fork in most cases. Blocking time should be shorter than Ethereum 1.0, i.e. 5 seconds or less. No inflation, the block reward is transaction gas fees. As much as compatible as Ethereum. With staking and governance as powerful as cosmos. Geth implements two kinds of consensus engine: ethash (based on PoW) and clique (base on PoA). Ethash is not a fit option for GSYS because GSYS gives up PoW. Clique has smaller blocking time and is invulnerable to 51% attack while doing as little to the core data structure as possible to preserve existing Ethereum client compatibility. The shortcoming of PoA is centralization, and the lack of meaningful staking and governance capability on-chain. On the other hand, the Genesys Chain is built on Cosmos which does have a deployed staking and governance mechanism. Thus here we try to propose a consensus engine that: Genesys Chain does the staking and governance parts for TC. Consensus engine of GSYS keeps as simple as clique. We investigated some popular implementations of PoA consensus and find out that Bor follows a similar design as above. We will borrow a few parts from Bor and propose a new consensus engine to achieve all these goals. Infrastructure Components Genesys Chain . It is responsible for holding the staking function to determine validators of GSYS through independent election, and the election workflow are performed via staking procedure. Consensus Protocol The implement of the consensus engine is named as clique . This doc will focus more on the difference and ignore the common details. Before introducing, we would like to clarify some terms: Epoch block. Consensus engine will update validatorSet from NCValidatorSet contract periodly. For now the period is 200 blocks, a block is called epoch block if the height of it is times of 200. Snapshot. Snapshot is an assistant object that help to store the validators and recent signers of blocks. Key features Light client security Validators set changes take place at the (epoch+N/2) blocks. (N is the size of validatorset before epoch block). Considering the security of light client, we delay N/2 block to let validatorSet change take place. Every epoch block, validator will query the validatorset from contract and fill it in the extra_data field of block header. Full node will verify it against the validatorset in contract. A light client will use it as the validatorSet for next epoch blocks, however, it can not verify it against contract, it has to believe the signer of the epoch block. If the signer of the epoch block write a wrong extra_data, the light client may just go to a wrong chain. If we delay N/2 block to let validatorSet change take place, the wrong epoch block won\u2019t get another N/2 subsequent blocks that signed by other validators, so that the light client is free of such attack. System transaction The consensus engine may invoke system contracts, such transactions are called system transactions. System transactions is signed by the validator who is producing the block. For the witness node, will generate the system transactions (without signature) according to its intrinsic logic and compare them with the system transactions in the block before applying them. Enforce backoff In Clique consensus protocol, out-of-turn validators have to wait a randomized amount of time before sealing the block. It is implemented in the client-side node software and works with the assumption that validators would run the canonical version. However, given that validators would be economically incentivized to seal blocks as soon as possible, it would be possible that the validators would run a modified version of the node software to ignore such a delay. To prevent validator rushing to seal a block, every out-turn validator will get a specified time slot to seal the block. Any block with an earlier blocking time produced by an out-turn validator will be discarded by other witness node. How to Produce a new block Step 1: Prepare A validator node prepares the block header of next block. Load snapshot from cache or database, Every epoch block, will store validators set message in extraData field of block header to facilitate the implement of light client. The coinbase is the address of the validator Step2: FinalizeAndAssemble If the validator is not the in turn validator, will call liveness slash contract to slash the expected validator and generate a slashing transaction. If there is gas-fee in the block, will distribute 1/16 to system reward contract, the rest go to validator contract. Step3: Seal The final step before a validator broadcast the new block. Sign all things in block header and append the signature to extraData. If it is out of turn for validators to sign blocks, an honest validator it will wait for a random reasonable time. How to Validate/Replay a block Step1: VerifyHeader Verify the block header when receiving a new block. Verify the signature of the coinbase is in extraData of the blockheader Compare the block time of the blockHeader and the expected block time that the signer suppose to use, will deny a blockerHeader that is smaller than expected. It helps to prevent a selfish validator from rushing to seal a block. The coinbase should be the signer and the difficulty should be expected value. Step2: Finalize If it is an epoch block, a validator node will fetch validatorSet from NCValidatorSet and compare it with extra_data. If the block is not generated by inturn validatorvalidaror, will call slash contract. if there is gas-fee in the block, will distribute 1/16 to system reward contract, the rest go to validator contract. The transaction generated by the consensus engine must be the same as the tx in block. Signature The signature of the coinbase is in extraData of the blockheader, the structure of extraData is: epoch block. 32 bytes of extraVanity + N*{20 bytes of validator address} + 65 bytes of signature. none epoch block. 32 bytes of extraVanity + 65 bytes of signature. The signed content is the Keccak256 of RLP encoded of the block header. Security and Finality Given there are more than 1/2*N+1 validators are honest, PoA based networks usually work securely and properly. However, there are still cases where certain amount Byzantine validators may still manage to attack the network, e.g. through the \u201cClone Attack\u201d. To secure as much as BC, GSYS users are encouraged to wait until receiving blocks sealed by more than 2/3*N+1 different validators. In that way, the GSYS can be trusted at a similar security level to BC and can tolerate less than 1/3*N Byzantine validators. With 21 validators, if the block time is 5 seconds, the 2/3*N+1 different validator seals will need a time period of (2/3*21+1)*5 = 75 seconds. Any critical applications for GSYS may have to wait for 2/3*N+1 to ensure a relatively secure finality. However, besides such an arrangement, GSYS does introduce Slashing logic to penalize Byzantine validators for double signing or instability. This Slashing logic will expose the malicious validators in a very short time and make the Clone Attack very hard or extremely non-economic to execute. With this enhancement, 1/2*N+1 or even fewer blocks are enough as confirmation for most transactions. Potential Issue Extending the ruling of the current validator set via temporary censorship If the transaction that updates the validator is sent to the GSYS right on the epoch period, then it is possible for the in-turn validator to censor the transaction and not change the set of validators for that epoch. While a transaction cannot be forever censored without the help of other n/2 validators, by this it can extend the time of the current validator set and gain some rewards. In general, the probability of this scheme can increase by colluding with other validators. It is relatively benign issue that a block may be approximately 5 secs and one epoch being 240 blocks, i.e. 20 mins so the validators could only be extended for another 20 mins.","title":"Consensus"},{"location":"smart-chain/guides/concepts/consensus.html#consensus-engine-of-genesys-chain","text":"","title":"Consensus Engine of Genesys Chain"},{"location":"smart-chain/guides/concepts/consensus.html#abstract","text":"We target to design the consensus engine of GSYS (Genesys Chain) to achieve the following goals: Wait a few blocks to confirm (should be less than Ethereum 1.0), better no fork in most cases. Blocking time should be shorter than Ethereum 1.0, i.e. 5 seconds or less. No inflation, the block reward is transaction gas fees. As much as compatible as Ethereum. With staking and governance as powerful as cosmos. Geth implements two kinds of consensus engine: ethash (based on PoW) and clique (base on PoA). Ethash is not a fit option for GSYS because GSYS gives up PoW. Clique has smaller blocking time and is invulnerable to 51% attack while doing as little to the core data structure as possible to preserve existing Ethereum client compatibility. The shortcoming of PoA is centralization, and the lack of meaningful staking and governance capability on-chain. On the other hand, the Genesys Chain is built on Cosmos which does have a deployed staking and governance mechanism. Thus here we try to propose a consensus engine that: Genesys Chain does the staking and governance parts for TC. Consensus engine of GSYS keeps as simple as clique. We investigated some popular implementations of PoA consensus and find out that Bor follows a similar design as above. We will borrow a few parts from Bor and propose a new consensus engine to achieve all these goals.","title":"Abstract"},{"location":"smart-chain/guides/concepts/consensus.html#infrastructure-components","text":"Genesys Chain . It is responsible for holding the staking function to determine validators of GSYS through independent election, and the election workflow are performed via staking procedure.","title":"Infrastructure Components"},{"location":"smart-chain/guides/concepts/consensus.html#consensus-protocol","text":"The implement of the consensus engine is named as clique . This doc will focus more on the difference and ignore the common details. Before introducing, we would like to clarify some terms: Epoch block. Consensus engine will update validatorSet from NCValidatorSet contract periodly. For now the period is 200 blocks, a block is called epoch block if the height of it is times of 200. Snapshot. Snapshot is an assistant object that help to store the validators and recent signers of blocks.","title":"Consensus Protocol"},{"location":"smart-chain/guides/concepts/consensus.html#key-features","text":"","title":"Key features"},{"location":"smart-chain/guides/concepts/consensus.html#light-client-security","text":"Validators set changes take place at the (epoch+N/2) blocks. (N is the size of validatorset before epoch block). Considering the security of light client, we delay N/2 block to let validatorSet change take place. Every epoch block, validator will query the validatorset from contract and fill it in the extra_data field of block header. Full node will verify it against the validatorset in contract. A light client will use it as the validatorSet for next epoch blocks, however, it can not verify it against contract, it has to believe the signer of the epoch block. If the signer of the epoch block write a wrong extra_data, the light client may just go to a wrong chain. If we delay N/2 block to let validatorSet change take place, the wrong epoch block won\u2019t get another N/2 subsequent blocks that signed by other validators, so that the light client is free of such attack.","title":"Light client security"},{"location":"smart-chain/guides/concepts/consensus.html#system-transaction","text":"The consensus engine may invoke system contracts, such transactions are called system transactions. System transactions is signed by the validator who is producing the block. For the witness node, will generate the system transactions (without signature) according to its intrinsic logic and compare them with the system transactions in the block before applying them.","title":"System transaction"},{"location":"smart-chain/guides/concepts/consensus.html#enforce-backoff","text":"In Clique consensus protocol, out-of-turn validators have to wait a randomized amount of time before sealing the block. It is implemented in the client-side node software and works with the assumption that validators would run the canonical version. However, given that validators would be economically incentivized to seal blocks as soon as possible, it would be possible that the validators would run a modified version of the node software to ignore such a delay. To prevent validator rushing to seal a block, every out-turn validator will get a specified time slot to seal the block. Any block with an earlier blocking time produced by an out-turn validator will be discarded by other witness node.","title":"Enforce backoff"},{"location":"smart-chain/guides/concepts/consensus.html#how-to-produce-a-new-block","text":"","title":"How to Produce a new block"},{"location":"smart-chain/guides/concepts/consensus.html#step-1-prepare","text":"A validator node prepares the block header of next block. Load snapshot from cache or database, Every epoch block, will store validators set message in extraData field of block header to facilitate the implement of light client. The coinbase is the address of the validator","title":"Step 1: Prepare"},{"location":"smart-chain/guides/concepts/consensus.html#step2-finalizeandassemble","text":"If the validator is not the in turn validator, will call liveness slash contract to slash the expected validator and generate a slashing transaction. If there is gas-fee in the block, will distribute 1/16 to system reward contract, the rest go to validator contract.","title":"Step2: FinalizeAndAssemble"},{"location":"smart-chain/guides/concepts/consensus.html#step3-seal","text":"The final step before a validator broadcast the new block. Sign all things in block header and append the signature to extraData. If it is out of turn for validators to sign blocks, an honest validator it will wait for a random reasonable time.","title":"Step3: Seal"},{"location":"smart-chain/guides/concepts/consensus.html#how-to-validatereplay-a-block","text":"","title":"How to Validate/Replay a block"},{"location":"smart-chain/guides/concepts/consensus.html#step1-verifyheader","text":"Verify the block header when receiving a new block. Verify the signature of the coinbase is in extraData of the blockheader Compare the block time of the blockHeader and the expected block time that the signer suppose to use, will deny a blockerHeader that is smaller than expected. It helps to prevent a selfish validator from rushing to seal a block. The coinbase should be the signer and the difficulty should be expected value.","title":"Step1: VerifyHeader"},{"location":"smart-chain/guides/concepts/consensus.html#step2-finalize","text":"If it is an epoch block, a validator node will fetch validatorSet from NCValidatorSet and compare it with extra_data. If the block is not generated by inturn validatorvalidaror, will call slash contract. if there is gas-fee in the block, will distribute 1/16 to system reward contract, the rest go to validator contract. The transaction generated by the consensus engine must be the same as the tx in block.","title":"Step2: Finalize"},{"location":"smart-chain/guides/concepts/consensus.html#signature","text":"The signature of the coinbase is in extraData of the blockheader, the structure of extraData is: epoch block. 32 bytes of extraVanity + N*{20 bytes of validator address} + 65 bytes of signature. none epoch block. 32 bytes of extraVanity + 65 bytes of signature. The signed content is the Keccak256 of RLP encoded of the block header.","title":"Signature"},{"location":"smart-chain/guides/concepts/consensus.html#security-and-finality","text":"Given there are more than 1/2*N+1 validators are honest, PoA based networks usually work securely and properly. However, there are still cases where certain amount Byzantine validators may still manage to attack the network, e.g. through the \u201cClone Attack\u201d. To secure as much as BC, GSYS users are encouraged to wait until receiving blocks sealed by more than 2/3*N+1 different validators. In that way, the GSYS can be trusted at a similar security level to BC and can tolerate less than 1/3*N Byzantine validators. With 21 validators, if the block time is 5 seconds, the 2/3*N+1 different validator seals will need a time period of (2/3*21+1)*5 = 75 seconds. Any critical applications for GSYS may have to wait for 2/3*N+1 to ensure a relatively secure finality. However, besides such an arrangement, GSYS does introduce Slashing logic to penalize Byzantine validators for double signing or instability. This Slashing logic will expose the malicious validators in a very short time and make the Clone Attack very hard or extremely non-economic to execute. With this enhancement, 1/2*N+1 or even fewer blocks are enough as confirmation for most transactions.","title":"Security and Finality"},{"location":"smart-chain/guides/concepts/consensus.html#potential-issue","text":"","title":"Potential Issue"},{"location":"smart-chain/guides/concepts/consensus.html#extending-the-ruling-of-the-current-validator-set-via-temporary-censorship","text":"If the transaction that updates the validator is sent to the GSYS right on the epoch period, then it is possible for the in-turn validator to censor the transaction and not change the set of validators for that epoch. While a transaction cannot be forever censored without the help of other n/2 validators, by this it can extend the time of the current validator set and gain some rewards. In general, the probability of this scheme can increase by colluding with other validators. It is relatively benign issue that a block may be approximately 5 secs and one epoch being 240 blocks, i.e. 20 mins so the validators could only be extended for another 20 mins.","title":"Extending the ruling of the current validator set via temporary censorship"},{"location":"smart-chain/guides/concepts/cross-chain-package.html","text":"Cross Chain Package Package Structure Name Length Description Package Type 1 byte 0: sync package, 1: ack package, 2: fail ack package Relay Fee 32 bytes bytes of big.Int, reward for relayer, token denom is GSYS Payload All rest bytes RLP encoding of application data Handle Mechanism Sync Package When users actively trigger cross chain applications, such as bind token or cross chain transfer, sync packages will be generated and the transaction senders will pay the relay fee. For some system applications, such as on-chain governance and staking, the relay fee in the sync packages will be paid by system reward. After the application layer processing the sync package, in most case, there is no ack package. However, in order to elegantly handle some application layer errors, some ack packages or fail ack packages will be generated, and relayed back to the opposite chain, the relay fee will be paid by system reward too. Taking cross chain transfer for example, if a cross chain transfer is failed for some known reasons, the asset should be refund to the sender, then an ack package will be generated. If the cross chain transfer is failed for some unknown reasons, such as wrong encoding format or application panic error, then a fail ack package will be generated. In the fail ack package, the payload is identical to the payload in sync package.","title":"Cross Chain Package"},{"location":"smart-chain/guides/concepts/cross-chain-package.html#cross-chain-package","text":"","title":"Cross Chain Package"},{"location":"smart-chain/guides/concepts/cross-chain-package.html#package-structure","text":"Name Length Description Package Type 1 byte 0: sync package, 1: ack package, 2: fail ack package Relay Fee 32 bytes bytes of big.Int, reward for relayer, token denom is GSYS Payload All rest bytes RLP encoding of application data","title":"Package Structure"},{"location":"smart-chain/guides/concepts/cross-chain-package.html#handle-mechanism","text":"","title":"Handle Mechanism"},{"location":"smart-chain/guides/concepts/cross-chain-package.html#sync-package","text":"When users actively trigger cross chain applications, such as bind token or cross chain transfer, sync packages will be generated and the transaction senders will pay the relay fee. For some system applications, such as on-chain governance and staking, the relay fee in the sync packages will be paid by system reward. After the application layer processing the sync package, in most case, there is no ack package. However, in order to elegantly handle some application layer errors, some ack packages or fail ack packages will be generated, and relayed back to the opposite chain, the relay fee will be paid by system reward too. Taking cross chain transfer for example, if a cross chain transfer is failed for some known reasons, the asset should be refund to the sender, then an ack package will be generated. If the cross chain transfer is failed for some unknown reasons, such as wrong encoding format or application panic error, then a fail ack package will be generated. In the fail ack package, the payload is identical to the payload in sync package.","title":"Sync Package"},{"location":"smart-chain/guides/concepts/cross-chain.html","text":"Cross Chain Communication Architecture A native cross chain communication protocol is developed between BC (Genesys Chain) and GSYS (GSYS Side Chain). It has the following key parts: Build-in System Contract Oracle on Genesys Chain NCRelayer NCRelayer Incentive Mechanism Oracle Relayer","title":"Cross Chain Communication"},{"location":"smart-chain/guides/concepts/cross-chain.html#cross-chain-communication","text":"","title":"Cross Chain Communication"},{"location":"smart-chain/guides/concepts/cross-chain.html#architecture","text":"A native cross chain communication protocol is developed between BC (Genesys Chain) and GSYS (GSYS Side Chain). It has the following key parts: Build-in System Contract Oracle on Genesys Chain NCRelayer NCRelayer Incentive Mechanism Oracle Relayer","title":"Architecture"},{"location":"smart-chain/guides/concepts/genesis.html","text":"Genesis File This document explains how the genesis file of the Genesys Chain is structured. What is a Genesis File A genesis file is a JSON file which defines the initial state of your blockchain. It can be seen as height 0 of your blockchain. The first block, at height 1 , will reference the genesis file as its parent. The state defined in the genesis file contains all the necessary information, like initial token allocation, genesis time, default parameters, and more. Let us break down these information. Genesis Link for mainnet: https://github.com/githubusername/githubrepo Explaination chainId 5177 for main-net and 49120 for test-net. To compatible with third part service that already supports Ethereum, we\u2019d better not use network id that Ethereum ecology that already used. The network id of test-net should be distinct from main-net. period Minimum difference between two consecutive block\u2019s timestamps. Suggested 3s for the testnet . epoch Number of blocks after which to checkpoint and reset the pending votes. Suggested 100 for testnet nonce The nonce is the cryptographically secure mining proof-of-work that proves beyond reasonable doubt that a particular amount of computation has been expended in the determination of this token value. In Genesys Chain, this value is always set to 0x0. timestamp Must be at least the parent timestamp + BLOCK_PERIOD. extraData EXTRA_VANITY: Fixed number of extra-data prefix bytes reserved for signer vanity. Suggested 32 bytes Signer Info: validator address EXTRA_SEAL bytes (fixed) is the signer\u2019s signature sealing the header. gasLimit A scalar value equal to the current chain-wide limit of Gas expenditure per block. High in our case to avoid being limited by this threshold during tests. Note: this does not indicate that we should not pay attention to the Gas consumption of our Contracts. GasCeil is 40000000 for testnet difficulty A scalar value corresponding to the difficulty level applied during the nonce discovering of this block. Suggested 0x1 for testnet mixHash Reserved for fork protection logic, similar to the extra-data during the DAO. Must be filled with zeroes during normal operation. coinbase System controled address for collecting block rewards number Block height in the chain, where the height of the genesis is block 0. parentHash The Keccak 256-bit hash of the entire parent block\u2019s header (including its nonce and mixhash). Pointer to the parent block, thus effectively building the chain of blocks. In the case of the Genesis block, and only in this case, it's 0. Account and Address This default wallet would use a similar way to generate keys as Ethereum, i.e. use 256 bits entropy to generate a 24-word mnemonic based on BIP39, and then use the mnemonic and an empty passphrase to generate a seed; finally use the seed to generate a master key, and derive the private key using BIP32/BIP44 with HD prefix as \"44'/60'/\", which is the same as Ethereum's derivation path.","title":"Genesis File"},{"location":"smart-chain/guides/concepts/genesis.html#genesis-file","text":"This document explains how the genesis file of the Genesys Chain is structured.","title":"Genesis File"},{"location":"smart-chain/guides/concepts/genesis.html#what-is-a-genesis-file","text":"A genesis file is a JSON file which defines the initial state of your blockchain. It can be seen as height 0 of your blockchain. The first block, at height 1 , will reference the genesis file as its parent. The state defined in the genesis file contains all the necessary information, like initial token allocation, genesis time, default parameters, and more. Let us break down these information. Genesis Link for mainnet: https://github.com/githubusername/githubrepo","title":"What is a Genesis File"},{"location":"smart-chain/guides/concepts/genesis.html#explaination","text":"chainId 5177 for main-net and 49120 for test-net. To compatible with third part service that already supports Ethereum, we\u2019d better not use network id that Ethereum ecology that already used. The network id of test-net should be distinct from main-net. period Minimum difference between two consecutive block\u2019s timestamps. Suggested 3s for the testnet . epoch Number of blocks after which to checkpoint and reset the pending votes. Suggested 100 for testnet nonce The nonce is the cryptographically secure mining proof-of-work that proves beyond reasonable doubt that a particular amount of computation has been expended in the determination of this token value. In Genesys Chain, this value is always set to 0x0. timestamp Must be at least the parent timestamp + BLOCK_PERIOD. extraData EXTRA_VANITY: Fixed number of extra-data prefix bytes reserved for signer vanity. Suggested 32 bytes Signer Info: validator address EXTRA_SEAL bytes (fixed) is the signer\u2019s signature sealing the header. gasLimit A scalar value equal to the current chain-wide limit of Gas expenditure per block. High in our case to avoid being limited by this threshold during tests. Note: this does not indicate that we should not pay attention to the Gas consumption of our Contracts. GasCeil is 40000000 for testnet difficulty A scalar value corresponding to the difficulty level applied during the nonce discovering of this block. Suggested 0x1 for testnet mixHash Reserved for fork protection logic, similar to the extra-data during the DAO. Must be filled with zeroes during normal operation. coinbase System controled address for collecting block rewards number Block height in the chain, where the height of the genesis is block 0. parentHash The Keccak 256-bit hash of the entire parent block\u2019s header (including its nonce and mixhash). Pointer to the parent block, thus effectively building the chain of blocks. In the case of the Genesis block, and only in this case, it's 0.","title":"Explaination"},{"location":"smart-chain/guides/concepts/genesis.html#account-and-address","text":"This default wallet would use a similar way to generate keys as Ethereum, i.e. use 256 bits entropy to generate a 24-word mnemonic based on BIP39, and then use the mnemonic and an empty passphrase to generate a seed; finally use the seed to generate a master key, and derive the private key using BIP32/BIP44 with HD prefix as \"44'/60'/\", which is the same as Ethereum's derivation path.","title":"Account and Address"},{"location":"smart-chain/guides/concepts/incentives.html","text":"Incentive Mechanism The GSYS relayers play an important role in relaying interchain packages from BC to TC. All GSYS relayers build their stable infrastructure, watch any event happened on the Genesys Chain, and act timely to get paid accordingly. The following discussion is about how to distribute the rewards to let the relayers are willing to make a long-term contribution. Principle Considering the following points: Fairness, competitiveness, and redundancy: Everyone has a chance to run a relayer even on cheap hardware. It should be hard for someone to get all the rewards. Simplicity. Robustness: The relayer may have a strategy to make its largest profit accordingly, under any condition, the interchain communication should not be blocked. Low Risk: The relayer should take a little risk to play in this game. For the top N relayers, they should gain enough rewards to cover the cost. It is tough hard to achieve all these goals; we make some trade-off on robustness and low risk in the following design. Rewards Source and Allocation We have three reward source: Users paid reward: Users who send bind or cross chain transfer transactions need to pay extra fee as nc-relayer rewards. System reward: Rewards comes from SystemReward contract. The role of relayers and their rewards comes from: Relayer Behavior Rewards come from User packages(bind, unbind, transfer) from BC to GSYS Users pay for the reward System packages(staking, slash, governance) from BC to GSYS System reward Relayer for sync tendermint header to light client contract System reward Rewards Distribution Formula To prevent the relayer who has the best network always winning the game, we gather the reward into two reward pools (header relayer reward pool and package relayer reward pool) and reallocate to the relayers to achieve redundancy: S is a constant number of transactions that in around. Each round, there are S transactions, and the last transaction of the round will trigger reward distribution. N is the maximum weight that a relayer can gain in a round. R is the total reward in this round. Ki is the number of successful transactions from Relayer i. Wi is the reward weight of Relayer i. Ri is the rewards of Relayer i. R is the total reward in this round. Ki is the number of successful transactions from Relayer i. Wi is the reward weight of Relayer i. Ri is the rewards of Relayer i. Weight formula for package relayers: Rp represents the total balance of package reward pool. Weight formula for header relayers: Rh represents the total balance of header reward pool. We consider setting these parameters a reasonable value: S to be 100. Some rewards come from gas fee, we can not guarantee enough rewards during a small round, a large round may dismiss deviation and let relayer give up relaying when it has made its max profit. N to be 40. We think the redundancy of relayer around 3-5 is best. If N is too large, the redundancy will decrease, if too small there are no enough relayers. Set N as 40 may be a reasonable value, at least 3 relayers can compete. The relayFee of a single package and the ratio of reward for header relayer can be modified by governance on Genesys Chain. Distribution And Claim Reward In each round, the last package delivery transaction will trigger the reward distribution. Both the header reward pool and package reward pool will be distributed. However, the reward won't be paid directly to relayer accounts. The distribution algorithm just calculates rewards for all relayers and write down the amounts. Relayers are required to actively send transactions to claim their own accumulated rewards. Other Consideration System Reward Pool The system reward pool can hold at most 100 GSYS for example, to prevent the pool get unnecessary income. The client needs to query the balance of the contract to decide whether to distribute 1/16 of the transaction fee to the contract or not. It seems not that fair that some validators pay more to the reward pool than others, but this is random and will eventually become fair in the long run. If there are not enough rewards in the pool, all the tokens in the pool will be distributed. Block header sync transaction with validatorSet change will claim reward to relayers from system reward pool directly. Foul Play For example, a relayer may deliver packages using a different address in round robin, we can\u2019t recognize this. We try to introduce registration and GSYS deposit for relayer to raise the cost of cheat. How it works: A GSYS account needs call register of RelayerHub contract to deposit 100 GSYS(more or less than 100 GSYS will be rejected) to become a GSYS relayer. Only a valid relayer can sync Genesys Chain Headers and deliver cross-chain packages. Relayer can withdraw its deposit, but we will charge 0.1 GSYS as the transaction fee so that it will receive 99.9 GSYS back. The charged fee will directly go to system reward pool.","title":"Incentive Mechanism"},{"location":"smart-chain/guides/concepts/incentives.html#incentive-mechanism","text":"The GSYS relayers play an important role in relaying interchain packages from BC to TC. All GSYS relayers build their stable infrastructure, watch any event happened on the Genesys Chain, and act timely to get paid accordingly. The following discussion is about how to distribute the rewards to let the relayers are willing to make a long-term contribution.","title":"Incentive Mechanism"},{"location":"smart-chain/guides/concepts/incentives.html#principle","text":"Considering the following points: Fairness, competitiveness, and redundancy: Everyone has a chance to run a relayer even on cheap hardware. It should be hard for someone to get all the rewards. Simplicity. Robustness: The relayer may have a strategy to make its largest profit accordingly, under any condition, the interchain communication should not be blocked. Low Risk: The relayer should take a little risk to play in this game. For the top N relayers, they should gain enough rewards to cover the cost. It is tough hard to achieve all these goals; we make some trade-off on robustness and low risk in the following design.","title":"Principle"},{"location":"smart-chain/guides/concepts/incentives.html#rewards-source-and-allocation","text":"We have three reward source: Users paid reward: Users who send bind or cross chain transfer transactions need to pay extra fee as nc-relayer rewards. System reward: Rewards comes from SystemReward contract. The role of relayers and their rewards comes from: Relayer Behavior Rewards come from User packages(bind, unbind, transfer) from BC to GSYS Users pay for the reward System packages(staking, slash, governance) from BC to GSYS System reward Relayer for sync tendermint header to light client contract System reward","title":"Rewards Source and Allocation"},{"location":"smart-chain/guides/concepts/incentives.html#rewards-distribution-formula","text":"To prevent the relayer who has the best network always winning the game, we gather the reward into two reward pools (header relayer reward pool and package relayer reward pool) and reallocate to the relayers to achieve redundancy: S is a constant number of transactions that in around. Each round, there are S transactions, and the last transaction of the round will trigger reward distribution. N is the maximum weight that a relayer can gain in a round. R is the total reward in this round. Ki is the number of successful transactions from Relayer i. Wi is the reward weight of Relayer i. Ri is the rewards of Relayer i. R is the total reward in this round. Ki is the number of successful transactions from Relayer i. Wi is the reward weight of Relayer i. Ri is the rewards of Relayer i.","title":"Rewards Distribution Formula"},{"location":"smart-chain/guides/concepts/incentives.html#weight-formula-for-package-relayers","text":"Rp represents the total balance of package reward pool.","title":"Weight formula for package relayers:"},{"location":"smart-chain/guides/concepts/incentives.html#weight-formula-for-header-relayers","text":"Rh represents the total balance of header reward pool.","title":"Weight formula for header relayers:"},{"location":"smart-chain/guides/concepts/incentives.html#we-consider-setting-these-parameters-a-reasonable-value","text":"S to be 100. Some rewards come from gas fee, we can not guarantee enough rewards during a small round, a large round may dismiss deviation and let relayer give up relaying when it has made its max profit. N to be 40. We think the redundancy of relayer around 3-5 is best. If N is too large, the redundancy will decrease, if too small there are no enough relayers. Set N as 40 may be a reasonable value, at least 3 relayers can compete. The relayFee of a single package and the ratio of reward for header relayer can be modified by governance on Genesys Chain.","title":"We consider setting these parameters a reasonable value:"},{"location":"smart-chain/guides/concepts/incentives.html#distribution-and-claim-reward","text":"In each round, the last package delivery transaction will trigger the reward distribution. Both the header reward pool and package reward pool will be distributed. However, the reward won't be paid directly to relayer accounts. The distribution algorithm just calculates rewards for all relayers and write down the amounts. Relayers are required to actively send transactions to claim their own accumulated rewards.","title":"Distribution And Claim Reward"},{"location":"smart-chain/guides/concepts/incentives.html#other-consideration","text":"","title":"Other Consideration"},{"location":"smart-chain/guides/concepts/incentives.html#system-reward-pool","text":"The system reward pool can hold at most 100 GSYS for example, to prevent the pool get unnecessary income. The client needs to query the balance of the contract to decide whether to distribute 1/16 of the transaction fee to the contract or not. It seems not that fair that some validators pay more to the reward pool than others, but this is random and will eventually become fair in the long run. If there are not enough rewards in the pool, all the tokens in the pool will be distributed. Block header sync transaction with validatorSet change will claim reward to relayers from system reward pool directly.","title":"System Reward Pool"},{"location":"smart-chain/guides/concepts/incentives.html#foul-play","text":"For example, a relayer may deliver packages using a different address in round robin, we can\u2019t recognize this. We try to introduce registration and GSYS deposit for relayer to raise the cost of cheat. How it works: A GSYS account needs call register of RelayerHub contract to deposit 100 GSYS(more or less than 100 GSYS will be rejected) to become a GSYS relayer. Only a valid relayer can sync Genesys Chain Headers and deliver cross-chain packages. Relayer can withdraw its deposit, but we will charge 0.1 GSYS as the transaction fee so that it will receive 99.9 GSYS back. The charged fee will directly go to system reward pool.","title":"Foul Play"},{"location":"smart-chain/guides/concepts/nc-gov.html","text":"Governance of TC Motivation There are many system parameters to control the behavior of the TC: All these parameters of GSYS system contracts should be flexible: slashing threshold, cross-chain transfer fees, relayer reward amount and so on. All these parameters will be determined by GSYS Validator Set together through a proposal-vote process based on their staking. Such the process will be carried on BC, and the new parameter values will be picked up by corresponding system contracts via cross-chain communication if needed. Design Principles Uniform interface. The contracts who are interested in these parameters only need to implement the same interface. Extensible. When adding a new system contract, there is no need to modify any other contracts. Failure toleration. Validators could vote to skip false proposals and go on. Multiplexing. Now we have only parameters gov, but in the future, there will be more governance functions. Workflow Contract Interface Every contract that wants to subscribe param change event, should implement the following interface: function updateParam(string key, bytes calldata value) external Some following check must be done inside the interface: The msg sender must be the gov contract. Basic check of value. (length, value range) An example implementation: modifier onlyGov() { require(msg.sender == GOV_CONTRACT_ADDR, \"the msg sender must be the gov contract\"); _; } function updateParam(string key, bytes calldata value) external onlyGov{ if (key == \"relayerReward\"){ require(value.length == 32, \"the length of value is not 32 when update relayer_reward param\"); uint256 memory paramValue = TypesToBytes.ToUint256(0, value); require(paramValue >= MIN_RELAYER_REWARD, \"the relayerReward is smaller than the minimum value\"); require(paramValue <= MAX_RELAYER_REWARD, \"the relayerReward is bigger than the maximal value\"); relayerReward = paramValue\uff1b }else{ require(false, \"receive unknown param\"); } } Gov Contract Implement the cross chain contract interface: handlePackage(bytes calldata msgBytes, bytes calldata proof, uint64 height, uint64 packageSequence) And do following step: - Basic check. Sequence check, Relayer sender check, block header sync check, merkel proof check. - Check the msg type according to the first byte of msgBytes, only param change msg type supported for now. Check and parse the msg bytes. - Use a fixed gas to invoke the updateParam interface of target contract. Catch any exception and emit fail event if necessary, but let the process go on. - Claim reward for the relayer and increase sequence. Workflow Please read this doc to learn how to send transactions on Genesys Chain","title":"Governance of TC"},{"location":"smart-chain/guides/concepts/nc-gov.html#governance-of-tc","text":"","title":"Governance of TC"},{"location":"smart-chain/guides/concepts/nc-gov.html#motivation","text":"There are many system parameters to control the behavior of the TC: All these parameters of GSYS system contracts should be flexible: slashing threshold, cross-chain transfer fees, relayer reward amount and so on. All these parameters will be determined by GSYS Validator Set together through a proposal-vote process based on their staking. Such the process will be carried on BC, and the new parameter values will be picked up by corresponding system contracts via cross-chain communication if needed.","title":"Motivation"},{"location":"smart-chain/guides/concepts/nc-gov.html#design-principles","text":"Uniform interface. The contracts who are interested in these parameters only need to implement the same interface. Extensible. When adding a new system contract, there is no need to modify any other contracts. Failure toleration. Validators could vote to skip false proposals and go on. Multiplexing. Now we have only parameters gov, but in the future, there will be more governance functions.","title":"Design Principles"},{"location":"smart-chain/guides/concepts/nc-gov.html#workflow","text":"","title":"Workflow"},{"location":"smart-chain/guides/concepts/nc-gov.html#contract-interface","text":"Every contract that wants to subscribe param change event, should implement the following interface: function updateParam(string key, bytes calldata value) external Some following check must be done inside the interface: The msg sender must be the gov contract. Basic check of value. (length, value range) An example implementation: modifier onlyGov() { require(msg.sender == GOV_CONTRACT_ADDR, \"the msg sender must be the gov contract\"); _; } function updateParam(string key, bytes calldata value) external onlyGov{ if (key == \"relayerReward\"){ require(value.length == 32, \"the length of value is not 32 when update relayer_reward param\"); uint256 memory paramValue = TypesToBytes.ToUint256(0, value); require(paramValue >= MIN_RELAYER_REWARD, \"the relayerReward is smaller than the minimum value\"); require(paramValue <= MAX_RELAYER_REWARD, \"the relayerReward is bigger than the maximal value\"); relayerReward = paramValue\uff1b }else{ require(false, \"receive unknown param\"); } }","title":"Contract Interface"},{"location":"smart-chain/guides/concepts/nc-gov.html#gov-contract","text":"Implement the cross chain contract interface: handlePackage(bytes calldata msgBytes, bytes calldata proof, uint64 height, uint64 packageSequence) And do following step: - Basic check. Sequence check, Relayer sender check, block header sync check, merkel proof check. - Check the msg type according to the first byte of msgBytes, only param change msg type supported for now. Check and parse the msg bytes. - Use a fixed gas to invoke the updateParam interface of target contract. Catch any exception and emit fail event if necessary, but let the process go on. - Claim reward for the relayer and increase sequence.","title":"Gov Contract"},{"location":"smart-chain/guides/concepts/nc-gov.html#workflow_1","text":"Please read this doc to learn how to send transactions on Genesys Chain","title":"Workflow"},{"location":"smart-chain/guides/concepts/oracle-module.html","text":"Oracle on Genesys Chain The oracle module is a common module like gov which is used to handle prophecy and claim. Prophecy means the validators want to reach a consensus on something, like cross chain transfer. Claim is raised by a validator and the content of claim is the the cross chain transfer. When most of the validators (like 70%) claim the same thing on the prophecy, the winning claim will be executed.For oracle module is a common module, other module which depends on oracle module will register claim type and related hooks checking and handling claim. Each claim type has a sequence, oracle module should process prophecy and claim by sequence. When one prophecy was executed successfully, the sequence of the claim type will be increased by one. Oracle Process Oracle module receives a claim message from validator, if the sequence is not current sequence, the claim message will be rejected. If sequence is valid, the hooks of the claim type will check the claim message, if the claim message is invalid, then return If claim message is valid and it\u2019s the first claim, the related prophecy will be created. If claim message is not the first claim, then it will be added to the existed prophecy. If the power of validators which claim the same content reaches a threshold like 70%, the prophecy will be marked success and the hooks will executed the winning claim. and the sequence of claim type will be increased. If there is no chance that the validators will reach a consensus, the prophecy will be marked failed and the prophecy will be deleted and the validators should start over again. Bridge Module Bridge module will process cross chain transactions. It contains two parts: transactions from bc to bsc and transactions from bsc to bc. For transactions from bsc to bc, it will depend on the oracle module. When the validators reach a consensus on a certain claim, the bridge module will process the transaction according to the claim, like transfer from bsc to bc. For transactions from bc to bsc, it will process the bc part of the transaction and write the related cross chain package for bsc.","title":"Oracle on Genesys Chain"},{"location":"smart-chain/guides/concepts/oracle-module.html#oracle-on-genesys-chain","text":"The oracle module is a common module like gov which is used to handle prophecy and claim. Prophecy means the validators want to reach a consensus on something, like cross chain transfer. Claim is raised by a validator and the content of claim is the the cross chain transfer. When most of the validators (like 70%) claim the same thing on the prophecy, the winning claim will be executed.For oracle module is a common module, other module which depends on oracle module will register claim type and related hooks checking and handling claim. Each claim type has a sequence, oracle module should process prophecy and claim by sequence. When one prophecy was executed successfully, the sequence of the claim type will be increased by one.","title":"Oracle on Genesys Chain"},{"location":"smart-chain/guides/concepts/oracle-module.html#oracle-process","text":"Oracle module receives a claim message from validator, if the sequence is not current sequence, the claim message will be rejected. If sequence is valid, the hooks of the claim type will check the claim message, if the claim message is invalid, then return If claim message is valid and it\u2019s the first claim, the related prophecy will be created. If claim message is not the first claim, then it will be added to the existed prophecy. If the power of validators which claim the same content reaches a threshold like 70%, the prophecy will be marked success and the hooks will executed the winning claim. and the sequence of claim type will be increased. If there is no chance that the validators will reach a consensus, the prophecy will be marked failed and the prophecy will be deleted and the validators should start over again.","title":"Oracle Process"},{"location":"smart-chain/guides/concepts/oracle-module.html#bridge-module","text":"Bridge module will process cross chain transactions. It contains two parts: transactions from bc to bsc and transactions from bsc to bc. For transactions from bsc to bc, it will depend on the oracle module. When the validators reach a consensus on a certain claim, the bridge module will process the transaction according to the claim, like transfer from bsc to bc. For transactions from bc to bsc, it will process the bc part of the transaction and write the related cross chain package for bsc.","title":"Bridge Module"},{"location":"smart-chain/guides/concepts/oracle-relayer.html","text":"Oracle Relayer The relayer is a service which monitors events on TC, builds and broadcasts transactions to BC. Each validator operator should maintain its own relayer service. The relayer service requires to have access to validator operator private key. All relayer service independently witness the peggy contract events, then build transactions to claim events to BC oracle module. The relay process: Continually listen for cross chain event Parse the cross chain tranfer parameters from event data Use this information to build an unsigned BC oracle transaction Sign and broadcast transaction. GitHub Implementation link: https://github.com/githubusername/githubrepo/oracle-relayer","title":"Oracle Relayer"},{"location":"smart-chain/guides/concepts/oracle-relayer.html#oracle-relayer","text":"The relayer is a service which monitors events on TC, builds and broadcasts transactions to BC. Each validator operator should maintain its own relayer service. The relayer service requires to have access to validator operator private key. All relayer service independently witness the peggy contract events, then build transactions to claim events to BC oracle module. The relay process: Continually listen for cross chain event Parse the cross chain tranfer parameters from event data Use this information to build an unsigned BC oracle transaction Sign and broadcast transaction. GitHub Implementation link: https://github.com/githubusername/githubrepo/oracle-relayer","title":"Oracle Relayer"},{"location":"smart-chain/guides/concepts/system-contract.html","text":"Build-in System Contract Disclaimer The software and related documentation are under active development, all subject to potential future change without notification and not ready for production use. The code and security audit have not been fully completed and not ready for any bug bounty. We advise you to be careful and experiment on the network at your own risk. Stay safe out there. On-Chain Light Client The purpose of cross-chain interoperability is to enable one blockchain to function as a light-client of another. Since Genesys Chain is using a classical Byzantine Fault Tolerant consensus algorithm, light-client verification is cheap and easy: all we have to do is check validator signatures on the latest block, and verify a Merkle proof of the state. In Tendermint, validators agree on a block before processing it. This means that the signatures and state root for that block aren't included until the next block. Thus, each block contains a field called LastCommit, which contains the votes responsible for committing the previous block, and a field in the block header called AppHash, which refers to the Merkle root hash of the application after processing the transactions from the previous block. So, if we want to verify the AppHash from height H, we need the signatures from LastCommit at height H+1. (And remember that this AppHash only contains the results from all transactions up to and including block H-1) Unlike Proof-of-Work, the light-client protocol does not need to download and check all the headers in the blockchain - the client can always jump straight to the latest header available, so long as the validator set has not changed much. If the validator set is changing, the client needs to track these changes, which requires downloading headers for each block in which there is a significant change. Here, we will assume the validator set is constant, and postpone handling validator set changes for another time. Ethereum platform supports stateless precompiled contract implemented with golang and normal contract implemented with solidity. Comparing with normal contract, precompiled contracts are more efficient and costs less gas, but they are stateless. However, on-chain light client must be stateful. So here we will try to a mixed approach: precompiled implemented contract(stateless calculation, such as signature verification) and normal contract (store validator set and trusted appHash). Precompile Contract Validate Tendermint Header This contract implements tendermint header verification algorithm. The input parameters contain the trusted consensus state and a new tendermint header. The validation algorithm will verify the new tendermint header against the trusted consensus state. If the new header is valid, a new consensus state will be created and returned to caller. Otherwise, an error will be returned. Validate Merkle Proof This contract implements a Tendermint merkle proof verification algorithm . Solidity Contract Tendermint Light Client Contract ConsensusState: The first consensus state will be written in the constructor. Once a new tendermint header is verified, a new consensus state will be created. type ConsensusState struct { chainID string height int64 appHash [] byte curValidatorSetHash [] byte nextValidatorSet * tmtypes . ValidatorSet } Tendermint Header: A relayer who want to sync new tendermint headers need to query BC to build this object. Then encode it to byte array and call syncTendermintHeader. type Header struct { Header blockHeader Validator [] CurValidatorSet Validator [] NextValidatorSet } This contract implements the following four methods: function syncTendermintHeader (byte[] header, uint64 height) syncTendermintHeader gets nearest consensus state by height and call validateTendermintHeader in precompiled contract to verify the tendermint header. If the success, a new consensus state will be saved. function getAppHash (uint64 height) returns(bytes32) getAppHash provides a method to get the verified appHash at the specified height. Besides, If the header the specified height have not be verified, then zero value will be returned. function isHeaderSynced (uint64 height) returns (bool) isHeaderSynced provides a lower cost method to judge if the specified height has been synced. function getSubmitter (uint64 height) returns (address) getSubmitter provides a method to get the submitter address of the specified header. Merkle Proof Verification Library This library provides an util to to verify merkle proof from BC. Contracts which need to verify Merkle proof just need to import this library. function verifyMerkleProof (int64 height, byte[] key, byte[] value, byte[] proof) bool verifyMerkleProof reassembles user parameters and call the the above precompiled contract to validate the proof. Other Build-in System Contract TokenHub Contract This contract focuses on cross chain token transfer. TokenManager Contract This contract focuses on binding and unbinding tokens on two chains. NCValidatorSet Contract It is a watcher of validators change of GSYS on Genesys Chain. It will interact with light client contracts to verify the interchain transaction, and apply the validator set change for TC. It also stores rewarded gas fee of blocking for validators, and distribute it to validators when receiving cross chain package of validatorSet change. System Reward Contract The incentive mechanism for relayers to maintain system contracts. They will get rewards from system reward contract. Liveness Slash Contract The liveness of GSYS relies on validator set can produce blocks timely when it is their turn. Validators can miss their turns due to any reason. This instability of the operation will hurt the performance of the network and introduce more non-deterministic into the system. This contract responsible for recording the missed blocking metrics of each validator. Once the metrics are above the predefined threshold, the blocking reward for validator will not be relayed to BC for distribution but shared with other better validators. BscValidatorSet Contract This contract focuses on handling staking change package from BC. It also provides the validatorset data query for GSYS consensus engine. RelayerHub Contract This contract manages the authority of nc-relayer. Someone who wants to run a nc-relayer must call the contract to deposit some GSYS to get the authorization. Governance Contract This contract handles governance package from BC. A governance package contains target contract address, parameter name and new parameter value. Once the package is verified, this contract will call the parameter update method of the target contract to update the parameter to new value. Cross Chain Contract This contract focuses on cross chain packages pretreatment and sending cross chain packages to BC by emit event. The packages pretreatment includes sequence validation and the merkle proof verification. Once they are passed, the package will be routed to application build-in system contract, such as tokenhub or bscvalidator. Besides, if tokenhub or bscvalidator want to send packages to BC, they need to encode their packages with rlp and call this contract to send them.","title":"Build-in System Contract"},{"location":"smart-chain/guides/concepts/system-contract.html#build-in-system-contract","text":"","title":"Build-in System Contract"},{"location":"smart-chain/guides/concepts/system-contract.html#disclaimer","text":"The software and related documentation are under active development, all subject to potential future change without notification and not ready for production use. The code and security audit have not been fully completed and not ready for any bug bounty. We advise you to be careful and experiment on the network at your own risk. Stay safe out there.","title":"Disclaimer"},{"location":"smart-chain/guides/concepts/system-contract.html#on-chain-light-client","text":"The purpose of cross-chain interoperability is to enable one blockchain to function as a light-client of another. Since Genesys Chain is using a classical Byzantine Fault Tolerant consensus algorithm, light-client verification is cheap and easy: all we have to do is check validator signatures on the latest block, and verify a Merkle proof of the state. In Tendermint, validators agree on a block before processing it. This means that the signatures and state root for that block aren't included until the next block. Thus, each block contains a field called LastCommit, which contains the votes responsible for committing the previous block, and a field in the block header called AppHash, which refers to the Merkle root hash of the application after processing the transactions from the previous block. So, if we want to verify the AppHash from height H, we need the signatures from LastCommit at height H+1. (And remember that this AppHash only contains the results from all transactions up to and including block H-1) Unlike Proof-of-Work, the light-client protocol does not need to download and check all the headers in the blockchain - the client can always jump straight to the latest header available, so long as the validator set has not changed much. If the validator set is changing, the client needs to track these changes, which requires downloading headers for each block in which there is a significant change. Here, we will assume the validator set is constant, and postpone handling validator set changes for another time. Ethereum platform supports stateless precompiled contract implemented with golang and normal contract implemented with solidity. Comparing with normal contract, precompiled contracts are more efficient and costs less gas, but they are stateless. However, on-chain light client must be stateful. So here we will try to a mixed approach: precompiled implemented contract(stateless calculation, such as signature verification) and normal contract (store validator set and trusted appHash).","title":"On-Chain Light Client"},{"location":"smart-chain/guides/concepts/system-contract.html#precompile-contract","text":"","title":"Precompile Contract"},{"location":"smart-chain/guides/concepts/system-contract.html#validate-tendermint-header","text":"This contract implements tendermint header verification algorithm. The input parameters contain the trusted consensus state and a new tendermint header. The validation algorithm will verify the new tendermint header against the trusted consensus state. If the new header is valid, a new consensus state will be created and returned to caller. Otherwise, an error will be returned.","title":"Validate Tendermint Header"},{"location":"smart-chain/guides/concepts/system-contract.html#validate-merkle-proof","text":"This contract implements a Tendermint merkle proof verification algorithm .","title":"Validate Merkle Proof"},{"location":"smart-chain/guides/concepts/system-contract.html#solidity-contract","text":"","title":"Solidity Contract"},{"location":"smart-chain/guides/concepts/system-contract.html#tendermint-light-client-contract","text":"ConsensusState: The first consensus state will be written in the constructor. Once a new tendermint header is verified, a new consensus state will be created. type ConsensusState struct { chainID string height int64 appHash [] byte curValidatorSetHash [] byte nextValidatorSet * tmtypes . ValidatorSet } Tendermint Header: A relayer who want to sync new tendermint headers need to query BC to build this object. Then encode it to byte array and call syncTendermintHeader. type Header struct { Header blockHeader Validator [] CurValidatorSet Validator [] NextValidatorSet } This contract implements the following four methods: function syncTendermintHeader (byte[] header, uint64 height) syncTendermintHeader gets nearest consensus state by height and call validateTendermintHeader in precompiled contract to verify the tendermint header. If the success, a new consensus state will be saved. function getAppHash (uint64 height) returns(bytes32) getAppHash provides a method to get the verified appHash at the specified height. Besides, If the header the specified height have not be verified, then zero value will be returned. function isHeaderSynced (uint64 height) returns (bool) isHeaderSynced provides a lower cost method to judge if the specified height has been synced. function getSubmitter (uint64 height) returns (address) getSubmitter provides a method to get the submitter address of the specified header.","title":"Tendermint Light Client Contract"},{"location":"smart-chain/guides/concepts/system-contract.html#merkle-proof-verification-library","text":"This library provides an util to to verify merkle proof from BC. Contracts which need to verify Merkle proof just need to import this library. function verifyMerkleProof (int64 height, byte[] key, byte[] value, byte[] proof) bool verifyMerkleProof reassembles user parameters and call the the above precompiled contract to validate the proof.","title":"Merkle Proof Verification Library"},{"location":"smart-chain/guides/concepts/system-contract.html#other-build-in-system-contract","text":"TokenHub Contract This contract focuses on cross chain token transfer. TokenManager Contract This contract focuses on binding and unbinding tokens on two chains. NCValidatorSet Contract It is a watcher of validators change of GSYS on Genesys Chain. It will interact with light client contracts to verify the interchain transaction, and apply the validator set change for TC. It also stores rewarded gas fee of blocking for validators, and distribute it to validators when receiving cross chain package of validatorSet change. System Reward Contract The incentive mechanism for relayers to maintain system contracts. They will get rewards from system reward contract. Liveness Slash Contract The liveness of GSYS relies on validator set can produce blocks timely when it is their turn. Validators can miss their turns due to any reason. This instability of the operation will hurt the performance of the network and introduce more non-deterministic into the system. This contract responsible for recording the missed blocking metrics of each validator. Once the metrics are above the predefined threshold, the blocking reward for validator will not be relayed to BC for distribution but shared with other better validators. BscValidatorSet Contract This contract focuses on handling staking change package from BC. It also provides the validatorset data query for GSYS consensus engine. RelayerHub Contract This contract manages the authority of nc-relayer. Someone who wants to run a nc-relayer must call the contract to deposit some GSYS to get the authorization. Governance Contract This contract handles governance package from BC. A governance package contains target contract address, parameter name and new parameter value. Once the package is verified, this contract will call the parameter update method of the target contract to update the parameter to new value. Cross Chain Contract This contract focuses on cross chain packages pretreatment and sending cross chain packages to BC by emit event. The packages pretreatment includes sequence validation and the merkle proof verification. Once they are passed, the package will be routed to application build-in system contract, such as tokenhub or bscvalidator. Besides, if tokenhub or bscvalidator want to send packages to BC, they need to encode their packages with rlp and call this contract to send them.","title":"Other Build-in System Contract"},{"location":"smart-chain/validator/Parameters.html","text":"GSYS ChainStaking Parameters Staking Token GSYS Validator Candidate Mainnet Minimiun Self-delegate Amount: 10000GSYS on Mainnet . Claim reward frequency: everyday at 0:00 UTC Unbonding Period: 7 days Testnet Minimiun Self-delegate Amount: 100 GSYS on testnet. Claim reward frequency: every 2 hours Unbonding Period: 4 hours","title":"GSYS ChainStaking Parameters"},{"location":"smart-chain/validator/Parameters.html#gsys-chainstaking-parameters","text":"","title":"GSYS ChainStaking Parameters"},{"location":"smart-chain/validator/Parameters.html#staking-token","text":"GSYS","title":"Staking Token"},{"location":"smart-chain/validator/Parameters.html#validator-candidate","text":"","title":"Validator Candidate"},{"location":"smart-chain/validator/Parameters.html#mainnet","text":"Minimiun Self-delegate Amount: 10000GSYS on Mainnet . Claim reward frequency: everyday at 0:00 UTC Unbonding Period: 7 days","title":"Mainnet"},{"location":"smart-chain/validator/Parameters.html#testnet","text":"Minimiun Self-delegate Amount: 100 GSYS on testnet. Claim reward frequency: every 2 hours Unbonding Period: 4 hours","title":"Testnet"},{"location":"smart-chain/validator/best-practice.html","text":"Best Practice Keep Track of Syncing Speed t=2021-05-13T17:17:17+0800 lvl=info msg=\"Imported new chain segment\" blocks=11 txs=3701 mgas=482.461 elapsed=8.075s mgasps=59.744 number=7,355,800 hash=0x84e085b1cd5b1ad4f9a954e2f660704c8375a80f04326395536eedf83363942f age=12h38m32s dirty=\"583.73 MiB\" t=2021-05-13T17:17:20+0800 lvl=info msg=\"Deep froze chain segment\" blocks=117 elapsed=263.497ms number=7,265,806 hash=0x7602f6b960b4092d39ff49781c64404a047e2c78bc166f071ee8714020c39b2e t=2021-05-13T17:17:25+0800 lvl=info msg=\"Imported new chain segment\" blocks=17 txs=5025 mgas=740.885 elapsed=8.125s mgasps=91.177 number=7,355,817 hash=0xde7a2a76ff7b38414acf3b360bb427d2d0b7dd1f8fe2afe2ffd59d64b237a81b age=12h37m49s dirty=\"594.65 MiB\" t=2021-05-13T17:17:33+0800 lvl=info msg=\"Imported new chain segment\" blocks=18 txs=5108 mgas=748.016 elapsed=8.354s mgasps=89.535 number=7,355,835 hash=0x757c476f9fe30fc6ef001fb4a03fa991843cf3ed271f21cfc01a9bba5e5eff98 age=12h37m3s dirty=\"604.39 MiB\" t=2021-05-13T17:17:42+0800 lvl=info msg=\"Imported new chain segment\" blocks=18 txs=5612 mgas=799.778 elapsed=8.260s mgasps=96.815 number=7,355,853 hash=0x73e87742ef4405ffefec987fc4b8b19e69c54b8f914c27ea69a502fae4d735e0 age=12h36m18s dirty=\"613.03 MiB\" Your syncing speed is mgasps . The value should be around 100. If you are syncing slowly, please check the speed of your disk. Use Chaindata Snapshot Please download the chain data snapshot and extract to your home folder to speed up Store your GSYS with a hardware wallet The most valuable assets of a validator are two keys: one for signing transactions and another for signing blocks Securing your fullnode RPC from hackers Please do not expose your RPC endpoints to public network. Account Private keys To protect your GSYS, do not share your 24 words with anyone. The only person who should ever need to know them is you. In short, HSMs are affordable, performant and portable pieces of hardware that help to securely generate, store and manage your private keys. Malware attacks and remote extraction of private keys are much more difficult when an HSM is configured properly. Software Vulnerabilities To protect your GSYS, you should only download software directly from official sources, and make sure that you're always using the latest, most secure version Running Server as a Daemon It is important to keep geth running at all times. There are several ways to achieve this, and the simplest solution we recommend is to register geth as a systemd service so that it will automatically get started upon system reboots and other events. Set up a backup node Run validator node in archive mode Shut down nodes gracefully Active monitoring with tools Steps to run a backup node Install the latest version of geth Sync to the latest height using fast sync mode. You can either download the latest snapshot or start fast sync once your node is fully synced Shut down your node gracefully kill -HUP $(pgrep geth) Restart your node with --gcmode archive Why node will be offline for a while after restart? or What will happen if client been force killed After running (synchronized) for a long period of time and being abruptly terminated, only archived nodes are expected to quickly re-synchronize upon restart. Steps to reproduce: Run the node synchronized for a period of time. Abruptly kill the node (kill -9 or system crash). Restart the node, observe where it resynchronizes from block height 1 hour ago. Reasons If Geth crashes (or is not shut down gracefully), the recent state held in memory is lost and needs to be regenerated. It takes Geth a long time to restore the states. The root reason is that geth does flush the state trie periodically. The period is defined as trieTimeout in config.toml . How to upgrade a backup node to become a validator node? You can stop mining new blocks by sending commands in geth console Connect to your validator node with geth attach ipc:path/to/geth.ipc miner.stop () Then, let backup node resume validating , miner.start ()","title":"Best Practice"},{"location":"smart-chain/validator/best-practice.html#best-practice","text":"","title":"Best Practice"},{"location":"smart-chain/validator/best-practice.html#keep-track-of-syncing-speed","text":"t=2021-05-13T17:17:17+0800 lvl=info msg=\"Imported new chain segment\" blocks=11 txs=3701 mgas=482.461 elapsed=8.075s mgasps=59.744 number=7,355,800 hash=0x84e085b1cd5b1ad4f9a954e2f660704c8375a80f04326395536eedf83363942f age=12h38m32s dirty=\"583.73 MiB\" t=2021-05-13T17:17:20+0800 lvl=info msg=\"Deep froze chain segment\" blocks=117 elapsed=263.497ms number=7,265,806 hash=0x7602f6b960b4092d39ff49781c64404a047e2c78bc166f071ee8714020c39b2e t=2021-05-13T17:17:25+0800 lvl=info msg=\"Imported new chain segment\" blocks=17 txs=5025 mgas=740.885 elapsed=8.125s mgasps=91.177 number=7,355,817 hash=0xde7a2a76ff7b38414acf3b360bb427d2d0b7dd1f8fe2afe2ffd59d64b237a81b age=12h37m49s dirty=\"594.65 MiB\" t=2021-05-13T17:17:33+0800 lvl=info msg=\"Imported new chain segment\" blocks=18 txs=5108 mgas=748.016 elapsed=8.354s mgasps=89.535 number=7,355,835 hash=0x757c476f9fe30fc6ef001fb4a03fa991843cf3ed271f21cfc01a9bba5e5eff98 age=12h37m3s dirty=\"604.39 MiB\" t=2021-05-13T17:17:42+0800 lvl=info msg=\"Imported new chain segment\" blocks=18 txs=5612 mgas=799.778 elapsed=8.260s mgasps=96.815 number=7,355,853 hash=0x73e87742ef4405ffefec987fc4b8b19e69c54b8f914c27ea69a502fae4d735e0 age=12h36m18s dirty=\"613.03 MiB\" Your syncing speed is mgasps . The value should be around 100. If you are syncing slowly, please check the speed of your disk.","title":"Keep Track of Syncing Speed"},{"location":"smart-chain/validator/best-practice.html#use-chaindata-snapshot","text":"Please download the chain data snapshot and extract to your home folder to speed up","title":"Use Chaindata Snapshot"},{"location":"smart-chain/validator/best-practice.html#store-your-gsys-with-a-hardware-wallet","text":"The most valuable assets of a validator are two keys: one for signing transactions and another for signing blocks","title":"Store your GSYS with a hardware wallet"},{"location":"smart-chain/validator/best-practice.html#securing-your-fullnode-rpc-from-hackers","text":"Please do not expose your RPC endpoints to public network.","title":"Securing your fullnode RPC from hackers"},{"location":"smart-chain/validator/best-practice.html#account-private-keys","text":"To protect your GSYS, do not share your 24 words with anyone. The only person who should ever need to know them is you. In short, HSMs are affordable, performant and portable pieces of hardware that help to securely generate, store and manage your private keys. Malware attacks and remote extraction of private keys are much more difficult when an HSM is configured properly.","title":"Account Private keys"},{"location":"smart-chain/validator/best-practice.html#software-vulnerabilities","text":"To protect your GSYS, you should only download software directly from official sources, and make sure that you're always using the latest, most secure version","title":"Software Vulnerabilities"},{"location":"smart-chain/validator/best-practice.html#running-server-as-a-daemon","text":"It is important to keep geth running at all times. There are several ways to achieve this, and the simplest solution we recommend is to register geth as a systemd service so that it will automatically get started upon system reboots and other events.","title":"Running Server as a Daemon"},{"location":"smart-chain/validator/best-practice.html#set-up-a-backup-node","text":"Run validator node in archive mode Shut down nodes gracefully Active monitoring with tools","title":"Set up a backup node"},{"location":"smart-chain/validator/best-practice.html#steps-to-run-a-backup-node","text":"Install the latest version of geth Sync to the latest height using fast sync mode. You can either download the latest snapshot or start fast sync once your node is fully synced Shut down your node gracefully kill -HUP $(pgrep geth) Restart your node with --gcmode archive","title":"Steps to run a backup node"},{"location":"smart-chain/validator/best-practice.html#why-node-will-be-offline-for-a-while-after-restart-or-what-will-happen-if-client-been-force-killed","text":"After running (synchronized) for a long period of time and being abruptly terminated, only archived nodes are expected to quickly re-synchronize upon restart. Steps to reproduce: Run the node synchronized for a period of time. Abruptly kill the node (kill -9 or system crash). Restart the node, observe where it resynchronizes from block height 1 hour ago. Reasons If Geth crashes (or is not shut down gracefully), the recent state held in memory is lost and needs to be regenerated. It takes Geth a long time to restore the states. The root reason is that geth does flush the state trie periodically. The period is defined as trieTimeout in config.toml .","title":"Why node will be offline for a while after restart? or What will happen if client been force killed"},{"location":"smart-chain/validator/best-practice.html#how-to-upgrade-a-backup-node-to-become-a-validator-node","text":"You can stop mining new blocks by sending commands in geth console Connect to your validator node with geth attach ipc:path/to/geth.ipc miner.stop () Then, let backup node resume validating , miner.start ()","title":"How to upgrade a backup node to become a validator node?"},{"location":"smart-chain/validator/guideline.html","text":"How to join Genesys Chain as Validator? Before You Start Choose Your Validator hardware VPS running recent versions of Mac OS X or Linux. IMPORTANT 2T GB of free disk space, solid-state drive(SSD), gp3, 8k IOPS, 250MB/S throughput, read latency <1ms 12 cores of CPU and 48 gigabytes of memory (RAM) Suggest m5zn.3xlarge instance type on AWS, or c2-standard-8 on Google cloud. A broadband Internet connection with upload/download speeds of 10 megabyte per second Setup a Validator Node at Testnet Note If you are running a node in Testnet, 2CPU/8GB of RAM is sufficient. Install GSYS Fullnode you can download the pre-build binaries from release page or follow the instructions here to set up a full node . Download the config files Download genesis.json and config.toml by: ## testnet wget --no-check-certificate $( curl -shttps://github.com/githubusername/githubrepo/releases/latest | grep browser_ | grep testnet | cut -d \\\" -f4 ) unzip testnet.zip Launch your node and wait for it to get synced. Create Consensus Key You need to create an account that represents a validator's consensus key. Use the following command to create a new account and set a password for that account: geth account new --datadir ./node Start Validator Node Warning Please do not expose your RPC endpoints to public network. echo { your-password } > password.txt geth --config ./config.toml --datadir ./node --syncmode snap -unlock { your-validator-address } --password password.txt --mine --allow-insecure-unlock --cache 18000 Get Testnet Token from Faucet You can get testnet GSYS from https://testnet-explorer.genesys.network/faucet-smart , but the GSYS is on Genesys Chain. Download eth-cli from GitHub . Use eth-cli to create an account or recover an account. You can follow the guide to transfer GSYS from GSYS testnet to BC testnet. Declare Your Candidacy Use eth-cli to create an account or recover an account, make sure the account get more than 10000 GSYS. Before sending create-validator transaction, make sure your bsc validator have already catched up. Example on testnet eth-cli staking nc-create-validator \\ --side-cons-addr {validator address} \\ --side-fee-addr {wallet address on TC} \\ --address-delegator {wallet address on BC} \\ --side-chain-id chapel \\ --amount 10000000000:GSYS \\ --commission-rate {10000000 represent 10%} \\ --commission-max-rate {20000000 represent 20%} \\ --commission-max-change-rate {10000000 represent 1%} \\ --moniker {validator name} \\ --details {validator detailed description} \\ --identity {keybase identity} \\ --website {website for validator} \\ --from {key name} \\ --chain-id GSYS-Chain-Ganges \\ --node=http://data-seed-pre-1-s3.genesys.network:80 Go to explorer to verify your transactions. Check your validator's status at this page Setup a Mainnet Validator 1. Install GSYS Fullnode you can download the pre-build binaries from release page or follow the instructions here to set up a full node . Download the config files Download genesis.json and config.toml by: ## mainet wget --no-check-certificate $( curl -s https://api.github.com/repos/shree-chain/bsc/releases/latest | grep browser_ | grep mainnet | cut -d \\\" -f4 ) unzip mainnet.zip 2. Write genesis state locally geth --datadir node init genesis.json You could see the following output: INFO [05-19|14:53:17.468] Allocated cache and file handles database=/Users/huangsuyu/Downloads/bsc/node/geth/chaindata cache=16.00MiB handles=16 INFO [05-19|14:53:17.498] Writing custom genesis block INFO [05-19|14:53:17.501] Persisted trie from memory database nodes=21 size=56.84KiB time=357.915\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=-574.00B INFO [05-19|14:53:17.502] Successfully wrote genesis state database=chaindata hash=7d79cc\u2026fb0d1e INFO [05-19|14:53:17.503] Allocated cache and file handles database=/Users/huangsuyu/Downloads/bsc/node/geth/lightchaindata cache=16.00MiB handles=16 INFO [05-19|14:53:17.524] Writing custom genesis block INFO [05-19|14:53:17.525] Persisted trie from memory database nodes=21 size=56.84KiB time=638.396\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=-574.00B INFO [05-19|14:53:17.528] Successfully wrote genesis state database=lightchaindata hash=7d79cc\u2026fb0d1e 3. Create Consensus Key You need to create an account that represents a validator's consensus key. Use the following command to create a new account and set a password for that account: Warning Please do not share access to keystore to others. geth account new --datadir ./node This command will return the public address and the path to your private key. BACKUP of keyfile is necessory! If you already have an account, use the seed phrase to recover it: geth account import --datadir ./node Start Validator Node Warning Please do not expose your RPC endpoints to public network. ## generate the consensus key and input the password geth account new --datadir ./node echo { your-password } > password.txt geth --config ./config.toml --datadir ./node --syncmode snap -unlock { your-validator-address } --password password.txt --mine --allow-insecure-unlock --cache 18000 Wait for node to sync Your node should now be catching up with the network by replaying all the transactions from genesis and recreating the blockchain state locally. This will take a long time, so make sure you've set it up on a stable connection so you can leave while it syncs. View the status of the network with https://genesys.network/ . You can monitor the status from log: $HOME/node/bsc.log by default. Congratulations! You've now successfully joined a network as a full node operator. Setup a data backup (recommended for the mainnet) If you are connecting to an existing network for which you have a data backup (from a provider you trust), you can optionally load the backup into your node storage rather than syncing from scratch. Learn more here 5. Declare Candidacy You can use eth-cli binary to sen create-validator transaction, thus you can declare your candidacy. Download eth-cli from GitHub Use eth-cli to create an account or recover an account, make sure the account get more than 10000 GSYS. Make sure your bsc validator have already catched up. Command for create validator on mainnet: eth-cli staking nc-create-validator \\ -side-cons-addr {validator address} \\ --side-fee-addr {wallet address on TC} \\ --address-delegator {wallet address on BC} \\ --side-chain-id bsc \\ --amount 10000000000:GSYS \\ --commission-rate {10000000 represent 10%} \\ --commission-max-rate {20000000 represent 20%} \\ --commission-max-change-rate {500000000 represent 5%} \\ --moniker {validator name} \\ --details {validator detailed description} \\ --identity {keybase identity} \\ --website {website for validator} \\ --from {key name} \\ --chain-id GSYS-Chain-Tigris \\ --node https://dataseed5.defibit.io:443 Make sure that the side-cons-addr is the address you unlock when start the validator node. Read the detailed manual here to understand other parameters. Go to explorer to verify your transactions. After Declare Your Candidacy 1.Monitor node status To get started quickly, run GethExporter in a Docker container. docker run -it -d -p 9090:9090 \\ -e \"GETH=http://mygethserverhere.com:8545\" \\ hunterlong/gethexporter 2. Update validator prodile You can submit a PullRequest to this repository to update your information: https://github.com/githubusername/githubrepo/validator-directory Reference: https://grafana.com/grafana/dashboards/6976 3. Publish Validator Information Please submit a Pull Request to this repo https://github.com/githubusername/githubrepo/validator-directory This repository is a place for validator candidates to give potential delegators a brief introduction about your team and infrastructure, and present your ecosystem contributions. 4. Stop Validating You can stop mining new blocks by sending commands in geth console Connect to your validator node with geth attach ipc:path/to/geth.ipc miner.stop () To resume validating, miner.start ()","title":"How to join Genesys Chain as Validator?"},{"location":"smart-chain/validator/guideline.html#how-to-join-genesys-chain-as-validator","text":"","title":"How to join Genesys Chain as Validator?"},{"location":"smart-chain/validator/guideline.html#before-you-start","text":"","title":"Before You Start"},{"location":"smart-chain/validator/guideline.html#choose-your-validator-hardware","text":"VPS running recent versions of Mac OS X or Linux. IMPORTANT 2T GB of free disk space, solid-state drive(SSD), gp3, 8k IOPS, 250MB/S throughput, read latency <1ms 12 cores of CPU and 48 gigabytes of memory (RAM) Suggest m5zn.3xlarge instance type on AWS, or c2-standard-8 on Google cloud. A broadband Internet connection with upload/download speeds of 10 megabyte per second","title":"Choose Your Validator hardware"},{"location":"smart-chain/validator/guideline.html#setup-a-validator-node-at-testnet","text":"Note If you are running a node in Testnet, 2CPU/8GB of RAM is sufficient. Install GSYS Fullnode you can download the pre-build binaries from release page or follow the instructions here to set up a full node . Download the config files Download genesis.json and config.toml by: ## testnet wget --no-check-certificate $( curl -shttps://github.com/githubusername/githubrepo/releases/latest | grep browser_ | grep testnet | cut -d \\\" -f4 ) unzip testnet.zip Launch your node and wait for it to get synced.","title":"Setup a Validator Node at Testnet"},{"location":"smart-chain/validator/guideline.html#create-consensus-key","text":"You need to create an account that represents a validator's consensus key. Use the following command to create a new account and set a password for that account: geth account new --datadir ./node","title":"Create Consensus Key"},{"location":"smart-chain/validator/guideline.html#start-validator-node","text":"Warning Please do not expose your RPC endpoints to public network. echo { your-password } > password.txt geth --config ./config.toml --datadir ./node --syncmode snap -unlock { your-validator-address } --password password.txt --mine --allow-insecure-unlock --cache 18000","title":"Start Validator Node"},{"location":"smart-chain/validator/guideline.html#get-testnet-token-from-faucet","text":"You can get testnet GSYS from https://testnet-explorer.genesys.network/faucet-smart , but the GSYS is on Genesys Chain. Download eth-cli from GitHub . Use eth-cli to create an account or recover an account. You can follow the guide to transfer GSYS from GSYS testnet to BC testnet.","title":"Get Testnet Token from Faucet"},{"location":"smart-chain/validator/guideline.html#declare-your-candidacy","text":"Use eth-cli to create an account or recover an account, make sure the account get more than 10000 GSYS. Before sending create-validator transaction, make sure your bsc validator have already catched up. Example on testnet eth-cli staking nc-create-validator \\ --side-cons-addr {validator address} \\ --side-fee-addr {wallet address on TC} \\ --address-delegator {wallet address on BC} \\ --side-chain-id chapel \\ --amount 10000000000:GSYS \\ --commission-rate {10000000 represent 10%} \\ --commission-max-rate {20000000 represent 20%} \\ --commission-max-change-rate {10000000 represent 1%} \\ --moniker {validator name} \\ --details {validator detailed description} \\ --identity {keybase identity} \\ --website {website for validator} \\ --from {key name} \\ --chain-id GSYS-Chain-Ganges \\ --node=http://data-seed-pre-1-s3.genesys.network:80 Go to explorer to verify your transactions. Check your validator's status at this page","title":"Declare Your Candidacy"},{"location":"smart-chain/validator/guideline.html#setup-a-mainnet-validator","text":"","title":"Setup a Mainnet Validator"},{"location":"smart-chain/validator/guideline.html#1-install-gsys-fullnode","text":"you can download the pre-build binaries from release page or follow the instructions here to set up a full node . Download the config files Download genesis.json and config.toml by: ## mainet wget --no-check-certificate $( curl -s https://api.github.com/repos/shree-chain/bsc/releases/latest | grep browser_ | grep mainnet | cut -d \\\" -f4 ) unzip mainnet.zip","title":"1. Install GSYS Fullnode"},{"location":"smart-chain/validator/guideline.html#2-write-genesis-state-locally","text":"geth --datadir node init genesis.json You could see the following output: INFO [05-19|14:53:17.468] Allocated cache and file handles database=/Users/huangsuyu/Downloads/bsc/node/geth/chaindata cache=16.00MiB handles=16 INFO [05-19|14:53:17.498] Writing custom genesis block INFO [05-19|14:53:17.501] Persisted trie from memory database nodes=21 size=56.84KiB time=357.915\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=-574.00B INFO [05-19|14:53:17.502] Successfully wrote genesis state database=chaindata hash=7d79cc\u2026fb0d1e INFO [05-19|14:53:17.503] Allocated cache and file handles database=/Users/huangsuyu/Downloads/bsc/node/geth/lightchaindata cache=16.00MiB handles=16 INFO [05-19|14:53:17.524] Writing custom genesis block INFO [05-19|14:53:17.525] Persisted trie from memory database nodes=21 size=56.84KiB time=638.396\u00b5s gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=-574.00B INFO [05-19|14:53:17.528] Successfully wrote genesis state database=lightchaindata hash=7d79cc\u2026fb0d1e","title":"2. Write genesis state locally"},{"location":"smart-chain/validator/guideline.html#3-create-consensus-key","text":"You need to create an account that represents a validator's consensus key. Use the following command to create a new account and set a password for that account: Warning Please do not share access to keystore to others. geth account new --datadir ./node This command will return the public address and the path to your private key. BACKUP of keyfile is necessory! If you already have an account, use the seed phrase to recover it: geth account import --datadir ./node","title":"3. Create Consensus Key"},{"location":"smart-chain/validator/guideline.html#start-validator-node_1","text":"Warning Please do not expose your RPC endpoints to public network. ## generate the consensus key and input the password geth account new --datadir ./node echo { your-password } > password.txt geth --config ./config.toml --datadir ./node --syncmode snap -unlock { your-validator-address } --password password.txt --mine --allow-insecure-unlock --cache 18000","title":"Start Validator Node"},{"location":"smart-chain/validator/guideline.html#wait-for-node-to-sync","text":"Your node should now be catching up with the network by replaying all the transactions from genesis and recreating the blockchain state locally. This will take a long time, so make sure you've set it up on a stable connection so you can leave while it syncs. View the status of the network with https://genesys.network/ . You can monitor the status from log: $HOME/node/bsc.log by default. Congratulations! You've now successfully joined a network as a full node operator.","title":"Wait for node to sync"},{"location":"smart-chain/validator/guideline.html#setup-a-data-backup-recommended-for-the-mainnet","text":"If you are connecting to an existing network for which you have a data backup (from a provider you trust), you can optionally load the backup into your node storage rather than syncing from scratch. Learn more here","title":"Setup a data backup (recommended for the mainnet)"},{"location":"smart-chain/validator/guideline.html#5-declare-candidacy","text":"You can use eth-cli binary to sen create-validator transaction, thus you can declare your candidacy. Download eth-cli from GitHub Use eth-cli to create an account or recover an account, make sure the account get more than 10000 GSYS. Make sure your bsc validator have already catched up. Command for create validator on mainnet: eth-cli staking nc-create-validator \\ -side-cons-addr {validator address} \\ --side-fee-addr {wallet address on TC} \\ --address-delegator {wallet address on BC} \\ --side-chain-id bsc \\ --amount 10000000000:GSYS \\ --commission-rate {10000000 represent 10%} \\ --commission-max-rate {20000000 represent 20%} \\ --commission-max-change-rate {500000000 represent 5%} \\ --moniker {validator name} \\ --details {validator detailed description} \\ --identity {keybase identity} \\ --website {website for validator} \\ --from {key name} \\ --chain-id GSYS-Chain-Tigris \\ --node https://dataseed5.defibit.io:443 Make sure that the side-cons-addr is the address you unlock when start the validator node. Read the detailed manual here to understand other parameters. Go to explorer to verify your transactions.","title":"5. Declare Candidacy"},{"location":"smart-chain/validator/guideline.html#after-declare-your-candidacy","text":"","title":"After Declare Your Candidacy"},{"location":"smart-chain/validator/guideline.html#1monitor-node-status","text":"To get started quickly, run GethExporter in a Docker container. docker run -it -d -p 9090:9090 \\ -e \"GETH=http://mygethserverhere.com:8545\" \\ hunterlong/gethexporter","title":"1.Monitor node status"},{"location":"smart-chain/validator/guideline.html#2-update-validator-prodile","text":"You can submit a PullRequest to this repository to update your information: https://github.com/githubusername/githubrepo/validator-directory Reference: https://grafana.com/grafana/dashboards/6976","title":"2. Update validator prodile"},{"location":"smart-chain/validator/guideline.html#3-publish-validator-information","text":"Please submit a Pull Request to this repo https://github.com/githubusername/githubrepo/validator-directory This repository is a place for validator candidates to give potential delegators a brief introduction about your team and infrastructure, and present your ecosystem contributions.","title":"3. Publish Validator Information"},{"location":"smart-chain/validator/guideline.html#4-stop-validating","text":"You can stop mining new blocks by sending commands in geth console Connect to your validator node with geth attach ipc:path/to/geth.ipc miner.stop () To resume validating, miner.start ()","title":"4. Stop Validating"},{"location":"smart-chain/validator/overview.html","text":"Genesys Chain Validator Overview What is Genesys Chain? Genesys Chain is an innovative solution to bring programmability and interoperability to Genesys Chain. Genesys Chain relies on a system of 21 validators with Proof of Staked Authority (PoSA) consensus that can support short block time and lower fees. The most bonded validator candidates of staking will become validators and produce blocks. The double-sign detection and other slashing logic guarantee security, stability, and chain finality. What is Validator? Genesys Chain relies on a set of validators who are responsible for committing new blocks in the blockchain. These validators participate in the consensus protocol by signing blocks that contain cryptographic signatures signed by each validator's private key. The validator set is determined by a staking module built on Genesys Chain for Genesys Chain, and propagated every day UTC 00:00 from BC to GSYS via Cross-Chain communication. Economics Validator's rewards come from transaction fees and commission fees from delegators. Let us also assume that the reward for a block is 100 GSYS and that a certain validator has 20% of self-bonded GSYS and sets its commission rate to 20%. These tokens do not go directly to the proposer. Instead, they are shared among validators and delegators. These 100 GSYS will be distributed according to each participant's stake: Commission: 80*20%= 16 GSYS Validator gets: 100*20% + Commission = 36 GSYS All delegators get: 100*80% - Commission = 64 GSYS If validators double sign, are frequently offline, their staked GSYS ( not including GSYS of users that delegated to them) can be slashed. The penalty depends on the severity of the violation. You can learn to see the revenue history from BitQuery's chart or a table of BscScan Risks for Validators If you try to cheat the system, or act contrary to the specification, you will be liable to incur a penalty, known as slashing . Potential Loss Loss for Double-Sign Slash Running your validator keys simultaneously on two or more machines will result in Double-Sign slashing. Penalty for Double-Sign Slash: 10000 staked GSYS will be slashed for the validator. The Double-Sign Jail time is 2^63-1 seconds, which means the candidate cannot become a validator anymore. Note: Rewards for submitting double-sign evidence: 1000GSYS Anyone can submit a slashing request on BC with the evidence of Double Sign of TC, which should contain the 2 block headers with the same height and parent block, sealed by the offending validator. Loss for Offline Slash: If a validator missed more than 50 blocks every 24h, the blocking reward for validator will not be relayed to BC for distribution but shared with other better validators. If it missed more than 150 blocks every 24h, then this will be propagated back to BC where another Slashing will happen Penalty for Offline Slash: 50 staked GSYS will be slashed for the validator. The Downtime Jail time is 2 days, which means the candidate can send a unjail transaction to become a candidate again. Loss for Too Low self-delegation Validator candidates must stake 10000GSYS as self-delegation. If the self-delegation amount is lower, the Jail time is 1 day.","title":"Genesys Chain Validator Overview"},{"location":"smart-chain/validator/overview.html#genesys-chain-validator-overview","text":"","title":"Genesys Chain Validator Overview"},{"location":"smart-chain/validator/overview.html#what-is-genesys-chain","text":"Genesys Chain is an innovative solution to bring programmability and interoperability to Genesys Chain. Genesys Chain relies on a system of 21 validators with Proof of Staked Authority (PoSA) consensus that can support short block time and lower fees. The most bonded validator candidates of staking will become validators and produce blocks. The double-sign detection and other slashing logic guarantee security, stability, and chain finality.","title":"What is Genesys Chain?"},{"location":"smart-chain/validator/overview.html#what-is-validator","text":"Genesys Chain relies on a set of validators who are responsible for committing new blocks in the blockchain. These validators participate in the consensus protocol by signing blocks that contain cryptographic signatures signed by each validator's private key. The validator set is determined by a staking module built on Genesys Chain for Genesys Chain, and propagated every day UTC 00:00 from BC to GSYS via Cross-Chain communication.","title":"What is Validator?"},{"location":"smart-chain/validator/overview.html#economics","text":"Validator's rewards come from transaction fees and commission fees from delegators. Let us also assume that the reward for a block is 100 GSYS and that a certain validator has 20% of self-bonded GSYS and sets its commission rate to 20%. These tokens do not go directly to the proposer. Instead, they are shared among validators and delegators. These 100 GSYS will be distributed according to each participant's stake: Commission: 80*20%= 16 GSYS Validator gets: 100*20% + Commission = 36 GSYS All delegators get: 100*80% - Commission = 64 GSYS If validators double sign, are frequently offline, their staked GSYS ( not including GSYS of users that delegated to them) can be slashed. The penalty depends on the severity of the violation. You can learn to see the revenue history from BitQuery's chart or a table of BscScan","title":"Economics"},{"location":"smart-chain/validator/overview.html#risks-for-validators","text":"If you try to cheat the system, or act contrary to the specification, you will be liable to incur a penalty, known as slashing .","title":"Risks for Validators"},{"location":"smart-chain/validator/overview.html#potential-loss","text":"","title":"Potential Loss"},{"location":"smart-chain/validator/overview.html#loss-for-double-sign-slash","text":"Running your validator keys simultaneously on two or more machines will result in Double-Sign slashing. Penalty for Double-Sign Slash: 10000 staked GSYS will be slashed for the validator. The Double-Sign Jail time is 2^63-1 seconds, which means the candidate cannot become a validator anymore. Note: Rewards for submitting double-sign evidence: 1000GSYS Anyone can submit a slashing request on BC with the evidence of Double Sign of TC, which should contain the 2 block headers with the same height and parent block, sealed by the offending validator.","title":"Loss for Double-Sign Slash"},{"location":"smart-chain/validator/overview.html#loss-for-offline-slash","text":"If a validator missed more than 50 blocks every 24h, the blocking reward for validator will not be relayed to BC for distribution but shared with other better validators. If it missed more than 150 blocks every 24h, then this will be propagated back to BC where another Slashing will happen Penalty for Offline Slash: 50 staked GSYS will be slashed for the validator. The Downtime Jail time is 2 days, which means the candidate can send a unjail transaction to become a candidate again.","title":"Loss for Offline Slash:"},{"location":"smart-chain/validator/overview.html#loss-for-too-low-self-delegation","text":"Validator candidates must stake 10000GSYS as self-delegation. If the self-delegation amount is lower, the Jail time is 1 day.","title":"Loss for Too Low self-delegation"},{"location":"smart-chain/validator/security.html","text":"Security Each validator candidate is encouraged to run its operations independently, as diverse setups increase the resilience of the network. Sentry Nodes (DDOS Protection) Validators are responsible for ensuring that the network can sustain denial of service attacks. One recommended way to mitigate these risks is for validators to carefully structure their network topology in a so-called sentry node architecture. Sentry nodes can be quickly spun up or change their IP addresses. Because the links to the sentry nodes are in private IP space, an internet based attacked cannot disturb them directly. This will ensure validator block proposals and votes always make it to the rest of the network. To setup your sentry node architecture you can follow the instructions below: Build a private network and setup trusted private connections between validator node and it sentry Please do not expose your validator fullnode RPC endpoints to public network. Install your fullnode Set sentry as peers for validator node In the console of the sentry node, run admin.nodeInfo.enode You should get something similar to this. enode://f2da64f49c30a0038bba3391f40805d531510c473ec2bcc7c201631ba003c6f16fa09e03308e48f87d21c0fed1e4e0bc53428047f6dcf34da344d3f5bb69373b@[::]:30306?discport=0 !!! Note: [::] will be parsed as localhost (127.0.0.1). If your nodes are on a local network check each individual host machine and find your IP with ifconfig If your peers are not on the local network, you need to know your external IP address (use a service) to construct the enode URL. Copy this value and in the console of the first node run, Update config.toml file of validator node # make node invisible NoDiscovery = true # connect only to sentry StaticNodes = [\"enode://f2da64f49c30a0038bba3391f40805d531510c473ec2bcc7c201631ba003c6f16fa09e03308e48f87d21c0fed1e4e0bc53428047f6dcf34da344d3f5bb69373b@[10.1.1.1]:30306\"] This will return true if successful, but that doesn\u2019t mean the node was added successfully. To confirm run admin.peers and you should see the details of the node you just added. That way your validator node will try to peer with your provided sentry nodes only. Confirm the connection To confirm run admin.peers and you should see the details of the node you just added. Firewall Configuration geth uses several TCP ports for different purposes. geth use a listener (TCP) port and a discovery (UDP) port, both on 30303 by default. If you need to run JSON-RPC, you'll also need TCP port 8545. Note that JSON-RPC port should not be opened to the outside world, because from there you can do admin operations.","title":"Security"},{"location":"smart-chain/validator/security.html#security","text":"Each validator candidate is encouraged to run its operations independently, as diverse setups increase the resilience of the network.","title":"Security"},{"location":"smart-chain/validator/security.html#sentry-nodes-ddos-protection","text":"Validators are responsible for ensuring that the network can sustain denial of service attacks. One recommended way to mitigate these risks is for validators to carefully structure their network topology in a so-called sentry node architecture. Sentry nodes can be quickly spun up or change their IP addresses. Because the links to the sentry nodes are in private IP space, an internet based attacked cannot disturb them directly. This will ensure validator block proposals and votes always make it to the rest of the network. To setup your sentry node architecture you can follow the instructions below: Build a private network and setup trusted private connections between validator node and it sentry Please do not expose your validator fullnode RPC endpoints to public network. Install your fullnode Set sentry as peers for validator node In the console of the sentry node, run admin.nodeInfo.enode You should get something similar to this. enode://f2da64f49c30a0038bba3391f40805d531510c473ec2bcc7c201631ba003c6f16fa09e03308e48f87d21c0fed1e4e0bc53428047f6dcf34da344d3f5bb69373b@[::]:30306?discport=0 !!! Note: [::] will be parsed as localhost (127.0.0.1). If your nodes are on a local network check each individual host machine and find your IP with ifconfig If your peers are not on the local network, you need to know your external IP address (use a service) to construct the enode URL. Copy this value and in the console of the first node run, Update config.toml file of validator node # make node invisible NoDiscovery = true # connect only to sentry StaticNodes = [\"enode://f2da64f49c30a0038bba3391f40805d531510c473ec2bcc7c201631ba003c6f16fa09e03308e48f87d21c0fed1e4e0bc53428047f6dcf34da344d3f5bb69373b@[10.1.1.1]:30306\"] This will return true if successful, but that doesn\u2019t mean the node was added successfully. To confirm run admin.peers and you should see the details of the node you just added. That way your validator node will try to peer with your provided sentry nodes only. Confirm the connection To confirm run admin.peers and you should see the details of the node you just added.","title":"Sentry Nodes (DDOS Protection)"},{"location":"smart-chain/validator/security.html#firewall-configuration","text":"geth uses several TCP ports for different purposes. geth use a listener (TCP) port and a discovery (UDP) port, both on 30303 by default. If you need to run JSON-RPC, you'll also need TCP port 8545. Note that JSON-RPC port should not be opened to the outside world, because from there you can do admin operations.","title":"Firewall Configuration"},{"location":"smart-chain/validator/testnet.html","text":"How to become a Validator Candidate Install Fullnode Please follow this guide to install bsc fullnode locally. Create an account You need to create an account that represents a key pair first. Use the following command to create a new account and set a password for that account: geth account new --datadir ./node This command will return the public address and the path to your private key. BACKUP of keyfile is necessory! If you already have an account, use the seed phrase to recover it: geth account import --datadir ./node Get some testnet fund from faucet Go to this faucet page: https://testnet-explorer.genesys.network/faucet-smart Transfer GSYS from GSYS to BC Please refer to this guide to transfer GSYS with Genesys Chain extension wallet. Become a validator candidate You can use eth-cli to declare your candidacy some of GSYS to a validator Go to testnet explorer to verify your transactions. Get Genesis file and Config file wget --no-check-certificate $( curl -s https://api.github.com/repos/shree-chain/bsc/releases/latest | grep browser_ | grep testnet | cut -d \\\" -f4 ) unzip testnet.zip Start Fullnode on GSYS Testnet Please run this command to run a fullnode as validator candidate geth --datadir node init genesis.json geth --config ./config.toml --datadir ./node --syncmode snap -unlock { validator-address } --mine --allow-insecure-unlock Become a validator candidate of testnet You can use eth-cli to declare your candidacy some of GSYS to a validator Go to explorer to verify your transactions.","title":"How to become a Validator Candidate"},{"location":"smart-chain/validator/testnet.html#how-to-become-a-validator-candidate","text":"","title":"How to become a Validator Candidate"},{"location":"smart-chain/validator/testnet.html#install-fullnode","text":"Please follow this guide to install bsc fullnode locally.","title":"Install Fullnode"},{"location":"smart-chain/validator/testnet.html#create-an-account","text":"You need to create an account that represents a key pair first. Use the following command to create a new account and set a password for that account: geth account new --datadir ./node This command will return the public address and the path to your private key. BACKUP of keyfile is necessory! If you already have an account, use the seed phrase to recover it: geth account import --datadir ./node","title":"Create an account"},{"location":"smart-chain/validator/testnet.html#get-some-testnet-fund-from-faucet","text":"Go to this faucet page: https://testnet-explorer.genesys.network/faucet-smart","title":"Get some testnet fund from faucet"},{"location":"smart-chain/validator/testnet.html#transfer-gsys-from-gsys-to-bc","text":"Please refer to this guide to transfer GSYS with Genesys Chain extension wallet.","title":"Transfer GSYS from GSYS to BC"},{"location":"smart-chain/validator/testnet.html#become-a-validator-candidate","text":"You can use eth-cli to declare your candidacy some of GSYS to a validator Go to testnet explorer to verify your transactions.","title":"Become a validator candidate"},{"location":"smart-chain/validator/testnet.html#get-genesis-file-and-config-file","text":"wget --no-check-certificate $( curl -s https://api.github.com/repos/shree-chain/bsc/releases/latest | grep browser_ | grep testnet | cut -d \\\" -f4 ) unzip testnet.zip","title":"Get Genesis file and Config file"},{"location":"smart-chain/validator/testnet.html#start-fullnode-on-gsys-testnet","text":"Please run this command to run a fullnode as validator candidate geth --datadir node init genesis.json geth --config ./config.toml --datadir ./node --syncmode snap -unlock { validator-address } --mine --allow-insecure-unlock","title":"Start Fullnode on GSYS Testnet"},{"location":"smart-chain/validator/testnet.html#become-a-validator-candidate-of-testnet","text":"You can use eth-cli to declare your candidacy some of GSYS to a validator Go to explorer to verify your transactions.","title":"Become a validator candidate of testnet"},{"location":"smart-chain/wallet/AlphaWallet.html","text":"How to use AlphaWallet for Genesys Chain on your mobile Install 1. Get App from Andriod Play Store, iOS app Store, Andriod APK file or iOS TestFlight https://alphawallet.com/download-alphawallet-app/ Or you can make your own build from the open source code https://github.com/AlphaWallet 2. Open AlphaWallet on your mobile, backup Seed Phrase Setup Your Wallet for Genesys Chain 1. Click Setting tab, Select Active Network 2. Select GSYS. If you want to enable the testnet as well, select GSYS(test). Setup Your DApp browser for Genesys Chain 1. Click Browser tab, Click the Ethereum 2. In the browser active network page, select GSYS or GSYS(Test) It\u2019s ready, and now you can get some testnet GSYS from the faucet. Get Testnet Fund 1. Copy your address. 2. Go to https://testnet-explorer.genesys.network/faucet-smart/","title":"How to use AlphaWallet for Genesys Chain on your mobile"},{"location":"smart-chain/wallet/AlphaWallet.html#how-to-use-alphawallet-for-genesys-chain-on-your-mobile","text":"","title":"How to use AlphaWallet for Genesys Chain on your mobile"},{"location":"smart-chain/wallet/AlphaWallet.html#install","text":"","title":"Install"},{"location":"smart-chain/wallet/AlphaWallet.html#1-get-app-from-andriod-play-store-ios-app-store-andriod-apk-file-or-ios-testflight-httpsalphawalletcomdownload-alphawallet-app","text":"Or you can make your own build from the open source code https://github.com/AlphaWallet","title":"1. Get App from Andriod Play Store, iOS app Store, Andriod APK file or iOS TestFlight https://alphawallet.com/download-alphawallet-app/"},{"location":"smart-chain/wallet/AlphaWallet.html#2-open-alphawallet-on-your-mobile-backup-seed-phrase","text":"","title":"2. Open AlphaWallet on your mobile, backup Seed Phrase"},{"location":"smart-chain/wallet/AlphaWallet.html#setup-your-wallet-for-genesys-chain","text":"","title":"Setup Your Wallet for Genesys Chain"},{"location":"smart-chain/wallet/AlphaWallet.html#1-click-setting-tab-select-active-network","text":"","title":"1. Click Setting tab, Select Active Network"},{"location":"smart-chain/wallet/AlphaWallet.html#2-select-gsys-if-you-want-to-enable-the-testnet-as-well-select-gsystest","text":"","title":"2. Select GSYS. If you want to enable the testnet as well, select GSYS(test)."},{"location":"smart-chain/wallet/AlphaWallet.html#setup-your-dapp-browser-for-genesys-chain","text":"","title":"Setup Your DApp browser for Genesys Chain"},{"location":"smart-chain/wallet/AlphaWallet.html#1-click-browser-tab-click-the-ethereum","text":"","title":"1. Click Browser tab, Click the Ethereum"},{"location":"smart-chain/wallet/AlphaWallet.html#2-in-the-browser-active-network-page-select-gsys-or-gsystest","text":"It\u2019s ready, and now you can get some testnet GSYS from the faucet.","title":"2. In the browser active network page, select GSYS or GSYS(Test)"},{"location":"smart-chain/wallet/AlphaWallet.html#get-testnet-fund","text":"","title":"Get Testnet Fund"},{"location":"smart-chain/wallet/AlphaWallet.html#1-copy-your-address","text":"","title":"1. Copy your address."},{"location":"smart-chain/wallet/AlphaWallet.html#2-go-to-httpstestnet-explorergenesysnetworkfaucet-smart","text":"","title":"2. Go to https://testnet-explorer.genesys.network/faucet-smart/"},{"location":"smart-chain/wallet/arkane-developer.html","text":"Wallet provider for Dapps A wallet provider is a service that allows DApps to provide wallets to their end-users without having to deal with the security concerns of key management. It is a great way to make your Dapp ready to onboard a more mainstream audience. Arkane allows you to easily integrate your app with the Genesys Chain, whether you already have an Dapp integrated with web3 or are building a new application from scratch. Arkane provides a smooth and delightful experience for you, your users on both web and mobile. Arkane will help you interact with the Genesys Chain, create blockchain wallets, create different asset types such as fungible (BLUE20, ERC20), and non-fungible tokens - NFTs - (BLUE721, and ERC1155) and interact with smart contracts. Next to a superior developer experience, you can give your users a user-friendly interface. Each application is unique and has different needs, therefore they provide different ways of interacting with Arkane. Applications that have support for Web3 are recommendated to integrate the Arkane Web3 provider , others are suggested to use the Arkane Widget . Key features Support for Web and mobile applications Offers social logins Offers a fiat-on-ramp Only wallet that supports NFTs (BLUE721 and ERC1155) on Genesys Chain Multichain, supports both GSYS and Ethereum Easy to integrate using web3 Build for a mainstream audience Offers in-app customer support Provide a complete test environment Wallet creation via APIs Getting Started \ud83c\udf89 If you already support Web3-technology, you can improve the UX within your application by integrating the Arkane Web3 provider, a smart wrapper around the existing Web3 Ethereum JavaScript API. By making use of our Web3 provider you are able to leverage the full potential of Arkane with minimal effort and you will be able to onboard users that are less tech savvy without making them leave your application or download third party plugins. Integrating just takes 2 steps and 5 minutes Don't support Web3 yet? Don't worry we've got you covered with our \ud83d\udce6 Widget - Arkane Connect . Step 1: Add the library to your project Install the library by downloading it to your project via NPM npm i @arkane-network/web3-arkane-provider followed by adding the script to the head of your page. <script src=\"/node_modules/@arkane-network/web3-arkane-provider/dist/web3-arkane-provider.js\"></script> After adding the javascript file to your page, a global Arkane object is added to your window. This object is the gateway for creating the web3 wrapper and fully integrates the widget - Arkane Connect. Step 2: Initialize the web3 provider Add the following lines of code to your project, it will load the Arkane web3 provider. Arkane.createArkaneProviderEngine({clientId: \u2018Arketype\u2019}).then(provider => { web3 = new Web3(provider); }); The web3 instance now works as if it was injected by parity or metamask. You can fetch wallets, sign transactions, and messages. Congratulations, your dapp now supports Arkane \ud83c\udf89 \ud83e\uddd9 To connect to Arkanes production environment and mainnet, you will need to register your app and request your Client ID . Want to know more about the wonderful world Arkane has to offer, check out their documentation Receive GSYS and BLUE20 tokens Every GSYS wallet in Arkane is able to send and receive GSYS or BLUE20 tokens. They will automatically appear in your wallet. Resources: Genesys Chain partners with Arkane Arkane Developer Introduction Video (25min)","title":"Wallet Provider for DApps"},{"location":"smart-chain/wallet/arkane-developer.html#wallet-provider-for-dapps","text":"A wallet provider is a service that allows DApps to provide wallets to their end-users without having to deal with the security concerns of key management. It is a great way to make your Dapp ready to onboard a more mainstream audience. Arkane allows you to easily integrate your app with the Genesys Chain, whether you already have an Dapp integrated with web3 or are building a new application from scratch. Arkane provides a smooth and delightful experience for you, your users on both web and mobile. Arkane will help you interact with the Genesys Chain, create blockchain wallets, create different asset types such as fungible (BLUE20, ERC20), and non-fungible tokens - NFTs - (BLUE721, and ERC1155) and interact with smart contracts. Next to a superior developer experience, you can give your users a user-friendly interface. Each application is unique and has different needs, therefore they provide different ways of interacting with Arkane. Applications that have support for Web3 are recommendated to integrate the Arkane Web3 provider , others are suggested to use the Arkane Widget .","title":"Wallet provider for Dapps"},{"location":"smart-chain/wallet/arkane-developer.html#key-features","text":"Support for Web and mobile applications Offers social logins Offers a fiat-on-ramp Only wallet that supports NFTs (BLUE721 and ERC1155) on Genesys Chain Multichain, supports both GSYS and Ethereum Easy to integrate using web3 Build for a mainstream audience Offers in-app customer support Provide a complete test environment Wallet creation via APIs","title":"Key features"},{"location":"smart-chain/wallet/arkane-developer.html#getting-started","text":"If you already support Web3-technology, you can improve the UX within your application by integrating the Arkane Web3 provider, a smart wrapper around the existing Web3 Ethereum JavaScript API. By making use of our Web3 provider you are able to leverage the full potential of Arkane with minimal effort and you will be able to onboard users that are less tech savvy without making them leave your application or download third party plugins. Integrating just takes 2 steps and 5 minutes Don't support Web3 yet? Don't worry we've got you covered with our \ud83d\udce6 Widget - Arkane Connect .","title":"Getting Started \ud83c\udf89"},{"location":"smart-chain/wallet/arkane-developer.html#step-1-add-the-library-to-your-project","text":"Install the library by downloading it to your project via NPM npm i @arkane-network/web3-arkane-provider followed by adding the script to the head of your page. <script src=\"/node_modules/@arkane-network/web3-arkane-provider/dist/web3-arkane-provider.js\"></script> After adding the javascript file to your page, a global Arkane object is added to your window. This object is the gateway for creating the web3 wrapper and fully integrates the widget - Arkane Connect.","title":"Step 1: Add the library to your project"},{"location":"smart-chain/wallet/arkane-developer.html#step-2-initialize-the-web3-provider","text":"Add the following lines of code to your project, it will load the Arkane web3 provider. Arkane.createArkaneProviderEngine({clientId: \u2018Arketype\u2019}).then(provider => { web3 = new Web3(provider); }); The web3 instance now works as if it was injected by parity or metamask. You can fetch wallets, sign transactions, and messages.","title":"Step 2: Initialize the web3 provider"},{"location":"smart-chain/wallet/arkane-developer.html#congratulations-your-dapp-now-supports-arkane","text":"\ud83e\uddd9 To connect to Arkanes production environment and mainnet, you will need to register your app and request your Client ID . Want to know more about the wonderful world Arkane has to offer, check out their documentation","title":"Congratulations, your dapp now supports Arkane \ud83c\udf89"},{"location":"smart-chain/wallet/arkane-developer.html#receive-gsys-and-blue20-tokens","text":"Every GSYS wallet in Arkane is able to send and receive GSYS or BLUE20 tokens. They will automatically appear in your wallet.","title":"Receive GSYS and BLUE20 tokens"},{"location":"smart-chain/wallet/arkane-developer.html#resources","text":"Genesys Chain partners with Arkane Arkane Developer Introduction Video (25min)","title":"Resources:"},{"location":"smart-chain/wallet/arkane.html","text":"How to create a GSYS wallet in Arkane If you are looking for a user-friendly Genesys Chain wallet, consider creating an Arkane wallet. It allows you to enable recovery mechanism and comes with end-user support via their in-app chat, making sure you are never lost in the wonderful land of cryptocurrency. Key features Cloud wallet, offers support Web and mobile Register via social (Google, Facebook, Twitter) In app crypto purchases Support multiple blockchains Build for a mainstream audience In-app customer support Step 1. Sign up to Arkane Navigate to https://arkane.network and click the 'YOUR WALLET'-button in the top right corner. Click 'Create Account' if you are new to Arkane. You can sign up to Arkane with your social credentials or with email and password. After signing up with one of your social accounts (fastest) or with your email address and password. You will need to accept the terms and conditions. To secure your wallet you need to configure a PIN. You PIN should be between 4 and 6 digits. Your PIN will be used to approve future transactions. Step 2. Create your wallet Now that you've configured your PIN, you are ready to create a Genesys Chain wallet. Just select Genesys Chain from the list. To create a new wallet press 'Create new wallet' Once you've press the button, Arkane will ask you to confirm using your PIN (the one you configured a few steps before). After that your wallet will be created and you will be taken to your Dashboard. \ud83e\udd73 Congratulations! You have now created your Genesys Chain wallet to manage your digital assets on the Genesys Chain blockchain. Receive GSYS and BLUE20 tokens Every GSYS wallet in Arkane is able to send and receive GSYS or BLUE20 tokens. They will automatically appear in your wallet. Resources: Genesys Chain partners with Arkane Arkane Developer Introduction Video (25min) Use Arkane in your DApp","title":"How to create a GSYS wallet in Arkane"},{"location":"smart-chain/wallet/arkane.html#how-to-create-a-gsys-wallet-in-arkane","text":"If you are looking for a user-friendly Genesys Chain wallet, consider creating an Arkane wallet. It allows you to enable recovery mechanism and comes with end-user support via their in-app chat, making sure you are never lost in the wonderful land of cryptocurrency.","title":"How to create a GSYS wallet in Arkane"},{"location":"smart-chain/wallet/arkane.html#key-features","text":"Cloud wallet, offers support Web and mobile Register via social (Google, Facebook, Twitter) In app crypto purchases Support multiple blockchains Build for a mainstream audience In-app customer support","title":"Key features"},{"location":"smart-chain/wallet/arkane.html#step-1-sign-up-to-arkane","text":"Navigate to https://arkane.network and click the 'YOUR WALLET'-button in the top right corner. Click 'Create Account' if you are new to Arkane. You can sign up to Arkane with your social credentials or with email and password. After signing up with one of your social accounts (fastest) or with your email address and password. You will need to accept the terms and conditions. To secure your wallet you need to configure a PIN. You PIN should be between 4 and 6 digits. Your PIN will be used to approve future transactions.","title":"Step 1. Sign up to Arkane"},{"location":"smart-chain/wallet/arkane.html#step-2-create-your-wallet","text":"Now that you've configured your PIN, you are ready to create a Genesys Chain wallet. Just select Genesys Chain from the list. To create a new wallet press 'Create new wallet' Once you've press the button, Arkane will ask you to confirm using your PIN (the one you configured a few steps before). After that your wallet will be created and you will be taken to your Dashboard.","title":"Step 2. Create your wallet"},{"location":"smart-chain/wallet/arkane.html#congratulations","text":"You have now created your Genesys Chain wallet to manage your digital assets on the Genesys Chain blockchain.","title":"\ud83e\udd73 Congratulations!"},{"location":"smart-chain/wallet/arkane.html#receive-gsys-and-blue20-tokens","text":"Every GSYS wallet in Arkane is able to send and receive GSYS or BLUE20 tokens. They will automatically appear in your wallet.","title":"Receive GSYS and BLUE20 tokens"},{"location":"smart-chain/wallet/arkane.html#resources","text":"Genesys Chain partners with Arkane Arkane Developer Introduction Video (25min) Use Arkane in your DApp","title":"Resources:"},{"location":"smart-chain/wallet/binance-cn.html","text":"\u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305\u6307\u5357 \u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305\u662f\u4ec0\u4e48? \u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305\u652f\u6301\u5e01\u5b89\u94fe\u548c\u5e01\u5b89\u667a\u80fd\u94fe\u3002\u7528\u6237\u4e5f\u53ef\u4ee5\u5b8c\u6210\u8de8\u94fe\u8f6c\u8d26\u3002 \u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305\u5c06\u5f88\u5feb\u652f\u6301\u4ee5\u592a\u574a\u3002\u540c\u65f6\uff0c\u4e5f\u4f1a\u5f88\u5feb\u652f\u6301\u4e0eDapps\u7684\u4ea4\u4e92\u3002 \u706b\u72d0\u548cChrome\u6d4f\u89c8\u5668\u90fd\u4e0a\u67b6\u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305\u3002 Tip \u706b\u72d0\u6d4f\u89c8\u5668\u66f4\u65b0\u66f4\u5feb\u3002 \u5b89\u88c5 \u4ee5\u706b\u72d0\u6d4f\u89c8\u5668\u4e3a\u4f8b \u6253\u5f00\u706b\u72d0\u6d4f\u89c8\u5668\u5e02\u573a: https://addons.mozilla.org/en-US/firefox/addon/shree-chain/?src=search \u641c\u7d22\"Genesys Chain\" \u6ce8\u610f\u26a0\ufe0f: \u8bf7\u786e\u8ba4\u5f00\u53d1\u8005\u662fGenesys Chain \u70b9\u51fb \u201cAdd to Firefox\u201d \u5b8c\u6210! \u4f60\u5df2\u7ecf\u6210\u529f\u5728\u706b\u72d0\u6d4f\u89c8\u5668\u4e2d\u5b89\u88c5\u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305! \u5176\u4ed6\u6d4f\u89c8\u5668\u7684\u6d41\u7a0b\u7c7b\u4f3c\u3002 \u5728\u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305\u4e2d\u521b\u5efa\u65b0\u8d26\u6237 \u70b9\u51fb \u201cI do not own a wallet\u201d \u8f93\u5165\u5bc6\u7801 \u6ce8\u610f\u26a0\ufe0f\uff1a\u5fc5\u987b\u662f\u5f3a\u5bc6\u7801 \u70b9\u51fb \u201cContinue\u201d \u5907\u4efd\u52a9\u8bb0\u8bcd \u4f60\u5df2\u7ecf\u5b8c\u6210\u8d26\u6237\u521b\u5efa! \u901a\u8fc7\u52a9\u8bb0\u8bcd\u5bfc\u5165\u5df2\u6709\u8d26\u6237 \u6309\u7167\u4e0a\u8ff0\u6b65\u9aa4\u5b8c\u6210\u5b89\u88c5 \u70b9\u51fb \u201cI own a wallet\u201d \u8f93\u5165\u4f60\u7684\u52a9\u8bb0\u8bcd\u548c\u5bc6\u7801 \u70b9\u51fb \u201cGet started\u201d \u4f60\u5df2\u7ecf\u5b8c\u6210\u8d26\u6237\u6062\u590d! \u83b7\u5f97\u6d4b\u8bd5\u7f51GSYS \u6253\u5f00\u4ee5\u4e0b\u9875\u9762 https://testnet-explorer.genesys.network/faucet-smart/ \u6253\u5f00\u94b1\u5305\u540e\uff0c\u5207\u6362\u5230Genesys Chain Testnet \u590d\u5236\u5730\u5740 \u7c98\u8d34\u5230\u8f93\u5165\u6846\u5e76\u70b9\u51fb \u201cGive me GSYS\u201d \u70b9\u51fb \u201c+\u201d and \u6dfb\u52a0\u201cGSYS\u201d \u4ee3\u5e01 \u4ea4\u6613\u5b8c\u6210\u540e\uff0c\u4f60\u5f88\u5feb\u5c31\u80fd\u770b\u5230\u8d26\u6237\u4e0a\u7684GSYS GSYS\u4eceNC\u8f6c\u5230BC \u4ee5\u6d4b\u8bd5\u7f51\u4e3a\u4f8b\uff1a \u6253\u5f00\u94b1\u5305\u540e\uff0c\u5207\u6362\u5230Genesys Chain Testnet\u3002\u590d\u5236\u5730\u5740\uff0c\u4ee5 tbnb1 \u5f00\u5934 \u70b9\u51fb \u201c+\u201d and \u6dfb\u52a0\u201cGSYS\u201d \u4ee3\u5e01 \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u70b9\u51fb \u201cSend\u201d \u5728\u8f93\u5165\u5730\u5740\u548c\u548c\u91d1\u989d\u540e\uff0c\u70b9\u51fb\u201cSend\u201d \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u786e\u8ba4\u8f6c\u8d26\u5b8c\u6210 GSYS\u4eceBC\u8f6c\u5230NC \u6253\u5f00\u94b1\u5305\u540e\uff0c\u5207\u6362\u5230Genesys Chain Testnet\u3002\u590d\u5236\u5730\u5740\uff0c\u4ee5 0x \u5f00\u5934 \u70b9\u51fb \u201c+\u201d and \u6dfb\u52a0\u201cGSYS\u201d \u4ee3\u5e01 \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u70b9\u51fb \u201cSend\u201d \u5728\u8f93\u5165\u5730\u5740\u548c\u548c\u91d1\u989d\u540e\uff0c\u70b9\u51fb\u201cSend\u201d \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u786e\u8ba4\u8f6c\u8d26\u5b8c\u6210 \u5728\u6d4b\u8bd5\u7f51\u4e0a\u5b8c\u5c06BEP2\u4ee3\u5e01\u8f6c\u6362\u4e3aBLUE20\u683c\u5f0f \u6839\u636e\u4ee5\u4e0a\u6307\u4ee4\u5b8c\u6210\u5b89\u88c5 \u6839\u636e\u4ee5\u4e0a\u6307\u4ee4\u5b8c\u6210\u8d26\u6237\u7684\u521b\u5efa\u6216\u6062\u590d \u6253\u5f00\u94b1\u5305\u540e\uff0c\u5207\u6362\u5230Genesys Chain Testnet\u3002\u70b9\u51fb\u201c+\u201d \u6dfb\u52a0\u4f60\u7684BEP2\u4ee3\u5e01 \u786e\u8ba4GSYS\u4f59\u989d\u591f\u652f\u4ed8\u8de8\u94fe\u8f6c\u8d26\u8d39\u7528 \u5207\u6362\u5230Genesys Chain Testnet\u3002\u590d\u5236\u5730\u5740\uff0c\u4ee5 tbnb1 \u5f00\u5934 \u82e5\u9700\u8981\uff0c\u70b9\u51fb\u201c+\u201d \u6dfb\u52a0\u4f60\u7684BLUE20\u4ee3\u5e01 \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u70b9\u51fb \u201cSend\u201d \u5728\u8f93\u5165\u5730\u5740\u548c\u548c\u91d1\u989d\u540e\uff0c\u70b9\u51fb\u201cSend\u201d\u5e76\u786e\u8ba4 \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u786e\u8ba4\u6536\u5230BLUE20\u4ee3\u5e01 \u5728\u6d4b\u8bd5\u7f51\u4e0a\u5b8c\u5c06BLUE20\u4ee3\u5e01\u8f6c\u6362\u4e3aBEP2\u683c\u5f0f \u6839\u636e\u4ee5\u4e0a\u6307\u4ee4\u5b8c\u6210\u5b89\u88c5 \u6839\u636e\u4ee5\u4e0a\u6307\u4ee4\u5b8c\u6210\u8d26\u6237\u7684\u521b\u5efa\u6216\u6062\u590d \u6253\u5f00\u94b1\u5305\u540e\uff0c\u5207\u6362\u5230Genesys Chain Testnet\u3002\u70b9\u51fb\u201c+\u201d \u6dfb\u52a0\u4f60\u7684BLUE20\u4ee3\u5e01 \u786e\u8ba4GSYS\u4f59\u989d\u591f\u652f\u4ed8\u8de8\u94fe\u8f6c\u8d26\u8d39\u7528 \u5207\u6362\u5230Genesys Chain Testnet\u3002\u590d\u5236\u5730\u5740\uff0c\u4ee5 tbnb1 \u5f00\u5934 \u6ce8\u610f\u26a0\ufe0f\uff1a\u4e3b\u7f51\u5730\u5740\u4ee5 bnb1 \u5f00\u5934 \u82e5\u9700\u8981\uff0c\u70b9\u51fb\u201c+\u201d \u6dfb\u52a0\u4f60\u7684BEP2\u4ee3\u5e01 \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u70b9\u51fb \u201cSend\u201d \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u786e\u8ba4\u6536\u5230BEP2\u4ee3\u5e01","title":"\u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305\u6307\u5357"},{"location":"smart-chain/wallet/binance-cn.html#_1","text":"","title":"\u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305\u6307\u5357"},{"location":"smart-chain/wallet/binance-cn.html#_2","text":"\u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305\u652f\u6301\u5e01\u5b89\u94fe\u548c\u5e01\u5b89\u667a\u80fd\u94fe\u3002\u7528\u6237\u4e5f\u53ef\u4ee5\u5b8c\u6210\u8de8\u94fe\u8f6c\u8d26\u3002 \u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305\u5c06\u5f88\u5feb\u652f\u6301\u4ee5\u592a\u574a\u3002\u540c\u65f6\uff0c\u4e5f\u4f1a\u5f88\u5feb\u652f\u6301\u4e0eDapps\u7684\u4ea4\u4e92\u3002 \u706b\u72d0\u548cChrome\u6d4f\u89c8\u5668\u90fd\u4e0a\u67b6\u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305\u3002 Tip \u706b\u72d0\u6d4f\u89c8\u5668\u66f4\u65b0\u66f4\u5feb\u3002","title":"\u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305\u662f\u4ec0\u4e48?"},{"location":"smart-chain/wallet/binance-cn.html#_3","text":"\u4ee5\u706b\u72d0\u6d4f\u89c8\u5668\u4e3a\u4f8b \u6253\u5f00\u706b\u72d0\u6d4f\u89c8\u5668\u5e02\u573a: https://addons.mozilla.org/en-US/firefox/addon/shree-chain/?src=search \u641c\u7d22\"Genesys Chain\" \u6ce8\u610f\u26a0\ufe0f: \u8bf7\u786e\u8ba4\u5f00\u53d1\u8005\u662fGenesys Chain \u70b9\u51fb \u201cAdd to Firefox\u201d \u5b8c\u6210! \u4f60\u5df2\u7ecf\u6210\u529f\u5728\u706b\u72d0\u6d4f\u89c8\u5668\u4e2d\u5b89\u88c5\u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305! \u5176\u4ed6\u6d4f\u89c8\u5668\u7684\u6d41\u7a0b\u7c7b\u4f3c\u3002","title":"\u5b89\u88c5"},{"location":"smart-chain/wallet/binance-cn.html#_4","text":"\u70b9\u51fb \u201cI do not own a wallet\u201d \u8f93\u5165\u5bc6\u7801 \u6ce8\u610f\u26a0\ufe0f\uff1a\u5fc5\u987b\u662f\u5f3a\u5bc6\u7801 \u70b9\u51fb \u201cContinue\u201d \u5907\u4efd\u52a9\u8bb0\u8bcd \u4f60\u5df2\u7ecf\u5b8c\u6210\u8d26\u6237\u521b\u5efa!","title":"\u5728\u5e01\u5b89\u94fe\u63d2\u4ef6\u94b1\u5305\u4e2d\u521b\u5efa\u65b0\u8d26\u6237"},{"location":"smart-chain/wallet/binance-cn.html#_5","text":"\u6309\u7167\u4e0a\u8ff0\u6b65\u9aa4\u5b8c\u6210\u5b89\u88c5 \u70b9\u51fb \u201cI own a wallet\u201d \u8f93\u5165\u4f60\u7684\u52a9\u8bb0\u8bcd\u548c\u5bc6\u7801 \u70b9\u51fb \u201cGet started\u201d \u4f60\u5df2\u7ecf\u5b8c\u6210\u8d26\u6237\u6062\u590d!","title":"\u901a\u8fc7\u52a9\u8bb0\u8bcd\u5bfc\u5165\u5df2\u6709\u8d26\u6237"},{"location":"smart-chain/wallet/binance-cn.html#gsys","text":"\u6253\u5f00\u4ee5\u4e0b\u9875\u9762 https://testnet-explorer.genesys.network/faucet-smart/ \u6253\u5f00\u94b1\u5305\u540e\uff0c\u5207\u6362\u5230Genesys Chain Testnet \u590d\u5236\u5730\u5740 \u7c98\u8d34\u5230\u8f93\u5165\u6846\u5e76\u70b9\u51fb \u201cGive me GSYS\u201d \u70b9\u51fb \u201c+\u201d and \u6dfb\u52a0\u201cGSYS\u201d \u4ee3\u5e01 \u4ea4\u6613\u5b8c\u6210\u540e\uff0c\u4f60\u5f88\u5feb\u5c31\u80fd\u770b\u5230\u8d26\u6237\u4e0a\u7684GSYS","title":"\u83b7\u5f97\u6d4b\u8bd5\u7f51GSYS"},{"location":"smart-chain/wallet/binance-cn.html#gsysncbc","text":"\u4ee5\u6d4b\u8bd5\u7f51\u4e3a\u4f8b\uff1a \u6253\u5f00\u94b1\u5305\u540e\uff0c\u5207\u6362\u5230Genesys Chain Testnet\u3002\u590d\u5236\u5730\u5740\uff0c\u4ee5 tbnb1 \u5f00\u5934 \u70b9\u51fb \u201c+\u201d and \u6dfb\u52a0\u201cGSYS\u201d \u4ee3\u5e01 \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u70b9\u51fb \u201cSend\u201d \u5728\u8f93\u5165\u5730\u5740\u548c\u548c\u91d1\u989d\u540e\uff0c\u70b9\u51fb\u201cSend\u201d \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u786e\u8ba4\u8f6c\u8d26\u5b8c\u6210","title":"GSYS\u4eceNC\u8f6c\u5230BC"},{"location":"smart-chain/wallet/binance-cn.html#gsysbcnc","text":"\u6253\u5f00\u94b1\u5305\u540e\uff0c\u5207\u6362\u5230Genesys Chain Testnet\u3002\u590d\u5236\u5730\u5740\uff0c\u4ee5 0x \u5f00\u5934 \u70b9\u51fb \u201c+\u201d and \u6dfb\u52a0\u201cGSYS\u201d \u4ee3\u5e01 \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u70b9\u51fb \u201cSend\u201d \u5728\u8f93\u5165\u5730\u5740\u548c\u548c\u91d1\u989d\u540e\uff0c\u70b9\u51fb\u201cSend\u201d \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u786e\u8ba4\u8f6c\u8d26\u5b8c\u6210","title":"GSYS\u4eceBC\u8f6c\u5230NC"},{"location":"smart-chain/wallet/binance-cn.html#bep2blue20","text":"\u6839\u636e\u4ee5\u4e0a\u6307\u4ee4\u5b8c\u6210\u5b89\u88c5 \u6839\u636e\u4ee5\u4e0a\u6307\u4ee4\u5b8c\u6210\u8d26\u6237\u7684\u521b\u5efa\u6216\u6062\u590d \u6253\u5f00\u94b1\u5305\u540e\uff0c\u5207\u6362\u5230Genesys Chain Testnet\u3002\u70b9\u51fb\u201c+\u201d \u6dfb\u52a0\u4f60\u7684BEP2\u4ee3\u5e01 \u786e\u8ba4GSYS\u4f59\u989d\u591f\u652f\u4ed8\u8de8\u94fe\u8f6c\u8d26\u8d39\u7528 \u5207\u6362\u5230Genesys Chain Testnet\u3002\u590d\u5236\u5730\u5740\uff0c\u4ee5 tbnb1 \u5f00\u5934 \u82e5\u9700\u8981\uff0c\u70b9\u51fb\u201c+\u201d \u6dfb\u52a0\u4f60\u7684BLUE20\u4ee3\u5e01 \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u70b9\u51fb \u201cSend\u201d \u5728\u8f93\u5165\u5730\u5740\u548c\u548c\u91d1\u989d\u540e\uff0c\u70b9\u51fb\u201cSend\u201d\u5e76\u786e\u8ba4 \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u786e\u8ba4\u6536\u5230BLUE20\u4ee3\u5e01","title":"\u5728\u6d4b\u8bd5\u7f51\u4e0a\u5b8c\u5c06BEP2\u4ee3\u5e01\u8f6c\u6362\u4e3aBLUE20\u683c\u5f0f"},{"location":"smart-chain/wallet/binance-cn.html#blue20bep2","text":"\u6839\u636e\u4ee5\u4e0a\u6307\u4ee4\u5b8c\u6210\u5b89\u88c5 \u6839\u636e\u4ee5\u4e0a\u6307\u4ee4\u5b8c\u6210\u8d26\u6237\u7684\u521b\u5efa\u6216\u6062\u590d \u6253\u5f00\u94b1\u5305\u540e\uff0c\u5207\u6362\u5230Genesys Chain Testnet\u3002\u70b9\u51fb\u201c+\u201d \u6dfb\u52a0\u4f60\u7684BLUE20\u4ee3\u5e01 \u786e\u8ba4GSYS\u4f59\u989d\u591f\u652f\u4ed8\u8de8\u94fe\u8f6c\u8d26\u8d39\u7528 \u5207\u6362\u5230Genesys Chain Testnet\u3002\u590d\u5236\u5730\u5740\uff0c\u4ee5 tbnb1 \u5f00\u5934 \u6ce8\u610f\u26a0\ufe0f\uff1a\u4e3b\u7f51\u5730\u5740\u4ee5 bnb1 \u5f00\u5934 \u82e5\u9700\u8981\uff0c\u70b9\u51fb\u201c+\u201d \u6dfb\u52a0\u4f60\u7684BEP2\u4ee3\u5e01 \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u70b9\u51fb \u201cSend\u201d \u5207\u6362\u5230Genesys Chain Testnet\uff0c\u786e\u8ba4\u6536\u5230BEP2\u4ee3\u5e01","title":"\u5728\u6d4b\u8bd5\u7f51\u4e0a\u5b8c\u5c06BLUE20\u4ee3\u5e01\u8f6c\u6362\u4e3aBEP2\u683c\u5f0f"},{"location":"smart-chain/wallet/binance.html","text":"Use Genesys Chain Extension Wallet What is it? Genesys Chain Extension Wallet is a Crypto Wallet for Genesys Chain, Genesys Chain. You can send and receive funds on Genesys Chain, Genesys Chain and cross-chain transfers between both of GSYS\u2019s blockchains. In the future, Genesys Chain Extension Wallet will add support for Ethereum blockchain and enable access for distributed applications, or \"Dapps\" in your browser! It\u2019s supported in Firefox and Chrome browsers. Tip Firefox users are more likely to access the latest version timely Download Link Chrome App Store Link: https://chrome.google.com/webstore/detail/shree-chain-wallet/fhbohimaelbohpjbbldcngcnapndodjp Firefox App Store Link: https://addons.mozilla.org/en-US/firefox/addon/shree-chain/?src=search How to manually install the Genesys Chain Extension Wallet Install Example: Install Genesys Chain Wallet in Firefox browser Open Extension in Firefox: https://addons.mozilla.org/en-US/firefox/addon/shree-chain/?src=search Search for Genesys Chain Note: Make sure it\u2019s offered by Genesys Chain Click on \u201cAdd to Firefox\u201d That\u2019s it! You have successfully installed the Genesys Chain Wallet extension in Firefox! The workflow is the same for all browsers Create an account in extension wallet for Genesys Chain Click on \u201cI do not own a wallet\u201d Choose your own Password Note: it has to be a strong password Click on \u201cContinue\u201d Backup your recovery phrase Congratulations! you have created your account! Recover your account with Mnemonic Phrase Install Genesys Chain extension by following the previous steps firstClick on \u201cI own a wallet\u201d Type your recovery phrase and choose a strong password Click on \u201cGet started\u201d Now you are all set! Get Testnet GSYS from Faucet Go to https://testnet-explorer.genesys.network/faucet-smart/ Switch to Genesys Chain Testnet after unlock your extension wallet Copy your address Paste your address in the box and click on \u201cGive me GSYS\u201d Click on the \u201c+\u201d and add \u201cGSYS\u201d token After the transfer transaction is sent, you will see an increase in your balance Transfer Testnet GSYS from GSYS to BC Switch to Genesys Chain testnet and copy your address after unlock your extension wallet, start with tbnb1 Click on the \u201c+\u201d and add \u201cGSYS\u201d token Switch to Genesys Chain testnet and click on \u201cSend\u201d Click on \u201cSend\u201d when you have filled in other information. You have to confirm it too Switch back to Genesys Chain Testnet to confirm this cross-chain transfer Transfer Testnet GSYS from BC to TC Switch to Genesys Chain testnet after unlock your extension wallet and copy your address, start with 0x Click on the \u201c+\u201d and add \u201cGSYS\u201d token Switch to Genesys Chain testnet and click on \u201cSend\u201d Click on \u201cSend\u201d when you have filled in other information. You have to confirm it too Switch back to Genesys Chain Testnet to confirm this cross-chain transfer Swap Testnet BEP2 token to its BLUE20 equivalent Follow the instructions above to Install Genesys Chain extension wallet if not ready Follow the instructions above to create or Recover your account Switch to Genesys Chain testnet after unlock your extension wallet and Click at \u201c+\u201d to add your BEP2 token if necessary Verify your balance has enough GSYS to pay transfer fee Switch to Genesys Chain testnet and copy your address, start with 0x Click at \u201c+\u201d to add your BLUE20 token if necessary Switch to Genesys Chain testnet and click on \u201cSend\u201d Click on \u201cSend\u201d when you have filled in other information. You have to confirm it too Switch to Genesys Chain testnet, you should see your BLUE20 token balance change Swap Testnet BLUE20 token to its BEP2 equivalent Follow the instructions above to Install Genesys Chain extension wallet if not ready Follow the instructions above to create or Recover your account Switch to Genesys Chain testnet and Click at \u201c+\u201d to add your BLUE20 token if necessary Verify your balance has enough GSYS to pay transfer fee Switch to Genesys Chain testnet and copy your address, start with tbnb1 Note: for mainnet, the address starts with bnb1 Click at \u201c+\u201d to add your BEP2 token if necessary Switch to Genesys Chain testnet and click on \u201cSend\u201d Confirm your transaction and verify your balance change","title":"Use Genesys Chain Extension Wallet"},{"location":"smart-chain/wallet/binance.html#use-genesys-chain-extension-wallet","text":"","title":"Use Genesys Chain Extension Wallet"},{"location":"smart-chain/wallet/binance.html#what-is-it","text":"Genesys Chain Extension Wallet is a Crypto Wallet for Genesys Chain, Genesys Chain. You can send and receive funds on Genesys Chain, Genesys Chain and cross-chain transfers between both of GSYS\u2019s blockchains. In the future, Genesys Chain Extension Wallet will add support for Ethereum blockchain and enable access for distributed applications, or \"Dapps\" in your browser! It\u2019s supported in Firefox and Chrome browsers. Tip Firefox users are more likely to access the latest version timely","title":"What is it?"},{"location":"smart-chain/wallet/binance.html#download-link","text":"Chrome App Store Link: https://chrome.google.com/webstore/detail/shree-chain-wallet/fhbohimaelbohpjbbldcngcnapndodjp Firefox App Store Link: https://addons.mozilla.org/en-US/firefox/addon/shree-chain/?src=search How to manually install the Genesys Chain Extension Wallet","title":"Download Link"},{"location":"smart-chain/wallet/binance.html#install","text":"Example: Install Genesys Chain Wallet in Firefox browser Open Extension in Firefox: https://addons.mozilla.org/en-US/firefox/addon/shree-chain/?src=search Search for Genesys Chain Note: Make sure it\u2019s offered by Genesys Chain Click on \u201cAdd to Firefox\u201d That\u2019s it! You have successfully installed the Genesys Chain Wallet extension in Firefox! The workflow is the same for all browsers","title":"Install"},{"location":"smart-chain/wallet/binance.html#create-an-account-in-extension-wallet-for-genesys-chain","text":"Click on \u201cI do not own a wallet\u201d Choose your own Password Note: it has to be a strong password Click on \u201cContinue\u201d Backup your recovery phrase Congratulations! you have created your account!","title":"Create an account in extension wallet for Genesys Chain"},{"location":"smart-chain/wallet/binance.html#recover-your-account-with-mnemonic-phrase","text":"Install Genesys Chain extension by following the previous steps firstClick on \u201cI own a wallet\u201d Type your recovery phrase and choose a strong password Click on \u201cGet started\u201d Now you are all set!","title":"Recover your account with Mnemonic Phrase"},{"location":"smart-chain/wallet/binance.html#get-testnet-gsys-from-faucet","text":"Go to https://testnet-explorer.genesys.network/faucet-smart/ Switch to Genesys Chain Testnet after unlock your extension wallet Copy your address Paste your address in the box and click on \u201cGive me GSYS\u201d Click on the \u201c+\u201d and add \u201cGSYS\u201d token After the transfer transaction is sent, you will see an increase in your balance","title":"Get Testnet GSYS from Faucet"},{"location":"smart-chain/wallet/binance.html#transfer-testnet-gsys-from-gsys-to-bc","text":"Switch to Genesys Chain testnet and copy your address after unlock your extension wallet, start with tbnb1 Click on the \u201c+\u201d and add \u201cGSYS\u201d token Switch to Genesys Chain testnet and click on \u201cSend\u201d Click on \u201cSend\u201d when you have filled in other information. You have to confirm it too Switch back to Genesys Chain Testnet to confirm this cross-chain transfer","title":"Transfer Testnet GSYS from GSYS to BC"},{"location":"smart-chain/wallet/binance.html#transfer-testnet-gsys-from-bc-to-tc","text":"Switch to Genesys Chain testnet after unlock your extension wallet and copy your address, start with 0x Click on the \u201c+\u201d and add \u201cGSYS\u201d token Switch to Genesys Chain testnet and click on \u201cSend\u201d Click on \u201cSend\u201d when you have filled in other information. You have to confirm it too Switch back to Genesys Chain Testnet to confirm this cross-chain transfer","title":"Transfer Testnet GSYS from BC to TC"},{"location":"smart-chain/wallet/binance.html#swap-testnet-bep2-token-to-its-blue20-equivalent","text":"Follow the instructions above to Install Genesys Chain extension wallet if not ready Follow the instructions above to create or Recover your account Switch to Genesys Chain testnet after unlock your extension wallet and Click at \u201c+\u201d to add your BEP2 token if necessary Verify your balance has enough GSYS to pay transfer fee Switch to Genesys Chain testnet and copy your address, start with 0x Click at \u201c+\u201d to add your BLUE20 token if necessary Switch to Genesys Chain testnet and click on \u201cSend\u201d Click on \u201cSend\u201d when you have filled in other information. You have to confirm it too Switch to Genesys Chain testnet, you should see your BLUE20 token balance change","title":"Swap Testnet BEP2 token to its BLUE20 equivalent"},{"location":"smart-chain/wallet/binance.html#swap-testnet-blue20-token-to-its-bep2-equivalent","text":"Follow the instructions above to Install Genesys Chain extension wallet if not ready Follow the instructions above to create or Recover your account Switch to Genesys Chain testnet and Click at \u201c+\u201d to add your BLUE20 token if necessary Verify your balance has enough GSYS to pay transfer fee Switch to Genesys Chain testnet and copy your address, start with tbnb1 Note: for mainnet, the address starts with bnb1 Click at \u201c+\u201d to add your BEP2 token if necessary Switch to Genesys Chain testnet and click on \u201cSend\u201d Confirm your transaction and verify your balance change","title":"Swap Testnet BLUE20 token to its BEP2 equivalent"},{"location":"smart-chain/wallet/ezdefi.html","text":"How to use ezDeFi for Genesys Chain Install ezDeFi Go to http://ezdefi.com to install the most recent version of ezDeFi. Download ezDeFi Mobile App wallet on Apple Appstore or the Google PlayStore and ezDeFi Browser Extension on Chrome Webstore Launch the mobile app (or browser extension) in order to start a new wallet. Get ready by completing the initial setup. Getting the Genesys Chain On mobile app, go to \"Setting\" => \"Advanced Setting\" => \"Custom RPC Network\" to see default Genesys Chain . On browser extension, go to \"Setting\" => \"Network\" to see default Genesys Chain Add GSYS token in your wallet On mobile app, tap on the \"Add more\", search for \"Smart Chain\", tap on the \"+\" button and create new address of GSYS token On browser extension, click on \"More Assets\", search for \"Smart Chain\", select GSYS token Back to mains creen to see GSYS token already added on mobile app (or browser extension) Add a address of GSYS token You can add new addrew address by create new, add Existed Address or import of the other wallet Create New, or add Existed address of the other token Import from Private key, from Phrase recovery (or Mnemonic phrase), or from Read only address (or account) Sending GSYS token On mobile app On browser extension Access Genesys Chain DApps ezDeFi Wallet is fully compatible with Genesys Chain DApps. On mobile app On browser extension ezDeFi at a glance ezDeFi \u201cGlobal Payment Ecosystem Based On Blockchain\u201d has 4 key products: Public blockchain, Mobile app wallet, Browser Extension wallet, and Payment gateway. ezDeFi wallet has 2 versions: mobile application and browser extension with features of multi-chain, multi-address, cloud backup, and app-extension sync. ezDeFi Payment Gateway supports merchants with a wide range of blockchains and e-commerce platforms namely: WHMCS, woo-commerce, EDD, and more with a low transaction fee, no-chargeback, and multiple cryptocurrency integration. In 2019, ezDeFi has acquired 523 clients using Payment Gateway, 2000+ downloads for wallets of both mobile app and browesr extension","title":"How to use ezDeFi for Genesys Chain"},{"location":"smart-chain/wallet/ezdefi.html#how-to-use-ezdefi-for-genesys-chain","text":"","title":"How to use ezDeFi for Genesys Chain"},{"location":"smart-chain/wallet/ezdefi.html#install-ezdefi","text":"","title":"Install ezDeFi"},{"location":"smart-chain/wallet/ezdefi.html#go-to-httpezdeficom-to-install-the-most-recent-version-of-ezdefi","text":"Download ezDeFi Mobile App wallet on Apple Appstore or the Google PlayStore and ezDeFi Browser Extension on Chrome Webstore","title":"Go to http://ezdefi.com to install the most recent version of ezDeFi."},{"location":"smart-chain/wallet/ezdefi.html#launch-the-mobile-app-or-browser-extension-in-order-to-start-a-new-wallet","text":"","title":"Launch the mobile app (or browser extension) in order to start a new wallet."},{"location":"smart-chain/wallet/ezdefi.html#get-ready-by-completing-the-initial-setup","text":"","title":"Get ready by completing the initial setup."},{"location":"smart-chain/wallet/ezdefi.html#getting-the-genesys-chain","text":"","title":"Getting the Genesys Chain"},{"location":"smart-chain/wallet/ezdefi.html#on-mobile-app-go-to-setting-advanced-setting-custom-rpc-network-to-see-default-genesys-chain-on-browser-extension-go-to-setting-network-to-see-default-genesys-chain","text":"","title":"On mobile app, go to \"Setting\" =&gt; \"Advanced Setting\" =&gt; \"Custom RPC Network\" to see default Genesys Chain . On browser extension, go to \"Setting\" =&gt; \"Network\" to see default Genesys Chain"},{"location":"smart-chain/wallet/ezdefi.html#add-gsys-token-in-your-wallet","text":"","title":"Add GSYS token in your wallet"},{"location":"smart-chain/wallet/ezdefi.html#on-mobile-app-tap-on-the-add-more-search-for-smart-chain-tap-on-the-button-and-create-new-address-of-gsys-token","text":"","title":"On mobile app, tap on the \"Add more\", search for \"Smart Chain\", tap on the \"+\" button and create new address of GSYS token"},{"location":"smart-chain/wallet/ezdefi.html#on-browser-extension-click-on-more-assets-search-for-smart-chain-select-gsys-token","text":"","title":"On browser extension, click on \"More Assets\", search for \"Smart Chain\", select GSYS token"},{"location":"smart-chain/wallet/ezdefi.html#back-to-mains-creen-to-see-gsys-token-already-added-on-mobile-app-or-browser-extension","text":"","title":"Back to mains creen to see GSYS token already added on mobile app (or browser extension)"},{"location":"smart-chain/wallet/ezdefi.html#add-a-address-of-gsys-token","text":"","title":"Add a address of GSYS token"},{"location":"smart-chain/wallet/ezdefi.html#you-can-add-new-addrew-address-by-create-new-add-existed-address-or-import-of-the-other-wallet","text":"","title":"You can add new addrew address by create new, add Existed Address or import of the other wallet"},{"location":"smart-chain/wallet/ezdefi.html#create-new-or-add-existed-address-of-the-other-token","text":"","title":"Create New, or add Existed address of the other token"},{"location":"smart-chain/wallet/ezdefi.html#import-from-private-key-from-phrase-recovery-or-mnemonic-phrase-or-from-read-only-address-or-account","text":"","title":"Import from Private key, from Phrase recovery (or Mnemonic phrase), or from Read only address (or account)"},{"location":"smart-chain/wallet/ezdefi.html#sending-gsys-token","text":"","title":"Sending GSYS token"},{"location":"smart-chain/wallet/ezdefi.html#on-mobile-app","text":"","title":"On mobile app"},{"location":"smart-chain/wallet/ezdefi.html#on-browser-extension","text":"","title":"On browser extension"},{"location":"smart-chain/wallet/ezdefi.html#access-genesys-chain-dapps","text":"","title":"Access Genesys Chain DApps"},{"location":"smart-chain/wallet/ezdefi.html#ezdefi-wallet-is-fully-compatible-with-genesys-chain-dapps","text":"","title":"ezDeFi Wallet is fully compatible with Genesys Chain DApps."},{"location":"smart-chain/wallet/ezdefi.html#on-mobile-app_1","text":"","title":"On mobile app"},{"location":"smart-chain/wallet/ezdefi.html#on-browser-extension_1","text":"","title":"On browser extension"},{"location":"smart-chain/wallet/ezdefi.html#ezdefi-at-a-glance","text":"ezDeFi \u201cGlobal Payment Ecosystem Based On Blockchain\u201d has 4 key products: Public blockchain, Mobile app wallet, Browser Extension wallet, and Payment gateway. ezDeFi wallet has 2 versions: mobile application and browser extension with features of multi-chain, multi-address, cloud backup, and app-extension sync. ezDeFi Payment Gateway supports merchants with a wide range of blockchains and e-commerce platforms namely: WHMCS, woo-commerce, EDD, and more with a low transaction fee, no-chargeback, and multiple cryptocurrency integration. In 2019, ezDeFi has acquired 523 clients using Payment Gateway, 2000+ downloads for wallets of both mobile app and browesr extension","title":"ezDeFi at a glance"},{"location":"smart-chain/wallet/faq.html","text":"GSYS Extension Wallet FAQ Tokens not visible after withdrawing from GSYS Many users who interact with a centralized exchange like GSYS eventually want to withdraw to a wallet that they fully control, like MetaMask. So once you've used their withdraw form, what could be scarier than not seeing your tokens? First, you'll need to use the MetaMask add Custom Network feature to add the Genesys Chain or Genesys Chain's RPC URLs endpoints to your MetaMask. Once you've added the Genesys Chain or the Genesys Chain to your MetaMask, you will be able to select different networks to view the assets (you may need to add Custom Tokens too) held by your selected account on that network. How Much GSYS You Need To Send Tokens if you try to send tokens without having any GSYS in your account you will be told you have insufficient funds. This means you do not have enough GSYS in your account to cover the cost of gas. Each transaction (including token and contract transactions) require gas and that gas is paid in GSYS. You can think of this like a transaction fee. You can remedy this by sending 0.001 GSYS to that account in order to be able to make the transaction. A standard Ether transfer TX will be 21000 gas & a gas price of 15 Gwei. With tokens, the amount of gas is typically gas, so the total TX fee increases to 0.002 GSYS - 0.003 GSYS. Current Gas Price curl --location --request POST 'https://nc-dataseed2.genesys.network' \\ --header 'Content-Type: application/json' \\ --data-raw '{\"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"eth_gasPrice\", \"params\": []}'","title":"GSYS Extension Wallet FAQ"},{"location":"smart-chain/wallet/faq.html#gsys-extension-wallet-faq","text":"","title":"GSYS Extension Wallet FAQ"},{"location":"smart-chain/wallet/faq.html#tokens-not-visible-after-withdrawing-from-gsys","text":"Many users who interact with a centralized exchange like GSYS eventually want to withdraw to a wallet that they fully control, like MetaMask. So once you've used their withdraw form, what could be scarier than not seeing your tokens? First, you'll need to use the MetaMask add Custom Network feature to add the Genesys Chain or Genesys Chain's RPC URLs endpoints to your MetaMask. Once you've added the Genesys Chain or the Genesys Chain to your MetaMask, you will be able to select different networks to view the assets (you may need to add Custom Tokens too) held by your selected account on that network.","title":"Tokens not visible after withdrawing from GSYS"},{"location":"smart-chain/wallet/faq.html#how-much-gsys-you-need-to-send-tokens","text":"if you try to send tokens without having any GSYS in your account you will be told you have insufficient funds. This means you do not have enough GSYS in your account to cover the cost of gas. Each transaction (including token and contract transactions) require gas and that gas is paid in GSYS. You can think of this like a transaction fee. You can remedy this by sending 0.001 GSYS to that account in order to be able to make the transaction. A standard Ether transfer TX will be 21000 gas & a gas price of 15 Gwei. With tokens, the amount of gas is typically gas, so the total TX fee increases to 0.002 GSYS - 0.003 GSYS.","title":"How Much GSYS You Need To Send Tokens"},{"location":"smart-chain/wallet/faq.html#current-gas-price","text":"curl --location --request POST 'https://nc-dataseed2.genesys.network' \\ --header 'Content-Type: application/json' \\ --data-raw '{\"jsonrpc\":\"2.0\", \"id\":1, \"method\":\"eth_gasPrice\", \"params\": []}'","title":"Current Gas Price"},{"location":"smart-chain/wallet/infinitywallet.html","text":"Using Infinity Wallet on the Genesys Chain What is it? Infinity Wallet is the ultimate easy to use, secure, multicurrency, practical and convenient self-custodial cryptocurrency wallet, that provides all a user will ever need in one platform. With a wide range of new and innovative features to access digital assets, empowering financial freedom. Advancing the world of decentralized finance with an all-in-one digital wallet experience and streamlining adoption of cryptocurrency. Infinity Wallet is packed with a wealth of features and designed for the best possible user experience. With a simple and modular interface allowing to interact, monitor, trade, transact, view news and much more in a secure environment, as the one-stop application that a user will ever need for decentralized finance. Connect to DeFi protocols and Dapps directly on desktop or mobile from within the Infinity Wallet, to securely use decentralized platforms without compromising your assets. Providing enhanced ease of use and security, as well as support for multiple chains. Download Link Downloads: https://infinitywallet.io/download GSYS Page: https://infinitywallet.io/asset/shree Install Infinity Wallet Go to https://infinitywallet.io to install the most recent version of the Infinity Wallet. The Infinity Wallet is currently available to be downloaded for desktop devices on Windows , macOS and Linux . In the coming months there will be a mobile wallet released to accompany our revolutionary desktop wallet. Launch the Infinity Wallet to create your local account and wallet Create a local account, you can name this anything as the account name is only used locally within your own device Create a password for your local account and confirm your password Select to either create a new wallet or recover an existing wallet (You can import your 12 or 24 word seed phrase from most other wallets into the Infinity Wallet as we follow the standard) Give your wallet a name so you can easily identify it within your local account If you would like to have additional security, you can create an individual pin for each of your wallets (This is optional) Select if you want to use a 12 or 24 word seed You will now need to confirm that you understand that you have to backup your 12 or 24 word seed to be able to recover your wallet. We recommend keeping your seed phrase offline and somewhere secure (Never share your seed with anyone, including the Infinity Wallet support team) Make a backup of the words on the screen, we recommend making a paper backup and not an online backup. If you ever lose access to your computer or forget your password, you will need your 12 or 24 word seed to recover your wallet (Keep these words secure and never share them with anyone, as these words grant full access to your wallet) Confirm a selection of the words in the correct order as requested, to generate your wallet Congratulations you have successfully created your Infinity Wallet and can now access the vast array of features it has to offer Using Genesys Chain Now that you have created your wallet you can monitor and manage a wide range of different cryptos within the Infinity Wallet, including GSYS and Genesys Chain Tokens Receive GSYS on the Genesys Chain To receive GSYS on the Genesys Chain you will have to enable it by going to My Wallet and clicking on + Add asset , then select to enable Genesys (TC) . All TC tokens on the Infinity Wallet will use the same address as GSYS TC Now that Genesys (TC) is enabled go back to My Wallet and select Genesys (TC) , to get your receive adddress click on the receive button Copy your receive address by clicking on it, or select one of the options to print, share or request an amount to generate a decentralized link to request funds Send GSYS on the Genesys Chain To send go to My Wallet , select Genesys (TC) and then click on the send button Either enter an address to send to, select from your contact list, or scan a QR request by importing, scanning with a webcam, or using our drag and scan desktop technology If you select to use the drag and scan QR technology, then all you need to do is drag the window over a QR code you have been shared and it will automatically detect the address and fill it in for you as the send address Enter the amount of the coin you want to send Confirm the details of your send Congratulations you have successfully sent Connect to DeFi Platforms and Dapps Infinity Wallet supports the ability for users to connect securely to decentralized application on the Genesys Chain, Genesys Chain and Ethereum. To connect your wallet make sure the platform you are connecting to supports Wallet Connect, then go to your Infinity Wallet and click WalletConnect in the bottom left corner. In the popup that will show you can select one of 3 options to connect, the recommended and easiest option will be to use the \" Desktop Scan \" which uses our drag and scan desktop technology Drag and resize the desktop QR scanner over the QR you want to scan, in this case we will be connecting to Infinity Crypto (https://infinitycrypto.com/) Approve the connection between the platform and your wallet. All transactions on the platform will be pushed to be confirmed and signed within the Infinity Wallet, ensuring your keys are never shared and providing maximum security while interacting with Dapps and DeFi After sucessfully approving the connection between the Infinity Wallet and the Dapp or DeFi platform, you will see that the WalletConnect icon in the bottom left of the Infinity Wallet will be green, signifying that your wallet is now connected to the Dapp or DeFi platform Congratulations you can now start interacting with the Dapp or DeFi platform and confirming all transactions securely from the safety of your Infinity Wallet On creating a transaction on the Dapp or DeFi platform you will receive a popup request within your Infinity Wallet to send, sign or approve a transaction. You can review the information of the transaction and either accept or decline it After confirming an interaction, the Infinity Wallet will sign the transaction and push it over the network, without revealing your key to the platform you are interacting with. Within the Infinity Wallet and on the Platform you should see a success message that the transaction was signed and pushed The Infinity Wallet is aiming to push crypto innovation to its limits and has a wide range of future features and UI enhancements on the roadmap, to further expedite global adoption of cryptocurrency. Along with its companion platform Infinity Crypto, which is revolutionizing the DeFi and exchange space on Genesys Chain and Ethereum.","title":"Using Infinity Wallet on the Genesys Chain"},{"location":"smart-chain/wallet/infinitywallet.html#using-infinity-wallet-on-the-genesys-chain","text":"","title":"Using Infinity Wallet on the Genesys Chain"},{"location":"smart-chain/wallet/infinitywallet.html#what-is-it","text":"Infinity Wallet is the ultimate easy to use, secure, multicurrency, practical and convenient self-custodial cryptocurrency wallet, that provides all a user will ever need in one platform. With a wide range of new and innovative features to access digital assets, empowering financial freedom. Advancing the world of decentralized finance with an all-in-one digital wallet experience and streamlining adoption of cryptocurrency. Infinity Wallet is packed with a wealth of features and designed for the best possible user experience. With a simple and modular interface allowing to interact, monitor, trade, transact, view news and much more in a secure environment, as the one-stop application that a user will ever need for decentralized finance. Connect to DeFi protocols and Dapps directly on desktop or mobile from within the Infinity Wallet, to securely use decentralized platforms without compromising your assets. Providing enhanced ease of use and security, as well as support for multiple chains.","title":"What is it?"},{"location":"smart-chain/wallet/infinitywallet.html#download-link","text":"Downloads: https://infinitywallet.io/download GSYS Page: https://infinitywallet.io/asset/shree","title":"Download Link"},{"location":"smart-chain/wallet/infinitywallet.html#install-infinity-wallet","text":"","title":"Install Infinity Wallet"},{"location":"smart-chain/wallet/infinitywallet.html#go-to-httpsinfinitywalletio-to-install-the-most-recent-version-of-the-infinity-wallet","text":"The Infinity Wallet is currently available to be downloaded for desktop devices on Windows , macOS and Linux . In the coming months there will be a mobile wallet released to accompany our revolutionary desktop wallet.","title":"Go to https://infinitywallet.io to install the most recent version of the Infinity Wallet."},{"location":"smart-chain/wallet/infinitywallet.html#launch-the-infinity-wallet-to-create-your-local-account-and-wallet","text":"Create a local account, you can name this anything as the account name is only used locally within your own device Create a password for your local account and confirm your password Select to either create a new wallet or recover an existing wallet (You can import your 12 or 24 word seed phrase from most other wallets into the Infinity Wallet as we follow the standard) Give your wallet a name so you can easily identify it within your local account If you would like to have additional security, you can create an individual pin for each of your wallets (This is optional) Select if you want to use a 12 or 24 word seed You will now need to confirm that you understand that you have to backup your 12 or 24 word seed to be able to recover your wallet. We recommend keeping your seed phrase offline and somewhere secure (Never share your seed with anyone, including the Infinity Wallet support team) Make a backup of the words on the screen, we recommend making a paper backup and not an online backup. If you ever lose access to your computer or forget your password, you will need your 12 or 24 word seed to recover your wallet (Keep these words secure and never share them with anyone, as these words grant full access to your wallet) Confirm a selection of the words in the correct order as requested, to generate your wallet Congratulations you have successfully created your Infinity Wallet and can now access the vast array of features it has to offer","title":"Launch the Infinity Wallet to create your local account and wallet"},{"location":"smart-chain/wallet/infinitywallet.html#using-genesys-chain","text":"Now that you have created your wallet you can monitor and manage a wide range of different cryptos within the Infinity Wallet, including GSYS and Genesys Chain Tokens","title":"Using Genesys Chain"},{"location":"smart-chain/wallet/infinitywallet.html#receive-gsys-on-the-genesys-chain","text":"To receive GSYS on the Genesys Chain you will have to enable it by going to My Wallet and clicking on + Add asset , then select to enable Genesys (TC) . All TC tokens on the Infinity Wallet will use the same address as GSYS TC Now that Genesys (TC) is enabled go back to My Wallet and select Genesys (TC) , to get your receive adddress click on the receive button Copy your receive address by clicking on it, or select one of the options to print, share or request an amount to generate a decentralized link to request funds","title":"Receive GSYS on the Genesys Chain"},{"location":"smart-chain/wallet/infinitywallet.html#send-gsys-on-the-genesys-chain","text":"To send go to My Wallet , select Genesys (TC) and then click on the send button Either enter an address to send to, select from your contact list, or scan a QR request by importing, scanning with a webcam, or using our drag and scan desktop technology If you select to use the drag and scan QR technology, then all you need to do is drag the window over a QR code you have been shared and it will automatically detect the address and fill it in for you as the send address Enter the amount of the coin you want to send Confirm the details of your send Congratulations you have successfully sent","title":"Send GSYS on the Genesys Chain"},{"location":"smart-chain/wallet/infinitywallet.html#connect-to-defi-platforms-and-dapps","text":"Infinity Wallet supports the ability for users to connect securely to decentralized application on the Genesys Chain, Genesys Chain and Ethereum. To connect your wallet make sure the platform you are connecting to supports Wallet Connect, then go to your Infinity Wallet and click WalletConnect in the bottom left corner. In the popup that will show you can select one of 3 options to connect, the recommended and easiest option will be to use the \" Desktop Scan \" which uses our drag and scan desktop technology Drag and resize the desktop QR scanner over the QR you want to scan, in this case we will be connecting to Infinity Crypto (https://infinitycrypto.com/) Approve the connection between the platform and your wallet. All transactions on the platform will be pushed to be confirmed and signed within the Infinity Wallet, ensuring your keys are never shared and providing maximum security while interacting with Dapps and DeFi After sucessfully approving the connection between the Infinity Wallet and the Dapp or DeFi platform, you will see that the WalletConnect icon in the bottom left of the Infinity Wallet will be green, signifying that your wallet is now connected to the Dapp or DeFi platform Congratulations you can now start interacting with the Dapp or DeFi platform and confirming all transactions securely from the safety of your Infinity Wallet On creating a transaction on the Dapp or DeFi platform you will receive a popup request within your Infinity Wallet to send, sign or approve a transaction. You can review the information of the transaction and either accept or decline it After confirming an interaction, the Infinity Wallet will sign the transaction and push it over the network, without revealing your key to the platform you are interacting with. Within the Infinity Wallet and on the Platform you should see a success message that the transaction was signed and pushed The Infinity Wallet is aiming to push crypto innovation to its limits and has a wide range of future features and UI enhancements on the roadmap, to further expedite global adoption of cryptocurrency. Along with its companion platform Infinity Crypto, which is revolutionizing the DeFi and exchange space on Genesys Chain and Ethereum.","title":"Connect to DeFi Platforms and Dapps"},{"location":"smart-chain/wallet/ledger.html","text":"Ledger GSYS and coins on Genesys Chain are supported by the Ledger Nano S hardware wallet. The following describes how to use Ledger Nano S to connect to TC Requirements A Ledger Nano S hardware wallet with latest firmware. Latest version of Ethereum app installed An internet connection and an available USB port. Use an adapter for USB-C ports U2F compatible browsers: Google Chrome, Opera, FireFox, Brave App Installation Instructions Tip The existing Ethereum App is compatible with Genesys Chain 1) Plug in and unlock your Ledger device, open Ledger Live on your computer, then open the \"Manager\" panel. 2) Within the \"Manager\" pane, type in \"Ethereum\" in the search field. Locate \"Ethereum\", then click on \"Install\". (Note: Do not use the \"Genesys Chain\" App) 3) The Ethereum app will now install on your Ledger device. Enabling contract data for BLUE20 Tip Please ensure your enabled contract data before transfering BLUE20 tokens If you want to send BEP-20 tokens, you need to activate contract data on your device. Otherwise, invalid status 6a80 is returned. Steps: Connect and unlock your Ledger device. Open the Ethereum application. Press the right button to navigate to Settings. Then press both buttons to validate. In the Contract data settings, press both buttons to allow contract data in transactions. The device displays Allowed. Connect with MetaMask Genesys Chain is compatible with MetaMask. Users can use MetaMask as a bridge between Ledger Nano S and Genesys Chain to make transactions to the Genesys Chain testnet. 1) Connect MetaMask to GSYS Testnet by following this guide to add a custom network Testnet RPC URLs ChainID: 0x61 (97 in decimal) Symbol: GSYS Block Explorer Mainnet RPC URLs ChainID: 0x38 (56 in decimal) Symbol: GSYS Block Explorer Unlock your Metamask Click on \u201cConnect Hardware Wallet\u201d Choose \u201cLedger\u201d Choose your address You should see a new account Please read this doc to learn about how to interact with blockchain. With Ledger, you need to approve your transaction in your device. Initiate a transfer transaction, then click on next Review the transaction details, then confirm the same info on Ledger device You can view the transaction info and confirm it on Ledger: 11) Once the transaction is ready to get signed, your Ledger device will display this screen. Click on both buttons for broadcasting this transaction. 12) Track the transaction stsatus in \u201cActivity\u201d tab FAQ Fail to tranfer BLUE20 tokens Error message: '{\"value\":{\"code\":-32603,\"message\":\"Error: TransportStatusError: Ledger device: Invalid data received (0x6a80)\"}}' You need to follow these steps to enable contract data.","title":"Ledger"},{"location":"smart-chain/wallet/ledger.html#ledger","text":"GSYS and coins on Genesys Chain are supported by the Ledger Nano S hardware wallet. The following describes how to use Ledger Nano S to connect to TC","title":"Ledger"},{"location":"smart-chain/wallet/ledger.html#requirements","text":"A Ledger Nano S hardware wallet with latest firmware. Latest version of Ethereum app installed An internet connection and an available USB port. Use an adapter for USB-C ports U2F compatible browsers: Google Chrome, Opera, FireFox, Brave","title":"Requirements"},{"location":"smart-chain/wallet/ledger.html#app-installation-instructions","text":"Tip The existing Ethereum App is compatible with Genesys Chain 1) Plug in and unlock your Ledger device, open Ledger Live on your computer, then open the \"Manager\" panel. 2) Within the \"Manager\" pane, type in \"Ethereum\" in the search field. Locate \"Ethereum\", then click on \"Install\". (Note: Do not use the \"Genesys Chain\" App) 3) The Ethereum app will now install on your Ledger device.","title":"App Installation Instructions"},{"location":"smart-chain/wallet/ledger.html#enabling-contract-data-for-blue20","text":"Tip Please ensure your enabled contract data before transfering BLUE20 tokens If you want to send BEP-20 tokens, you need to activate contract data on your device. Otherwise, invalid status 6a80 is returned. Steps: Connect and unlock your Ledger device. Open the Ethereum application. Press the right button to navigate to Settings. Then press both buttons to validate. In the Contract data settings, press both buttons to allow contract data in transactions. The device displays Allowed.","title":"Enabling contract data for BLUE20"},{"location":"smart-chain/wallet/ledger.html#connect-with-metamask","text":"Genesys Chain is compatible with MetaMask. Users can use MetaMask as a bridge between Ledger Nano S and Genesys Chain to make transactions to the Genesys Chain testnet. 1) Connect MetaMask to GSYS Testnet by following this guide to add a custom network Testnet RPC URLs ChainID: 0x61 (97 in decimal) Symbol: GSYS Block Explorer Mainnet RPC URLs ChainID: 0x38 (56 in decimal) Symbol: GSYS Block Explorer","title":"Connect with MetaMask"},{"location":"smart-chain/wallet/ledger.html#unlock-your-metamask","text":"","title":"Unlock your Metamask"},{"location":"smart-chain/wallet/ledger.html#click-on-connect-hardware-wallet","text":"","title":"Click on \u201cConnect Hardware Wallet\u201d"},{"location":"smart-chain/wallet/ledger.html#choose-ledger","text":"","title":"Choose \u201cLedger\u201d"},{"location":"smart-chain/wallet/ledger.html#choose-your-address","text":"You should see a new account","title":"Choose your address"},{"location":"smart-chain/wallet/ledger.html#please-read-this-doc-to-learn-about-how-to-interact-with-blockchain","text":"With Ledger, you need to approve your transaction in your device.","title":"Please read this doc to learn about how to interact with blockchain."},{"location":"smart-chain/wallet/ledger.html#initiate-a-transfer-transaction-then-click-on-next","text":"","title":"Initiate a transfer transaction, then click on next"},{"location":"smart-chain/wallet/ledger.html#review-the-transaction-details-then-confirm-the-same-info-on-ledger-device","text":"","title":"Review the transaction details, then confirm the same info on Ledger device"},{"location":"smart-chain/wallet/ledger.html#you-can-view-the-transaction-info-and-confirm-it-on-ledger","text":"11) Once the transaction is ready to get signed, your Ledger device will display this screen. Click on both buttons for broadcasting this transaction. 12) Track the transaction stsatus in \u201cActivity\u201d tab","title":"You can view the transaction info and confirm it on Ledger:"},{"location":"smart-chain/wallet/ledger.html#faq","text":"Fail to tranfer BLUE20 tokens Error message: '{\"value\":{\"code\":-32603,\"message\":\"Error: TransportStatusError: Ledger device: Invalid data received (0x6a80)\"}}' You need to follow these steps to enable contract data.","title":"FAQ"},{"location":"smart-chain/wallet/manual.html","text":"How to manually install the Genesys Chain Extension Wallet Download the zip file Visit https://genesys.network/en/ Click Chrome and you will download the file Genesys ChainBrowserExtension-1.114.0.zip Install in Chrome Visit chrome://extensions/ Open the Developer mode Drag and drop the mathwallet.zip file into the Extension window. Then the install is completed. Other browsers The same method is working for the browsers such as Firefox, Brave etc. If you have any other questions, join https://t.me/bcextensionwallet Note: manually installed version will not upgrade automatically, so you will need to manually install the new version.","title":"How to manually install the Genesys Chain Extension Wallet"},{"location":"smart-chain/wallet/manual.html#how-to-manually-install-the-genesys-chain-extension-wallet","text":"","title":"How to manually install the Genesys Chain Extension Wallet"},{"location":"smart-chain/wallet/manual.html#download-the-zip-file","text":"Visit https://genesys.network/en/ Click Chrome and you will download the file Genesys ChainBrowserExtension-1.114.0.zip","title":"Download the zip file"},{"location":"smart-chain/wallet/manual.html#install-in-chrome","text":"Visit chrome://extensions/ Open the Developer mode Drag and drop the mathwallet.zip file into the Extension window. Then the install is completed.","title":"Install in Chrome"},{"location":"smart-chain/wallet/manual.html#other-browsers","text":"The same method is working for the browsers such as Firefox, Brave etc. If you have any other questions, join https://t.me/bcextensionwallet Note: manually installed version will not upgrade automatically, so you will need to manually install the new version.","title":"Other browsers"},{"location":"smart-chain/wallet/math-resource.html","text":"Math Wallet Tutorials Genesys Chain \u65b0\u624b\u6307\u5357 Link: http://blog.mathwallet.xyz/?p=3895 \u5982\u4f55\u4f7f\u7528 \u5e01\u5b89\u94fe Staking \u5de5\u5177 Link: http://blog.mathwallet.xyz/?p=3890 \u5982\u4f55\u4f7f\u7528 \u5e01\u5b89\u94fe \u8de8\u94fe\u8f6c\u8d26\u5de5\u5177 Link: http://blog.mathwallet.xyz/?p=3893 GSYS DAPP Dev Tutorial\uff081\uff09- GSYS Smart Contract Develop Environment Link: http://blog.mathwallet.org/?p=2357","title":"Math Wallet Tutorials"},{"location":"smart-chain/wallet/math-resource.html#math-wallet-tutorials","text":"Genesys Chain \u65b0\u624b\u6307\u5357 Link: http://blog.mathwallet.xyz/?p=3895 \u5982\u4f55\u4f7f\u7528 \u5e01\u5b89\u94fe Staking \u5de5\u5177 Link: http://blog.mathwallet.xyz/?p=3890 \u5982\u4f55\u4f7f\u7528 \u5e01\u5b89\u94fe \u8de8\u94fe\u8f6c\u8d26\u5de5\u5177 Link: http://blog.mathwallet.xyz/?p=3893 GSYS DAPP Dev Tutorial\uff081\uff09- GSYS Smart Contract Develop Environment Link: http://blog.mathwallet.org/?p=2357","title":"Math Wallet Tutorials"},{"location":"smart-chain/wallet/math.html","text":"How to use Math Wallet for Genesys Chain Install 1. Get App from Chrome web store 2. Add to your browser, for example, Brave Setup Your Wallet 1. Set your password 2. Choose GSYS network Choose Genesys Chain from this list: 3. Create Your Wallet 4. Save your private key It\u2019s ready, and now you can get some testnet GSYS from the faucet. Get Testnet Fund 1. Copy your address. 2. Go to https://testnet-explorer.genesys.network/faucet-smart/ Go to explorer to verify GSYS is sent: https://genesys.network/ Transfer GSYS from GSYS to BC in Testnet 1. Create your Genesys Chain Ganges Testnet address with eth-cli Download the binary here If you already have a backup of your recovery phrase from Genesys Chain Ganges Testnet, it can be reused here. eth-cli keys add {wallet-alias} 2. Go to this page: https://developer.mathwallet.org/bsc02/ Go to this page for mainnet: https://developer.mathwallet.org/bsc01/ Paste your testnet address to Recipient and fill the transfer amount. Please note the fees are also deducted for paying gas and cross-chain transfer. 3. Approve your transaction 4. Confirm Reception in explorer Link: https://gchainexplorer.genesys.network/testnet Transfer BLUE20 from GSYS to BC in Testnet One of the key innovations of a dual-chain architecture is that token issuer can manage its assets on both chains. They could bind BEP2 tokens and BLUE20 tokens together. In Genesys Chain Ganges Testnet, there are several pegged tokens: Pegged BTC on Genesys Chain Testnet and Genesys Chain Testnet Pegged ETH on Genesys Chain Testnet and Genesys Chain Testnet Pegged XRP on Genesys Chain Testnet and Genesys Chain Testnet You can get some of these pegged tokens from faucet and transfer them back to Genesys Chain testnet. 1. Approve this transaction 2. Send BLUE20 To BC","title":"How to use Math Wallet for Genesys Chain"},{"location":"smart-chain/wallet/math.html#how-to-use-math-wallet-for-genesys-chain","text":"","title":"How to use Math Wallet for Genesys Chain"},{"location":"smart-chain/wallet/math.html#install","text":"","title":"Install"},{"location":"smart-chain/wallet/math.html#1-get-app-from-chrome-web-store","text":"","title":"1. Get App from Chrome web store"},{"location":"smart-chain/wallet/math.html#2-add-to-your-browser-for-example-brave","text":"","title":"2. Add to your browser, for example, Brave"},{"location":"smart-chain/wallet/math.html#setup-your-wallet","text":"","title":"Setup Your Wallet"},{"location":"smart-chain/wallet/math.html#1-set-your-password","text":"","title":"1. Set your password"},{"location":"smart-chain/wallet/math.html#2-choose-gsys-network","text":"","title":"2. Choose GSYS network"},{"location":"smart-chain/wallet/math.html#choose-genesys-chain-from-this-list","text":"","title":"Choose Genesys Chain from this list:"},{"location":"smart-chain/wallet/math.html#3-create-your-wallet","text":"","title":"3. Create Your Wallet"},{"location":"smart-chain/wallet/math.html#4-save-your-private-key","text":"It\u2019s ready, and now you can get some testnet GSYS from the faucet.","title":"4. Save your private key"},{"location":"smart-chain/wallet/math.html#get-testnet-fund","text":"","title":"Get Testnet Fund"},{"location":"smart-chain/wallet/math.html#1-copy-your-address","text":"","title":"1. Copy your address."},{"location":"smart-chain/wallet/math.html#2-go-to-httpstestnet-explorergenesysnetworkfaucet-smart","text":"Go to explorer to verify GSYS is sent: https://genesys.network/","title":"2. Go to https://testnet-explorer.genesys.network/faucet-smart/"},{"location":"smart-chain/wallet/math.html#transfer-gsys-from-gsys-to-bc-in-testnet","text":"","title":"Transfer GSYS from GSYS to BC in Testnet"},{"location":"smart-chain/wallet/math.html#1-create-your-genesys-chain-ganges-testnet-address-with-eth-cli","text":"Download the binary here If you already have a backup of your recovery phrase from Genesys Chain Ganges Testnet, it can be reused here. eth-cli keys add {wallet-alias}","title":"1. Create your Genesys Chain Ganges Testnet address with eth-cli"},{"location":"smart-chain/wallet/math.html#2-go-to-this-page-httpsdevelopermathwalletorgbsc02","text":"Go to this page for mainnet: https://developer.mathwallet.org/bsc01/ Paste your testnet address to Recipient and fill the transfer amount. Please note the fees are also deducted for paying gas and cross-chain transfer.","title":"2. Go to this page: https://developer.mathwallet.org/bsc02/"},{"location":"smart-chain/wallet/math.html#3-approve-your-transaction","text":"","title":"3. Approve your transaction"},{"location":"smart-chain/wallet/math.html#4-confirm-reception-in-explorer","text":"Link: https://gchainexplorer.genesys.network/testnet","title":"4. Confirm Reception in explorer"},{"location":"smart-chain/wallet/math.html#transfer-blue20-from-gsys-to-bc-in-testnet","text":"One of the key innovations of a dual-chain architecture is that token issuer can manage its assets on both chains. They could bind BEP2 tokens and BLUE20 tokens together. In Genesys Chain Ganges Testnet, there are several pegged tokens: Pegged BTC on Genesys Chain Testnet and Genesys Chain Testnet Pegged ETH on Genesys Chain Testnet and Genesys Chain Testnet Pegged XRP on Genesys Chain Testnet and Genesys Chain Testnet You can get some of these pegged tokens from faucet and transfer them back to Genesys Chain testnet.","title":"Transfer BLUE20 from GSYS to BC in Testnet"},{"location":"smart-chain/wallet/math.html#1-approve-this-transaction","text":"","title":"1. Approve this transaction"},{"location":"smart-chain/wallet/math.html#2-send-blue20-to-bc","text":"","title":"2. Send BLUE20 To BC"},{"location":"smart-chain/wallet/metamask.html","text":"Use MetaMask For Genesys Chain Tip You may encounter a network configuration issue in recent releases of MetaMask, Please go to \"Upgrade\" section for solution What is it? MetaMask was created out of the needs of creating more secure and usable Ethereum-based web sites. In particular, it handles account management and connecting the user to the blockchain. It\u2019s supported in Chrome, Brave, and Safari browsers. Install Example: Install MetaMask in Brave browser Open Extension Category in Brave: https://chrome.google.com/webstore/category/extensionsSearch for MetaMask Warning Note: Make sure it\u2019s offered by metamask.io Click on \u201cAdd to Brave\u201d That\u2019s it! You have successfully installed MetaMask extension in Brave! Tip The workflow is the same for all browsers Create an account in MetaMask for Genesys Chain Click on the \u201cCreate a wallet\u201d button 2. Create Password of at least 8 characters Click on \u201cCreate\u201d and then write down your backup phrase. Select each phrase in order to make sure it is correct then click \u201cConfirm\u201d. Congratulations! you have create your MetaMask account! Connect Your MetaMask With Genesys Chain Go to setting page Add a new network Testnet RPC URLs ChainID: 11512 Symbol: GSYS Block Explorer: https://testnet-explorer.genesys.network Mainnet RPC URLs ChainID: 11513 Symbol: GSYS Block Explorer: https://genesys.network Claim some testnet token to your account Click on your address for copy Go to faucet page: https://testnet-explorer.genesys.network/faucet-smart, then paste your address in the box and click on \u201cGive me GSYS\u201d Tip Please note that you can only claim once every minute After the transfer transaction is sent, you will see an increase of your balance Transfer GSYS to other Genesys Chain address Log in to your MetaMask Click on Send button Copy the receiver\u2019s address in the box Input the amount Go to Advanced Options to modify default gas price when necessary Confirm your transaction, then click Next Click Confirm to send your transaction Wait for your transaction to be included in the new block Once your transaction is confirmed, check it on block explorer by clicking Details Click on your account to see \"Details'' Verify your transaction in Explorer: Add BLUE20 Tokens Deploy an ERC20 contract at https://remix.ethereum.org/ You can create a new file or import a sample contract: https://gist.github.com/HaoyangLiu/3c4dc081b7b5250877e40b82667c8508 Connect your Genesys Chain Account to Remix Select \u201cABCToken\u201d contract and compile Deploy your compiled contract Adjust Gas Fee for your contract, then confirm your deploy contract You can see that there is a new ceate contract transaction in block explorer In MetaMask, Click on \u201cAdd Token\u201d Choose \u201cCustom Token\u201d and copy the contract address in the box Click on \u201cAdd Tokens\u201d Then you can see change of your balance Create Multiple Accounts To create multiple accounts, you click on Profile icon on MetaMask and then click on Create Account You can then add an account name and click on Create. Then you can see a new account is created! Upgrade Since the release of v8.1.3, MetaMask sometimes displays the warning message \"Invalid Custom Network\". To solve this issue, click on \"'Settings\" and enter Chain ID of Genesys Chain network again. If 56 doesn\u2019t work, try 0x38 .","title":"Use MetaMask For Genesys Chain"},{"location":"smart-chain/wallet/metamask.html#use-metamask-for-genesys-chain","text":"Tip You may encounter a network configuration issue in recent releases of MetaMask, Please go to \"Upgrade\" section for solution","title":"Use MetaMask For Genesys Chain"},{"location":"smart-chain/wallet/metamask.html#what-is-it","text":"MetaMask was created out of the needs of creating more secure and usable Ethereum-based web sites. In particular, it handles account management and connecting the user to the blockchain. It\u2019s supported in Chrome, Brave, and Safari browsers.","title":"What is it?"},{"location":"smart-chain/wallet/metamask.html#install","text":"Example: Install MetaMask in Brave browser Open Extension Category in Brave: https://chrome.google.com/webstore/category/extensionsSearch for MetaMask Warning Note: Make sure it\u2019s offered by metamask.io Click on \u201cAdd to Brave\u201d That\u2019s it! You have successfully installed MetaMask extension in Brave! Tip The workflow is the same for all browsers","title":"Install"},{"location":"smart-chain/wallet/metamask.html#create-an-account-in-metamask-for-genesys-chain","text":"Click on the \u201cCreate a wallet\u201d button 2. Create Password of at least 8 characters Click on \u201cCreate\u201d and then write down your backup phrase. Select each phrase in order to make sure it is correct then click \u201cConfirm\u201d. Congratulations! you have create your MetaMask account!","title":"Create an account in MetaMask for Genesys Chain"},{"location":"smart-chain/wallet/metamask.html#connect-your-metamask-with-genesys-chain","text":"Go to setting page Add a new network Testnet RPC URLs ChainID: 11512 Symbol: GSYS Block Explorer: https://testnet-explorer.genesys.network Mainnet RPC URLs ChainID: 11513 Symbol: GSYS Block Explorer: https://genesys.network Claim some testnet token to your account Click on your address for copy Go to faucet page: https://testnet-explorer.genesys.network/faucet-smart, then paste your address in the box and click on \u201cGive me GSYS\u201d Tip Please note that you can only claim once every minute After the transfer transaction is sent, you will see an increase of your balance","title":"Connect Your MetaMask With Genesys Chain"},{"location":"smart-chain/wallet/metamask.html#transfer-gsys-to-other-genesys-chain-address","text":"Log in to your MetaMask Click on Send button Copy the receiver\u2019s address in the box Input the amount Go to Advanced Options to modify default gas price when necessary Confirm your transaction, then click Next Click Confirm to send your transaction Wait for your transaction to be included in the new block Once your transaction is confirmed, check it on block explorer by clicking Details Click on your account to see \"Details'' Verify your transaction in Explorer:","title":"Transfer GSYS to other Genesys Chain address"},{"location":"smart-chain/wallet/metamask.html#add-blue20-tokens","text":"Deploy an ERC20 contract at https://remix.ethereum.org/ You can create a new file or import a sample contract: https://gist.github.com/HaoyangLiu/3c4dc081b7b5250877e40b82667c8508 Connect your Genesys Chain Account to Remix Select \u201cABCToken\u201d contract and compile Deploy your compiled contract Adjust Gas Fee for your contract, then confirm your deploy contract You can see that there is a new ceate contract transaction in block explorer In MetaMask, Click on \u201cAdd Token\u201d Choose \u201cCustom Token\u201d and copy the contract address in the box Click on \u201cAdd Tokens\u201d Then you can see change of your balance","title":"Add BLUE20 Tokens"},{"location":"smart-chain/wallet/metamask.html#create-multiple-accounts","text":"To create multiple accounts, you click on Profile icon on MetaMask and then click on Create Account You can then add an account name and click on Create. Then you can see a new account is created!","title":"Create Multiple Accounts"},{"location":"smart-chain/wallet/metamask.html#upgrade","text":"Since the release of v8.1.3, MetaMask sometimes displays the warning message \"Invalid Custom Network\". To solve this issue, click on \"'Settings\" and enter Chain ID of Genesys Chain network again. If 56 doesn\u2019t work, try 0x38 .","title":"Upgrade"},{"location":"smart-chain/wallet/myetherwallet.html","text":"MyEtherWallet Connect to MetaMask on MEW Unlock your MetaMask first Open new MEW page > Click \u201caccess my wallet\u201d Click MEX CX Agree with connection Now you are all set!","title":"MyEtherWallet"},{"location":"smart-chain/wallet/myetherwallet.html#myetherwallet","text":"","title":"MyEtherWallet"},{"location":"smart-chain/wallet/myetherwallet.html#connect-to-metamask-on-mew","text":"Unlock your MetaMask first Open new MEW page > Click \u201caccess my wallet\u201d Click MEX CX Agree with connection Now you are all set!","title":"Connect to MetaMask on MEW"},{"location":"smart-chain/wallet/staking.html","text":"Staking with extension wallet How to delegate your GSYS with extension wallet Install Genesys Chain extension wallet Go to the staking page: Mainnet: https://www.genesys.network/en/staking Testnet: https://testnet-staking.genesys.network/en/staking Testnet example Click on \u201cConnect Wallet\u201d Unlock your wallet Click on \u201cdelegate\u201d and input the amount Confirm your transaction in extension wallet Success your delegation overview You can see the staking history here How to redelegate your GSYS with extension wallet By staking you GSYS, you participate in the selection process of Genesys Chain validators and earn rewards. Staking GSYS is critical for securing the network. Validators can self-bond, meaning they can delegate GSYS to themselves, and they can also receive delegations from any other GSYS holders. Redelegations between a unique delegator, source validator, and destination validator can only happen once every 7 days Click on redelegate Select a new validator and redegelate amount Confirm your transaction in extension wallet Success Refresh and see your delegation changes How to undelegate your GSYS with extension wallet Click on undelegate input the amount Confirm your transaction in extension wallet Success Refresh and see your delegation changes","title":"Staking with extension wallet"},{"location":"smart-chain/wallet/staking.html#staking-with-extension-wallet","text":"","title":"Staking with extension wallet"},{"location":"smart-chain/wallet/staking.html#how-to-delegate-your-gsys-with-extension-wallet","text":"Install Genesys Chain extension wallet Go to the staking page: Mainnet: https://www.genesys.network/en/staking Testnet: https://testnet-staking.genesys.network/en/staking Testnet example Click on \u201cConnect Wallet\u201d Unlock your wallet Click on \u201cdelegate\u201d and input the amount Confirm your transaction in extension wallet Success your delegation overview You can see the staking history here","title":"How to delegate your GSYS with extension wallet"},{"location":"smart-chain/wallet/staking.html#how-to-redelegate-your-gsys-with-extension-wallet","text":"By staking you GSYS, you participate in the selection process of Genesys Chain validators and earn rewards. Staking GSYS is critical for securing the network. Validators can self-bond, meaning they can delegate GSYS to themselves, and they can also receive delegations from any other GSYS holders. Redelegations between a unique delegator, source validator, and destination validator can only happen once every 7 days Click on redelegate Select a new validator and redegelate amount Confirm your transaction in extension wallet Success Refresh and see your delegation changes","title":"How to redelegate your GSYS with extension wallet"},{"location":"smart-chain/wallet/staking.html#how-to-undelegate-your-gsys-with-extension-wallet","text":"Click on undelegate input the amount Confirm your transaction in extension wallet Success Refresh and see your delegation changes","title":"How to undelegate your GSYS with extension wallet"},{"location":"smart-chain/wallet/trezor.html","text":"Trezor GSYS and coins on Genesys Chain are supported by the Trezor hardware wallet. The following describes how to use Trezor to connect to TC. Requirements Visit https://wallet.trezor.io and initialize your Trezor Trezor Model T firmware version 2.3.0 . Trezor Model One firmware version 1.9.3 . An internet connection and an available USB port. Use an adapter for USB-C ports U2F compatible browsers: Google Chrome, Opera, FireFox, Brave Connect with MetaMask Genesys Chain is compatible with MetaMask. Users can use MetaMask as a bridge between Trezor and Genesys Chain to make transactions to the Genesys Chain testnet. 1) Connect MetaMask to GSYS Testnet by following this guide to add a custom network Testnet RPC URLs ChainID: 97 Symbol: GSYS Block Explorer Mainnet RPC URLs ChainID: 56 Symbol: GSYS Block Explorer](https://bscscan.com) Unlock your Metamask Click on \u201cConnect Hardware Wallet\u201d Choose an address in your Trezor You should see a new account Transfer Guide Initiate a transfer transaction, then click on next Review the transaction details, then confirm the same info in your Trezor device Confirm the same info in your Trezor device Track the transaction stsatus in \u201cActivity\u201d tab","title":"Trezor"},{"location":"smart-chain/wallet/trezor.html#trezor","text":"GSYS and coins on Genesys Chain are supported by the Trezor hardware wallet. The following describes how to use Trezor to connect to TC.","title":"Trezor"},{"location":"smart-chain/wallet/trezor.html#requirements","text":"Visit https://wallet.trezor.io and initialize your Trezor Trezor Model T firmware version 2.3.0 . Trezor Model One firmware version 1.9.3 . An internet connection and an available USB port. Use an adapter for USB-C ports U2F compatible browsers: Google Chrome, Opera, FireFox, Brave","title":"Requirements"},{"location":"smart-chain/wallet/trezor.html#connect-with-metamask","text":"Genesys Chain is compatible with MetaMask. Users can use MetaMask as a bridge between Trezor and Genesys Chain to make transactions to the Genesys Chain testnet. 1) Connect MetaMask to GSYS Testnet by following this guide to add a custom network Testnet RPC URLs ChainID: 97 Symbol: GSYS Block Explorer Mainnet RPC URLs ChainID: 56 Symbol: GSYS Block Explorer](https://bscscan.com)","title":"Connect with MetaMask"},{"location":"smart-chain/wallet/trezor.html#unlock-your-metamask","text":"","title":"Unlock your Metamask"},{"location":"smart-chain/wallet/trezor.html#click-on-connect-hardware-wallet","text":"","title":"Click on \u201cConnect Hardware Wallet\u201d"},{"location":"smart-chain/wallet/trezor.html#choose-an-address-in-your-trezor","text":"You should see a new account","title":"Choose an address in your Trezor"},{"location":"smart-chain/wallet/trezor.html#transfer-guide","text":"","title":"Transfer Guide"},{"location":"smart-chain/wallet/trezor.html#initiate-a-transfer-transaction-then-click-on-next","text":"","title":"Initiate a transfer transaction, then click on next"},{"location":"smart-chain/wallet/trezor.html#review-the-transaction-details-then-confirm-the-same-info-in-your-trezor-device","text":"","title":"Review the transaction details, then confirm the same info in your Trezor device"},{"location":"smart-chain/wallet/trezor.html#confirm-the-same-info-in-your-trezor-device","text":"","title":"Confirm the same info in your Trezor device"},{"location":"smart-chain/wallet/trezor.html#track-the-transaction-stsatus-in-activity-tab","text":"","title":"Track the transaction stsatus in \u201cActivity\u201d tab"},{"location":"smart-chain/wallet/trustwallet.html","text":"Using Trust Wallet for Genesys Chain Install Trust Wallet Go to https://trustwallet.com to install the most recent version of Trust Wallet. Trust Wallet can be downloded from the Apple Appstore or from the Google PlayStore . Launch the app in order to create a new wallet and accept the terms of use. Backup the recovery phrase and keep it secure at all times. Complete the initial setup and you're wallet is ready for use. Getting the Smart Chain Address Tap on the toggle at the upper right and then search for \"Smart Chain\". Get the Smart Chain address by tapping on Copy, or Receive to display the QR code. Receive GSYS and BLUE20 tokens Your Smart Chain address is able to receive GSYS or BLUE20 tokens. Withdraw Genesys (GSYS) from GSYS . BLUE20 tokens are also supported by Trust Wallet. Sending GSYS to a Smart Chain address Tap on Send to initiate the transfer, then fill in Recepient address and Amount. Confirm the transaction by tapping on Send. Transaction will be done in seconds. Access Genesys Chain DApps Switching to Smart Chain Network to access DApps. Type the URL on the built in browser in order to access a DApp. Tap on the ETH logon on the upper right corner to see Network options. Choose Smart Chain. Trust Wallet is fully compatible with Genesys Chain DApps. More DApps will be added on the built-in browser for convenience. Resources: Trust Wallet Now Supports Genesys Chain (TC) Trust Wallet supports BLUE20 Tokens Access Genesys Chain DApps with Trust Wallet","title":"Using Trust Wallet for Genesys Chain"},{"location":"smart-chain/wallet/trustwallet.html#using-trust-wallet-for-genesys-chain","text":"","title":"Using Trust Wallet for Genesys Chain"},{"location":"smart-chain/wallet/trustwallet.html#install-trust-wallet","text":"","title":"Install Trust Wallet"},{"location":"smart-chain/wallet/trustwallet.html#go-to-httpstrustwalletcom-to-install-the-most-recent-version-of-trust-wallet","text":"Trust Wallet can be downloded from the Apple Appstore or from the Google PlayStore .","title":"Go to https://trustwallet.com to install the most recent version of Trust Wallet."},{"location":"smart-chain/wallet/trustwallet.html#launch-the-app-in-order-to-create-a-new-wallet-and-accept-the-terms-of-use","text":"","title":"Launch the app in order to create a new wallet and accept the terms of use."},{"location":"smart-chain/wallet/trustwallet.html#backup-the-recovery-phrase-and-keep-it-secure-at-all-times","text":"","title":"Backup the recovery phrase and keep it secure at all times."},{"location":"smart-chain/wallet/trustwallet.html#complete-the-initial-setup-and-youre-wallet-is-ready-for-use","text":"","title":"Complete the initial setup and you're wallet is ready for use."},{"location":"smart-chain/wallet/trustwallet.html#getting-the-smart-chain-address","text":"","title":"Getting the Smart Chain Address"},{"location":"smart-chain/wallet/trustwallet.html#tap-on-the-toggle-at-the-upper-right-and-then-search-for-smart-chain","text":"","title":"Tap on the toggle at the upper right and then search for \"Smart Chain\"."},{"location":"smart-chain/wallet/trustwallet.html#get-the-smart-chain-address-by-tapping-on-copy-or-receive-to-display-the-qr-code","text":"","title":"Get the Smart Chain address by tapping on Copy, or Receive to display the QR code."},{"location":"smart-chain/wallet/trustwallet.html#receive-gsys-and-blue20-tokens","text":"","title":"Receive GSYS and BLUE20 tokens"},{"location":"smart-chain/wallet/trustwallet.html#your-smart-chain-address-is-able-to-receive-gsys-or-blue20-tokens","text":"","title":"Your Smart Chain address is able to receive GSYS or BLUE20 tokens."},{"location":"smart-chain/wallet/trustwallet.html#withdraw-genesys-gsys-from-gsys","text":"","title":"Withdraw Genesys (GSYS) from GSYS."},{"location":"smart-chain/wallet/trustwallet.html#blue20-tokens-are-also-supported-by-trust-wallet","text":"","title":"BLUE20 tokens are also supported by Trust Wallet."},{"location":"smart-chain/wallet/trustwallet.html#sending-gsys-to-a-smart-chain-address","text":"","title":"Sending GSYS to a Smart Chain address"},{"location":"smart-chain/wallet/trustwallet.html#tap-on-send-to-initiate-the-transfer-then-fill-in-recepient-address-and-amount","text":"","title":"Tap on Send to initiate the transfer, then fill in Recepient address and Amount."},{"location":"smart-chain/wallet/trustwallet.html#confirm-the-transaction-by-tapping-on-send-transaction-will-be-done-in-seconds","text":"","title":"Confirm the transaction by tapping on Send. Transaction will be done in seconds."},{"location":"smart-chain/wallet/trustwallet.html#access-genesys-chain-dapps","text":"","title":"Access Genesys Chain DApps"},{"location":"smart-chain/wallet/trustwallet.html#switching-to-smart-chain-network-to-access-dapps","text":"","title":"Switching to Smart Chain Network to access DApps."},{"location":"smart-chain/wallet/trustwallet.html#type-the-url-on-the-built-in-browser-in-order-to-access-a-dapp","text":"","title":"Type the URL on the built in browser in order to access a DApp."},{"location":"smart-chain/wallet/trustwallet.html#tap-on-the-eth-logon-on-the-upper-right-corner-to-see-network-options-choose-smart-chain","text":"","title":"Tap on the ETH logon on the upper right corner to see Network options. Choose Smart Chain."},{"location":"smart-chain/wallet/trustwallet.html#trust-wallet-is-fully-compatible-with-genesys-chain-dapps","text":"","title":"Trust Wallet is fully compatible with Genesys Chain DApps."},{"location":"smart-chain/wallet/trustwallet.html#more-dapps-will-be-added-on-the-built-in-browser-for-convenience","text":"","title":"More DApps will be added on the built-in browser for convenience."},{"location":"smart-chain/wallet/trustwallet.html#resources","text":"Trust Wallet Now Supports Genesys Chain (TC) Trust Wallet supports BLUE20 Tokens Access Genesys Chain DApps with Trust Wallet","title":"Resources:"},{"location":"smart-chain/wallet/wallet_api.html","text":"Genesys Chain Wallet injects a global API into websites visited by its users at window.Genesys Chain . This API specification borrows heavily from API MetaMask provided, considering the massive adoption. So Web3 site developers can easily connect their dApps with the Genesys Chain Wallet. The APIs allow websites to request users' Genesys Chain addresses, read data from the blockchain the user is connected to, and prompt the users to sign messages and transactions. The presence of the provider object window.Genesys Chain indicates a Genesys Chain/Genesys Chain user. The API this extension wallet provides includes API specified by EIP-1193 and API defined by MetaMask (including some massively relied legacy ones). Development Progress Currently (version 1.112.8) as Genesys Chain Wallet natively supports Genesys Chain, we are planning to open a series of APIs for dApp developers to interact with Genesys Chain. At the end of the day, most APIs available in Genesys Chain javascript sdk would be available. Currently, only the following is supported: * transfer Difference with MetaMask Warning Please read through this section if you are a web3 developer who has integrated with MetaMask and interested in integrating with Genesys Chain Wallet. Inpage injected object The biggest difference between Genesys Chain Wallet and MetaMask is we inject Genesys Chain rather than ethereum (or web3 ) to the web page. So user could keep two extensions at the same time. Genesys Chain.request({method: \"eth_sign\", params: [\"address\", \"message\"]) We haven't supported the full complex signing data APIs MetaMask provided, while we only provide standard eth_sign JSON-RPC call. The message item in params for this request on MetaMask has to be hex-encoded keccak256 hash (otherwise the API would silent failure for dapp https://www.reddit.com/r/Metamask/comments/9wp7kj/eth_sign_not_working/). In contrast, web3 developers could pass any message in plaintext to this method, and our UI would render it as it is to the wallet users. Genesys Chain.request({method: \"eth_accounts\"}) When this API is invoked without the user's approval, MetaMask would return an empty array. In contrast, we would ask the user to unlock his wallet and return the address user connected to. Upcoming Breaking Changes Warning Important Information On November 16, 2020 , MetaMask is making changes to their provider API that will be breaking for some web3 sites. These changes are upcoming , but you can prepare for them today. Follow this GitHub issue for updates. In this implementation, some APIs will be supported as Legacy API (For example we will still implement the chainIdChanged on Genesys Chain object until MetaMask formally deprecates it). Basic Usage For any non-trivial Genesys Chain web application \u2014 a.k.a. web3 site \u2014 to work, you will have to: Detect the Genesys Chain provider ( window.Genesys Chain ) Detect which Genesys Chain network the user is connected to Get the user's Genesys Chain account(s) You can learn how to accomplish the 2 and 3 from above list by reviewing the snippet in the Using the Provider section . The provider API is all you need to create a full-featured web3 application. That said, many developers use a convenience library, such as ethers and web3.js, instead of using the provider directly. If you need higher-level abstractions than those provided by this API, we recommend that you use a convenience library. Today, many dApps are built on top of the higher-level API provided by web3-react or use-wallet (which builds on top of web3-react). web3-react We made a tiny lib nc-connector that implements the AbstractConnector interface of web3-react library. You can add this to your project in parallel with injected-connector by: yarn add @shree-chain/nc-connector or npm i @shree-chain/nc-connector . import { BscConnector } from '@shree-chain/nc-connector' export const bsc = new BscConnector({ supportedChainIds: [56, 97] // later on 1 ethereum mainnet and 3 ethereum ropsten will be supported }) // invoke method on bsc e.g. await bsc.activate(); await bsc.getAccount(); await bsc.getChainId(); use-wallet There is an example in use-wallet origin repo shows how to 'inject' a customized web3-react connector to UseWalletProvider : function App() { const { account, connect, reset, status } = useWallet() return ( <div> <h1>Genesys Chain Connector</h1> {status === 'disconnected' ? ( <button onClick={() => connect('bsc')}>Connect</button> ) : ( <button onClick={() => reset()}>Disconnect</button> )} {account && <p>Connected as {account}</p>} </div> ) } render( <UseWalletProvider connectors={{ bsc: { web3ReactConnector() { return new BscConnector({ supportedChainIds: [56, 97] }) }, handleActivationError(err) { if (err instanceof UserRejectedRequestError) { return new ConnectionRejectedError() } }, }, }} > <App /> </UseWalletProvider>, document.getElementById('root') ) Chain IDs Warning At the moment, the Genesys Chain.chainId property and the chainChanged event should be preferred over the eth_chainId RPC method. Their chain ID values are correctly formatted, per the table below. eth_chainId returns an incorrectly formatted (0-padded) chain ID for the chains in the table below, e.g. 0x01 instead of 0x1 . See the Upcoming Breaking Changes section for details on when the eth_chainId RPC method will be fixed. Custom RPC endpoints are not affected; they always return the chain ID specified by the user. These are the IDs of the GSYS Chains that Genesys Chain Wallet supports by default. Hex Decimal Network 0x38 56 Genesys Chain Main Network (nc-mainnet) 0x61 97 Genesys Chain Test Network (nc-testnet) This API can also return chain ids of GSYS Chains if users switch to them. The possible return value would be: | Chain Id | Network | | -------------------- | ---------------------------------------- | | GSYS-Chain-Tigris | Genesys Chain Main Network (bbc-mainnet) | | GSYS-Chain-Ganges | Genesys Chain Test Network (bbc-testnet) | Properties Genesys Chain.chainId Warning The value of this property can change at any time, and should not be exclusively relied upon. See the chainChanged event for details. NOTE: See the Chain IDs section for important information about the Genesys Chain Wallet provider's chain IDs. A hexadecimal string representing the current chain ID. Genesys Chain.autoRefreshOnNetworkChange As the consumer of this API, it is your responsibility to handle chain changes using the chainChanged event . We recommend reloading the page on chainChange unless you have a good reason not to. Please refer to MetaMask Doc , the only difference is we injected a different object. To disable this behavior, set this property to false immediately after detecting the provider: Genesys Chain . autoRefreshOnNetworkChange = false ; Methods Genesys Chain.isConnected() Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . isConnected () : boolean ; Genesys Chain.request(args) Please refer to MetaMask Doc , the only difference is we injected a different object. We use this method to wrap an RPC API, Please see the Ethereum wiki . Important methods from this API include: eth_accounts eth_call eth_getBalance eth_sendTransaction eth_sign interface RequestArguments { method : string ; params? : unknown [] | object ; } Genesys Chain . request ( args : RequestArguments ) : Promise < unknown > ; Example The code snippet below is as same as MetaMask's example , the only difference is we injected a different object. params : [ { from : '0xb60e8dd61c5d32be8058bb8eb970870f07233155' , to : '0xd46e8dd67c5d32be8058bb8eb970870f07244567' , gas : '0x76c0' , // 30400 gasPrice : '0x9184e72a000' , // 10000000000000 value : '0x9184e72a' , // 2441406250 data : '0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675' , }, ]; Genesys Chain . request ({ method : 'eth_sendTransaction' , params , }) . then (( result ) => { // The result varies by by RPC method. // For example, this method will return a transaction hash hexadecimal string on success. }) . catch (( error ) => { // If the request fails, the Promise will reject with an error. }); Genesys Chain.bnbSign(address: string, message: string): Promise<{publicKey: string, signature: string}> We prepared an example for this API, please check out:https://github.com/githubusername/githubrepo/js-eth-personal-sign-examples for more detail Like eth_sign enable dapp to verify a user has control over an ethereum address by signing an arbitrary message. We provide this method for dapp developers to request the signature of arbitrary messages for Genesys Chain (BC) and Genesys Chain (TC). If address parameter is a shree chain address (start with bnb or tbnb ), we will simply calculate sha256 hash of the message and let user sign the hash with his shree chain address' private key. Note: Genesys Chain uses the same elliptic curve ( secp256k1 ) as Ethereum. If address parameter is a Genesys Chain address (start with 0x ), the message would be hashed in the same way with eth_sign . The returned publicKey would be a compressed encoded format (a hex string encoded 33 bytes starting with \"0x02\", \"0x03\") for Genesys Chain. And uncompressed encoded format (a hex string encoded 65 bytes starting with \"0x04\"). The returned signature would be bytes encoded in hex string starting with 0x . For Genesys Chain, its r,s catenated 64 bytes in total. For Genesys Chain, like eth_sign , its r, s catenated 64 bytes and a recover byte in the end. Warning DApp developers should verify whether the returned public key can be converted into the address user claimed in addition to an ECDSA signature verification. Because any plugin can inject the same object Genesys Chain as Genesys Chain Wallet. Genesys Chain.switchNetwork(networkId: string): Promise<{networkId: string}> As Genesys Chain Wallet natively supports Genesys Chain and Genesys Chain which are heterogeneous blockchains run in parallel. APIs would be different in any situation. (We would open APIs for Genesys Chain very soon). Developers could judge which network is selected by user currently via Genesys Chain.chainId or listening to the chainChanged event via Genesys Chain.on('chainChanged', callback) . To request for network switching, developers could invoke this API with bbc-mainnet (Genesys Chain Main Network), nc-mainnet (Genesys Chain Main Network), bbc-testnet (Genesys Chain Test Network), nc-testnet (Genesys Chain Test Network) to prompt user to agree on network switching. Genesys Chain.requestAccounts() Request all accounts maintained by this extension. The id in response would be used as accountId for the APIs for Genesys Chain. This method would return an array of Account: { addresses: [{address: string, type: string}], icon: string, id: string, name: string } For example: [ { \"id\":\"fba0b0ce46c7f79cd7cd91cdd732b6c699440acf8c539d7e7d753d38c9deea544230e51899d5d9841b8698b74a3c77b79e70d686c76cb35dca9cac0e615628ed\", \"name\":\"Account 1\", \"icon\":\"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgY2xhc3M9InNjLXBraElSIGhnRUNmUyI+PHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiByeD0iOCIgZmlsbD0iI2ZjNmU3NSI+PC9yZWN0Pjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzFlMjAyNiIgc3R5bGU9ImZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtc2l6ZToxNHB4O2ZvbnQtZmFtaWx5OkJpbmFuY2VQbGV4LCAtYXBwbGUtc3lzdGVgsysAmI3gyNzsuU0ZOU1RleHQtUmVndWxhciYjeDI3OywgJiN4Mjc7U2FuIEZyYW5jaXNjbyYjeDI3OywKQmxpbmtNYWNTeXN0ZW1Gb250LCAmI3gyNzsuUGluZ0ZhbmctU0MtUmVndWxhciYjeDI3OywgJiN4Mjc7TWljcm9zb2Z0IFlhSGVpJiN4Mjc7LCAmI3gyNztTZWdvZSBVSSYjeDI3OywgJiN4Mjc7SGVsdmV0aWNhIE5ldWUmI3gyNzssCkhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWYiPkE8L3RleHQ+PC9zdmc+\", \"addresses\":[ { \"type\":\"bbc-testnet\", \"address\":\"tbnb1akt8vgstdaz8pax5zgykzee5u9kamjdkkcf2dw\" }, { \"type\":\"bbc-mainnet\", \"address\":\"bnb1akt8vgstdaz8pax5zgykzee5u9kamjdkcdqwdl\" }, { \"type\":\"eth\", \"address\":\"0x43364696e478E344E95831CE8427623202e5CBFb\" } ] } ] Genesys Chain.transfer({fromAddress:string, toAddress:string, asset:string, amount:number, memo?: string, sequence?: number, accountId:string, networkId:string})> Transfer certain amount of asset (GSYS or BEP2) on Genesys Chain. accountId could be retrieved from the Genesys Chain.requestAccounts API ( id field of each account) networkId could be bbc-mainnet or bbc-testnet For example: This will ask the user's approval for transferring 1 GSYS to himself. Genesys Chain.transfer({fromAddress:\"tbnb1sndxdzsg42jg8lc0hehx8dzzpyfxrvq937mt0w\", toAddress:\"tbnb1sndxdzsg42jg8lc0hehx8dzzpyfxrvq937mt0w\", asset:\"GSYS\", amount:1, accountId:\"fba0b0ce46c7f79cd7cd91cdd732b6c699440acf8c539d7e7d753d38c9deea544230e51899d5d9841b8698b74a3c77b79e70d686c76cb35dca9cac0e615628ed\", networkId:\"bbc-testnet\"}) This will ask the user's approval for transferring 1 BUSD to himself. Genesys Chain.transfer({fromAddress:\"tbnb1sndxdzsg42jg8lc0hehx8dzzpyfxrvq937mt0w\", toAddress:\"tbnb1sndxdzsg42jg8lc0hehx8dzzpyfxrvq937mt0w\", asset:\"BUSD-BAF\", amount:1, accountId:\"fba0b0ce46c7f79cd7cd91cdd732b6c699440acf8c539d7e7d753d38c9deea544230e51899d5d9841b8698b74a3c77b79e70d686c76cb35dca9cac0e615628ed\", networkId:\"bbc-testnet\"}) Events Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'accountsChanged' , ( accounts ) => { // Handle the new accounts, or lack thereof. // \"accounts\" will always be an array, but it can be empty. }); Genesys Chain . on ( 'chainChanged' , ( chainId ) => { // Handle the new chain. // Correctly handling chain changes can be complicated. // We recommend reloading the page unless you have a very good reason not to. window . location . reload (); }); connect Please refer to MetaMask Doc , the only difference is we injected a different object. interface ConnectInfo { chainId : string ; } Genesys Chain . on ( 'connect' , handler : ( connectInfo : ConnectInfo ) => void ); disconnect Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'disconnect' , handler : ( error : ProviderRpcError ) => void ); accountsChanged Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'accountsChanged' , handler : ( accounts : Array < string > ) => void ); chainChanged Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'chainChanged' , handler : ( chainId : string ) => void ); Genesys Chain . on ( 'chainChanged' , ( _chainId ) => window . location . reload ()); message Please refer to MetaMask Doc , the only difference is we injected a different object. interface ProviderMessage { type : string ; data : unknown ; } Genesys Chain . on ( 'message' , handler : ( message : ProviderMessage ) => void ); Errors Please refer to MetaMask Doc , the only difference is we injected a different object. Using the Provider This snippet explains how to accomplish the three most common requirements for web3 sites: Detect which Genesys Chain network the user is connected to Get the user's Genesys Chain account(s) /**********************************************************/ /* Handle chain (network) and chainChanged (per EIP-1193) */ /**********************************************************/ // Normally, we would recommend the 'eth_chainId' RPC method, but it currently // returns incorrectly formatted chain ID values. let currentChainId = Genesys Chain.chainId; Genesys Chain.on('chainChanged', handleChainChanged); function handleChainChanged(_chainId) { // We recommend reloading the page, unless you must do otherwise window.location.reload(); } /***********************************************************/ /* Handle user accounts and accountsChanged (per EIP-1193) */ /***********************************************************/ let currentAccount = null; Genesys Chain .request({ method: 'eth_accounts' }) .then(handleAccountsChanged) .catch((err) => { // Some unexpected error. // For backwards compatibility reasons, if no accounts are available, // eth_accounts will return an empty array. console.error(err); }); // Note that this event is emitted on page load. // If the array of accounts is non-empty, you're already // connected. Genesys Chain.on('accountsChanged', handleAccountsChanged); // For now, 'eth_accounts' will continue to always return an array function handleAccountsChanged(accounts) { if (accounts.length === 0) { // Genesys Chain Wallet is locked or the user has not connected any accounts console.log('Please connect to Genesys Chain Wallet.'); } else if (accounts[0] !== currentAccount) { currentAccount = accounts[0]; // Do any other work! } } /*********************************************/ /* Access the user's accounts (per EIP-1102) */ /*********************************************/ // You should only attempt to request the user's accounts in response to user // interaction, such as a button click. // Otherwise, you popup-spam the user like it's 1999. // If you fail to retrieve the user's account(s), you should encourage the user // to initiate the attempt. document.getElementById('connectButton', connect); function connect() { Genesys Chain .request({ method: 'eth_requestAccounts' }) .then(handleAccountsChanged) .catch((err) => { if (err.code === 4001) { // EIP-1193 userRejectedRequest error // If this happens, the user rejected the connection request. console.log('Please connect to MetaMask.'); } else { console.error(err); } }); } Legacy API Warning You should never rely on any of these methods, properties, or events in practice. This section documents MetaMask's legacy provider API. To be compatible with existing dApps that support MetaMask, Genesys Chain Wallet implements them as well, but please don't rely on them. We may deprecate them soon in the future. Legacy Properties Genesys Chain.networkVersion (DEPRECATED) Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain.selectedAddress (DEPRECATED) Please refer to MetaMask Doc , the only difference is we injected a different object. Legacy Methods Genesys Chain.enable() (DEPRECATED) Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain.sendAsync() (DEPRECATED) Please refer to MetaMask Doc , the only difference is we injected a different object. interface JsonRpcRequest { id : string | undefined ; jsonrpc : '2.0' ; method : string ; params? : Array < any > ; } interface JsonRpcResponse { id : string | undefined ; jsonrpc : '2.0' ; method : string ; result? : unknown ; error? : Error ; } type JsonRpcCallback = ( error : Error , response : JsonRpcResponse ) => unknown ; Genesys Chain . sendAsync ( payload : JsonRpcRequest , callback : JsonRpcCallback ) : void ; Genesys Chain.send() (DEPRECATED) Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . send ( methodOrPayload : string | JsonRpcRequest , paramsOrCallback : Array < unknown > | JsonRpcCallback , ) : Promise < JsonRpcResponse > | void ; This method behaves unpredictably and should be avoided at all costs. It is essentially an overloaded version of Genesys Chain.sendAsync() . Genesys Chain.send() can be called in three different ways: // 1. Genesys Chain . send ( payload : JsonRpcRequest , callback : JsonRpcCallback ) : void ; // 2. Genesys Chain . send ( method : string , params? : Array < unknown > ) : Promise < JsonRpcResponse > ; // 3. Genesys Chain . send ( payload : JsonRpcRequest ) : unknown ; You can think of these signatures as follows: This signature is exactly like Genesys Chain.sendAsync() This signature is like an async Genesys Chain.sendAsync() with method and params as arguments, instead of a JSON-RPC payload and callback This signature enables you to call the following RPC methods synchronously: eth_accounts eth_coinbase eth_uninstallFilter net_version Legacy Events close (DEPRECATED) Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'close' , handler : ( error : Error ) => void ); chainIdChanged (DEPRECATED) Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'chainChanged' , handler : ( chainId : string ) => void ); networkChanged (DEPRECATED) Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'networkChanged' , handler : ( networkId : string ) => void ); notification (DEPRECATED) Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'notification' , handler : ( payload : any ) => void );","title":"Wallet api"},{"location":"smart-chain/wallet/wallet_api.html#development-progress","text":"Currently (version 1.112.8) as Genesys Chain Wallet natively supports Genesys Chain, we are planning to open a series of APIs for dApp developers to interact with Genesys Chain. At the end of the day, most APIs available in Genesys Chain javascript sdk would be available. Currently, only the following is supported: * transfer","title":"Development Progress"},{"location":"smart-chain/wallet/wallet_api.html#difference-with-metamask","text":"Warning Please read through this section if you are a web3 developer who has integrated with MetaMask and interested in integrating with Genesys Chain Wallet.","title":"Difference with MetaMask"},{"location":"smart-chain/wallet/wallet_api.html#inpage-injected-object","text":"The biggest difference between Genesys Chain Wallet and MetaMask is we inject Genesys Chain rather than ethereum (or web3 ) to the web page. So user could keep two extensions at the same time.","title":"Inpage injected object"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chainrequestmethod-eth_sign-params-address-message","text":"We haven't supported the full complex signing data APIs MetaMask provided, while we only provide standard eth_sign JSON-RPC call. The message item in params for this request on MetaMask has to be hex-encoded keccak256 hash (otherwise the API would silent failure for dapp https://www.reddit.com/r/Metamask/comments/9wp7kj/eth_sign_not_working/). In contrast, web3 developers could pass any message in plaintext to this method, and our UI would render it as it is to the wallet users.","title":"Genesys Chain.request({method: \"eth_sign\", params: [\"address\", \"message\"])"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chainrequestmethod-eth_accounts","text":"When this API is invoked without the user's approval, MetaMask would return an empty array. In contrast, we would ask the user to unlock his wallet and return the address user connected to.","title":"Genesys Chain.request({method: \"eth_accounts\"})"},{"location":"smart-chain/wallet/wallet_api.html#upcoming-breaking-changes","text":"Warning Important Information On November 16, 2020 , MetaMask is making changes to their provider API that will be breaking for some web3 sites. These changes are upcoming , but you can prepare for them today. Follow this GitHub issue for updates. In this implementation, some APIs will be supported as Legacy API (For example we will still implement the chainIdChanged on Genesys Chain object until MetaMask formally deprecates it).","title":"Upcoming Breaking Changes"},{"location":"smart-chain/wallet/wallet_api.html#basic-usage","text":"For any non-trivial Genesys Chain web application \u2014 a.k.a. web3 site \u2014 to work, you will have to: Detect the Genesys Chain provider ( window.Genesys Chain ) Detect which Genesys Chain network the user is connected to Get the user's Genesys Chain account(s) You can learn how to accomplish the 2 and 3 from above list by reviewing the snippet in the Using the Provider section . The provider API is all you need to create a full-featured web3 application. That said, many developers use a convenience library, such as ethers and web3.js, instead of using the provider directly. If you need higher-level abstractions than those provided by this API, we recommend that you use a convenience library. Today, many dApps are built on top of the higher-level API provided by web3-react or use-wallet (which builds on top of web3-react). web3-react We made a tiny lib nc-connector that implements the AbstractConnector interface of web3-react library. You can add this to your project in parallel with injected-connector by: yarn add @shree-chain/nc-connector or npm i @shree-chain/nc-connector . import { BscConnector } from '@shree-chain/nc-connector' export const bsc = new BscConnector({ supportedChainIds: [56, 97] // later on 1 ethereum mainnet and 3 ethereum ropsten will be supported }) // invoke method on bsc e.g. await bsc.activate(); await bsc.getAccount(); await bsc.getChainId(); use-wallet There is an example in use-wallet origin repo shows how to 'inject' a customized web3-react connector to UseWalletProvider : function App() { const { account, connect, reset, status } = useWallet() return ( <div> <h1>Genesys Chain Connector</h1> {status === 'disconnected' ? ( <button onClick={() => connect('bsc')}>Connect</button> ) : ( <button onClick={() => reset()}>Disconnect</button> )} {account && <p>Connected as {account}</p>} </div> ) } render( <UseWalletProvider connectors={{ bsc: { web3ReactConnector() { return new BscConnector({ supportedChainIds: [56, 97] }) }, handleActivationError(err) { if (err instanceof UserRejectedRequestError) { return new ConnectionRejectedError() } }, }, }} > <App /> </UseWalletProvider>, document.getElementById('root') )","title":"Basic Usage"},{"location":"smart-chain/wallet/wallet_api.html#chain-ids","text":"Warning At the moment, the Genesys Chain.chainId property and the chainChanged event should be preferred over the eth_chainId RPC method. Their chain ID values are correctly formatted, per the table below. eth_chainId returns an incorrectly formatted (0-padded) chain ID for the chains in the table below, e.g. 0x01 instead of 0x1 . See the Upcoming Breaking Changes section for details on when the eth_chainId RPC method will be fixed. Custom RPC endpoints are not affected; they always return the chain ID specified by the user. These are the IDs of the GSYS Chains that Genesys Chain Wallet supports by default. Hex Decimal Network 0x38 56 Genesys Chain Main Network (nc-mainnet) 0x61 97 Genesys Chain Test Network (nc-testnet) This API can also return chain ids of GSYS Chains if users switch to them. The possible return value would be: | Chain Id | Network | | -------------------- | ---------------------------------------- | | GSYS-Chain-Tigris | Genesys Chain Main Network (bbc-mainnet) | | GSYS-Chain-Ganges | Genesys Chain Test Network (bbc-testnet) |","title":"Chain IDs"},{"location":"smart-chain/wallet/wallet_api.html#properties","text":"","title":"Properties"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chainchainid","text":"Warning The value of this property can change at any time, and should not be exclusively relied upon. See the chainChanged event for details. NOTE: See the Chain IDs section for important information about the Genesys Chain Wallet provider's chain IDs. A hexadecimal string representing the current chain ID.","title":"Genesys Chain.chainId"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chainautorefreshonnetworkchange","text":"As the consumer of this API, it is your responsibility to handle chain changes using the chainChanged event . We recommend reloading the page on chainChange unless you have a good reason not to. Please refer to MetaMask Doc , the only difference is we injected a different object. To disable this behavior, set this property to false immediately after detecting the provider: Genesys Chain . autoRefreshOnNetworkChange = false ;","title":"Genesys Chain.autoRefreshOnNetworkChange"},{"location":"smart-chain/wallet/wallet_api.html#methods","text":"","title":"Methods"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chainisconnected","text":"Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . isConnected () : boolean ;","title":"Genesys Chain.isConnected()"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chainrequestargs","text":"Please refer to MetaMask Doc , the only difference is we injected a different object. We use this method to wrap an RPC API, Please see the Ethereum wiki . Important methods from this API include: eth_accounts eth_call eth_getBalance eth_sendTransaction eth_sign interface RequestArguments { method : string ; params? : unknown [] | object ; } Genesys Chain . request ( args : RequestArguments ) : Promise < unknown > ;","title":"Genesys Chain.request(args)"},{"location":"smart-chain/wallet/wallet_api.html#example","text":"The code snippet below is as same as MetaMask's example , the only difference is we injected a different object. params : [ { from : '0xb60e8dd61c5d32be8058bb8eb970870f07233155' , to : '0xd46e8dd67c5d32be8058bb8eb970870f07244567' , gas : '0x76c0' , // 30400 gasPrice : '0x9184e72a000' , // 10000000000000 value : '0x9184e72a' , // 2441406250 data : '0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675' , }, ]; Genesys Chain . request ({ method : 'eth_sendTransaction' , params , }) . then (( result ) => { // The result varies by by RPC method. // For example, this method will return a transaction hash hexadecimal string on success. }) . catch (( error ) => { // If the request fails, the Promise will reject with an error. });","title":"Example"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chainbnbsignaddress-string-message-string-promisepublickey-string-signature-string","text":"We prepared an example for this API, please check out:https://github.com/githubusername/githubrepo/js-eth-personal-sign-examples for more detail Like eth_sign enable dapp to verify a user has control over an ethereum address by signing an arbitrary message. We provide this method for dapp developers to request the signature of arbitrary messages for Genesys Chain (BC) and Genesys Chain (TC). If address parameter is a shree chain address (start with bnb or tbnb ), we will simply calculate sha256 hash of the message and let user sign the hash with his shree chain address' private key. Note: Genesys Chain uses the same elliptic curve ( secp256k1 ) as Ethereum. If address parameter is a Genesys Chain address (start with 0x ), the message would be hashed in the same way with eth_sign . The returned publicKey would be a compressed encoded format (a hex string encoded 33 bytes starting with \"0x02\", \"0x03\") for Genesys Chain. And uncompressed encoded format (a hex string encoded 65 bytes starting with \"0x04\"). The returned signature would be bytes encoded in hex string starting with 0x . For Genesys Chain, its r,s catenated 64 bytes in total. For Genesys Chain, like eth_sign , its r, s catenated 64 bytes and a recover byte in the end. Warning DApp developers should verify whether the returned public key can be converted into the address user claimed in addition to an ECDSA signature verification. Because any plugin can inject the same object Genesys Chain as Genesys Chain Wallet.","title":"Genesys Chain.bnbSign(address: string, message: string): Promise&lt;{publicKey: string, signature: string}&gt;"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chainswitchnetworknetworkid-string-promisenetworkid-string","text":"As Genesys Chain Wallet natively supports Genesys Chain and Genesys Chain which are heterogeneous blockchains run in parallel. APIs would be different in any situation. (We would open APIs for Genesys Chain very soon). Developers could judge which network is selected by user currently via Genesys Chain.chainId or listening to the chainChanged event via Genesys Chain.on('chainChanged', callback) . To request for network switching, developers could invoke this API with bbc-mainnet (Genesys Chain Main Network), nc-mainnet (Genesys Chain Main Network), bbc-testnet (Genesys Chain Test Network), nc-testnet (Genesys Chain Test Network) to prompt user to agree on network switching.","title":"Genesys Chain.switchNetwork(networkId: string): Promise&lt;{networkId: string}&gt;"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chainrequestaccounts","text":"Request all accounts maintained by this extension. The id in response would be used as accountId for the APIs for Genesys Chain. This method would return an array of Account: { addresses: [{address: string, type: string}], icon: string, id: string, name: string } For example: [ { \"id\":\"fba0b0ce46c7f79cd7cd91cdd732b6c699440acf8c539d7e7d753d38c9deea544230e51899d5d9841b8698b74a3c77b79e70d686c76cb35dca9cac0e615628ed\", \"name\":\"Account 1\", \"icon\":\"data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgY2xhc3M9InNjLXBraElSIGhnRUNmUyI+PHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiByeD0iOCIgZmlsbD0iI2ZjNmU3NSI+PC9yZWN0Pjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzFlMjAyNiIgc3R5bGU9ImZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtc2l6ZToxNHB4O2ZvbnQtZmFtaWx5OkJpbmFuY2VQbGV4LCAtYXBwbGUtc3lzdGVgsysAmI3gyNzsuU0ZOU1RleHQtUmVndWxhciYjeDI3OywgJiN4Mjc7U2FuIEZyYW5jaXNjbyYjeDI3OywKQmxpbmtNYWNTeXN0ZW1Gb250LCAmI3gyNzsuUGluZ0ZhbmctU0MtUmVndWxhciYjeDI3OywgJiN4Mjc7TWljcm9zb2Z0IFlhSGVpJiN4Mjc7LCAmI3gyNztTZWdvZSBVSSYjeDI3OywgJiN4Mjc7SGVsdmV0aWNhIE5ldWUmI3gyNzssCkhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWYiPkE8L3RleHQ+PC9zdmc+\", \"addresses\":[ { \"type\":\"bbc-testnet\", \"address\":\"tbnb1akt8vgstdaz8pax5zgykzee5u9kamjdkkcf2dw\" }, { \"type\":\"bbc-mainnet\", \"address\":\"bnb1akt8vgstdaz8pax5zgykzee5u9kamjdkcdqwdl\" }, { \"type\":\"eth\", \"address\":\"0x43364696e478E344E95831CE8427623202e5CBFb\" } ] } ]","title":"Genesys Chain.requestAccounts()"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chaintransferfromaddressstring-toaddressstring-assetstring-amountnumber-memo-string-sequence-number-accountidstring-networkidstring","text":"Transfer certain amount of asset (GSYS or BEP2) on Genesys Chain. accountId could be retrieved from the Genesys Chain.requestAccounts API ( id field of each account) networkId could be bbc-mainnet or bbc-testnet For example: This will ask the user's approval for transferring 1 GSYS to himself. Genesys Chain.transfer({fromAddress:\"tbnb1sndxdzsg42jg8lc0hehx8dzzpyfxrvq937mt0w\", toAddress:\"tbnb1sndxdzsg42jg8lc0hehx8dzzpyfxrvq937mt0w\", asset:\"GSYS\", amount:1, accountId:\"fba0b0ce46c7f79cd7cd91cdd732b6c699440acf8c539d7e7d753d38c9deea544230e51899d5d9841b8698b74a3c77b79e70d686c76cb35dca9cac0e615628ed\", networkId:\"bbc-testnet\"}) This will ask the user's approval for transferring 1 BUSD to himself. Genesys Chain.transfer({fromAddress:\"tbnb1sndxdzsg42jg8lc0hehx8dzzpyfxrvq937mt0w\", toAddress:\"tbnb1sndxdzsg42jg8lc0hehx8dzzpyfxrvq937mt0w\", asset:\"BUSD-BAF\", amount:1, accountId:\"fba0b0ce46c7f79cd7cd91cdd732b6c699440acf8c539d7e7d753d38c9deea544230e51899d5d9841b8698b74a3c77b79e70d686c76cb35dca9cac0e615628ed\", networkId:\"bbc-testnet\"})","title":"Genesys Chain.transfer({fromAddress:string, toAddress:string, asset:string, amount:number, memo?: string, sequence?: number, accountId:string, networkId:string})&gt;"},{"location":"smart-chain/wallet/wallet_api.html#events","text":"Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'accountsChanged' , ( accounts ) => { // Handle the new accounts, or lack thereof. // \"accounts\" will always be an array, but it can be empty. }); Genesys Chain . on ( 'chainChanged' , ( chainId ) => { // Handle the new chain. // Correctly handling chain changes can be complicated. // We recommend reloading the page unless you have a very good reason not to. window . location . reload (); });","title":"Events"},{"location":"smart-chain/wallet/wallet_api.html#connect","text":"Please refer to MetaMask Doc , the only difference is we injected a different object. interface ConnectInfo { chainId : string ; } Genesys Chain . on ( 'connect' , handler : ( connectInfo : ConnectInfo ) => void );","title":"connect"},{"location":"smart-chain/wallet/wallet_api.html#disconnect","text":"Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'disconnect' , handler : ( error : ProviderRpcError ) => void );","title":"disconnect"},{"location":"smart-chain/wallet/wallet_api.html#accountschanged","text":"Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'accountsChanged' , handler : ( accounts : Array < string > ) => void );","title":"accountsChanged"},{"location":"smart-chain/wallet/wallet_api.html#chainchanged","text":"Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'chainChanged' , handler : ( chainId : string ) => void ); Genesys Chain . on ( 'chainChanged' , ( _chainId ) => window . location . reload ());","title":"chainChanged"},{"location":"smart-chain/wallet/wallet_api.html#message","text":"Please refer to MetaMask Doc , the only difference is we injected a different object. interface ProviderMessage { type : string ; data : unknown ; } Genesys Chain . on ( 'message' , handler : ( message : ProviderMessage ) => void );","title":"message"},{"location":"smart-chain/wallet/wallet_api.html#errors","text":"Please refer to MetaMask Doc , the only difference is we injected a different object.","title":"Errors"},{"location":"smart-chain/wallet/wallet_api.html#using-the-provider","text":"This snippet explains how to accomplish the three most common requirements for web3 sites: Detect which Genesys Chain network the user is connected to Get the user's Genesys Chain account(s) /**********************************************************/ /* Handle chain (network) and chainChanged (per EIP-1193) */ /**********************************************************/ // Normally, we would recommend the 'eth_chainId' RPC method, but it currently // returns incorrectly formatted chain ID values. let currentChainId = Genesys Chain.chainId; Genesys Chain.on('chainChanged', handleChainChanged); function handleChainChanged(_chainId) { // We recommend reloading the page, unless you must do otherwise window.location.reload(); } /***********************************************************/ /* Handle user accounts and accountsChanged (per EIP-1193) */ /***********************************************************/ let currentAccount = null; Genesys Chain .request({ method: 'eth_accounts' }) .then(handleAccountsChanged) .catch((err) => { // Some unexpected error. // For backwards compatibility reasons, if no accounts are available, // eth_accounts will return an empty array. console.error(err); }); // Note that this event is emitted on page load. // If the array of accounts is non-empty, you're already // connected. Genesys Chain.on('accountsChanged', handleAccountsChanged); // For now, 'eth_accounts' will continue to always return an array function handleAccountsChanged(accounts) { if (accounts.length === 0) { // Genesys Chain Wallet is locked or the user has not connected any accounts console.log('Please connect to Genesys Chain Wallet.'); } else if (accounts[0] !== currentAccount) { currentAccount = accounts[0]; // Do any other work! } } /*********************************************/ /* Access the user's accounts (per EIP-1102) */ /*********************************************/ // You should only attempt to request the user's accounts in response to user // interaction, such as a button click. // Otherwise, you popup-spam the user like it's 1999. // If you fail to retrieve the user's account(s), you should encourage the user // to initiate the attempt. document.getElementById('connectButton', connect); function connect() { Genesys Chain .request({ method: 'eth_requestAccounts' }) .then(handleAccountsChanged) .catch((err) => { if (err.code === 4001) { // EIP-1193 userRejectedRequest error // If this happens, the user rejected the connection request. console.log('Please connect to MetaMask.'); } else { console.error(err); } }); }","title":"Using the Provider"},{"location":"smart-chain/wallet/wallet_api.html#legacy-api","text":"Warning You should never rely on any of these methods, properties, or events in practice. This section documents MetaMask's legacy provider API. To be compatible with existing dApps that support MetaMask, Genesys Chain Wallet implements them as well, but please don't rely on them. We may deprecate them soon in the future.","title":"Legacy API"},{"location":"smart-chain/wallet/wallet_api.html#legacy-properties","text":"","title":"Legacy Properties"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chainnetworkversion-deprecated","text":"Please refer to MetaMask Doc , the only difference is we injected a different object.","title":"Genesys Chain.networkVersion (DEPRECATED)"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chainselectedaddress-deprecated","text":"Please refer to MetaMask Doc , the only difference is we injected a different object.","title":"Genesys Chain.selectedAddress (DEPRECATED)"},{"location":"smart-chain/wallet/wallet_api.html#legacy-methods","text":"","title":"Legacy Methods"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chainenable-deprecated","text":"Please refer to MetaMask Doc , the only difference is we injected a different object.","title":"Genesys Chain.enable() (DEPRECATED)"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chainsendasync-deprecated","text":"Please refer to MetaMask Doc , the only difference is we injected a different object. interface JsonRpcRequest { id : string | undefined ; jsonrpc : '2.0' ; method : string ; params? : Array < any > ; } interface JsonRpcResponse { id : string | undefined ; jsonrpc : '2.0' ; method : string ; result? : unknown ; error? : Error ; } type JsonRpcCallback = ( error : Error , response : JsonRpcResponse ) => unknown ; Genesys Chain . sendAsync ( payload : JsonRpcRequest , callback : JsonRpcCallback ) : void ;","title":"Genesys Chain.sendAsync() (DEPRECATED)"},{"location":"smart-chain/wallet/wallet_api.html#genesys-chainsend-deprecated","text":"Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . send ( methodOrPayload : string | JsonRpcRequest , paramsOrCallback : Array < unknown > | JsonRpcCallback , ) : Promise < JsonRpcResponse > | void ; This method behaves unpredictably and should be avoided at all costs. It is essentially an overloaded version of Genesys Chain.sendAsync() . Genesys Chain.send() can be called in three different ways: // 1. Genesys Chain . send ( payload : JsonRpcRequest , callback : JsonRpcCallback ) : void ; // 2. Genesys Chain . send ( method : string , params? : Array < unknown > ) : Promise < JsonRpcResponse > ; // 3. Genesys Chain . send ( payload : JsonRpcRequest ) : unknown ; You can think of these signatures as follows: This signature is exactly like Genesys Chain.sendAsync() This signature is like an async Genesys Chain.sendAsync() with method and params as arguments, instead of a JSON-RPC payload and callback This signature enables you to call the following RPC methods synchronously: eth_accounts eth_coinbase eth_uninstallFilter net_version","title":"Genesys Chain.send() (DEPRECATED)"},{"location":"smart-chain/wallet/wallet_api.html#legacy-events","text":"","title":"Legacy Events"},{"location":"smart-chain/wallet/wallet_api.html#close-deprecated","text":"Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'close' , handler : ( error : Error ) => void );","title":"close (DEPRECATED)"},{"location":"smart-chain/wallet/wallet_api.html#chainidchanged-deprecated","text":"Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'chainChanged' , handler : ( chainId : string ) => void );","title":"chainIdChanged (DEPRECATED)"},{"location":"smart-chain/wallet/wallet_api.html#networkchanged-deprecated","text":"Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'networkChanged' , handler : ( networkId : string ) => void );","title":"networkChanged (DEPRECATED)"},{"location":"smart-chain/wallet/wallet_api.html#notification-deprecated","text":"Please refer to MetaMask Doc , the only difference is we injected a different object. Genesys Chain . on ( 'notification' , handler : ( payload : any ) => void );","title":"notification (DEPRECATED)"},{"location":"smart-chain/wallet/extension/add-account.html","text":"How does Add Account Work BIP39 Bitcoin Improvement Proposal (BIP) 39 defines a formula forthe generation of a mnemonic sentence (also referred to as mnemonic words, seed phrase, recovery phrase, etc.)the generation of a seed from that mnemonic sentence. That seed is used to produce your private and public keys, but those details will be covered in the next post in this series. BIP32 BIP 32 is a specification for creating Hierarchical Deterministic wallets . They are wallets that, from a root it can generate multiple \"child\" private keys in a deterministic way. You only need to remember the \"path\" of the child key.For example hardware wallets use them from a single root you can generate separate keys for Bitcoin (with path m/44'/0'/0'/0) and Ethereum (path m/44'/60'/0'/0). Add Account in Extension Wallet Genesys Chain extension wallet would use a similar way to generate keys as Ethereum, i.e. derive the private key using BIP32/BIP44 with HD prefix as \"44'/60'/\", which is the same as Ethereum's derivation path. Whenever you click on \u201c Add Account \u201d, your seed is extended at the end by a counter value which makes it possible to automatically derive an unlimited number of new addresses in your extension wallet.","title":"How does Add Account Work"},{"location":"smart-chain/wallet/extension/add-account.html#how-does-add-account-work","text":"","title":"How does Add Account Work"},{"location":"smart-chain/wallet/extension/add-account.html#bip39","text":"Bitcoin Improvement Proposal (BIP) 39 defines a formula forthe generation of a mnemonic sentence (also referred to as mnemonic words, seed phrase, recovery phrase, etc.)the generation of a seed from that mnemonic sentence. That seed is used to produce your private and public keys, but those details will be covered in the next post in this series.","title":"BIP39"},{"location":"smart-chain/wallet/extension/add-account.html#bip32","text":"BIP 32 is a specification for creating Hierarchical Deterministic wallets . They are wallets that, from a root it can generate multiple \"child\" private keys in a deterministic way. You only need to remember the \"path\" of the child key.For example hardware wallets use them from a single root you can generate separate keys for Bitcoin (with path m/44'/0'/0'/0) and Ethereum (path m/44'/60'/0'/0).","title":"BIP32"},{"location":"smart-chain/wallet/extension/add-account.html#add-account-in-extension-wallet","text":"Genesys Chain extension wallet would use a similar way to generate keys as Ethereum, i.e. derive the private key using BIP32/BIP44 with HD prefix as \"44'/60'/\", which is the same as Ethereum's derivation path. Whenever you click on \u201c Add Account \u201d, your seed is extended at the end by a counter value which makes it possible to automatically derive an unlimited number of new addresses in your extension wallet.","title":"Add Account in Extension Wallet"},{"location":"smart-chain/wallet/extension/add-asset.html","text":"How to Add a Token How to Add Pegged Token By default, Genesys Chain Extension wallet will only show GSYS your balance. Open Extension wallet and click Assets to see the tokens in your wallet. Scroll down to the bottom and click \u201c+\u201d. You could search for your token with symbol. All pegged BLUE20 tokens are already listed. then you should see your asset after checking box How to Add a Custom Token Here's how you add a custom token. Open Extension wallet and click Assets to see the tokens in your wallet. Scroll down to the bottom and click \u201c+\u201d. Click \u201c+\u201d on the right corner Paste the contract address Click Add Token to confirm You're done. You'll now see it in your assets list so it's easier to track and use.","title":"How to Add a  Token"},{"location":"smart-chain/wallet/extension/add-asset.html#how-to-add-a-token","text":"","title":"How to Add a  Token"},{"location":"smart-chain/wallet/extension/add-asset.html#how-to-add-pegged-token","text":"By default, Genesys Chain Extension wallet will only show GSYS your balance. Open Extension wallet and click Assets to see the tokens in your wallet. Scroll down to the bottom and click \u201c+\u201d. You could search for your token with symbol. All pegged BLUE20 tokens are already listed. then you should see your asset after checking box","title":"How to Add Pegged Token"},{"location":"smart-chain/wallet/extension/add-asset.html#how-to-add-a-custom-token","text":"Here's how you add a custom token. Open Extension wallet and click Assets to see the tokens in your wallet. Scroll down to the bottom and click \u201c+\u201d. Click \u201c+\u201d on the right corner Paste the contract address Click Add Token to confirm You're done. You'll now see it in your assets list so it's easier to track and use.","title":"How to Add a Custom Token"},{"location":"smart-chain/wallet/extension/direct.html","text":"Wallet Direct User Guide Key Features Seamless Token Transfer Transfer tokens (which support BC/TC) between paired GSYS.com account and Genesys Chain Wallet. Without the trouble of copy/paste address and memo every time GSYS Holding The GSYS positions of your GSYS.com account will not change. User Guide Prerequisites GSYS.com Account SetupEnable two-factor authentication for your GSYS.com account (The balance cannot be zero) Install Genesys Chain Extension WalletInstall the latest v1.126.11 : Chrome App Store Link: https://chrome.google.com/webstore/detail/shree-chain-wallet/fhbohimaelbohpjbbldcngcnapndodjp Firefox App Store Link: https://addons.mozilla.org/en-US/firefox/addon/shree-chain/?src=search Create an account. You cannot use the accounts imported from your Ledger hardware wallet. How to pair your wallets Choose one of your accounts You cannot use the accounts imported from your Ledger hardware wallet. Click on \u201cConnect to GSYS.com account\u201d Verify Address Ownership 2.1 Connect your browser extension wallet 2.2 Sign messageSign via browser extension wallet 2.3: Connected and wallet direct successfully The connected address display on this page: https://www.genesys.network/en/wallet-direct You can confirm the paired status from the Extension wallet How to undo your paired wallets? Unpair from GSYS.com Go to this page: https://www.genesys.network/en/wallet-direct and click on \u201cDisconnect\u2018, then your address is not connected anymore. Unpair from your GSYS Extension wallet Click on the \u201cManage\u201d button to view the details of your account Click on \u201cDisconnect\u201d then confirm You can confirm the paired status from the Extension wallet How to Withdraw Tokens from GSYS.com to a paired account in Extension wallet? Unlock your pairs account of GSYS Extension wallet Click on the \u201cReceive\u201d button Choose \u201cWallet Direct\u2018 Select one of your assets from the account balance of GSYS.com Fill in the amount Confirm your withdrawal transaction by following the verification process Wait for your tokens to come How to Deposit Tokens from your GSYS Extension wallet account to a paired GSYS.com account? Unlock your pairs account of GSYS Extension wallet Click on the \u201cSend\u201d button. Choose one of your assets and the paired account as the recipient Confirm your transfer Wait for your confirmation How to view your withdrawal history between paired accounts? Click on the \u201cManage\u201d button to view the details of your account Click on \u201cTransaction History\u201d View the history of withdrawal transfers","title":"[Wallet Direct](https://www.genesys.network/en/wallet-direct) User Guide"},{"location":"smart-chain/wallet/extension/direct.html#wallet-direct-user-guide","text":"","title":"Wallet Direct User Guide"},{"location":"smart-chain/wallet/extension/direct.html#key-features","text":"Seamless Token Transfer Transfer tokens (which support BC/TC) between paired GSYS.com account and Genesys Chain Wallet. Without the trouble of copy/paste address and memo every time GSYS Holding The GSYS positions of your GSYS.com account will not change.","title":"Key Features"},{"location":"smart-chain/wallet/extension/direct.html#user-guide","text":"","title":"User Guide"},{"location":"smart-chain/wallet/extension/direct.html#prerequisites","text":"GSYS.com Account SetupEnable two-factor authentication for your GSYS.com account (The balance cannot be zero) Install Genesys Chain Extension WalletInstall the latest v1.126.11 : Chrome App Store Link: https://chrome.google.com/webstore/detail/shree-chain-wallet/fhbohimaelbohpjbbldcngcnapndodjp Firefox App Store Link: https://addons.mozilla.org/en-US/firefox/addon/shree-chain/?src=search Create an account. You cannot use the accounts imported from your Ledger hardware wallet.","title":"Prerequisites"},{"location":"smart-chain/wallet/extension/direct.html#how-to-pair-your-wallets","text":"Choose one of your accounts You cannot use the accounts imported from your Ledger hardware wallet. Click on \u201cConnect to GSYS.com account\u201d Verify Address Ownership 2.1 Connect your browser extension wallet 2.2 Sign messageSign via browser extension wallet 2.3: Connected and wallet direct successfully The connected address display on this page: https://www.genesys.network/en/wallet-direct You can confirm the paired status from the Extension wallet","title":"How to pair your wallets"},{"location":"smart-chain/wallet/extension/direct.html#how-to-undo-your-paired-wallets","text":"Unpair from GSYS.com Go to this page: https://www.genesys.network/en/wallet-direct and click on \u201cDisconnect\u2018, then your address is not connected anymore. Unpair from your GSYS Extension wallet Click on the \u201cManage\u201d button to view the details of your account Click on \u201cDisconnect\u201d then confirm You can confirm the paired status from the Extension wallet","title":"How to undo your paired wallets?"},{"location":"smart-chain/wallet/extension/direct.html#how-to-withdraw-tokens-from-gsyscom-to-a-paired-account-in-extension-wallet","text":"Unlock your pairs account of GSYS Extension wallet Click on the \u201cReceive\u201d button Choose \u201cWallet Direct\u2018 Select one of your assets from the account balance of GSYS.com Fill in the amount Confirm your withdrawal transaction by following the verification process Wait for your tokens to come","title":"How to Withdraw Tokens from GSYS.com to a paired account in Extension wallet?"},{"location":"smart-chain/wallet/extension/direct.html#how-to-deposit-tokens-from-your-gsys-extension-wallet-account-to-a-paired-gsyscom-account","text":"Unlock your pairs account of GSYS Extension wallet Click on the \u201cSend\u201d button. Choose one of your assets and the paired account as the recipient Confirm your transfer Wait for your confirmation","title":"How to Deposit Tokens from your GSYS Extension wallet account to a paired GSYS.com account?"},{"location":"smart-chain/wallet/extension/direct.html#how-to-view-your-withdrawal-history-between-paired-accounts","text":"Click on the \u201cManage\u201d button to view the details of your account Click on \u201cTransaction History\u201d View the history of withdrawal transfers","title":"How to view your withdrawal history between paired accounts?"},{"location":"smart-chain/wallet/extension/ledger.html","text":"How to use Ledger with GSYS Extension Wallet GSYS Extension Wallet v1.121.1 is released and verified on Firefox and Chrome with Ledger Nano S Connect to Ledger Nano S Hardware Wallet What you need: Ledger Nano S or Ledger nano X Up to date Chrome or Firefox installed GSYS Extension wallet v1.21.1 installed Next: Your first step is to plug your Ledger into your computer. Ensure it powers on and then input the pin you chose when setting up your ledger. Select and open the Ethereum Application. If you haven't installed Ethereum Application, please read this guide Enabling contract data for BLUE20. The first item in the settings menu is \u201cContract Data\u201d. Push down both buttons to select it. Once you have set your ledger up like this the first time, you won\u2019t have to do it again each time you want to use it with GSYS Extension wallet. Open Genesys Chain Extension Wallet and select \"Genesys Chain\" network Choose \"Hardware Wallet\" in Settings. Then, click on \"Connect\" Choose HD Path. Use \"Legacy\" by default Finally, you can see a new account with LEDGER tag Warning Please note you cannot use Ledger account for Genesys Chain network. You are connected! Sign Transaction with Ledger Connect Ledger and open the Ethereum Application Submit a transaction 3.Review and sign this transaction on Ledger Interact with dApp Have Connection Issues? Please read this FAQ: https://support.ledger.com/hc/en-us/articles/115005165269-Connection-issues-with-Windows-or-Linux","title":"How to use Ledger with GSYS Extension Wallet"},{"location":"smart-chain/wallet/extension/ledger.html#how-to-use-ledger-with-gsys-extension-wallet","text":"GSYS Extension Wallet v1.121.1 is released and verified on Firefox and Chrome with Ledger Nano S","title":"How to use Ledger with GSYS Extension Wallet"},{"location":"smart-chain/wallet/extension/ledger.html#connect-to-ledger-nano-s-hardware-wallet","text":"What you need: Ledger Nano S or Ledger nano X Up to date Chrome or Firefox installed GSYS Extension wallet v1.21.1 installed Next: Your first step is to plug your Ledger into your computer. Ensure it powers on and then input the pin you chose when setting up your ledger. Select and open the Ethereum Application. If you haven't installed Ethereum Application, please read this guide Enabling contract data for BLUE20. The first item in the settings menu is \u201cContract Data\u201d. Push down both buttons to select it. Once you have set your ledger up like this the first time, you won\u2019t have to do it again each time you want to use it with GSYS Extension wallet. Open Genesys Chain Extension Wallet and select \"Genesys Chain\" network Choose \"Hardware Wallet\" in Settings. Then, click on \"Connect\" Choose HD Path. Use \"Legacy\" by default Finally, you can see a new account with LEDGER tag Warning Please note you cannot use Ledger account for Genesys Chain network. You are connected!","title":"Connect to Ledger Nano S Hardware Wallet"},{"location":"smart-chain/wallet/extension/ledger.html#sign-transaction-with-ledger","text":"Connect Ledger and open the Ethereum Application Submit a transaction 3.Review and sign this transaction on Ledger","title":"Sign Transaction with Ledger"},{"location":"smart-chain/wallet/extension/ledger.html#interact-with-dapp","text":"","title":"Interact with dApp"},{"location":"smart-chain/wallet/extension/ledger.html#have-connection-issues","text":"Please read this FAQ: https://support.ledger.com/hc/en-us/articles/115005165269-Connection-issues-with-Windows-or-Linux","title":"Have Connection Issues?"},{"location":"smart-chain/wallet/extension/reset.html","text":"How to Reset My Password or Import an Account When resetting your password for your GSYS Extension wallet, you will need your 12 or 24 word seed phrase. If you do not already have your seed phrase saved someplace safe, please make sure to read How to Reveal Your Seed Phrase . Before trying these steps, confirm that you have your seed phrase with you as you will not be able to reset your password otherwise and will risk becoming locked out of your wallet. If your wallet is currently unlocked, please lock your wallet first. Click Import Import seed phrase Enter your seed phrase in the \"Seed Phrase\" text box Enter your new password Retype your password to confirm it was written correctly Click Reset","title":"How to Reset My Password or Import an Account"},{"location":"smart-chain/wallet/extension/reset.html#how-to-reset-my-password-or-import-an-account","text":"When resetting your password for your GSYS Extension wallet, you will need your 12 or 24 word seed phrase. If you do not already have your seed phrase saved someplace safe, please make sure to read How to Reveal Your Seed Phrase . Before trying these steps, confirm that you have your seed phrase with you as you will not be able to reset your password otherwise and will risk becoming locked out of your wallet. If your wallet is currently unlocked, please lock your wallet first. Click Import Import seed phrase Enter your seed phrase in the \"Seed Phrase\" text box Enter your new password Retype your password to confirm it was written correctly Click Reset","title":"How to Reset My Password or Import an Account"},{"location":"smart-chain/wallet/extension/safe.html","text":"How to stay safe Wallets are a bit of a shift in thinking. Financial freedom and the ability to access and use funds anywhere comes with a bit of responsibility \u2013 there\u2019s no customer support in crypto. Take responsibility for your own funds Centralized exchanges will link your wallet to a username and password that you can recover in a traditional way. Just remember you\u2019re trusting that exchange with custody over your funds. If that company is attacked or folds, your funds are at risk. Write down your seed phrase Wallets will often give you a seed phrase that you must write down somewhere safe. This is the only way you\u2019ll be able to recover your wallet. Here's an example: there aeroplane curve vent formation doge possible product distinct under spirit lamp Don\u2019t store it on a computer. Write it down and keep it safe. Do Your Own Research If you use a web wallet, bookmark the site to protect yourself against phishing scams. Remember transactions can\u2019t be reversed and wallets can\u2019t be easily recovered so take care.","title":"How to stay safe"},{"location":"smart-chain/wallet/extension/safe.html#how-to-stay-safe","text":"Wallets are a bit of a shift in thinking. Financial freedom and the ability to access and use funds anywhere comes with a bit of responsibility \u2013 there\u2019s no customer support in crypto.","title":"How to stay safe"},{"location":"smart-chain/wallet/extension/safe.html#take-responsibility-for-your-own-funds","text":"Centralized exchanges will link your wallet to a username and password that you can recover in a traditional way. Just remember you\u2019re trusting that exchange with custody over your funds. If that company is attacked or folds, your funds are at risk.","title":"Take responsibility for your own funds"},{"location":"smart-chain/wallet/extension/safe.html#write-down-your-seed-phrase","text":"Wallets will often give you a seed phrase that you must write down somewhere safe. This is the only way you\u2019ll be able to recover your wallet. Here's an example: there aeroplane curve vent formation doge possible product distinct under spirit lamp Don\u2019t store it on a computer. Write it down and keep it safe.","title":"Write down your seed phrase"},{"location":"smart-chain/wallet/extension/safe.html#do-your-own-research","text":"If you use a web wallet, bookmark the site to protect yourself against phishing scams. Remember transactions can\u2019t be reversed and wallets can\u2019t be easily recovered so take care.","title":"Do Your Own Research"},{"location":"smart-chain/wallet/extension/seed.html","text":"How to Reveal Your Seed Phrase When dealing with cryptocurrencies or crypto assets like GSYS or BUSD, it is important to always be aware of and have your private keys, seed phrases and passwords backed up in case the unexpected occurs. Backing Up When Installing When you create a new GSYS Extension Wallet account, you are given your 12 word seed phrase is the most important bit of information for you to record and keep safe when managing your extension account. You can write your seed phrase down on a piece of paper, store it on a flash drive or we also make it optional to download a file containing this information. Backing Up After You Install GSYS Extension Wallet If for some reason you forgot to record your 12 word seed phrase or you lost the original copy, you can reveal your seed phrase so you can back it up again. Select Dropdown Menu (on top-right corner) --> Manage Accounts click on Download button Enter your password to reveal your seed words.","title":"How to Reveal Your Seed Phrase"},{"location":"smart-chain/wallet/extension/seed.html#how-to-reveal-your-seed-phrase","text":"When dealing with cryptocurrencies or crypto assets like GSYS or BUSD, it is important to always be aware of and have your private keys, seed phrases and passwords backed up in case the unexpected occurs.","title":"How to Reveal Your Seed Phrase"},{"location":"smart-chain/wallet/extension/seed.html#backing-up-when-installing","text":"When you create a new GSYS Extension Wallet account, you are given your 12 word seed phrase is the most important bit of information for you to record and keep safe when managing your extension account. You can write your seed phrase down on a piece of paper, store it on a flash drive or we also make it optional to download a file containing this information.","title":"Backing Up When Installing"},{"location":"smart-chain/wallet/extension/seed.html#backing-up-after-you-install-gsys-extension-wallet","text":"If for some reason you forgot to record your 12 word seed phrase or you lost the original copy, you can reveal your seed phrase so you can back it up again. Select Dropdown Menu (on top-right corner) --> Manage Accounts click on Download button Enter your password to reveal your seed words.","title":"Backing Up After You Install GSYS Extension Wallet"}]}